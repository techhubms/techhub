{
  "EnhancedContent": "In this post I make a (potentially) spicy assertion: if you're worried about the speed that .NET is moving, and more specifically the fact that Microsoft only gives 2 or 3 years of support to new versions of .NET, *maybe* the answer isn't that .NET should slow down .NET. *Maybe* it isn't even that Microsoft should shoulder the burden of supporting more versions of .NET. *Maybe* the answer is that you should just **pay for post-EOL support** like other ecosystems do.\n\n>\n> This post is sponsored by [HeroDevs](https://www.herodevs.com/), and is the result of chatting with [Hayden Barnes](@unixterminal.bsky.social) in the fallout on my post about [the worst .NET vulnerability ever](/understanding-the-worst-dotnet-vulnerability-request-smuggling-and-cve-2025-55315/). That said, all the opinions expressed in this post are entirely my ownâ€”I just think HeroDevs' Never Ending Support for .NET could be a great option for many companies.\n> >\n\nIn this post I describe the official support for .NET provided by Microsoft and what \"support\" actually means. I discuss the advantages and disadvantages of updating to a new major version and then provide an alternative: pay for EOL support instead. Finally I show how you can easily fix your EOL .NET 6 applications by using HeroDevs' Never Ending Support for .NET 6, demonstrating how it protects you from [the recent 9.9 severity CVE](/understanding-the-worst-dotnet-vulnerability-request-smuggling-and-cve-2025-55315/).\n\n## .NET, support lifecycles, and managing vulnerabilities\n\n.NET 10 has just been released, and while some people are excited to see the performance improvements and to use the new features, others will no doubt be worrying about the inevitable march of time before the *current* version of .NET they're using is out of support. A new version of .NET is released every November, and is either a Long Term Support (LTS) release or Standard Term Support (STS) release:\n\n- Odd number releases are Standard Term Support (STS), and receive 2 years of support from Microsoft.\n- Even number releases are Long Term Support (LTS), and receive 3 years of support from Microsoft.\n\nThe following image shows how this works (adapted from the official [.NET support policy page](https://dotnet.microsoft.com/en-us/platform/support/policy/dotnet-core))\n\n![Illustration showing .NET 9 as an STS release that happened in November 2024 and all other releases happening in November, alternating between LTS and STS and .NET 10 as the latest](/content/images/2025/dotnet-release-schedule.svg)\n\nThere's no difference in the quality bar between LTS and STS releases, the only difference is how long the release is supported by Microsoft until it becomes End of Life (EOL). But what do \"supported\" and \"EOL\" even mean? ðŸ¤”\n\n### What does \"supported\" mean?\n\nMost people have an intrinsic feel for what \"supported\" means and it's typically something like \"if there's a bug, it'll get fixed\". But Microsoft is very specific about *exactly* what supported means in [their policy](https://dotnet.microsoft.com/en-us/platform/support/policy/dotnet-core). There are two \"phases\" to support for both LTS and STS releases:\n\n- **Active support**: During the active support period, .NET releases are updated to improve functional capabilities and mitigate security vulnerabilities.\n- **Maintenance support**: During the maintenance support period, .NET releases are updated to mitigate security vulnerabilities, only. The maintenance support period is the final 6 months of support for any release.\n\nSo for the majority of the support timeline, you can expect to see fixes for security vulnerabilities, and \"updates to improve functional capabilities\". What counts as an \"improvement to functional capability\" is actually [pretty broad](https://dotnet.microsoft.com/en-us/platform/support/policy/dotnet-core):\n\n- Resolve reported crashes.\n- Resolve severe performance issues.\n- Resolve functional bugs in common scenarios.\n- Add support for a new operating system version or new hardware platform.\n\n>\n> Given how the first three points are all about fixing relatively severe issues, I was somewhat surprised to see \"supporting a whole new OS version\" on the list, but that somewhat makes sense. For example, if Debian releases a new version, it's likely the .NET team are going to want to make sure the latest released version of .NET works on it!\n> >\n\n6 months before a release goes EOL and stops receiving official support entirely, it enters \"maintenance\", in which *only* security vulnerabilities will be addressed:\n\n![Illustration showing that the last 6 months of a release is &#34;maintenance&#34; mode](/content/images/2025/dotnet-release-schedule-maintenance.png)\n\nWhatever your issue, you should be able to [contact a Microsoft Support Professional](https://support.microsoft.com/supportforbusiness/productselection/?sapid=4fd4947b-15ea-ce01-080f-97f2ca3c76e8) to ask for support. This is particularly appealing to larger companies that like to have a single person they can shout at if things aren't working, and typically have an ongoing relationship with Microsoft anyway. Of course, you can also interact with the various teams on GitHub in [the dotnet org](https://github.com/dotnet) too.\n\nIf you do file an issue on GitHub, and assuming that you provide sufficient information that the issue can be reproduced, then I've found the team to be very receptive to [resolving issues](https://github.com/dotnet/runtime/issues/112565):\n\n![Resolving an issue in the .NET runtime](/content/images/2025/herodevs_github.png)\n\nWhere you might struggle is where your issue is considered minor. If you find a security issue, or a common crashing bug, then sure, it'll probably be fixed in all supported versions of .NET. But if your issue is rare, or if it's risky (because it could have adverse impacts, for example) then you *might* have a harder time getting the fix implemented in all versions of .NET, *even if they're technically still supported*. This is particularly true in the last 6 months of support, when the release enters \"maintenance\" support. In this stage, you'll likely only get security vulnerability fixes.\n\nAnother aspect to consider is that whenever you raise an issue, you'll be asked what version of .NET you're using. Which brings us to the next very important point: *only* the latest patch version of a .NET major version is supported.\n\n### You patch every month, right?\n\n.NET 10 was released on 11th November, but in a month's time I'm sure there will be patches released for the runtime, for ASP.NET Core, for the .NET SDK, and for a variety of other packages that make up the base .NET ecosystem as provided by Microsoft.\n\nEven if you're using a .NET release which *is* actively supported, you're *only supported if you're using the latest patched version*. To make this concrete, the latest released versions of .NET 9 at the time of writing are:\n\n- .NET 9 SDK `9.0.307`\n- .NET Runtime `9.0.11`\n\nIf you have an application today that's using .NET 9, and you're *not* running on the latest .NET 9 patch version (`9.0.11` ), then you're using *an unsupported version of .NET*. And next month there will likely be a `9.0.12` version, which will supplant `9.0.11` !\n\n>\n> Only the *latest* patch versions of all the .NET components are supported. As of today, that means the latest patches for .NET 8, .NET 9, and .NET 10 respectively.\n> >\n\nPutting that all together, if you want to stick to using only Microsoft supported versions of .NET, that means that *every month*, you need to, at a minimum:\n\n- Update the .NET SDKs used to build .NET applications.\n- Update the .NET runtime used to deploy and run your applications.\n\nIf you *can't* update these versions every month, then you won't be using a Microsoft supported version of .NET.\n\nThe good news is that patch updates for .NET are *typically* very easy to apply. They rarely contain breaking issues or require significant effort. But eventually there won't be any more patch versions, the version of .NET you're using will go out of support, and *then* what?\n\n### Running an unsupported version of .NET is playing with fire\n\nFundamentally, nothing happens from a *technical* point of view when a .NET version goes out of official support. Everything keeps working, just as it did before. Nevertheless, depending on your regulatory environment, you may find you're no longer compliant, with all the potential associated financial or legal implications.\n\nEven if you're not in a regulated environment, you still have the potential for a big problem to hit at any point: when you (or someone else) discovers an issue in your out-of-support version of .NET.\n\nThis is the exact scenario many people found themselves in recently, when [the request-smuggling security vulnerability CVE-2025-55315](https://github.com/dotnet/aspnetcore/issues/64033) was announced. This vulnerability is Very Badâ„¢ï¸ (a 9.9 severity), because it allows attackers to potentially bypass security controls, exfiltrate data, login as other users, perform injection attacks and more, all by relying on [request smuggling](https://en.wikipedia.org/wiki/HTTP_request_smuggling). Hopefully, you get the pictureâ€¦Not Good.\n\n![A request smuggling attack exploiting differences between a proxy and server implementation](/content/images/2025/request_smuggling_05.svg)\n\n>\n> I [wrote an extensive blog post looking at this vulnerability](/understanding-the-worst-dotnet-vulnerability-request-smuggling-and-cve-2025-55315/), explaining how request smuggling works in general, walking through the specific vulnerability in CVE-2025-55315, describing how to test if you're vulnerable and what to do to protect yourself.\n> >\n\nPatches were released for the vulnerability for .NET 8, .NET 9, and .NET 10, as these were in support. But basically *all* versions of .NET are vulnerable; *at least* .NET Core 3.1. NET 5, .NET 6, and .NET 7.\n\nAll of which leaves those organisations running an unsupported version of .NET in a sticky situation. If you keep running an unsupported version of .NET, then your application has a known 9.9 severity vulnerability. The alternative is to perform a *major* version update of your applications to use a supported version of .NET, but that might also be easier said than doneâ€¦\n\n>\n> If you're using .NET 6, then there's another option, [HeroDevs](https://www.herodevs.com/support/dot-net-nes), which we're going to come to shortly! ðŸ˜…\n> >\n\n## The difficulties of a major version update\n\nMany developers look forward to new major versions of .NET. A new major version of .NET typically means:\n\n- **Performance improvements**. Incredibly, each new version of .NET is faster than the previous version.\n- **New features**. A major version typically means new features. Whether that's incremental improvements or entirely new features, most releases touch all parts of the .NET stack.\n- **Support for new platforms**. Some major releases include support for new operating systems and CPU architectures.\n\nBut a major upgrade isn't always for the feint of heart. We've come a long way from the huge shifts between .NET Core 1.0, .NET Core 2.0, and .NET Core 3.1, but there are still many potential risks associated with performing major version updates, particularly when viewed from an *organisation*'s point of view. For example:\n\n- **Breaking changes**. Major version updates inevitably come with a variety [of breaking changes](https://learn.microsoft.com/en-us/dotnet/core/compatibility/10.0). How severely you're affected by these issues will depend on your specific application, but you should always review this list to establish which, if any, would impact you, and plan work to mitigate them as part of an upgrade.\n- **Behavioural changes**. Even if the changes in an update aren't considered *breaking*, they may still result in a difference in *behaviour*, which could cause your application to behave in a way you don't expect. Often the only way to identify these issues (if they're not marked as breaking changes) is to test your updated application extensively.\n- **Tooling upgrades**. Building a new version of .NET may require that you update various tooling, whether that's the SDK you use to build your application, the continuous integration (CI) runners you use to build your app, or the machines you deploy your application to. This work often takes a large proportion of the overall migration time, and is commonly overlooked.\n- **Regulatory compliance**. Depending on your environment, you may need to re-certify all the applications that you update to a new major version, to ensure they're compliant with any regulations. That can cost time and money.\n- **Internal support**. If you have a \"platform\" team which supports other teams, then there's a degree of experience and learning developers need to undertake to [learn about what's available](/series/exploring-the-dotnet-10-preview/).\n- **Opportunity cost**. Time spent migrating to newer versions of .NET is time spent not implementing new features or addressing customer needs.\n\nUpdating to a new major version clearly has a number of advantages, but for some organisations and applications, the benefits of performance improvements and new features simply aren't enough to offset the risk and costs associated with performing a migration.\n\nBut those *same* organizations *also* can't afford to be stuck on unsupported versions that will cause them regulatory problems, or be at risk of handling unpatched CVEs [like CVE-2025-55315](/understanding-the-worst-dotnet-vulnerability-request-smuggling-and-cve-2025-55315/). So what's a poor .NET-using org to do?\n\n## Why not just pay for support?\n\nAnd now we get to my pitch: **delay the major-version update if it's too painful, and just pay for support for old .NET versions**.\n\nAs I discussed in the previous section, organizations often don't *want* to do major version updates, due to the difficulties described previously. Organisations make these major updates because they *have* to, to ensure they can address any security issues that appear, and to ensure they're compliant with their regulatory requirements.\n\n>\n> A prime example is an application which is no longer being actively developed. The costs associated with performing a major version update in this case likely outweigh the benefits, especially if this triggers any sort of compliance or audit requirements. But leaving the app unsupported is also not an option.\n> >\n\nThe fact that organisations don't *want* to update to new major versions of .NET sometimes manifests as pleas to Microsoft for them to extend the support windows for .NET. Many organisations yearn for the decades-long support of Windows or .NET Framework, and ask \"why can't modern .NET be like that\".\n\nBut here's the thing, even with a *decade* of support, organizations don't want to upgrade! Windows 10 was no longer supported as of October 2025 (10 years after its release), and yet [it still accounts for 40% of active Windows versions](https://gs.statcounter.com/windows-version-market-share/desktop/worldwide)! Organisations *hate* changeâ€¦\n\nOf course, Windows 10 ended *standard* support in October 2025, but [you can still *pay* for extended support](https://www.microsoft.com/en-gb/windows/extended-security-updates?r=1) for Windows 10 and receive security updates. So it seems like the simple answer is \"if you don't want to update, just pay for support\".\n\n### Post-EOL support in other ecosystems\n\nThis model of paying for support after a product's official support has ended is also common in other ecosystems. Take Java for example. Multiple vendors produce Open JDK distributions, and provide substantial support durations for them, but you often need to pay for that:\n\n| Vendor | Supported JDKs | Support Duration | | --- | --- | --- | | Red Hat) | 8, 11, 17, 21 ([varies by RHEL release](https://access.redhat.com/articles/1299013)) | Typically up to 8+ years (with RHEL subscription) | | Microsoft) | 11, 17, 21 ([based on Microsoft support policy](https://learn.microsoft.com/en-us/java/openjdk/support#release-and-servicing-roadmap)) | Typically 6+ years | | Ubuntu | 8, 11, 17, 21 ([varies by Ubuntu release](https://ubuntu.com/toolchains/java)) | 12 years (with extended support) |\n\nSimilarly, the [Java Spring and Spring Boot frameworks](https://spring.io/projects/spring-framework) provide free support for releases initially, and then have paid options through VMware Tanzu, [as shown on their support page](https://spring.io/projects/spring-framework#support):\n\n![The Spring support matrix from https://spring.io/projects/spring-framework#support ](/content/images/2025/spring.png)\n\nHowever there are also a whole load of third-party companies that will happily provide paid support for Spring Framework and Spring Boot even beyond these timelines ([including HeroDevs](https://www.herodevs.com/support/spring-nes)!)\n\nAnd it's not like the willingness to pay for support after a product is officially EOL is restricted to the Java ecosystem. You can find EOL support for all *sorts* of front-end frameworks like Angular, AngularJS, Vue, heck, even *Bootstrap*.\n\n![An example of the front-end frameworks supported by HeroDevs](/content/images/2025/herodevs_frontend.png)\n\nSo why not .NET too?\n\n### Post-EOL support in .NET\n\nSo why does it seem like some companies are so hesitant to pay for post-EOL support for .NET? I would speculate that part of the reason is because *Microsoft* has typically been willing to provide *very* long support windows in general. Take .NET Framework for example; .NET Framework 3.5 is *still* supportedâ€”it's not EOL until 2029!\n\nI suspect another major reason is that some .NET organisations simply don't know that paying for post-EOL support is an option! as far as I can tell, Microsoft doesn't explicitly endorse or even *mention* that this is available for the ecosystem, nor do Microsoft-adjacent bodies like [the .NET Foundation](https://dotnetfoundation.org/). I really don't know why they wouldn't, it seems like a win-win scenario to me. ðŸ¤·\n\nSo consider this my public service announcement:\n\n>\n> If you're still running applications on .NET 6, or if you're eyeing .NET 8's end of support next year with concern, don't worry. Switch to a post-EOL support build of .NET 6 (or .NET 8 next year), and you'll receive security fixes without needing to do go through a costly major version update.\n> >\n\nThis is the pitch [HeroDevs make for their .NET support](https://www.herodevs.com/support/dot-net-nes):\n\n- **Security Fixes**. A new version of NES for .NET will be released each time HeroDevs find, validate, and fix a security issue.\n- **Drop-In Compatibility**. A direct replacement for your frameworkâ€”no migrations, no rewrites, just ongoing support.\n- **SLA Compliance**. HeroDevs [provides SLAs](https://docs.herodevs.com/legal/service-level-agreement) that ensure compliance by providing incident response and remediation in accordance with industry-standard regulations, including SOC 2, FedRAMP, PCI, and HIPAA.\n\nOf course, like me, you'll probably still have questions:\n\n- \"Just *how* easy is to swap to a post-EOL supported version?\"\n- \"Will I get fixes for security issues found in *other* versions of .NET?\"\n- \"How much is this going to cost?\"\n\nThe final point is going to vary depending on your requirements, so you'll need to [dig into that yourself](https://www.herodevs.com/pricing). But I wanted to get a feel for the technical side of the first two questions, so I gave HeroDevs' [Never Ending Support (NES) for .NET 6](https://www.herodevs.com/support/dot-net-nes) a try!\n\n## Trying out HeroDevs' Never Ending Support for .NET\n\nHeroDevs provide a drop-in replacement for out-of-support .NET 6 versions as part of their [Never-Ending Support (NES) for .NET](https://www.herodevs.com/support/dot-net-nes). They provide both Linux and Windows binaries, so you can easily patch your existing applications, no matter how you deploy.\n\nI wanted to test out the NES binaries, and I thought the best way to show the benefits would be to test the binaries against the recent [CVE-2025-55315](https://github.com/dotnet/aspnetcore/issues/64033) vulnerability. My plan was:\n\n- Create a simple docker image using the latest official .NET 6 version.\n- Demonstrate the presence of the [CVE-2025-55315](https://github.com/dotnet/aspnetcore/issues/64033) vulnerability.\n- Update the docker image to use HeroDevs' NES version of .NET 6.\n- Show that the vulnerability no longer exists.\n\nLuckily, as I described in [my post about the CVE-2025-55315 vulnerability](/understanding-the-worst-dotnet-vulnerability-request-smuggling-and-cve-2025-55315/), we can test for the presence of the vulnerability in .NET using [this GitHub repo from Hayden Barnes](https://github.com/sirredbeard/CVE-2025-55315-repro). The app in this repo tests for the CVE-2025-55315 by sending a malicious payload to an ASP.NET Core app. It then prints the result of the test to the output. For example, if we run the test against an up-to-date .NET 8.0 release, we get the following results:\n\n![Shows the result of the repro testing for the CVE-2025-55315 against .NET 8, and includes 2/2 tests passed](/content/images/2025/herodevs_repro.png)\n\nAt the bottom of the output you can see the `2/2 tests passed` , showing that the latest .NET 8 release (8.0.22) is *not* vulnerable to CVE-2025-55315. Now we'll try it against .NET 6.\n\n### Demonstrating that .NET 6 is vulnerable to CVE-2025-55315\n\nThe dockerfile below is how I tested against .NET 6. It uses the latest .NET 10 SDK to build the app from the reproduction GitHub repo, and then copies the published app into the latest [official .NET 6 docker image](https://github.com/dotnet/dotnet-docker/blob/main/README.aspnet.md).\n\n```dockerfile\n# ---------------Builder image---------------------- #\nFROM mcr.microsoft.com/dotnet/sdk:10.0 AS builder\n\n# Clone the reproduction repo\nRUN git clone https://github.com/sirredbeard/CVE-2025-55315-repro /app\n\n# Publish the app for .NET 6 to the /app/publish folder\nRUN dotnet publish /app/Repro/Repro.csproj -c Release --framework net6.0 -o /app/publish\n\n# ---------------Final image---------------------- #\n# Use the latest official .NET 6 image\nFROM mcr.microsoft.com/dotnet/aspnet:6.0\n\n# Copy the published app from the builder image\nWORKDIR /app COPY --from=builder /app/publish .\n\n# Run the app\nENTRYPOINT [\"dotnet\", \"Repro.dll\"]\n\n```\n\n>\n> Note that I *built* the app with .NET 10, but you can always use a more recent version of the .NET SDK to build applications that target *older* versions of .NET. In many ways this is preferable to using an old .NET SDK, as you benefit from compiler improvements and the ability to use newer versions of C#.\n> >\n\nTo test the above docker image, copy it into a file called `Dockerfile` and build and test it using the following:\n\n```bash docker build -t andrewlock/repro-test:official-6.0 . docker run --rm -it andrewlock/repro-test:official-6.0\n\n```\n\nThis runs the same vulnerability reproduction tests as we ran for .NET 8, but this time the tests fail, and we can see that [the latest .NET 6 release, version 6.0.36,](https://dotnet.microsoft.com/en-us/download/dotnet/6.0) *is* vulnerable to CVE-2025-55315, as shown by the `0/2 tests passed` in the logs:\n\n![=== Runtime Version Information === .NET Runtime: 6.0.36 Runtime Directory: /usr/share/dotnet/shared/Microsoft.NETCore.App/6.0.36/ warn: Microsoft.AspNetCore.Server.Kestrel Overriding address(es) 'http://+:80'. Binding to endpoints defined via IConfiguration and/or UseKestrel() instead. info: Microsoft.Hosting.Lifetime\\[14\\] Now listening on: http://localhost:5000 info: Microsoft.Hosting.Lifetime Application started. Press Ctrl+C to shut down. Kestrel.Core Version: 6.0.36+64ea4108e7dcf1ca575f8dd2028363b0b1ef6ebc info: Microsoft.Hosting.Lifetime Hosting environment: Production info: Microsoft.Hosting.Lifetime Content root path: /app ASP.NET Core Version: 6.0.36+64ea4108e7dcf1ca575f8dd2028363b0b1ef6ebc =================================== Server started on http://localhost:5000 info: Microsoft.AspNetCore.Hosting.Diagnostics\\[1\\] Request starting HTTP/1.1 GET http:/// - - info: Program Bad chunk extension NOT detected. info: Microsoft.AspNetCore.Hosting.Diagnostics\\[2\\] Request finished HTTP/1.1 GET http:/// - - - 408 - - 10915.5124ms Test 1 FAILED info: Microsoft.AspNetCore.Hosting.Diagnostics\\[1\\] Request starting HTTP/1.1 GET http:/// - - info: Program Bad chunk extension NOT detected. info: Microsoft.AspNetCore.Hosting.Diagnostics\\[2\\] Request finished HTTP/1.1 GET http:/// - - - 408 - - 10977.8230ms Test 2 FAILED 0/2 tests passed info: Microsoft.Hosting.Lifetime Application is shutting down...](/content/images/2025/herodevs_repro_6.png)\n\nThis shows that if you're running .NET 6 today, you've vulnerable to CVE-2025-55315.\n\n### Using the HeroDevs NES for .NET 6 build\n\nTo test out HeroDevs' NES for .NET 6 support, [Hayden Barnes](/cdn-cgi/l/email-protection#5d353f3c2f33382e1d35382f3239382b2e733e3230) provided me with a docker image containing their patched NES version of .NET 6.\n\n>\n> This isn't necessarily the way you *need* to integrate HeroDevs into your build pipeline, it was just a convenient approach for me. HeroDevs provide multiple ways to integrate, so [reach out to them](https://www.herodevs.com/contact) for more details!\n> >\n\nThe only change I made was to switch out the \"official\" .NET 6 image with HeroDevs patched version of .NET 6. Note that you won't be able to use the docker image below as-is, you'll need to contact HeroDevs to get access to patched versions of .NET; I was provided this image directly by HeroDevs just for testing.\n\n```dockerfile\n\n# ---------------Builder image---------------------- #\nFROM mcr.microsoft.com/dotnet/sdk:10.0 AS builder\n\nRUN git clone https://github.com/sirredbeard/CVE-2025-55315-repro /app RUN dotnet publish /app/Repro/Repro.csproj -c Release --framework net6.0 -o /app/publish\n\n# ---------------Final image---------------------- #\n# ðŸ‘‡ Using HeroDevs NES for .NET 6 version\nFROM registry.nes.herodevs.com/oci/dotnet-runtime:6.0.39-bullseye-slim\n\nWORKDIR /app COPY --from=builder /app/publish .\n\nENTRYPOINT [\"dotnet\", \"Repro.dll\"]\n\n```\n\nI then built the docker image and ran it using:\n\n```bash docker build -t andrewlock/repro-test:nes-6.0 . docker run --rm -it andrewlock/repro-test:nes-6.0\n\n```\n\nand as you can see from the logs below, the NES version of .NET 6 is *not* vulnerable to CVE-2025-55315! ðŸŽ‰\n\n![=== Runtime Version Information === .NET Runtime: 6.0.39 Runtime Directory: /usr/share/dotnet/shared/Microsoft.NETCore.App/6.0.39/ info: Microsoft.Hosting.Lifetime\\[14\\] Now listening on: http://localhost:5000 info: Microsoft.Hosting.Lifetime Application started. Press Ctrl+C to shut down. info: Microsoft.Hosting.Lifetime Hosting environment: Production info: Microsoft.Hosting.Lifetime Content root path: /app Kestrel.Core Version: 6.0.39+c7c5c868b73b54f925f3a9d0ca7080b5910be4b9 ASP.NET Core Version: 6.0.39+c7c5c868b73b54f925f3a9d0ca7080b5910be4b9 =================================== Server started on http://localhost:5000 info: Microsoft.AspNetCore.Hosting.Diagnostics\\[1\\] Request starting HTTP/1.1 GET http:/// - - info: Program Bad chunk extension detected. info: Microsoft.AspNetCore.Hosting.Diagnostics\\[2\\] Request finished HTTP/1.1 GET http:/// - - - 400 - - 82.6425ms Test 1 PASSED info: Microsoft.AspNetCore.Hosting.Diagnostics\\[1\\] Request starting HTTP/1.1 GET http:/// - - info: Program Bad chunk extension detected. info: Microsoft.AspNetCore.Hosting.Diagnostics\\[2\\] Request finished HTTP/1.1 GET http:/// - - - 400 - - 0.4682ms Test 2 PASSED 2/2 tests passed info: Microsoft.Hosting.Lifetime Application is shutting down...](/content/images/2025/herodevs_repro_nes.png)\n\nThe logs above show that the .NET version provided in the NES for .NET build is `6.0.39` , higher than the latest official version of `6.0.36` . This is thanks to the additional patches HeroDevs apply to the runtime and libraries on *top* of the 6.0.36 base.\n\nAnd there you have it. We easily replaced a vulnerable version of .NET 6 with HeroDevs' NES for .NET version and our app was no longer vulnerable. No costly or risky major version updates required, just support for what you're already using!\n\n>\n> One aspect I didn't strictly demonstrate was that we didn't even recompile the appâ€”we simply swapped out the *runtime* image, not the build step. Even if you *can't* rebuild your app (perhaps you lost the source code, for example), the HeroDevs solution still works, while updating to a new major version clearly wouldn't be an option!\n> >\n\nI demonstrated an ASP.NET Core app in this example, but HeroDevs support many different components: the .NET SDK, the runtime, the ASP.NET Core runtime, WPF, and more! Just [reach out to the team at HeroDevs](https://www.herodevs.com/support/dot-net-nes) and see how they can help you keep your applications protected.\n\n## Conclusion\n\nIn this post I described the support that Microsoft provides for .NET, including what \"supported\" means, the requirement for you to patch every month to be supported, and the risks you're exposing yourself to if you *don't* regularly patch your applications.\n\nI then discussed some of the difficulties of staying up to date when a major version is no longer supported. A major version update can mean potentially time-consuming and costly updates, depending on the number and type of applications you need to support. Obviously there are benefits to updating to newer major versions, and I'm certainly not suggesting you *don't* update. But if you *can't* update, then there's another option: pay for support.\n\nIn many other ecosystems, paying for support of end-of-life (EOL) products is common place. It's just an accepted maintenance cost, and it frees organisations from the regulatory and maintenance barriers of *having* to update all your applications when a framework goes EOL. For organisations that have dozens, hundreds, or even thousands of apps, performing a mass migration simply isn't practical, and post-EOL support is a very practical option.\n\nAnd I think .NET organisations should embrace this. Companies like [HeroDevs](https://www.herodevs.com/) can provide patched versions of EOL runtimes that you can \"drop in\" to your existing apps and get instance support and protection, with very little work required on your sideâ€”you don't even need to recompile your apps, which my be crucial in some cases (oops, we lost the source codeðŸ˜…).\n\nAt the end of this post I tried out HeroDevs support, by showing how easy it is to drop in their Never Ending Support (NES) for .NET 6 binary. After switching to NES for .NET, I demonstrated how an application that was vulnerable to [the critical CVE-2025-55315 vulnerability](/understanding-the-worst-dotnet-vulnerability-request-smuggling-and-cve-2025-55315/) was now protected.\n\nMore organisations should be considering this as a path forward; if upgrading to a new major version is too costly, or simply isn't possible, take a look at [HeroDevs](https://www.herodevs.com/), and see if they can meet your needs!\n\n## Tags\n\nAndrew Lock | .Net Escapades\n\n![](/assets/img/icons/apple/apple-touch-icon-180x180.png) Want an email when there's new posts?\n\nStay up to the date with the latest posts!\n\nOops! Check your details and try again.\n\nThanks! Check your email for confirmation.",
  "Link": "https://andrewlock.net/companies-using-dotnet-need-to-suck-it-up-and-pay-for-support/",
  "Title": "Companies complaining .NET moves too fast should just pay for post-EOL support",
  "Author": "Andrew Lock",
  "FeedLevelAuthor": "Andrew Lock | .NET Escapades",
  "FeedUrl": "https://andrewlock.net/rss.xml",
  "FeedName": "Andrew Lock's Blog",
  "ProcessedDate": "2025-11-18 11:02:54",
  "PubDate": "2025-11-18T10:00:00+00:00",
  "Description": "In this post I describe a solution to .NET \"releasing too quickly\": just pay for support of older versions, such as HeroDevs' Never Ending Support for .NET 6",
  "Tags": [
    ".NET Core",
    "ASP.NET Core",
    "Security"
  ],
  "OutputDir": "_blogs"
}
