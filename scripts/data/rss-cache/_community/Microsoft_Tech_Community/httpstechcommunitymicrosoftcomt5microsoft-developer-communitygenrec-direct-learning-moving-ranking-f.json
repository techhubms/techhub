{
  "Title": "GenRec Direct Learning: Moving Ranking from Feature Pipelines to Token-Native Sequence Modeling",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Description": "Authors: Chunlong Yu, Han Zheng, Jie Zhu, I-Hong Jhuo, Li Xia, Lin Zhu, Sawyer Shen\n\n#### **TL;DR**\n\nMost modern ranking stacks rely on large generative models as **feature extractors**, flattening their outputs into vectors that are then fed into downstream rankers. While effective, this pattern introduces additional pipeline complexity and often dilutes token‑level semantics. **GenRec Direct Learning (DirL)** explores a different direction: using a **generative, token‑native sequential model** as the ranking engine itself. In this formulation, ranking becomes an **end‑to‑end sequence modeling** problem over user behavior, context, and candidate items—without an explicit feature‑extraction stage.\n\n#### **Why revisit the classic L2 ranker design?**\n\nLarge‑scale recommender systems have historically evolved as layered pipelines: more signals lead to more feature plumbing, which in turn introduces more special cases. In our previous L2 ranking architecture, signals were split into **dense** and **sparse** branches and merged late in the stack (Fig. 1). As the system matured, three recurring issues became increasingly apparent.\n\n![]()\n\nFigure 1: traditional ranking DNN\n\n**1) Growing pipeline surface area** Each new signal expands the surrounding ecosystem—feature definitions, joins, normalization logic, validation, and offline/online parity checks. Over time, this ballooning surface area slows iteration, raises operational overhead, and increases the risk of subtle production inconsistencies.\n\n**2) Semantics diluted by flattening** Generative models naturally capture rich structure: token‑level interactions, compositional meaning, and contextual dependencies. However, when these representations are flattened into sparse or dense feature vectors, much of that structure is lost—undermining the very semantics that make generative representations powerful.\n\n**3) Sequence modeling is treated as an add-on** While traditional rankers can ingest history features, modeling long behavioral sequences and fine‑grained temporal interactions typically requires extensive manual feature engineering. As a result, sequence modeling is often bolted on rather than treated as a first‑class concern.\n\n**DirL goal:** **** treat ranking as **native sequence learning**, not as “MLP over engineered features.”\n\n![]()\n\n#### **What “Direct Learning” means in DirL**\n\nThe core shift behind **Direct Learning (DirL)** is simple but fundamental.\n\nInstead of the conventional pipeline:\n\ngenerative model → embeddings → downstream ranker,\n\nDirL adopts an end‑to‑end formulation:\n\ntokenized sequence → generative sequential model → ranking score(s).\n\nIn DirL, user context, long‑term behavioral history, and candidate item information are all represented within a single, unified token sequence. Ranking is then performed directly by a generative, token‑native sequential model.\n\nThis design enables several key capabilities:\n\n- **Long‑term behavior modeling beyond short summary windows**\nThe model operates over extended user histories, allowing it to capture long‑range dependencies and evolving interests that are difficult to represent with fixed‑size aggregates.\n\n- **Fine‑grained user–content interaction learning**\nBy modeling interactions at the token level, DirL learns detailed behavioral and content patterns rather than relying on coarse, pre‑engineered features.\n\n- **Preserved cross‑token semantics within the ranking model**\nSemantic structure is maintained throughout the ranking process, instead of being collapsed into handcrafted dense or sparse vectors before scoring.\n\n#### **Architecture overview (from signals to ranking)**\n\n**1) Unified Tokenization**\n\nAll inputs in DirL are converted into a **shared token embedding space**, allowing heterogeneous signals to be modeled within a single sequential backbone. Conceptually, each input sequence consists of three token types:\n\n- **User / context tokens**\nThese tokens encode user or request‑level information, such as age or cohort‑like attributes, request or canvas context, temporal signals (e.g., day or time), and user‑level statistics like historical CTR.\n\n- **History tokens**\nThese represent prior user interactions over time, including signals such as engaged document IDs, semantic or embedding IDs, and topic‑like attributes. Each interaction is mapped to a token, preserving temporal order and enabling long‑range behavior modeling.\n\n- **Candidate tokens**\nEach candidate item to be scored is represented as a token constructed from document features and user–item interaction features. These features are concatenated and projected into a fixed‑dimensional vector via an MLP, yielding a token compatible with the shared embedding space.\n\nCategorical features are embedded directly, while dense numerical signals are passed through MLP layers before being fused into their corresponding tokens. As a result, the model backbone consumes a sequence of the form:\n\n[1 user/context token] + [N history tokens] + [1 candidate token]\n\n**2) Long-sequence modeling backbone (HSTU)**\n\nTo model long input sequence, DirL adopts a sequential backbone designed to scale beyond naïve full attention. In the current setup, the backbone consists of stacked HSTU layers with multi‑head attention and dropout for regularization. The hidden state of the candidate token from the final HSTU layer is then fed into an MMoE module for scoring.\n\n**3) Multi-task prediction head (MMoE)**\n\nRanking typically optimizes multiple objectives (e.g., engagement‑related proxies). DirL employs a multi‑gate mixture‑of‑experts (MMoE) layer to support multi‑task prediction while sharing representation learning.\n\nThe MMoE layer consists of N shared experts and one task‑specific expert per task. For each task, a gating network produces a weighted combination of the shared experts and the task‑specific expert. The aggregated representation is then fed into a task‑specific MLP head to produce the final prediction.\n\n![]()\n\nFigure 2: DirL structure\n\n#### **Early experiments: what worked and what didn’t**\n\n**What looked promising**\n\nEarly results indicate that a token‑native setup improves both inhouse evaluation metrics and online engagement (time spent per UU), suggesting that modeling long behavior sequences in a unified token space is directionally beneficial.\n\n**The hard part: efficiency and scale**\n\nThe same design choices that improve expressiveness also raise practical hurdles:\n\n- **Training velocity slows down****:** long-sequence modeling and larger components can turn iteration cycles from hours into days, making ablations expensive.\n\n- **Serving and training costs increase****:** large sparse embedding tables + deep sequence stacks can dominate memory and compute.\n\n- **Capacity constraints limit rollout speed****:** Hardware availability and cost ceilings become a gating factor for expanding traffic and experimentation.\n\nIn short: DirL’s main challenge isn’t “can it learn the right dependencies?”—it’s “can we make it cheap and fast enough to be a production workhorse?”\n\n#### **Path to production viability: exploratory directions**\n\nOur current work focuses on understanding how to keep the semantic benefits of token‑native modeling while exploring options that could help reduce overall cost.\n\n**1) Embedding tables**\n\n- consolidate and prune oversized sparse tables\n\n- rely more on shared token representations where possible\n\n**2) Right-size the sequence model**\n\n- reduce backbone depth where marginal gains flatten\n\n- evaluate minimal effective token sets—identify which tokens actually move metrics.\n\n- explore sequence length vs. performance curves to find the “knee”\n\n**3) Inference and systems optimization**\n\n- dynamic batching tuned for token-native inference\n\n- kernel fusion and graph optimizations\n\n- quantization strategies that preserve ranking model behavior\n\n#### **Why this direction matters**\n\nDirL explores a broader shift in recommender systems—from feature‑heavy pipelines with shallow rankers toward **** **foundation‑style sequential models** that learn directly from user trajectories. If token‑native ranking can be made efficient, it unlocks several advantages:\n\n- Simpler modeling interfaces, with fewer feature‑plumbing layers.\n\n- Stronger semantic utilization, reducing information loss from aggressive flattening.\n\n- A more natural path to long‑term behavior and intent modeling.\n\nEarly signals are encouraging. The next phase is about translating this promise into practice—making the approach **scalable, cost‑efficient, and fast enough to iterate** as a production system.\n\n#### **Using Microsoft Services to Enable Token‑Native Ranking Research**\n\nThis work was developed and validated within Microsoft’s internal machine learning and experimentation ecosystem.\n\nTraining data was derived from seven days of MSN production logs and user behavior labels, encompassing thousands of features, including numerical, ID‑based, cross, and sequential features. Model training was performed using a **PyTorch‑based deep learning framework built by the MSN infrastructure team** and executed on **Azure Machine Learning** with a single A100 GPU.\n\nFor online serving, the trained model was deployed on **DLIS**, Microsoft’s internal inference platform. Evaluation was conducted through controlled online experiments on the **Azure Exp platform**, enabling validation of user engagement signals under real production traffic.\n\nAlthough the implementation leverages Microsoft’s internal platforms, the core ideas behind DirL are broadly applicable. Practitioners interested in exploring similar approaches may consider the following high‑level steps:\n\n- Construct a unified token space that captures user context, long‑term behavior sequences, and candidate items.\n\n- Apply a long‑sequence modeling backbone to learn directly from extended user trajectories.\n\n- Formulate ranking as a native sequence modeling problem, scoring candidates from token‑level representations.\n\n- Evaluate both model effectiveness and system efficiency, balancing gains in expressiveness against training and serving cost.\n\n#### **Call to action**\n\nWe encourage practitioners and researchers working on large‑scale recommender systems to experiment with token‑native ranking architectures alongside traditional feature‑heavy pipelines, compare trade‑offs in modeling power and system efficiency, and share insights on when direct sequence learning provides practical advantages in production environments.\n\n#### **Acknowledgement:**\n\nWe would like to acknowledge the support and contributions from several colleagues who helped make this work possible.\n\nWe thank Gaoyuan Jiang and Lightning Huang for their assistance with model deployment, Jianfei Wang for support with the training platform, Gong Cheng for ranker monitoring, Peiyuan Xu for sequential feature logging, and Chunhui Han and Peng Hu for valuable discussions on model design.",
  "Link": "https://techcommunity.microsoft.com/t5/microsoft-developer-community/genrec-direct-learning-moving-ranking-from-feature-pipelines-to/ba-p/4494252",
  "FeedName": "Microsoft Tech Community",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "EnhancedContent": "Authors: Chunlong Yu, Han Zheng, Jie Zhu, I-Hong Jhuo, Li Xia, Lin Zhu, Sawyer Shen\n\n#### **TL;DR**\n\nMost modern ranking stacks rely on large generative models as **feature extractors**, flattening their outputs into vectors that are then fed into downstream rankers. While effective, this pattern introduces additional pipeline complexity and often dilutes token‑level semantics. **GenRec Direct Learning (DirL)** explores a different direction: using a **generative, token‑native sequential model** as the ranking engine itself. In this formulation, ranking becomes an **end‑to‑end sequence modeling** problem over user behavior, context, and candidate items—without an explicit feature‑extraction stage.\n\n#### **Why revisit the classic L2 ranker design?**\n\nLarge‑scale recommender systems have historically evolved as layered pipelines: more signals lead to more feature plumbing, which in turn introduces more special cases. In our previous L2 ranking architecture, signals were split into **dense** and **sparse**branches and merged late in the stack (Fig. 1). As the system matured, three recurring issues became increasingly apparent.\n\nFigure 1: traditional ranking DNN\n\n**1) Growing pipeline surface area** Each new signal expands the surrounding ecosystem—feature definitions, joins, normalization logic, validation, and offline/online parity checks. Over time, this ballooning surface area slows iteration, raises operational overhead, and increases the risk of subtle production inconsistencies.\n\n**2) Semantics diluted by flattening** Generative models naturally capture rich structure: token‑level interactions, compositional meaning, and contextual dependencies. However, when these representations are flattened into sparse or dense feature vectors, much of that structure is lost—undermining the very semantics that make generative representations powerful.\n\n**3) Sequence modeling is treated as an add-on** While traditional rankers can ingest history features, modeling long behavioral sequences and fine‑grained temporal interactions typically requires extensive manual feature engineering. As a result, sequence modeling is often bolted on rather than treated as a first‑class concern.\n\n**DirL goal:******treat ranking as **native sequence learning**, not as “MLP over engineered features.”\n\n#### **What “Direct Learning” means in DirL**\n\nThe core shift behind **Direct Learning (DirL)** is simple but fundamental.\n\nInstead of the conventional pipeline:\n\ngenerative model → embeddings → downstream ranker,\n\nDirL adopts an end‑to‑end formulation:\n\ntokenized sequence → generative sequential model → ranking score(s).\n\nIn DirL, user context, long‑term behavioral history, and candidate item information are all represented within a single, unified token sequence. Ranking is then performed directly by a generative, token‑native sequential model.\n\nThis design enables several key capabilities:\n\n- **Long‑term behavior modeling beyond short summary windows**\nThe model operates over extended user histories, allowing it to capture long‑range dependencies and evolving interests that are difficult to represent with fixed‑size aggregates.\n\n- **Fine‑grained user–content interaction learning**\nBy modeling interactions at the token level, DirL learns detailed behavioral and content patterns rather than relying on coarse, pre‑engineered features.\n\n- **Preserved cross‑token semantics within the ranking model**\nSemantic structure is maintained throughout the ranking process, instead of being collapsed into handcrafted dense or sparse vectors before scoring.\n\n#### **Architecture overview (from signals to ranking)**\n\n**1) Unified Tokenization**\n\nAll inputs in DirL are converted into a **shared token embedding space**, allowing heterogeneous signals to be modeled within a single sequential backbone. Conceptually, each input sequence consists of three token types:\n\n- **User / context tokens**\nThese tokens encode user or request‑level information, such as age or cohort‑like attributes, request or canvas context, temporal signals (e.g., day or time), and user‑level statistics like historical CTR.\n\n- **History tokens**\nThese represent prior user interactions over time, including signals such as engaged document IDs, semantic or embedding IDs, and topic‑like attributes. Each interaction is mapped to a token, preserving temporal order and enabling long‑range behavior modeling.\n\n- **Candidate tokens**\nEach candidate item to be scored is represented as a token constructed from document features and user–item interaction features. These features are concatenated and projected into a fixed‑dimensional vector via an MLP, yielding a token compatible with the shared embedding space.\n\nCategorical features are embedded directly, while dense numerical signals are passed through MLP layers before being fused into their corresponding tokens. As a result, the model backbone consumes a sequence of the form:\n\n[1 user/context token] + [N history tokens] + [1 candidate token]\n\n**2) Long-sequence modeling backbone (HSTU)**\n\nTo model long input sequence, DirL adopts a sequential backbone designed to scale beyond naïve full attention. In the current setup, the backbone consists of stacked HSTU layers with multi‑head attention and dropout for regularization. The hidden state of the candidate token from the final HSTU layer is then fed into an MMoE module for scoring.\n\n**3) Multi-task prediction head (MMoE)**\n\nRanking typically optimizes multiple objectives (e.g., engagement‑related proxies). DirL employs a multi‑gate mixture‑of‑experts (MMoE) layer to support multi‑task prediction while sharing representation learning.\n\nThe MMoE layer consists of N shared experts and one task‑specific expert per task. For each task, a gating network produces a weighted combination of the shared experts and the task‑specific expert. The aggregated representation is then fed into a task‑specific MLP head to produce the final prediction.\n\nFigure 2: DirL structure\n\n#### **Early experiments: what worked and what didn’t**\n\n**What looked promising**\n\nEarly results indicate that a token‑native setup improves both inhouse evaluation metrics and online engagement (time spent per UU), suggesting that modeling long behavior sequences in a unified token space is directionally beneficial.\n\n**The hard part: efficiency and scale**\n\nThe same design choices that improve expressiveness also raise practical hurdles:\n\n- **Training velocity slows down****:** long-sequence modeling and larger components can turn iteration cycles from hours into days, making ablations expensive.\n\n- **Serving and training costs increase****:**large sparse embedding tables + deep sequence stacks can dominate memory and compute.\n\n- **Capacity constraints limit rollout speed****:** Hardware availability and cost ceilings become a gating factor for expanding traffic and experimentation.\n\nIn short: DirL’s main challenge isn’t “can it learn the right dependencies?”—it’s “can we make it cheap and fast enough to be a production workhorse?”\n\n#### **Path to production viability: exploratory directions**\n\nOur current work focuses on understanding how to keep the semantic benefits of token‑native modeling while exploring options that could help reduce overall cost.\n\n**1) Embedding tables**\n\n- consolidate and prune oversized sparse tables\n\n- rely more on shared token representations where possible\n\n**2) Right-size the sequence model**\n\n- reduce backbone depth where marginal gains flatten\n\n- evaluate minimal effective token sets—identify which tokens actually move metrics.\n\n- explore sequence length vs. performance curves to find the “knee”\n\n**3) Inference and systems optimization**\n\n- dynamic batching tuned for token-native inference\n\n- kernel fusion and graph optimizations\n\n- quantization strategies that preserve ranking model behavior\n\n#### **Why this direction matters**\n\nDirL explores a broader shift in recommender systems—from feature‑heavy pipelines with shallow rankers toward******foundation‑style sequential models** that learn directly from user trajectories. If token‑native ranking can be made efficient, it unlocks several advantages:\n\n- Simpler modeling interfaces, with fewer feature‑plumbing layers.\n\n- Stronger semantic utilization, reducing information loss from aggressive flattening.\n\n- A more natural path to long‑term behavior and intent modeling.\n\nEarly signals are encouraging. The next phase is about translating this promise into practice—making the approach **scalable, cost‑efficient, and fast enough to iterate** as a production system.\n\n#### **Using Microsoft Services to Enable Token‑Native Ranking Research**\n\nThis work was developed and validated within Microsoft’s internal machine learning and experimentation ecosystem.\n\nTraining data was derived from seven days of MSN production logs and user behavior labels, encompassing thousands of features, including numerical, ID‑based, cross, and sequential features. Model training was performed using a **PyTorch‑based deep learning framework built by the MSN infrastructure team** and executed on **Azure Machine Learning** with a single A100 GPU.\n\nFor online serving, the trained model was deployed on **DLIS**, Microsoft’s internal inference platform. Evaluation was conducted through controlled online experiments on the **Azure Exp platform**, enabling validation of user engagement signals under real production traffic.\n\nAlthough the implementation leverages Microsoft’s internal platforms, the core ideas behind DirL are broadly applicable. Practitioners interested in exploring similar approaches may consider the following high‑level steps:\n\n- Construct a unified token space that captures user context, long‑term behavior sequences, and candidate items.\n\n- Apply a long‑sequence modeling backbone to learn directly from extended user trajectories.\n\n- Formulate ranking as a native sequence modeling problem, scoring candidates from token‑level representations.\n\n- Evaluate both model effectiveness and system efficiency, balancing gains in expressiveness against training and serving cost.\n\n#### **Call to action**\n\nWe encourage practitioners and researchers working on large‑scale recommender systems to experiment with token‑native ranking architectures alongside traditional feature‑heavy pipelines, compare trade‑offs in modeling power and system efficiency, and share insights on when direct sequence learning provides practical advantages in production environments.\n\n#### **Acknowledgement:**\n\nWe would like to acknowledge the support and contributions from several colleagues who helped make this work possible.\n\nWe thank Gaoyuan Jiang and Lightning Huang for their assistance with model deployment, Jianfei Wang for support with the training platform, Gong Cheng for ranker monitoring, Peiyuan Xu for sequential feature logging, and Chunhui Han and Peng Hu for valuable discussions on model design.\n\nUpdated Feb 23, 2026\n\nVersion 1.0\n\n[ai](/tag/ai?nodeId=board%3AAzureDevCommunityBlog)\n\n[llm](/tag/llm?nodeId=board%3AAzureDevCommunityBlog)\n\n[ml catalog](/tag/ml%20catalog?nodeId=board%3AAzureDevCommunityBlog)\n\n[!\\[chunlongyu&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/m_assets/avatars/default/avatar-6.svg?image-dimensions=50x50)](/users/chunlongyu/3337830) [chunlongyu](/users/chunlongyu/3337830) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined January 16, 2026\n\n[View Profile](/users/chunlongyu/3337830)\n\n/category/azure/blog/azuredevcommunityblog [Microsoft Developer Community Blog](/category/azure/blog/azuredevcommunityblog) Follow this blog board to get notified when there's new activity",
  "ProcessedDate": "2026-02-28 07:08:45",
  "OutputDir": "_community",
  "PubDate": "2026-02-28T07:00:00+00:00",
  "Author": "chunlongyu",
  "Tags": []
}
