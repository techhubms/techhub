{
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "FeedName": "Microsoft Tech Community",
  "EnhancedContent": "When you deploy externally accessible applications into Kubernetes, there is usually a requirement for creating some DNS records pointing to these applications, to allow your users to resolve them. Rather than manually creating these DNS records, there are tools that will do this work for you, one of which isÂ [External DNS](https://github.com/kubernetes-sigs/external-dns).\n\nExternal DNS can watch your Kubernetes resource configuration for specific annotations and then use these to create DNS records in your DNS zone. It has integrations with many DNS providers, including Azure DNS. This solution works well and is in use by many customers using AKS and Azure DNS. Where we hit a limitation with External DNS in Azure is in scenarios where we are need to distribute traffic across multiple clusters for load balancing and global distribution.\n\nThere are a few ways to achieve this global distribution in Azure, one way is to use Azure Traffic Manger. Unlike something like Azure Front Door, Azure Traffic Manager is a DNS based global load balancer. Traffic is directed to your different AKS clusters based on DNS resolution using Traffic Manager. When a user queries your Traffic Manager CNAME, they hit the Traffic Manager DNS servers, which then return a DNS record for a specific cluster based on your load balancing configuration. Traffic Manager can then introduce advanced load balancing scenarios such as:\n\n- **Geographic routing** - direct users to the nearest endpoint based on their location\n- **Weighted distribution** - split traffic percentages (e.g., 80% to one region, 20% to another)\n- **Priority-based failover** - automatic disaster recovery with primary/backup regions\n- **Performance-based routing** - direct users to the endpoint with lowest latency\n\nSo, given Azure Traffic Manager is a essentially a DNS service, it would be good if we could manage it using External DNS. We already use External DNS to create DNS records for each of our individual clusters, so why not use it to also create the Traffic Manager DNS configuration to load balance across them. This would also provides the added benefit of allowing us to change our load balancing strategy or configuration by making changes to our External DNS annotations.\n\nUnfortunately, an External DNS integration for Traffic Manager doesn't currently exist. In this post, I'll walk through a proof-of-concept for a provider I built to explore whether this integration is viable, and share what I learned along the way.\n\n## External DNS Webhook Provider\n\nExternal DNS has two types of integrations. The first, and most common for \"official\" providers are \"In-tree\" providers, which are the integrations that have been created by External DNS contributors and sit within the central External DNS repository. This includes the Azure DNS provider. The second type of provider is the WebHook provider, which allows for external contributors to easily create their own providers without the need to submit them to the core External DNS repo and go through that release process. We are going to use the WebHook provider\n\n> >\n> External DNS has begun the process of phasing out \"In-tree\" providers and replacing with WebHook ones. No new \"In-tree\" providers will be accepted.\n> >\n\nBy using the WebHook provider mechanism, I was able to create a proof of concept Azure Traffic Manager provider that does the following:\n\n1. **Watches Kubernetes Services** for Traffic Manager annotations\n2. **Automatically creates and manages** Traffic Manager profiles and endpoints\n3. **Syncs state** between your Kubernetes clusters and Azure\n4. **Enables annotation-driven configuration** - no manual Traffic Manager management needed\n5. **Handles duplication** so that when your second cluster attempts to create a Traffic Manager record it adds an endpoint to the existing instance\n6. **Works alongside** the standard External DNS Azure provider for complete DNS automation\n\nHere's what the architecture looks like:\n\n## Example Configuration: Multi-Region Deployment\n\nLet me walk you through a practical example using this provider to see how it works. We will deploy an application across two Azure regions with weighted traffic distribution and automatic failover. This example assumes you have built and deployed the PoC provider as discussed below.\n\n### Step 1: Deploy Your Application\n\nYou deploy your application to both East US and West US AKS clusters. Each deployment is a standard Kubernetes Service with LoadBalancer type. We then apply annotations that tell our External DNS provider how to create and configure the Traffic Manger resource. These annotations are defined as part of our plugin.\n\n``` apiVersion: v1 kind: Service metadata: name: my-app-east namespace: production annotations:\n# Standard External DNS annotation\nexternal-dns.alpha.kubernetes.io/hostname: my-app-east.example.com\n# Enable Traffic Manager integration\nexternal-dns.alpha.kubernetes.io/webhook-traffic-manager-enabled: \"true\" external-dns.alpha.kubernetes.io/webhook-traffic-manager-resource-group: \"my-tm-rg\" external-dns.alpha.kubernetes.io/webhook-traffic-manager-profile-name: \"my-app-global\"\n# Weighted routing configuration\nexternal-dns.alpha.kubernetes.io/webhook-traffic-manager-weight: \"70\" external-dns.alpha.kubernetes.io/webhook-traffic-manager-endpoint-name: \"east-us\" external-dns.alpha.kubernetes.io/webhook-traffic-manager-endpoint-location: \"eastus\"\n# Health check configuration\nexternal-dns.alpha.kubernetes.io/webhook-traffic-manager-monitor-path: \"/health\" external-dns.alpha.kubernetes.io/webhook-traffic-manager-monitor-protocol: \"HTTPS\" spec: type: LoadBalancer ports:\n- port: 443\ntargetPort: 8080 selector: app: my-app ```\n\nThe West US deployment has identical annotations, except:\n\n- Weight: \"30\" (sending 30% of traffic here initially)\n- Endpoint name: \"west-us\"\n- Location: \"westus\"\n\n### Step 2: Automatic Resource Creation\n\nWhen you deploy these Services, here's what happens automatically:\n\n1. **Azure Load Balancer** provisions and assigns public IPs to each Service\n2. **External DNS (Azure provider)**creates A records:\n- my-app-east.example.com â†’ East US LB IP\n- my-app-west.example.com â†’ West US LB IP\n3. **External DNS (Webhook provider)** creates a Traffic Manager profile named my-app-global\n4. **Webhook adds endpoints**to the profile:\n- East endpoint (weight: 70, target: my-app-east.example.com)\n- West endpoint (weight: 30, target: my-app-west.example.com)\n5. **External DNS (Azure provider)**creates a CNAME:\n- my-app.example.com â†’ Traffic Manager FQDN\n\nNow when users access my-app.example.com, Traffic Manager routes 70% of traffic to East US and 30% to West US, with automatic health checking on both endpoints.\n\n### Step 3: Gradual Traffic Migration\n\nWant to shift more traffic to West US? Just update the annotations:\n\n``` kubectl annotate service my-app-east \\ external-dns.alpha.kubernetes.io/webhook-traffic-manager-weight=\"50\" \\ --overwrite\n\nkubectl annotate service my-app-west \\ external-dns.alpha.kubernetes.io/webhook-traffic-manager-weight=\"50\" \\ --overwrite ```\n\nWithin minutes, traffic distribution automatically adjusts to 50/50. This enables:\n\n- **Blue-green deployments** - test new versions with small traffic percentages\n- **Canary releases** - gradually increase traffic to new deployments\n- **Geographic optimisation** - adjust weights based on user distribution\n\n### Step 4: Automatic Failover\n\nIf the East US cluster becomes unhealthy, Traffic Manager's health checks detect this and automatically fail over 100% of traffic to West US, no manual intervention required.\n\n## How It Works\n\nThe webhook implements External DNS's webhook provider protocol:\n\n#### 1. Negotiate Capabilities\n\nExternal DNS queries the webhook to determine supported features and versions.\n\n#### 2. Adjust Endpoints\n\nExternal DNS sends all discovered endpoints to the webhook. The webhook:\n\n- Filters for Services with Traffic Manager annotations\n- Validates configuration\n- Enriches endpoints with metadata\n- Returns only Traffic Manager-enabled endpoints\n\n#### 3. Record State\n\nExternal DNS queries the webhook for current Traffic Manager state. The webhook:\n\n- Syncs profiles from Azure\n- Converts to External DNS endpoint format\n- Returns CNAME records pointing to Traffic Manager FQDNs\n\n#### 4. Apply Changes\n\nExternal DNS sends CREATE/UPDATE/DELETE operations. The webhook:\n\n- Creates Traffic Manager profiles as needed\n- Adds/updates/removes endpoints\n- Configures health monitoring\n- Updates in-memory state cache\n\nThe webhook uses Azure SDK for Go to interact with the Traffic Manager API and maintains an in-memory cache of profile state to optimise performance and reduce API calls.\n\n## Proof of Concept\n\n> >\n> **ðŸ›‘ Important: This is a Proof of Concept**\n> > >\n> This project is provided as example code to demonstrate the integration pattern between External DNS and Traffic Manager. It is **not a supported product** and comes with no SLAs, warranties, or commitments.\n> > >\n> The code is published to help you understand how to build this type of integration. If you decide to implement something similar for your production environment, you should treat this as inspiration and build your own solution that you can properly test, secure, and maintain.\n> > >\n> Think of this as a blueprint, not a finished product.\n> >\n\nWith that caveat out of the way, if you want to experiment with this approach, the PoC is available on GitHub: [github.com/sam-cogan/external-dns-traffic-manager.](https://github.com/sam-cogan/external-dns-traffic-manager)The [readme file](https://github.com/sam-cogan/external-dns-traffic-manager/blob/main/README.md) containers detailed instructions on how to deploy the PoC into a single and multi-cluster environment, along with demo applications to try it out.\n\n## Use Cases\n\nThis integration unlocks several powerful scenarios:\n\n- **Multi-Region High Availability** - Deploy your application across multiple Azure regions with automatic DNS-based load balancing and health-based failover. No additional load balancers or gateways required.\n- **Blue-Green Deployments** - Deploy a new version alongside your current version, send 5% of traffic to test, gradually increase, and roll back instantly if issues arise by changing annotations.\n- **Geographic Distribution** - Route European users to your Europe region and US users to your US region automatically using Traffic Manager's geographic routing with the same annotation-based approach.\n- **Disaster Recovery** - Configure priority-based routing with your primary region at priority 1 and DR region at priority 2. Traffic automatically fails over when health checks fail.\n- **Cost Optimisation** - Use weighted routing to balance traffic across regions based on capacity and costs. Send more traffic to regions where you have reserved capacity or lower egress costs.\n\n## Considerations and Future Work\n\nThis is a **proof of concept** and should be thoroughly tested before production use. Some areas for improvement:\n\n### Current Limitations\n\n- **In-memory state only** - no persistent storage (restarts require resync)\n- **Basic error handling** - needs more robust retry logic\n- **Limited observability** - could use more metrics and events\n- **Manual CRD cleanup** - DNSEndpoint CRDs need manual cleanup when switching providers\n\n### Potential Enhancements\n\n- **Support for more endpoint types** - currently focuses on ExternalEndpoints\n- **Advanced health check configuration** - custom intervals, timeouts, and thresholds\n- **Metric-based routing decisions** - integrate with Azure Monitor for intelligent routing\n- **GitOps integration** - Flux/ArgoCD examples and best practices\n- **Helm chart** - simplified deployment\n\nIf you try this out or have ideas for improvements, please open an issue or PR on GitHub.\n\n## Wrapping Up\n\nThis proof of concept shows that External DNS and Traffic Manager can work together nicely. Since Traffic Manager is really just an advanced DNS service, bringing it into External DNS's annotation-driven workflow makes a lot of sense. You get the same declarative approach for both basic DNS records and sophisticated traffic routing.\n\nWhile this isn't production-ready code (and you shouldn't use it as-is), it demonstrates a viable pattern. If you're dealing with multi-region Kubernetes deployments and need intelligent DNS-based routing, this might give you some ideas for building your own solution.\n\nThe code is out there for you to learn from, break, and hopefully improve upon. If you build something based on this or have feedback on the approach, I'd be interested to hear about it.\n\n## Resources\n\n- **GitHub Repository**: [github.com/sam-cogan/external-dns-traffic-manager](https://github.com/sam-cogan/external-dns-traffic-manager)\n- **External DNS Documentation**: [kubernetes-sigs.github.io/external-dns](https://kubernetes-sigs.github.io/external-dns/)\n- **Azure Traffic Manager**: [learn.microsoft.com/azure/traffic-manager](https://learn.microsoft.com/azure/traffic-manager/)\n- **Webhook Provider Guide**: [External DNS Webhook Tutorial](https://github.com/kubernetes-sigs/external-dns/blob/master/docs/tutorials/webhook-provider.md)\n\nUpdated Jan 29, 2026\n\nVersion 1.0\n\n[azure kubernetes service](/tag/azure%20kubernetes%20service?nodeId=board%3AAppsonAzureBlog)\n\n[containers](/tag/containers?nodeId=board%3AAppsonAzureBlog)\n\n[web apps](/tag/web%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[samcogan&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0yOTgxNTI4LVdSRVN4Rg?image-coordinates=64%2C0%2C1938%2C1873&amp;image-dimensions=50x50)](/users/samcogan/2981528) [samcogan](/users/samcogan/2981528) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined April 03, 2025\n\n[View Profile](/users/samcogan/2981528)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "Tags": [],
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Author": "samcogan",
  "ProcessedDate": "2026-01-29 09:12:02",
  "PubDate": "2026-01-29T08:43:34+00:00",
  "OutputDir": "_community",
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/exploring-traffic-manager-integration-for-external-dns/ba-p/4485690",
  "Description": "When you deploy externally accessible applications into Kubernetes, there is usually a requirement for creating some DNS records pointing to these applications, to allow your users to resolve them. Rather than manually creating these DNS records, there are tools that will do this work for you, one of which is [External DNS](https://github.com/kubernetes-sigs/external-dns).\n\nExternal DNS can watch your Kubernetes resource configuration for specific annotations and then use these to create DNS records in your DNS zone. It has integrations with many DNS providers, including Azure DNS. This solution works well and is in use by many customers using AKS and Azure DNS. Where we hit a limitation with External DNS in Azure is in scenarios where we are need to distribute traffic across multiple clusters for load balancing and global distribution.\n\nThere are a few ways to achieve this global distribution in Azure, one way is to use Azure Traffic Manger. Unlike something like Azure Front Door, Azure Traffic Manager is a DNS based global load balancer. Traffic is directed to your different AKS clusters based on DNS resolution using Traffic Manager. When a user queries your Traffic Manager CNAME, they hit the Traffic Manager DNS servers, which then return a DNS record for a specific cluster based on your load balancing configuration. Traffic Manager can then introduce advanced load balancing scenarios such as:\n\n- **Geographic routing** - direct users to the nearest endpoint based on their location\n- **Weighted distribution** - split traffic percentages (e.g., 80% to one region, 20% to another)\n- **Priority-based failover** - automatic disaster recovery with primary/backup regions\n- **Performance-based routing** - direct users to the endpoint with lowest latency\n\nSo, given Azure Traffic Manager is a essentially a DNS service, it would be good if we could manage it using External DNS. We already use External DNS to create DNS records for each of our individual clusters, so why not use it to also create the Traffic Manager DNS configuration to load balance across them. This would also provides the added benefit of allowing us to change our load balancing strategy or configuration by making changes to our External DNS annotations.\n\nUnfortunately, an External DNS integration for Traffic Manager doesn't currently exist. In this post, I'll walk through a proof-of-concept for a provider I built to explore whether this integration is viable, and share what I learned along the way.\n\n## External DNS Webhook Provider\n\nExternal DNS has two types of integrations. The first, and most common for \"official\" providers are \"In-tree\" providers, which are the integrations that have been created by External DNS contributors and sit within the central External DNS repository. This includes the Azure DNS provider. The second type of provider is the WebHook provider, which allows for external contributors to easily create their own providers without the need to submit them to the core External DNS repo and go through that release process. We are going to use the WebHook provider\n\n> >\n> External DNS has begun the process of phasing out \"In-tree\" providers and replacing with WebHook ones. No new \"In-tree\" providers will be accepted.\n> >\n\nBy using the WebHook provider mechanism, I was able to create a proof of concept Azure Traffic Manager provider that does the following:\n\n1. **Watches Kubernetes Services** for Traffic Manager annotations\n2. **Automatically creates and manages** Traffic Manager profiles and endpoints\n3. **Syncs state** between your Kubernetes clusters and Azure\n4. **Enables annotation-driven configuration** - no manual Traffic Manager management needed\n5. **Handles duplication** so that when your second cluster attempts to create a Traffic Manager record it adds an endpoint to the existing instance\n6. **Works alongside** the standard External DNS Azure provider for complete DNS automation\n\nHere's what the architecture looks like:\n\n![]()\n\n## Example Configuration: Multi-Region Deployment\n\nLet me walk you through a practical example using this provider to see how it works. We will deploy an application across two Azure regions with weighted traffic distribution and automatic failover. This example assumes you have built and deployed the PoC provider as discussed below.\n\n### Step 1: Deploy Your Application\n\nYou deploy your application to both East US and West US AKS clusters. Each deployment is a standard Kubernetes Service with LoadBalancer type. We then apply annotations that tell our External DNS provider how to create and configure the Traffic Manger resource. These annotations are defined as part of our plugin.\n\n- apiVersion: v1\nkind: Service metadata: name: my-app-east namespace: production annotations:\n# Standard External DNS annotation\nexternal-dns.alpha.kubernetes.io/hostname: my-app-east.example.com\n# Enable Traffic Manager integration\nexternal-dns.alpha.kubernetes.io/webhook-traffic-manager-enabled: \"true\" external-dns.alpha.kubernetes.io/webhook-traffic-manager-resource-group: \"my-tm-rg\" external-dns.alpha.kubernetes.io/webhook-traffic-manager-profile-name: \"my-app-global\"\n# Weighted routing configuration\nexternal-dns.alpha.kubernetes.io/webhook-traffic-manager-weight: \"70\" external-dns.alpha.kubernetes.io/webhook-traffic-manager-endpoint-name: \"east-us\" external-dns.alpha.kubernetes.io/webhook-traffic-manager-endpoint-location: \"eastus\"\n# Health check configuration\nexternal-dns.alpha.kubernetes.io/webhook-traffic-manager-monitor-path: \"/health\" external-dns.alpha.kubernetes.io/webhook-traffic-manager-monitor-protocol: \"HTTPS\" spec: type: LoadBalancer ports:\n- port: 443\ntargetPort: 8080 selector: app: my-app\n\nThe West US deployment has identical annotations, except:\n\n- Weight: \"30\" (sending 30% of traffic here initially)\n- Endpoint name: \"west-us\"\n- Location: \"westus\"\n\n### Step 2: Automatic Resource Creation\n\nWhen you deploy these Services, here's what happens automatically:\n\n1. **Azure Load Balancer** provisions and assigns public IPs to each Service\n2. **External DNS (Azure provider)**creates A records:\n- my-app-east.example.com â†’ East US LB IP\n- my-app-west.example.com â†’ West US LB IP\n3. **External DNS (Webhook provider)** creates a Traffic Manager profile named my-app-global\n4. **Webhook adds endpoints**to the profile:\n- East endpoint (weight: 70, target: my-app-east.example.com)\n- West endpoint (weight: 30, target: my-app-west.example.com)\n5. **External DNS (Azure provider)**creates a CNAME:\n- my-app.example.com â†’ Traffic Manager FQDN\n\nNow when users access my-app.example.com, Traffic Manager routes 70% of traffic to East US and 30% to West US, with automatic health checking on both endpoints.\n\n### Step 3: Gradual Traffic Migration\n\nWant to shift more traffic to West US? Just update the annotations:\n- kubectl annotate service my-app-east \\\nexternal-dns.alpha.kubernetes.io/webhook-traffic-manager-weight=\"50\" \\ --overwrite\n\nkubectl annotate service my-app-west \\ external-dns.alpha.kubernetes.io/webhook-traffic-manager-weight=\"50\" \\ --overwrite\n\nWithin minutes, traffic distribution automatically adjusts to 50/50. This enables:\n\n- **Blue-green deployments** - test new versions with small traffic percentages\n- **Canary releases** - gradually increase traffic to new deployments\n- **Geographic optimisation** - adjust weights based on user distribution\n\n### Step 4: Automatic Failover\n\nIf the East US cluster becomes unhealthy, Traffic Manager's health checks detect this and automatically fail over 100% of traffic to West US, no manual intervention required.\n\n## How It Works\n\nThe webhook implements External DNS's webhook provider protocol:\n\n#### 1. Negotiate Capabilities\n\nExternal DNS queries the webhook to determine supported features and versions.\n\n#### 2. Adjust Endpoints\n\nExternal DNS sends all discovered endpoints to the webhook. The webhook:\n\n- Filters for Services with Traffic Manager annotations\n- Validates configuration\n- Enriches endpoints with metadata\n- Returns only Traffic Manager-enabled endpoints\n\n#### 3. Record State\n\nExternal DNS queries the webhook for current Traffic Manager state. The webhook:\n\n- Syncs profiles from Azure\n- Converts to External DNS endpoint format\n- Returns CNAME records pointing to Traffic Manager FQDNs\n\n#### 4. Apply Changes\n\nExternal DNS sends CREATE/UPDATE/DELETE operations. The webhook:\n\n- Creates Traffic Manager profiles as needed\n- Adds/updates/removes endpoints\n- Configures health monitoring\n- Updates in-memory state cache\n\nThe webhook uses Azure SDK for Go to interact with the Traffic Manager API and maintains an in-memory cache of profile state to optimise performance and reduce API calls.\n\n## Proof of Concept\n\n> >\n> **ðŸ›‘ Important: This is a Proof of Concept**\n> > >\n> This project is provided as example code to demonstrate the integration pattern between External DNS and Traffic Manager. It is **not a supported product** and comes with no SLAs, warranties, or commitments.\n> > >\n> The code is published to help you understand how to build this type of integration. If you decide to implement something similar for your production environment, you should treat this as inspiration and build your own solution that you can properly test, secure, and maintain.\n> > >\n> Think of this as a blueprint, not a finished product.\n> >\n\nWith that caveat out of the way, if you want to experiment with this approach, the PoC is available on GitHub: [github.com/sam-cogan/external-dns-traffic-manager.](https://github.com/sam-cogan/external-dns-traffic-manager)The [readme file](https://github.com/sam-cogan/external-dns-traffic-manager/blob/main/README.md) containers detailed instructions on how to deploy the PoC into a single and multi-cluster environment, along with demo applications to try it out.\n\n## Use Cases\n\nThis integration unlocks several powerful scenarios:\n\n- **Multi-Region High Availability** - Deploy your application across multiple Azure regions with automatic DNS-based load balancing and health-based failover. No additional load balancers or gateways required.\n- **Blue-Green Deployments** - Deploy a new version alongside your current version, send 5% of traffic to test, gradually increase, and roll back instantly if issues arise by changing annotations.\n- **Geographic Distribution** - Route European users to your Europe region and US users to your US region automatically using Traffic Manager's geographic routing with the same annotation-based approach.\n- **Disaster Recovery** - Configure priority-based routing with your primary region at priority 1 and DR region at priority 2. Traffic automatically fails over when health checks fail.\n- **Cost Optimisation** - Use weighted routing to balance traffic across regions based on capacity and costs. Send more traffic to regions where you have reserved capacity or lower egress costs.\n\n## Considerations and Future Work\n\nThis is a **proof of concept** and should be thoroughly tested before production use. Some areas for improvement:\n\n### Current Limitations\n\n- **In-memory state only** - no persistent storage (restarts require resync)\n- **Basic error handling** - needs more robust retry logic\n- **Limited observability** - could use more metrics and events\n- **Manual CRD cleanup** - DNSEndpoint CRDs need manual cleanup when switching providers\n\n### Potential Enhancements\n\n- **Support for more endpoint types** - currently focuses on ExternalEndpoints\n- **Advanced health check configuration** - custom intervals, timeouts, and thresholds\n- **Metric-based routing decisions** - integrate with Azure Monitor for intelligent routing\n- **GitOps integration** - Flux/ArgoCD examples and best practices\n- **Helm chart** - simplified deployment\n\nIf you try this out or have ideas for improvements, please open an issue or PR on GitHub.\n\n## Wrapping Up\n\nThis proof of concept shows that External DNS and Traffic Manager can work together nicely. Since Traffic Manager is really just an advanced DNS service, bringing it into External DNS's annotation-driven workflow makes a lot of sense. You get the same declarative approach for both basic DNS records and sophisticated traffic routing.\n\nWhile this isn't production-ready code (and you shouldn't use it as-is), it demonstrates a viable pattern. If you're dealing with multi-region Kubernetes deployments and need intelligent DNS-based routing, this might give you some ideas for building your own solution.\n\nThe code is out there for you to learn from, break, and hopefully improve upon. If you build something based on this or have feedback on the approach, I'd be interested to hear about it.\n\n## Resources\n\n- **GitHub Repository**: [github.com/sam-cogan/external-dns-traffic-manager](https://github.com/sam-cogan/external-dns-traffic-manager)\n- **External DNS Documentation**: [kubernetes-sigs.github.io/external-dns](https://kubernetes-sigs.github.io/external-dns/)\n- **Azure Traffic Manager**: [learn.microsoft.com/azure/traffic-manager](https://learn.microsoft.com/azure/traffic-manager/)\n- **Webhook Provider Guide**: [External DNS Webhook Tutorial](https://github.com/kubernetes-sigs/external-dns/blob/master/docs/tutorials/webhook-provider.md)",
  "Title": "Exploring Traffic Manager Integration for External DNS"
}
