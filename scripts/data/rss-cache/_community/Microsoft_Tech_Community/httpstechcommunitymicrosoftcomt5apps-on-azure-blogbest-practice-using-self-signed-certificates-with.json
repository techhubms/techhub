{
  "FeedName": "Microsoft Tech Community",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Description": "If you are developing Java applications on Azure Functions (Linux dedicated plan) and need to connect to services secured by self-signed certificates, you have likely encountered the dreaded SSL handshake error:\n\n***PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target***\n\nBy default, the Java Virtual Machine (JVM) only trusts certificates signed by well-known Certificate Authorities (CAs). To fix this, you need to tell your Java Function App to trust your specific self-signed certificate.\n\nWhile there are several ways to achieve this, this guide outlines the **best practice**: manually adding the certificate to a custom Java keystore located in persistent storage.\n\n## Why this approach?\n\nIn Azure App Service and Azure Functions (Linux), the file system is generally ephemeral, meaning changes to system folders (like /usr/lib/jvm) are lost upon restart. However, the /home directory is **persistent**.\n\nBy creating a custom truststore in /home and pointing the JVM to it, your configuration remains intact across restarts, scaling operations, and platform updates.\n\n## Step-by-Step Solution\n\n### 1. Prepare the Custom Keystore\n\nFirst, we need to create a new base keystore. We will copy the default system cacerts (which contains standard public CAs) to our persistent storage.\n\n1. Connect to your Function App via SSH using the **Kudu** site (https://.scm.azurewebsites.net/webssh/host).\n2. Run the following command to copy the truststore.\n(**Note:** The source path may vary depending on your Java version. You can confirm your exact JVM path by running **echo $JAVA\\_HOME** in the console. For example, if it returns /usr/lib/jvm/msft-17-x64, use that path below.)\n\n- cp /usr/lib/jvm/msft-17-x64/lib/security/cacerts /home/site/wwwroot/my-truststore.jks![]()\n\n### 2. Import the Self-Signed Certificate\n\nUpload your root certificate (e.g., self-signed.badssl.com.cer) to the site (you can use drag-and-drop in Kudu or FTP). Then, import it into your new custom keystore.\n\nRun the following command (ensure keytool is in your PATH or navigate to the bin folder):\n- ./keytool -import -alias my-self-signed-cert \\\n-file /home/self-signed.badssl.com.cer \\ -keystore /home/site/wwwroot/my-truststore.jks \\ -storepass changeit -noprompt\n\n### 3. Verify the Import\n\nIt is always good practice to verify that the certificate was actually added. Run:\n- ./keytool -list -v \\\n-keystore /home/site/wwwroot/my-truststore.jks \\ -storepass changeit -alias my-self-signed-cert\n\nIf successful, you will see the certificate details printed in the console.\n\n### 4. Configure the Application Setting\n\nFinally, we need to tell the JVM to use our new truststore instead of the default system one.\n\nGo to the **Azure Portal > Configuration > Application Settings** and add (or update) the JAVA\\_OPTS setting:\n\n- **Name:** JAVA\\_OPTS\n- **Value:** -Djavax.net.ssl.trustStore=/home/site/wwwroot/my-truststore.jks -Djavax.net.ssl.trustStorePassword=changeit\n\nSave the settings. This will restart your Function App, and the JVM will now load your custom truststore at startup.\n\n## Important Considerations\n\n### File Location & Deployment\n\nIn the example above, we placed the keystore in /home/site/wwwroot/. **Warning:** Depending on your deployment method (e.g., specific ZipDeploy configurations or \"Run From Package\"), the contents of /wwwroot might be wiped or overwritten during a new code deployment.\n\nIf you are concerned about your deployment process overwriting the .jks file, you can save it in any other folder under /home, for example, /home/my-certs/. Just update the JAVA\\_OPTS path accordingly.\n\n### Maintenance\n\nThis is a manual solution. If your self-signed certificate expires:\n\n1. You do not need to recreate the whole keystore.\n2. Simply run the ./keytool -import command again to update the certificate in the existing .jks file.\n3. Maintaining the validity of the self-signed certificate is your responsibility.\n\n### Azure Key Vault Note\n\nYou might wonder, \"Can I use Azure Key Vault?\" Azure Key Vault is excellent for private keys, but it generally supports importing .pfx or .pem formats for privately signed certificates. Since public .cer certificates are not secrets (they are public, after all), the method above is often the most direct way to handle them for Java trust validation.\n\n## Alternative Workarounds\n\nIf you prefer not to manage a custom keystore file in the persistent **/home** directory, here are two alternative approaches. Both of these require modifying your application code.\n\n### 1. Load the Azure-Managed Certificate via Code\n\nYou can upload your .cer public certificate directly to the **TLS/SSL settings (Public Keys Certificates)** blade in the Azure Portal.\n\n- After uploading, you must add the Application Setting WEBSITE\\_LOAD\\_CERTIFICATES with the value \\* (or the specific certificate thumbprint).\n- Azure acts as the OS loader. It places the certificate file at **/var/ssl/certs/.der**.\n\nImportant Distinction: App Service vs. Function App\n\nThere is a difference in how the \"Blessed Images\" (the default platform images) handle these certificates at startup:\n\n- **Azure App Service (Linux):** In many scenarios, the platform's startup scripts automatically import these certificates into the JVM keystore.\n- **Azure Functions (Linux):** The Function App runtime **does not** automatically import these certificates into the JVM keystore during startup. If you SSH into the Function App and run *openssl* or *curl*, the connection might succeed because those OS-level tools check the /var/ssl/certs folder. However, your Java application will throw a above handshake error because the JVM only looks at its own cacerts truststore, which is effectively empty of your custom certs.\n\nSince the certificate is present on the disk, you must write Java code to explicitly load this specific file into an SSLContext.\n\nReference: [Use TLS/SSL Certificates in App Code - Azure App Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/app-service/configure-ssl-certificate-in-code?tabs=linux)\n\n### 2. Build the JKS Locally and Load it via Code\n\nInstead of creating the keystore on the server (the \"Best Practice\" method), you can create the my-truststore.jks on your local developer machine, include it inside your application (e.g., in src/main/resources), and deploy it as part of your JAR/WAR.\n\nYou then write code to load this JKS file from the classpath or file system to initialize your SSL connection.\n\nReference: [Configure Security for Tomcat, JBoss, or Java SE Apps - Azure App Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/app-service/configure-language-java-security?pivots=java-javase#initialize-the-java-key-store-in-linux)",
  "Author": "wanjing",
  "PubDate": "2026-02-25T08:08:28+00:00",
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/best-practice-using-self-signed-certificates-with-java-on-azure/ba-p/4496900",
  "EnhancedContent": "If you are developing Java applications on Azure Functions (Linux dedicated plan) and need to connect to services secured by self-signed certificates, you have likely encountered the dreaded SSL handshake error:\n\n***PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target***\n\nBy default, the Java Virtual Machine (JVM) only trusts certificates signed by well-known Certificate Authorities (CAs). To fix this, you need to tell your Java Function App to trust your specific self-signed certificate.\n\nWhile there are several ways to achieve this, this guide outlines the **best practice**: manually adding the certificate to a custom Java keystore located in persistent storage.\n\n## Why this approach?\n\nIn Azure App Service and Azure Functions (Linux), the file system is generally ephemeral, meaning changes to system folders (like /usr/lib/jvm) are lost upon restart. However, the /home directory is **persistent**.\n\nBy creating a custom truststore in /home and pointing the JVM to it, your configuration remains intact across restarts, scaling operations, and platform updates.\n\n## Step-by-Step Solution\n\n### 1. Prepare the Custom Keystore\n\nFirst, we need to create a new base keystore. We will copy the default system cacerts (which contains standard public CAs) to our persistent storage.\n\n1. Connect to your Function App via SSH using the **Kudu** site (https://&lt;your-app-name&gt;.scm.azurewebsites.net/webssh/host).\n2. Run the following command to copy the truststore.\n(**Note:** The source path may vary depending on your Java version. You can confirm your exact JVM path by running **echo $JAVA\\_HOME** in the console. For example, if it returns /usr/lib/jvm/msft-17-x64, use that path below.)\n\n``` cp /usr/lib/jvm/msft-17-x64/lib/security/cacerts /home/site/wwwroot/my-truststore.jks ```\n\n### 2. Import the Self-Signed Certificate\n\nUpload your root certificate (e.g., self-signed.badssl.com.cer) to the site (you can use drag-and-drop in Kudu or FTP). Then, import it into your new custom keystore.\n\nRun the following command (ensure keytool is in your PATH or navigate to the bin folder):\n\n``` ./keytool -import -alias my-self-signed-cert \\ -file /home/self-signed.badssl.com.cer \\ -keystore /home/site/wwwroot/my-truststore.jks \\ -storepass changeit -noprompt ```\n\n### 3. Verify the Import\n\nIt is always good practice to verify that the certificate was actually added. Run:\n\n``` ./keytool -list -v \\ -keystore /home/site/wwwroot/my-truststore.jks \\ -storepass changeit -alias my-self-signed-cert ```\n\nIf successful, you will see the certificate details printed in the console.\n\n### 4. Configure the Application Setting\n\nFinally, we need to tell the JVM to use our new truststore instead of the default system one.\n\nGo to the **Azure Portal &gt; Configuration &gt; Application Settings** and add (or update) the JAVA\\_OPTS setting:\n\n- **Name:** JAVA\\_OPTS\n- **Value:** -Djavax.net.ssl.trustStore=/home/site/wwwroot/my-truststore.jks -Djavax.net.ssl.trustStorePassword=changeit\n\nSave the settings. This will restart your Function App, and the JVM will now load your custom truststore at startup.\n\n## Important Considerations\n\n### File Location & Deployment\n\nIn the example above, we placed the keystore in /home/site/wwwroot/. **Warning:** Depending on your deployment method (e.g., specific ZipDeploy configurations or \"Run From Package\"), the contents of /wwwroot might be wiped or overwritten during a new code deployment.\n\nIf you are concerned about your deployment process overwriting the .jks file, you can save it in any other folder under /home, for example, /home/my-certs/. Just update the JAVA\\_OPTS path accordingly.\n\n### Maintenance\n\nThis is a manual solution. If your self-signed certificate expires:\n\n1. You do not need to recreate the whole keystore.\n2. Simply run the ./keytool -import command again to update the certificate in the existing .jks file.\n3. Maintaining the validity of the self-signed certificate is your responsibility.\n\n### Azure Key Vault Note\n\nYou might wonder, \"Can I use Azure Key Vault?\" Azure Key Vault is excellent for private keys, but it generally supports importing .pfx or .pem formats for privately signed certificates. Since public .cer certificates are not secrets (they are public, after all), the method above is often the most direct way to handle them for Java trust validation.\n\n## Alternative Workarounds\n\nIf you prefer not to manage a custom keystore file in the persistent **/home** directory, here are two alternative approaches. Both of these require modifying your application code.\n\n### 1. Load the Azure-Managed Certificate via Code\n\nYou can upload your .cer public certificate directly to the **TLS/SSL settings (Public Keys Certificates)** blade in the Azure Portal.\n\n- After uploading, you must add the Application Setting WEBSITE\\_LOAD\\_CERTIFICATES with the value \\* (or the specific certificate thumbprint).\n- Azure acts as the OS loader. It places the certificate file at **/var/ssl/certs/&lt;thumbprint&gt;.der**.\n\nImportant Distinction: App Service vs. Function App\n\nThere is a difference in how the \"Blessed Images\" (the default platform images) handle these certificates at startup:\n\n- **Azure App Service (Linux):** In many scenarios, the platform's startup scripts automatically import these certificates into the JVM keystore.\n- **Azure Functions (Linux):** The Function App runtime **does not** automatically import these certificates into the JVM keystore during startup. If you SSH into the Function App and run *openssl* or *curl*, the connection might succeed because those OS-level tools check the /var/ssl/certs folder. However, your Java application will throw a above handshake error because the JVM only looks at its own cacerts truststore, which is effectively empty of your custom certs.\n\nSince the certificate is present on the disk, you must write Java code to explicitly load this specific file into an SSLContext.\n\nReference: [Use TLS/SSL Certificates in App Code - Azure App Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/app-service/configure-ssl-certificate-in-code?tabs=linux)\n\n### 2. Build the JKS Locally and Load it via Code\n\nInstead of creating the keystore on the server (the \"Best Practice\" method), you can create the my-truststore.jks on your local developer machine, include it inside your application (e.g., in src/main/resources), and deploy it as part of your JAR/WAR.\n\nYou then write code to load this JKS file from the classpath or file system to initialize your SSL connection.\n\nReference: [Configure Security for Tomcat, JBoss, or Java SE Apps - Azure App Service | Microsoft Learn](https://learn.microsoft.com/en-us/azure/app-service/configure-language-java-security?pivots=java-javase#initialize-the-java-key-store-in-linux)\n\nUpdated Feb 25, 2026\n\nVersion 1.0\n\n[azure functions](/tag/azure%20functions?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[wanjing&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/m_assets/avatars/default/avatar-12.svg?image-dimensions=50x50)](/users/wanjing/1084225) [wanjing](/users/wanjing/1084225) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined June 21, 2021\n\n[View Profile](/users/wanjing/1084225)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "Title": "Best Practice: Using Self-Signed Certificates with Java on Azure Functions (Linux)",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "ProcessedDate": "2026-02-25 08:12:11",
  "OutputDir": "_community",
  "Tags": []
}
