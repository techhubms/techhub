{
  "ProcessedDate": "2026-02-12 07:22:24",
  "FeedName": "Microsoft Tech Community",
  "Author": "Charles_Chukwudozie",
  "Tags": [],
  "Link": "https://techcommunity.microsoft.com/t5/azure-architecture-blog/securing-multi-agent-ai-with-user-context-entra-id-obo-for/ba-p/4493308",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "PubDate": "2026-02-12T06:27:56+00:00",
  "Title": "Securing Multi-Agent AI with User Context: Entra ID OBO for Databricks Genie.",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Description": "*How we built an enterprise-grade multi-agent system that preserves user identity across AI agents and Databricks*\n\n## **Introduction**\n\nWhen building AI-powered applications for the enterprise, a common challenge emerges: how do you maintain user identity and access controls when an AI agent queries backend services on behalf of a user?\n\nIn many implementations, AI agents authenticate to backend systems using a shared service account or with PAT (Personal Access Token) tokens, effectively bypassing row-level security (RLS), column masking, and other data governance policies that organizations carefully configure. This creates a security gap where users can potentially access data they shouldn’t see, simply by asking an AI agent.\n\nIn this post, I’ll walk through how we solved this challenge for a current enterprise customer by implementing [Microsoft Entra ID](https://learn.microsoft.com/en-us/entra/fundamentals/what-is-entra) [On-Behalf-Of](https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth2-on-behalf-of-flow) (OBO) secure flow in a custom multi-agent LangGraph solution, enabling our [Databricks Genie](https://learn.microsoft.com/en-us/azure/databricks/genie/) agent to query data and the data agent designed to modify or update delta tables, to do so as the authenticated user, while preserving all RBAC policies.\n\n## **The Architecture**\n\nOur system is built on several key components:\n\n**[Chainlit](https://docs.chainlit.io/authentication/oauth)**: Python-based web interface for LLM-driven conversational applications, integrated with OAuth 2.0–based authentication. Customizing the framework to satisfy customer UI requirements eliminated the need to develop and maintain a bespoke React front end. It fulfilled the majority of requirements while reducing maintenance overhead.\n\n**Azure App Service** - Managed hosting with built-in authentication support and autoscaling\n\n[**LangGraph**](https://docs.langchain.com/oss/python/langgraph/overview): Opensource Multi-agent orchestration framework. **Azure Databricks Genie**: Natural language to SQL agent. [**Azure Cosmos DB**](https://learn.microsoft.com/en-us/azure/cosmos-db/overview): Long-term memory and checkpoint storage. **Microsoft Entra ID**: Identity provider with OBO support.\n\n![]()\n\nThis shows:\n\nGenie: Read-only natural language queries, per-user OBO Task Agent: Handles sensitive operations (SQL modifications, etc.) with HITL approval + OBO Memory: Shared agent, no per-user auth needed\n\n## **The Problem with Chainlit OAuth Provider**\n\nChainlit was integrated with Microsoft Entra ID for OAuth authentication; however, the default implementation assumes Microsoft Graph scopes, requiring extension to support custom resource scopes. This means:\n\nThe access token you receive is scoped for Microsoft [Graph API](https://learn.microsoft.com/en-us/graph/overview) You can’t use it for OBO flow to downstream services like Databricks The token’s audience is graph.microsoft.com, not your application For OBO to work, you need an access token where:\n\nThe audience is your application’s client ID The scope includes your custom API permission (e.g., api://{client\\_id}/access\\_as\\_user)\n\n## **Solution: Custom Entra ID OBO Provider**\n\nWe created a custom OAuth provider that replaces Chainlit’s built-in one.\n\n![]()\n\nKey insight: By requesting api://{client\\_id}/access\\_as\\_user as the scope, the returned access token has the correct audience for OBO exchange.\n\nSince we can’t call [Graph API](https://learn.microsoft.com/en-us/graph/overview) with this token (wrong audience), we extract user information from the ID token claims instead.\n\n## **The OBO Token Exchange**\n\nOnce we have the user’s access token (with correct audience), we exchange it for a Databricks-scoped token using [MSAL](https://learn.microsoft.com/en-us/entra/msal/python/).\n\n![]()\n\nThe resulting token:\n\nHas audience = Databricks resource ID Contains the user’s identity (UPN, OID) Can be used with Databricks SDK/API Respects all Unity Catalog permissions configured for that user\n\n## **Per-User Agent Creation**\n\nA critical design decision: never cache user-specific agents globally. Each user needs their own Genie agent instance.\n\n![]()\n\n## **Using the OBO Token with Databricks Genie**\n\nThe key integration point is passing the OBO-acquired token to the Databricks SDK’s WorkspaceClient as indicated in the above screenshot, which the Genie agent uses internally for all API calls as shown in the following image.\n\nInitialize Genie Agent with User’s Access Token:\n\n![]()\n\nWire It Into LangGraph:\n\n![]()\n\nThe user\\_access\\_token flows from Chainlit’s OAuth callback → session config → LangGraph config → agent creation, ensuring every Genie query runs with the authenticated user’s permissions.\n\n## **Human-in-the-Loop for Destructive SQL Operations**\n\nWhile Databricks Genie handles natural language queries (read-only), our system also supports custom SQL execution for data modifications. Since these operations can DELETE or UPDATE data, we implement human-in-the-loop approval using LangGraph’s interrupt feature.\n\nThe OBO token ensures that even when executing user-authored SQL, the query runs with the user’s permissions: they can only modify data they’re authorized to change.\n\n![]()\n\nThe destructive operation detector uses LLM-based intent analysis\n\n![]()\n\n## **Entra ID App Registration Requirements**\n\nYour Entra ID [app registration](https://learn.microsoft.com/en-us/entra/identity-platform/quickstart-register-app) needs:\n\n1. API Permissions: Azure Databricks → user\\_impersonation (admin consent required)\n2. Expose an API: Scope access\\_as\\_user on URI api://{client-id}\n3. Redirect URI: {your-app-url}/auth/oauth/azure-ad/callback\n\n## **Lessons Learned**\n\n1. **Token audience matters**: OBO fails if your initial token has the wrong audience\n2. **Don’t cache user-specific clients**: breaks user isolation\n3. **ID tokens contain user info**: use claims when you can’t call [Graph API](https://learn.microsoft.com/en-us/graph/overview)\n4. **HITL for destructive ops**: even with RBAC, require explicit user confirmation\n\n## **Conclusion**\n\nBy implementing Entra ID OBO flow in our multi-agent system, we achieved:\n\n1. User identity preservation across AI agents\n2. [RBAC](https://learn.microsoft.com/en-us/azure/role-based-access-control/overview) enforcement at the [Databricks/Unity Catalog](https://learn.microsoft.com/en-us/azure/databricks/data-governance/unity-catalog/) level\n3. Audit trail showing actual user making queries\n4. Zero-trust architecture: the AI agent never has more access than the user\n5. Human-in-the-loop for destructive SQL operations\n\nThis design applies beyond Databricks, any Azure service supporting OAuth 2.0 can be accessed via OBO. It also forms part of the AI governance foundation for this enterprise custom multiagent AI solution and ensures compliance with [Microsoft SFI](https://learn.microsoft.com/en-us/windows/security/book/security-foundation-offensive-research#secure-future-initiative-sfi) (Secure Future Initiative) and zero trust principles.\n\nAs custom multi-agent AI systems move beyond isolated applications and begin spanning enterprise platforms, identity delegation alone will not be sufficient. Organizations will require centralized services that standardize identity and user delegation across systems. Capabilities emerging in platforms such as Microsoft Entra Agent ID and Azure AI Foundry point in this direction, but they remain in preview and are primarily focused on first-party ecosystems.",
  "OutputDir": "_community",
  "EnhancedContent": "*How we built an enterprise-grade multi-agent system that preserves user identity across AI agents and Databricks*\n\n## **Introduction**\n\nWhen building AI-powered applications for the enterprise, a common challenge emerges: how do you maintain user identity and access controls when an AI agent queries backend services on behalf of a user?\n\nIn many implementations, AI agents authenticate to backend systems using a shared service account or with PAT (Personal Access Token) tokens, effectively bypassing row-level security (RLS), column masking, and other data governance policies that organizations carefully configure. This creates a security gap where users can potentially access data they shouldn’t see, simply by asking an AI agent.\n\nIn this post, I’ll walk through how we solved this challenge for a current enterprise customer by implementing [Microsoft Entra ID](https://learn.microsoft.com/en-us/entra/fundamentals/what-is-entra) [On-Behalf-Of](https://learn.microsoft.com/en-us/entra/identity-platform/v2-oauth2-on-behalf-of-flow) (OBO) secure flow in a custom multi-agent LangGraph solution, enabling our [Databricks Genie](https://learn.microsoft.com/en-us/azure/databricks/genie/) agent to query data and the data agent designed to modify or update delta tables, to do so as the authenticated user, while preserving all RBAC policies.\n\n## **The Architecture**\n\nOur system is built on several key components:\n\n**[Chainlit](https://docs.chainlit.io/authentication/oauth)**: Python-based web interface for LLM-driven conversational applications, integrated with OAuth 2.0–based authentication. Customizing the framework to satisfy customer UI requirements eliminated the need to develop and maintain a bespoke React front end. It fulfilled the majority of requirements while reducing maintenance overhead.\n\n**Azure App Service** - Managed hosting with built-in authentication support and autoscaling\n\n[**LangGraph**](https://docs.langchain.com/oss/python/langgraph/overview): Opensource Multi-agent orchestration framework. **Azure Databricks Genie**: Natural language to SQL agent. [**Azure Cosmos DB**](https://learn.microsoft.com/en-us/azure/cosmos-db/overview): Long-term memory and checkpoint storage. **Microsoft Entra ID**: Identity provider with OBO support.\n\nThis shows:\n\nGenie: Read-only natural language queries, per-user OBO Task Agent: Handles sensitive operations (SQL modifications, etc.) with HITL approval + OBO Memory: Shared agent, no per-user auth needed\n\n## **The Problem with Chainlit OAuth Provider**\n\nChainlit was integrated with Microsoft Entra ID for OAuth authentication; however, the default implementation assumes Microsoft Graph scopes, requiring extension to support custom resource scopes. This means:\n\nThe access token you receive is scoped for Microsoft [Graph API](https://learn.microsoft.com/en-us/graph/overview) You can’t use it for OBO flow to downstream services like Databricks The token’s audience is graph.microsoft.com, not your application For OBO to work, you need an access token where:\n\nThe audience is your application’s client ID The scope includes your custom API permission (e.g., api://{client\\_id}/access\\_as\\_user)\n\n## **Solution: Custom Entra ID OBO Provider**\n\nWe created a custom OAuth provider that replaces Chainlit’s built-in one.\n\nKey insight: By requesting api://{client\\_id}/access\\_as\\_user as the scope, the returned access token has the correct audience for OBO exchange.\n\nSince we can’t call [Graph API](https://learn.microsoft.com/en-us/graph/overview) with this token (wrong audience), we extract user information from the ID token claims instead.\n\n## **The OBO Token Exchange**\n\nOnce we have the user’s access token (with correct audience), we exchange it for a Databricks-scoped token using [MSAL](https://learn.microsoft.com/en-us/entra/msal/python/).\n\nThe resulting token:\n\nHas audience = Databricks resource ID Contains the user’s identity (UPN, OID) Can be used with Databricks SDK/API Respects all Unity Catalog permissions configured for that user\n\n## **Per-User Agent Creation**\n\nA critical design decision: never cache user-specific agents globally. Each user needs their own Genie agent instance.\n\n## **Using the OBO Token with Databricks Genie**\n\nThe key integration point is passing the OBO-acquired token to the Databricks SDK’s WorkspaceClient as indicated in the above screenshot, which the Genie agent uses internally for all API calls as shown in the following image.\n\nInitialize Genie Agent with User’s Access Token:\n\nWire It Into LangGraph:\n\nThe user\\_access\\_token flows from Chainlit’s OAuth callback → session config → LangGraph config → agent creation, ensuring every Genie query runs with the authenticated user’s permissions.\n\n## **Human-in-the-Loop for Destructive SQL Operations**\n\nWhile Databricks Genie handles natural language queries (read-only), our system also supports custom SQL execution for data modifications. Since these operations can DELETE or UPDATE data, we implement human-in-the-loop approval using LangGraph’s interrupt feature.\n\nThe OBO token ensures that even when executing user-authored SQL, the query runs with the user’s permissions: they can only modify data they’re authorized to change.\n\nThe destructive operation detector uses LLM-based intent analysis\n\n## **Entra ID App Registration Requirements**\n\nYour Entra ID [app registration](https://learn.microsoft.com/en-us/entra/identity-platform/quickstart-register-app) needs:\n\n1. API Permissions: Azure Databricks → user\\_impersonation (admin consent required)\n2. Expose an API: Scope access\\_as\\_user on URI api://{client-id}\n3. Redirect URI: {your-app-url}/auth/oauth/azure-ad/callback\n\n## **Lessons Learned**\n\n1. **Token audience matters**: OBO fails if your initial token has the wrong audience\n2. **Don’t cache user-specific clients**: breaks user isolation\n3. **ID tokens contain user info**: use claims when you can’t call [Graph API](https://learn.microsoft.com/en-us/graph/overview)\n4. **HITL for destructive ops**: even with RBAC, require explicit user confirmation\n\n## **Conclusion**\n\nBy implementing Entra ID OBO flow in our multi-agent system, we achieved:\n\n1. User identity preservation across AI agents\n2. [RBAC](https://learn.microsoft.com/en-us/azure/role-based-access-control/overview) enforcement at the [Databricks/Unity Catalog](https://learn.microsoft.com/en-us/azure/databricks/data-governance/unity-catalog/) level\n3. Audit trail showing actual user making queries\n4. Zero-trust architecture: the AI agent never has more access than the user\n5. Human-in-the-loop for destructive SQL operations\n\nThis design applies beyond Databricks, any Azure service supporting OAuth 2.0 can be accessed via OBO. It also forms part of the AI governance foundation for this enterprise custom multiagent AI solution and ensures compliance with [Microsoft SFI](https://learn.microsoft.com/en-us/windows/security/book/security-foundation-offensive-research#secure-future-initiative-sfi) (Secure Future Initiative) and zero trust principles.\n\nAs custom multi-agent AI systems move beyond isolated applications and begin spanning enterprise platforms, identity delegation alone will not be sufficient. Organizations will require centralized services that standardize identity and user delegation across systems. Capabilities emerging in platforms such as Microsoft Entra Agent ID and Azure AI Foundry point in this direction, but they remain in preview and are primarily focused on first-party ecosystems.\n\nUpdated Feb 09, 2026\n\nVersion 1.0\n\n[advance analytics](/tag/advance%20analytics?nodeId=board%3AAzureArchitectureBlog)\n\n[azure databricks](/tag/azure%20databricks?nodeId=board%3AAzureArchitectureBlog)\n\n[!\\[Charles_Chukwudozie&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0xMzk3Nzc4LTM3NTg2OWkzMTFFRkRFQjZCMkFCOUFG?image-dimensions=50x50)](/users/charles_chukwudozie/1397778) [Charles_Chukwudozie](/users/charles_chukwudozie/1397778) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined May 22, 2022\n\n[View Profile](/users/charles_chukwudozie/1397778)\n\n/category/azure/blog/azurearchitectureblog [Azure Architecture Blog](/category/azure/blog/azurearchitectureblog) Follow this blog board to get notified when there's new activity"
}
