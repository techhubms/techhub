{
  "OutputDir": "_community",
  "Author": "samcogan",
  "Description": "AKS has supported assigning Azure Managed Identities to pods for some time, first through Pod Identity and then later through Workload Identity. Using these tools it is possible to give a pod an Azure Identity that it can use to interact with other Azure services - pull secrets from Key Vault, read a file from Blob Storage or write to a database.\n\n[Workload Identity](https://learn.microsoft.com/en-us/entra/workload-id/workload-identities-overview) is the latest incarnation of this feature and significantly simplified this feature, removing the need to run additional management pods in the cluster and to have the identity injected in every node however it does have some issues of it's own. These issues are particularly evident when operating at scale and wanting to share the same Managed Identity across multiple workloads in the same cluster, or across multiple clusters.\n\nWorkload Identity relies on creating a Federated Identity Credential (FIC) in Azure that defines the trust relationship between the AKS OIDC issuer and Entra ID. Each combination of Service Account and Namespace that uses the same Managed Identity requires a separate FIC, as do services running in different clusters.\n\n![]()\n\nAs your scale grows, this can start to become a problem. Each managed identity can only support up to 20 FICs. Once you hit that limit, your only option is to create another Managed Identity. This leads to the proliferation of Managed Identities that have the same permissions and do the same job, but only exist to work around this problem.\n\nIn addition to the 20 FIC limit, there are some other issues with Workload Identity:\n\n- Creation of the FIC is an Azure Resource creation that often needs to occur alongside Kubernetes resource creation and makes automation of app deployment harder\n- There can be a cyclic dependency issue where the service account in Kubernetes needs to know the Identity details before the pod is created, but the FIC needs the service account and namespace details to create the OIDC binding\n- Additional outbound rules are required to allow the AKS cluster to access the Entra ID (login.microsoftonline.com) endpoints\n\n## Introducing Identity Bindings\n\n> >\n> Identity Bindings are currently in preview. Previews are provided \"as is\" and \"as available,\" and they're excluded from the service-level agreements and limited warranty. AKS previews are partially covered by customer support on a best-effort basis. As such, these features aren't meant for production use.\n> >\n\nIdentity Bindings introduce a cleaner, RBAC-driven approach to identity management in AKS. Instead of juggling multiple federated credentials and namespace scoping, you define bindings that link Kubernetes RBAC roles to Azure identities. Pods then request tokens via an AKS-hosted proxy, no external egress required.\n\n**Key benefits:**\n\n- **Centralised Access Control**: Authorisation flows through Kubernetes RBAC.\n- **Cross-Cluster Identity Reuse**: Federated credentials can be shared across namespaces and clusters.\n- **Reduced Networking Requirements**: No outbound calls for token acquisition; everything stays within the cluster.\n- **Simplified IaC**: Eliminates the “chicken-and-egg” problem when deploying identities alongside workloads.\n\nIdentity Bindings act as the link between applications running in AKS and the Azure managed identities they need to use. Instead of every cluster or namespace requiring its own federated identity configuration, each application is authorised through an Identity Binding defined inside the cluster. The binding expresses which workloads (via service accounts and RBAC) are allowed to request tokens for a given identity.\n\nWhen a pod needs a token, AKS validates the request against the binding, and if it matches, the request is routed through the cluster’s identity proxy to the single Federated Identity Credential (FIC) associated with the managed identity. The FIC then exchanges the pod’s OIDC token for an Azure access token. This pattern allows multiple clusters or namespaces to share one managed identity cleanly, while keeping all workload‑level authorisation decisions inside Kubernetes.\n\n![]()\n\nWith Workload Identity, every workload using a managed identity required its own Federated Identity Credential (FIC) tied to a specific namespace and service account, and you had to repeat that for every cluster. Hitting the 20‑FIC limit often forced teams to create duplicate managed identities, and deployments had to be carefully ordered to avoid cyclic dependencies. You also needed outbound access to Entra ID for token requests.\n\nIdentity Bindings significantly simplifies this. You create a single binding per cluster–identity pair, authorise workloads through RBAC, and let AKS handle token exchange internally with no external egress. There is no FIC sprawl, no need for identity duplication and less complexity in your automation.\n\n## Using Identity Bindings\n\nTo get started with using Identity Bindings, you need an AKS cluster and a Managed Identity created. Your Managed Identity should be granted permissions to access the Azure resources you require.\n\nThe first thing you need to do is ensure the feature is registered.\n\n- az feature register --namespace Microsoft.ContainerService --name IdentityBindingPreview\n\nNext, we need to do is create the identity binding. This is a one-to-one mapping between AKS cluster and Managed Identity, so only needs to be created once for each clusters/identity mapping. You provide the name of the cluster you want the binding mapped to, the full resource ID of the Managed Identity resources, and the name you want to give this binding, and this maps the two resources together. This only needs to be created once per cluster and all further administration is done via Kubernetes.\n- az aks identity-binding create -g \"\" --cluster-name \"\" -n \"\" --managed-identity-resource-id \"\"\n\nOnce this has been created, we need to configure access to it inside Kubernetes. To do this we create a ClusterRole which references the Managed Identity ID. Note that this must be a ClusterRole, it cannot just be a Role.\n- apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole metadata: name: identity-binding-user rules:\n- verbs: [\"use-managed-identity\"]\napiGroups: [\"cid.wi.aks.azure.com\"] resources: [\"\"]\n\nOnce this ClusterRole is created, we can assign it to any Namespace and Service Account combination we require, using a ClusterRoleBinding. Indentity Bindings are accessible to all Pods that use that Service Account, in that Namespace.\n- apiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding metadata: name: roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: identity-binding-user subjects:\n- kind: ServiceAccount\nname: namespace:\n\nNow all that is left to do is configure the Pod to use the Identity Binding, there are a two steps to this.\n\nFirst we need to apply the required labels and annotations to the pod to enable Identity Binding support:\n- metadata:\nlabels: azure.workload.identity/use: \"true\" annotations: azure.workload.identity/use-identity-binding: \"true\"\n\nThen, we need to ensure that the Pod is running using the Service Account we granted permission to use the Identity Binding.\n- spec:\nserviceAccountName:\n\nBelow is an example deployment that uses Identity Bindings.\n- apiVersion: apps/v1\nkind: Deployment metadata: name: keyvault-demo namespace: identity-binding-demo spec: replicas: 1 selector: matchLabels: app: keyvault-demo template: metadata: labels: app: keyvault-demo azure.workload.identity/use: \"true\" annotations: azure.workload.identity/use-identity-binding: \"true\" spec: serviceAccountName: keyvault-demo-sa containers:\n- name: keyvault-demo\n...\n\nOnce this Pod has been created, the Identity Binding should be attached and you should then be able to use it within your application using your SDK and language of choice. You can see an example of consuming an Identity Binding in GO [here](https://github.com/Azure/azure-workload-identity/blob/feature/custom-token-endpoint/examples/identitybinding-msal-go/main.go) .\n\n### Demo App\n\nIf you want to deploy a demo workload to test out your bindings, you can use the Pod definition below. This requires you to deploy a Key Vault, and grant your managed identity the \"Key Vault Secret User\" role on that Key Vault. You will also need to update the service principle and namespace to match your environment.\n- apiVersion: v1\nkind: Pod metadata: name: demo namespace: demo labels: azure.workload.identity/use: \"true\" annotations: azure.workload.identity/use-identity-binding: \"true\" spec: serviceAccount: demo containers:\n- name: azure-sdk\n# source code: https://github.com/Azure/azure-workload-identity/blob/feature/custom-token-endpoint/examples/identitybinding-msal-go/main.go\nimage: ghcr.io/bahe-msft/azure-workload-identity/identitybinding-msal-go:latest-linux-amd64 env:\n- name: KEYVAULT\\_URL\nvalue: ${KEYVAULT\\_URL}\n- name: SECRET\\_NAME\nvalue: ${KEYVAULT\\_SECRET\\_NAME} restartPolicy: Never\n\nOnce deployed, if you look at the logs, you should see that it is able to read the secret from Key Vault.\n- kubectl logs demo -n demo\n- I1107 20:03:42.865180 1 main.go:77] \"successfully got secret\" secret=\"Hello!\"\n\n## Conclusion\n\nIdentity Bindings offer a much cleaner model for managing workload identities in AKS, especially once you start operating at scale. By moving authorisation decisions into Kubernetes and relying on a single Federated Identity Credential per managed identity, they avoid the FIC sprawl, cyclic dependencies, and networking requirements that made Workload Identity harder to operate in larger environments. The end result is a simpler, more predictable way to let pods acquire Azure tokens. If you’re already using Workload Identity today, Identity Bindings are a natural evolution that reduces operational friction while keeping the security properties you expect.\n\n### Further Reading\n\n- [Identity Bindings Overview](https://learn.microsoft.com/en-us/azure/aks/identity-bindings-concepts)\n- [Setup Identity Bindings](https://learn.microsoft.com/en-us/azure/aks/identity-bindings)",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "EnhancedContent": "AKS has supported assigning Azure Managed Identities to pods for some time, first through Pod Identity and then later through Workload Identity. Using these tools it is possible to give a pod an Azure Identity that it can use to interact with other Azure services - pull secrets from Key Vault, read a file from Blob Storage or write to a database.\n\n[Workload Identity](https://learn.microsoft.com/en-us/entra/workload-id/workload-identities-overview) is the latest incarnation of this feature and significantly simplified this feature, removing the need to run additional management pods in the cluster and to have the identity injected in every node however it does have some issues of it's own. These issues are particularly evident when operating at scale and wanting to share the same Managed Identity across multiple workloads in the same cluster, or across multiple clusters.\n\nWorkload Identity relies on creating a Federated Identity Credential (FIC) in Azure that defines the trust relationship between the AKS OIDC issuer and Entra ID. Each combination of Service Account and Namespace that uses the same Managed Identity requires a separate FIC, as do services running in different clusters.\n\nAs your scale grows, this can start to become a problem. Each managed identity can only support up to 20 FICs. Once you hit that limit, your only option is to create another Managed Identity. This leads to the proliferation of Managed Identities that have the same permissions and do the same job, but only exist to work around this problem.\n\nIn addition to the 20 FIC limit, there are some other issues with Workload Identity:\n\n- Creation of the FIC is an Azure Resource creation that often needs to occur alongside Kubernetes resource creation and makes automation of app deployment harder\n- There can be a cyclic dependency issue where the service account in Kubernetes needs to know the Identity details before the pod is created, but the FIC needs the service account and namespace details to create the OIDC binding\n- Additional outbound rules are required to allow the AKS cluster to access the Entra ID (login.microsoftonline.com) endpoints\n\n## Introducing Identity Bindings\n\n> >\n> Identity Bindings are currently in preview. Previews are provided \"as is\" and \"as available,\" and they're excluded from the service-level agreements and limited warranty. AKS previews are partially covered by customer support on a best-effort basis. As such, these features aren't meant for production use.\n> >\n\nIdentity Bindings introduce a cleaner, RBAC-driven approach to identity management in AKS. Instead of juggling multiple federated credentials and namespace scoping, you define bindings that link Kubernetes RBAC roles to Azure identities. Pods then request tokens via an AKS-hosted proxy, no external egress required.\n\n**Key benefits:**\n\n- **Centralised Access Control**: Authorisation flows through Kubernetes RBAC.\n- **Cross-Cluster Identity Reuse**: Federated credentials can be shared across namespaces and clusters.\n- **Reduced Networking Requirements**: No outbound calls for token acquisition; everything stays within the cluster.\n- **Simplified IaC**: Eliminates the “chicken-and-egg” problem when deploying identities alongside workloads.\n\nIdentity Bindings act as the link between applications running in AKS and the Azure managed identities they need to use. Instead of every cluster or namespace requiring its own federated identity configuration, each application is authorised through an Identity Binding defined inside the cluster. The binding expresses which workloads (via service accounts and RBAC) are allowed to request tokens for a given identity.\n\nWhen a pod needs a token, AKS validates the request against the binding, and if it matches, the request is routed through the cluster’s identity proxy to the single Federated Identity Credential (FIC) associated with the managed identity. The FIC then exchanges the pod’s OIDC token for an Azure access token. This pattern allows multiple clusters or namespaces to share one managed identity cleanly, while keeping all workload‑level authorisation decisions inside Kubernetes.\n\nWith Workload Identity, every workload using a managed identity required its own Federated Identity Credential (FIC) tied to a specific namespace and service account, and you had to repeat that for every cluster. Hitting the 20‑FIC limit often forced teams to create duplicate managed identities, and deployments had to be carefully ordered to avoid cyclic dependencies. You also needed outbound access to Entra ID for token requests.\n\nIdentity Bindings significantly simplifies this. You create a single binding per cluster–identity pair, authorise workloads through RBAC, and let AKS handle token exchange internally with no external egress. There is no FIC sprawl, no need for identity duplication and less complexity in your automation.\n\n## Using Identity Bindings\n\nTo get started with using Identity Bindings, you need an AKS cluster and a Managed Identity created. Your Managed Identity should be granted permissions to access the Azure resources you require.\n\nThe first thing you need to do is ensure the feature is registered.\n\n``` az feature register --namespace Microsoft.ContainerService --name IdentityBindingPreview ```\n\nNext, we need to do is create the identity binding. This is a one-to-one mapping between AKS cluster and Managed Identity, so only needs to be created once for each clusters/identity mapping. You provide the name of the cluster you want the binding mapped to, the full resource ID of the Managed Identity resources, and the name you want to give this binding, and this maps the two resources together. This only needs to be created once per cluster and all further administration is done via Kubernetes.\n\n``` az aks identity-binding create -g \"<resource group name>\" --cluster-name \"<cluster name>\" -n \"<binding name>\" --managed-identity-resource-id \"<managed identity Azure Resource ID>\" ```\n\nOnce this has been created, we need to configure access to it inside Kubernetes. To do this we create a ClusterRole which references the Managed Identity ID. Note that this must be a ClusterRole, it cannot just be a Role.\n\n``` apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: identity-binding-user rules:\n- verbs: [\"use-managed-identity\"]\napiGroups: [\"cid.wi.aks.azure.com\"] resources: [\"<MI_CLIENT_ID>\"] ```\n\nOnce this ClusterRole is created, we can assign it to any Namespace and Service Account combination we require, using a ClusterRoleBinding. Indentity Bindings are accessible to all Pods that use that Service Account, in that Namespace.\n\n``` apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: <clusterrole name> roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: identity-binding-user subjects:\n- kind: ServiceAccount\nname: <service account name> namespace: <namespace of service account>\n\n```\n\nNow all that is left to do is configure the Pod to use the Identity Binding, there are a two steps to this.\n\nFirst we need to apply the required labels and annotations to the pod to enable Identity Binding support:\n\n``` metadata: labels: azure.workload.identity/use: \"true\" annotations: azure.workload.identity/use-identity-binding: \"true\" ```\n\nThen, we need to ensure that the Pod is running using the Service Account we granted permission to use the Identity Binding.\n\n``` spec: serviceAccountName: <service account name> ```\n\nBelow is an example deployment that uses Identity Bindings.\n\n``` apiVersion: apps/v1 kind: Deployment metadata: name: keyvault-demo namespace: identity-binding-demo spec: replicas: 1 selector: matchLabels: app: keyvault-demo template: metadata: labels: app: keyvault-demo azure.workload.identity/use: \"true\" annotations: azure.workload.identity/use-identity-binding: \"true\" spec: serviceAccountName: keyvault-demo-sa containers:\n- name: keyvault-demo\n...\n\n```\n\nOnce this Pod has been created, the Identity Binding should be attached and you should then be able to use it within your application using your SDK and language of choice. You can see an example of consuming an Identity Binding in GO [here](https://github.com/Azure/azure-workload-identity/blob/feature/custom-token-endpoint/examples/identitybinding-msal-go/main.go) .\n\n### Demo App\n\nIf you want to deploy a demo workload to test out your bindings, you can use the Pod definition below. This requires you to deploy a Key Vault, and grant your managed identity the \"Key Vault Secret User\" role on that Key Vault. You will also need to update the service principle and namespace to match your environment.\n\n``` apiVersion: v1 kind: Pod metadata: name: demo namespace: demo labels: azure.workload.identity/use: \"true\" annotations: azure.workload.identity/use-identity-binding: \"true\" spec: serviceAccount: demo containers:\n- name: azure-sdk\n# source code: https://github.com/Azure/azure-workload-identity/blob/feature/custom-token-endpoint/examples/identitybinding-msal-go/main.go\nimage: ghcr.io/bahe-msft/azure-workload-identity/identitybinding-msal-go:latest-linux-amd64 env:\n- name: KEYVAULT_URL\nvalue: ${KEYVAULT_URL}\n- name: SECRET_NAME\nvalue: ${KEYVAULT_SECRET_NAME} restartPolicy: Never ```\n\nOnce deployed, if you look at the logs, you should see that it is able to read the secret from Key Vault.\n\n``` kubectl logs demo -n demo ```\n\n``` I1107 20:03:42.865180 1 main.go:77] \"successfully got secret\" secret=\"Hello!\" ```\n\n## Conclusion\n\nIdentity Bindings offer a much cleaner model for managing workload identities in AKS, especially once you start operating at scale. By moving authorisation decisions into Kubernetes and relying on a single Federated Identity Credential per managed identity, they avoid the FIC sprawl, cyclic dependencies, and networking requirements that made Workload Identity harder to operate in larger environments. The end result is a simpler, more predictable way to let pods acquire Azure tokens. If you’re already using Workload Identity today, Identity Bindings are a natural evolution that reduces operational friction while keeping the security properties you expect.\n\n### Further Reading\n\n- [Identity Bindings Overview](https://learn.microsoft.com/en-us/azure/aks/identity-bindings-concepts)\n- [Setup Identity Bindings](https://learn.microsoft.com/en-us/azure/aks/identity-bindings)\n\nUpdated Jan 12, 2026\n\nVersion 1.0\n\n[azure active directory](/tag/azure%20active%20directory?nodeId=board%3AAppsonAzureBlog)\n\n[azure kubernetes service](/tag/azure%20kubernetes%20service?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[samcogan&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0yOTgxNTI4LVdSRVN4Rg?image-coordinates=64%2C0%2C1938%2C1873&amp;image-dimensions=50x50)](/users/samcogan/2981528) [samcogan](/users/samcogan/2981528) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined April 03, 2025\n\n[View Profile](/users/samcogan/2981528)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "PubDate": "2026-01-12T10:42:40+00:00",
  "ProcessedDate": "2026-01-12 11:03:36",
  "FeedName": "Microsoft Tech Community",
  "Tags": [],
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/identity-bindings-a-cleaner-model-for-multi-cluster-identity-in/ba-p/4478282",
  "Title": "Identity Bindings: A Cleaner Model for Multi‑Cluster Identity in AKS",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure"
}
