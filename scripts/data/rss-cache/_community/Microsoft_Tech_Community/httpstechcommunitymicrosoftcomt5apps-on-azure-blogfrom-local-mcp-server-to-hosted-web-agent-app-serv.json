{
  "OutputDir": "_community",
  "Tags": [],
  "FeedName": "Microsoft Tech Community",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Description": "In [Part 1](https://techcommunity.microsoft.com/blog/appsonazureblog/chat-with-your-app-service-logs-using-github-copilot/4491573), we introduced the App Service Observability MCP Server — a proof-of-concept that lets GitHub Copilot (and other AI assistants) query your App Service logs, analyze errors, and help debug issues through natural language. That version runs locally alongside your IDE, and it's great for individual developers who want to investigate their apps without leaving VS Code.\n\nA local MCP server is powerful, but it's personal. Your teammate has to clone the repo, configure their IDE, and run it themselves. What if your on-call engineer could just open a browser and start asking questions? What if your whole team had a shared observability assistant — no setup required?\n\nIn this post, we'll show how we took the same set of MCP tools and wrapped them in a hosted web application — deployed to Azure App Service with a chat UI and a built-in Azure OpenAI agent. We'll cover what changed, what stayed the same, and why this pattern opens the door to far more than just a web app.\n\n## Quick Recap: The Local MCP Server\n\nIf you haven't read [Part 1](https://techcommunity.microsoft.com/blog/appsonazureblog/chat-with-your-app-service-logs-using-github-copilot/4491573), here's the short version:\n\nWe built an [MCP (Model Context Protocol)](https://modelcontextprotocol.io/) server that exposes ~15 observability tools for App Service — things like querying Log Analytics, fetching Kudu container logs, analyzing HTTP errors, correlating deployments with failures, and checking logging configurations. You point your AI assistant (GitHub Copilot, Claude, etc.) at the server, and it calls those tools on your behalf to answer questions about your apps.\n\nThat version:\n\n- Runs locally on your machine via `node`\n- Uses **stdio** transport (your IDE spawns the process)\n- Relies on **your Azure credentials** (`az login`\n) — the AI operates with your exact permissions\n- Requires no additional Azure resources\n\nIt works. It's fast. And for a developer investigating their own apps, it's the simplest path. **This is still a perfectly valid way to use the project** — nothing about the hosted version replaces it.\n\n## The Problem: Sharing Is Hard\n\nThe local MCP server has a limitation: it's tied to one developer's machine and IDE. In practice, this means:\n\n- **On-call engineers** need to clone the repo and configure their environment before they can use it\n- **Team leads** can't point someone at a URL and say \"go investigate\"\n- **Non-IDE users** (PMs, support engineers) are left out entirely\n- **Consistent configuration** (which subscription, which resource group) has to be managed per-person\n\nWe wanted to keep the same tools and the same observability capabilities, but make them accessible to anyone with a browser.\n\n## The Solution: Host It on App Service\n\nThe answer turned out to be straightforward: deploy the MCP server itself to Azure App Service, give it a web frontend, and bring its own AI agent along for the ride.\n\nHere's what the hosted version adds on top of the local MCP server:\n\n| | Local MCP Server | Hosted Web Agent | | --- | --- | --- | | **How it works** | Runs locally, your IDE's AI calls the tools | Deployed to Azure App Service with its own AI agent | | **Interface** | VS Code, Claude Desktop, or any MCP client | Browser-based chat UI | | **Agent** | Your existing AI assistant (Copilot, Claude, etc.) | Built-in Azure OpenAI (GPT-5-mini) | | **Azure resources needed** | None beyond `az login` | App Service, Azure OpenAI, VNet | | **Best for** | Individual developers in their IDE | Teams who want a shared, centralized tool | | **Authentication** | Your local `az login`<br> credentials | Managed identity + Easy Auth (Entra ID) | | **Deploy** | `npm install && npm run build` | `azd up` |\n\nThe key insight: **the MCP tools are identical**. Both versions use the exact same set of observability tools — the only difference is who's calling them (your IDE's AI vs. the built-in Azure OpenAI agent) and where the server runs (your laptop vs. App Service).\n\n## What We Built\n\n### Architecture\n\n``` ┌─────────────────────────────────────────────────────────────────────────────┐ │ Web Browser │ │ React Chat UI — resource selectors, tool steps, markdown responses │ └──────────────────────────────────┬──────────────────────────────────────────┘ │ HTTP (REST API) ▼ ┌─────────────────────────────────────────────────────────────────────────────┐ │ Azure App Service (Node.js 20) │ │ ┌──────────────────────────────────────────────────────────────────────┐ │ │ │ Express Server │ │ │ │ ├── /api/chat → Agent loop (OpenAI → tool calls → respond) │ │ │ │ ├── /api/set-context → Set target app for investigation │ │ │ │ ├── /api/resource-groups, /api/apps → Resource discovery │ │ │ │ ├── /mcp → MCP protocol endpoint (Streamable HTTP) │ │ │ │ └── / → Static SPA (React chat UI) │ │ │ └──────────────────────────────────────────────────────────────────────┘ │ │ VNet Integration (snet-app) │ └─────────────────────────────────────────────────────────────────────────────┘ │ │ │ ▼ ▼ ▼ ┌──────────────┐ ┌───────────────────┐ ┌────────────────────┐ │ Azure OpenAI │ │ Log Analytics / │ │ ARM API / Kudu │ │ (GPT-5-mini) │ │ KQL Queries │ │ (app metadata, │ │ Private EP │ └───────────────────┘ │ container logs) │ └──────────────┘ └────────────────────┘ ```\n\nThe Express server does double duty: it serves the React chat UI as static files and exposes the MCP endpoint for remote IDE connections. The agent loop is simple — when a user sends a message, the server calls Azure OpenAI, which may request tool calls, the server executes those tools, and the loop continues until the AI has a final answer.\n\n### Demo\n\nThe following screenshots show how this app can be used. The first screenshot shows what happens when you ask about a functioning app. You can see the agent made 5 tool calls and was able to give a thorough summary of the current app's status, recent deployments, as well as provide some recommendations for how to improve observability of the app itself. I expanded the tools section so you could see exactly what the agent was doing behind the scenes and get a sense of how it was thinking. At this point, you can proceed to ask more questions about your app if there were other pieces of information you wanted to pull from your logs.\n\n![]()\n\nI then injected a fault into this app by initiating a deployment pointing to a config file that didn't actually exist. The goal here was to prove that the agent could correlate an application issue to a specific deployment event, something that currently involves manual effort and deep investigation into logs and source code. Having an agent that can do this for you in a matter of seconds saves so much time and effort that could be directed to more important activities and ensures that you find the issue the first time.\n\nA few minutes after initiating the bad deployment, I saw that my app was no longer responding. Rather than going to the logs and investigating myself, I asked the agent \"I'm getting an application error now, what happened?\" I obviously know what happened and what the source of the error was, but let's see if the agent can pick that up.\n\n![]()\n\nThe agent was able to see that something was wrong and then point me in the direction to address the issue. It ran a number of tool calls following our investigation steps called out in the skills file and was successfully able to identify the source of the error.\n\nAnd lastly, I wanted to confirm the error was associated with the recent deployment, something that our agent should be able to do because we built in the tools it needs to be able to corrleate these kinds of events with errors. I asked it directly and here was the response, exactly what I expected to see.\n\n![]()\n\n### Infrastructure (one command)\n\nEverything is defined in Bicep and deployed with the Azure Developer CLI:\n\n```\n\n```\n\n- azd up\n\n```\n\n```\n\nThis provisions:\n\n- **App Service Plan** (P0v3) with **App Service** (Node.js 20 LTS, VNet-integrated)\n- **Azure OpenAI** (GPT-5-mini, Global Standard) with a **private endpoint** and **private DNS zone**\n- **VNet** (10.0.0.0/16) with dedicated subnets for the app and private endpoints\n- **Managed Identity** with RBAC roles: Reader, Website Contributor, Log Analytics Reader, Cognitive Services OpenAI User\n\nNo API keys anywhere. The App Service authenticates to Azure OpenAI over a private network using its managed identity.\n\n### The Chat UI\n\nThe web interface is designed to get out of the way and let you focus on investigating:\n\n- **Resource group and app dropdowns** — Browse your subscription, pick the app you want to investigate\n- **Tool step visibility** — A collapsible panel shows exactly which tools the agent called, what arguments it used, and how long each took\n- **Session management** — Start fresh conversations, with confirmation dialogs when switching context mid-investigation\n- **Markdown responses** — The agent's answers are rendered with full formatting, code blocks, and tables\n\nWhen you first open the app, it auto-discovers your subscription and populates the resource group dropdown. Select an app, hit \"Tell me about this app,\" and the agent starts investigating.\n\n### Security\n\nSince this app has subscription-wide read access to your App Services and Log Analytics workspaces, **you should definitely enable authentication**. After deploying, configure Easy Auth in the Azure Portal:\n\n1. Go to your App Service → **Authentication**\n2. Click **Add identity provider** → select **Microsoft Entra ID**\n3. Set **Unauthenticated requests** to \"HTTP 401 Unauthorized\"\n\nThis ensures only authorized members of your organization can access the tool.\n\nThe connection to Azure OpenAI is secured via a **private endpoint** — traffic never traverses the public internet. The app authenticates using its managed identity with the `Cognitive Services OpenAI User` role.\n\n## What Stayed the Same\n\nThis is the part worth emphasizing: **the core tools didn't change at all**. Whether you're using the local MCP server or the hosted web agent, you get the same 15 tools.\n\nThe [Agent Skill (SKILL.md)](https://github.com/seligj95/app-service-observability-agent/blob/main/SKILL.md) from Part 1 also carries over. The hosted agent has the same domain expertise for App Service debugging baked into its system prompt — the same debugging workflows, common error patterns, KQL templates, and SKU reference that make the local version effective.\n\n## The Bigger Picture: It's Not Just a Web App\n\nHere's what makes this interesting beyond our specific implementation: **the pattern is the point**.\n\nWe took a set of domain-specific tools (App Service observability), wrapped them in a standard protocol (MCP), and showed two ways to use them:\n\n1. **Local MCP server** → Your IDE's AI calls the tools\n2. **Hosted web agent** → A deployed app with its own AI calls the same tools\n\nBut those are just two examples. The same tools could power:\n\n- **A Microsoft Teams bot** — Your on-call channel gets an observability assistant that anyone can [mention​](javascript:void%280%29)\n- **A Slack integration** — Same idea, different platform\n- **A CLI agent** — A terminal-based chat for engineers who live in the command line\n- **An automated monitor** — An agent that periodically checks your apps and files alerts\n- **An Azure Portal extension** — Observability chat embedded directly in the portal experience\n- **A mobile app** — Check on your apps from your phone during an incident\n\nThe MCP tools are the foundation. The agent and interface are just the delivery mechanism. Build whatever surface makes sense for your team.\n\nThis is one of the core ideas behind MCP: **write the tools once, use them everywhere**. The protocol standardizes how AI assistants discover and call tools, so you're not locked into any single client or agent.\n\n## Try It Yourself\n\nBoth versions are open-source:\n\n- **Local MCP server (Part 1):** [github.com/seligj95/app-service-observability-agent](https://github.com/seligj95/app-service-observability-agent)\n- **Hosted web agent (Part 2):** [github.com/seligj95/app-service-observability-agent-hosted](https://github.com/seligj95/app-service-observability-agent-hosted)\n\nTo deploy the hosted version:\n- git clone https://github.com/seligj95/app-service-observability-agent-hosted.git\ncd app-service-observability-agent-hosted azd up\n\nTo run the local version, see the [Getting Started section in Part 1](https://techcommunity.microsoft.com/blog/appsonazureblog/chat-with-your-app-service-logs-using-github-copilot/4491573).\n\n## What's Next?\n\nThis is still a proof-of-concept, and we're continuing to explore how AI-powered observability can become a first-class part of the App Service platform. Some things we're thinking about:\n\n- **More tools** — Resource health, autoscale history, certificate expiration, network diagnostics\n- **Multi-app investigations** — Correlate issues across multiple apps in a resource group\n- **Proactive monitoring** — Agents that watch your apps and alert you before users notice\n- **Deeper integration** — What if every App Service came with a built-in observability endpoint?\n\nWe'd love your feedback. Try it out, open an issue, or submit a PR if you have ideas for additional tools or debugging patterns. And if you build something interesting on top of these MCP tools — a Teams bot, a CLI agent, anything — we'd love to hear about it.",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/from-local-mcp-server-to-hosted-web-agent-app-service/ba-p/4493241",
  "PubDate": "2026-02-11T15:47:24+00:00",
  "Title": "From Local MCP Server to Hosted Web Agent: App Service Observability, Part 2",
  "ProcessedDate": "2026-02-11 16:20:59",
  "Author": "jordanselig",
  "EnhancedContent": "In [Part 1](https://techcommunity.microsoft.com/blog/appsonazureblog/chat-with-your-app-service-logs-using-github-copilot/4491573), we introduced the App Service Observability MCP Server — a proof-of-concept that lets GitHub Copilot (and other AI assistants) query your App Service logs, analyze errors, and help debug issues through natural language. That version runs locally alongside your IDE, and it's great for individual developers who want to investigate their apps without leaving VS Code.\n\nA local MCP server is powerful, but it's personal. Your teammate has to clone the repo, configure their IDE, and run it themselves. What if your on-call engineer could just open a browser and start asking questions? What if your whole team had a shared observability assistant — no setup required?\n\nIn this post, we'll show how we took the same set of MCP tools and wrapped them in a hosted web application — deployed to Azure App Service with a chat UI and a built-in Azure OpenAI agent. We'll cover what changed, what stayed the same, and why this pattern opens the door to far more than just a web app.\n\n## Quick Recap: The Local MCP Server\n\nIf you haven't read [Part 1](https://techcommunity.microsoft.com/blog/appsonazureblog/chat-with-your-app-service-logs-using-github-copilot/4491573), here's the short version:\n\nWe built an [MCP (Model Context Protocol)](https://modelcontextprotocol.io/) server that exposes ~15 observability tools for App Service — things like querying Log Analytics, fetching Kudu container logs, analyzing HTTP errors, correlating deployments with failures, and checking logging configurations. You point your AI assistant (GitHub Copilot, Claude, etc.) at the server, and it calls those tools on your behalf to answer questions about your apps.\n\nThat version:\n\n- Runs locally on your machine via `node`\n- Uses **stdio** transport (your IDE spawns the process)\n- Relies on **your Azure credentials** (`az login`\n) — the AI operates with your exact permissions\n- Requires no additional Azure resources\n\nIt works. It's fast. And for a developer investigating their own apps, it's the simplest path. **This is still a perfectly valid way to use the project** — nothing about the hosted version replaces it.\n\n## The Problem: Sharing Is Hard\n\nThe local MCP server has a limitation: it's tied to one developer's machine and IDE. In practice, this means:\n\n- **On-call engineers** need to clone the repo and configure their environment before they can use it\n- **Team leads** can't point someone at a URL and say \"go investigate\"\n- **Non-IDE users** (PMs, support engineers) are left out entirely\n- **Consistent configuration** (which subscription, which resource group) has to be managed per-person\n\nWe wanted to keep the same tools and the same observability capabilities, but make them accessible to anyone with a browser.\n\n## The Solution: Host It on App Service\n\nThe answer turned out to be straightforward: deploy the MCP server itself to Azure App Service, give it a web frontend, and bring its own AI agent along for the ride.\n\nHere's what the hosted version adds on top of the local MCP server:\n\n| | Local MCP Server | Hosted Web Agent | | --- | --- | --- | | **How it works** | Runs locally, your IDE's AI calls the tools | Deployed to Azure App Service with its own AI agent | | **Interface** | VS Code, Claude Desktop, or any MCP client | Browser-based chat UI | | **Agent** | Your existing AI assistant (Copilot, Claude, etc.) | Built-in Azure OpenAI (GPT-5-mini) | | **Azure resources needed** | None beyond `az login` | App Service, Azure OpenAI, VNet | | **Best for** | Individual developers in their IDE | Teams who want a shared, centralized tool | | **Authentication** | Your local `az login`<br> credentials | Managed identity + Easy Auth (Entra ID) | | **Deploy** | `npm install && npm run build` | `azd up` |\n\nThe key insight: **the MCP tools are identical**. Both versions use the exact same set of observability tools — the only difference is who's calling them (your IDE's AI vs. the built-in Azure OpenAI agent) and where the server runs (your laptop vs. App Service).\n\n## What We Built\n\n### Architecture\n\n``` ┌─────────────────────────────────────────────────────────────────────────────┐ │ Web Browser │ │ React Chat UI — resource selectors, tool steps, markdown responses │ └──────────────────────────────────┬──────────────────────────────────────────┘ │ HTTP (REST API) ▼ ┌─────────────────────────────────────────────────────────────────────────────┐ │ Azure App Service (Node.js 20) │ │ ┌──────────────────────────────────────────────────────────────────────┐ │ │ │ Express Server │ │ │ │ ├── /api/chat → Agent loop (OpenAI → tool calls → respond) │ │ │ │ ├── /api/set-context → Set target app for investigation │ │ │ │ ├── /api/resource-groups, /api/apps → Resource discovery │ │ │ │ ├── /mcp → MCP protocol endpoint (Streamable HTTP) │ │ │ │ └── / → Static SPA (React chat UI) │ │ │ └──────────────────────────────────────────────────────────────────────┘ │ │ VNet Integration (snet-app) │ └─────────────────────────────────────────────────────────────────────────────┘ │ │ │ ▼ ▼ ▼ ┌──────────────┐ ┌───────────────────┐ ┌────────────────────┐ │ Azure OpenAI │ │ Log Analytics / │ │ ARM API / Kudu │ │ (GPT-5-mini) │ │ KQL Queries │ │ (app metadata, │ │ Private EP │ └───────────────────┘ │ container logs) │ └──────────────┘ └────────────────────┘ ```\n\nThe Express server does double duty: it serves the React chat UI as static files and exposes the MCP endpoint for remote IDE connections. The agent loop is simple — when a user sends a message, the server calls Azure OpenAI, which may request tool calls, the server executes those tools, and the loop continues until the AI has a final answer.\n\n### Demo\n\nThe following screenshots show how this app can be used. The first screenshot shows what happens when you ask about a functioning app. You can see the agent made 5 tool calls and was able to give a thorough summary of the current app's status, recent deployments, as well as provide some recommendations for how to improve observability of the app itself. I expanded the tools section so you could see exactly what the agent was doing behind the scenes and get a sense of how it was thinking. At this point, you can proceed to ask more questions about your app if there were other pieces of information you wanted to pull from your logs.\n\nI then injected a fault into this app by initiating a deployment pointing to a config file that didn't actually exist. The goal here was to prove that the agent could correlate an application issue to a specific deployment event, something that currently involves manual effort and deep investigation into logs and source code. Having an agent that can do this for you in a matter of seconds saves so much time and effort that could be directed to more important activities and ensures that you find the issue the first time.\n\nA few minutes after initiating the bad deployment, I saw that my app was no longer responding. Rather than going to the logs and investigating myself, I asked the agent \"I'm getting an application error now, what happened?\" I obviously know what happened and what the source of the error was, but let's see if the agent can pick that up.\n\nThe agent was able to see that something was wrong and then point me in the direction to address the issue. It ran a number of tool calls following our investigation steps called out in the skills file and was successfully able to identify the source of the error.\n\nAnd lastly, I wanted to confirm the error was associated with the recent deployment, something that our agent should be able to do because we built in the tools it needs to be able to corrleate these kinds of events with errors. I asked it directly and here was the response, exactly what I expected to see.\n\n### Infrastructure (one command)\n\nEverything is defined in Bicep and deployed with the Azure Developer CLI:\n\n```\n\n```\n\n``` azd up ```\n\n```\n\n```\n\nThis provisions:\n\n- **App Service Plan** (P0v3) with **App Service** (Node.js 20 LTS, VNet-integrated)\n- **Azure OpenAI** (GPT-5-mini, Global Standard) with a **private endpoint** and **private DNS zone**\n- **VNet** (10.0.0.0/16) with dedicated subnets for the app and private endpoints\n- **Managed Identity** with RBAC roles: Reader, Website Contributor, Log Analytics Reader, Cognitive Services OpenAI User\n\nNo API keys anywhere. The App Service authenticates to Azure OpenAI over a private network using its managed identity.\n\n### The Chat UI\n\nThe web interface is designed to get out of the way and let you focus on investigating:\n\n- **Resource group and app dropdowns** — Browse your subscription, pick the app you want to investigate\n- **Tool step visibility** — A collapsible panel shows exactly which tools the agent called, what arguments it used, and how long each took\n- **Session management** — Start fresh conversations, with confirmation dialogs when switching context mid-investigation\n- **Markdown responses** — The agent's answers are rendered with full formatting, code blocks, and tables\n\nWhen you first open the app, it auto-discovers your subscription and populates the resource group dropdown. Select an app, hit \"Tell me about this app,\" and the agent starts investigating.\n\n### Security\n\nSince this app has subscription-wide read access to your App Services and Log Analytics workspaces, **you should definitely enable authentication**. After deploying, configure Easy Auth in the Azure Portal:\n\n1. Go to your App Service → **Authentication**\n2. Click **Add identity provider** → select **Microsoft Entra ID**\n3. Set **Unauthenticated requests** to \"HTTP 401 Unauthorized\"\n\nThis ensures only authorized members of your organization can access the tool.\n\nThe connection to Azure OpenAI is secured via a **private endpoint** — traffic never traverses the public internet. The app authenticates using its managed identity with the `Cognitive Services OpenAI User` role.\n\n## What Stayed the Same\n\nThis is the part worth emphasizing: **the core tools didn't change at all**. Whether you're using the local MCP server or the hosted web agent, you get the same 15 tools.\n\nThe [Agent Skill (SKILL.md)](https://github.com/seligj95/app-service-observability-agent/blob/main/SKILL.md) from Part 1 also carries over. The hosted agent has the same domain expertise for App Service debugging baked into its system prompt — the same debugging workflows, common error patterns, KQL templates, and SKU reference that make the local version effective.\n\n## The Bigger Picture: It's Not Just a Web App\n\nHere's what makes this interesting beyond our specific implementation: **the pattern is the point**.\n\nWe took a set of domain-specific tools (App Service observability), wrapped them in a standard protocol (MCP), and showed two ways to use them:\n\n1. **Local MCP server** → Your IDE's AI calls the tools\n2. **Hosted web agent** → A deployed app with its own AI calls the same tools\n\nBut those are just two examples. The same tools could power:\n\n- **A Microsoft Teams bot** — Your on-call channel gets an observability assistant that anyone can [mention​](javascript:void%280%29)\n- **A Slack integration** — Same idea, different platform\n- **A CLI agent** — A terminal-based chat for engineers who live in the command line\n- **An automated monitor** — An agent that periodically checks your apps and files alerts\n- **An Azure Portal extension** — Observability chat embedded directly in the portal experience\n- **A mobile app** — Check on your apps from your phone during an incident\n\nThe MCP tools are the foundation. The agent and interface are just the delivery mechanism. Build whatever surface makes sense for your team.\n\nThis is one of the core ideas behind MCP: **write the tools once, use them everywhere**. The protocol standardizes how AI assistants discover and call tools, so you're not locked into any single client or agent.\n\n## Try It Yourself\n\nBoth versions are open-source:\n\n- **Local MCP server (Part 1):** [github.com/seligj95/app-service-observability-agent](https://github.com/seligj95/app-service-observability-agent)\n- **Hosted web agent (Part 2):** [github.com/seligj95/app-service-observability-agent-hosted](https://github.com/seligj95/app-service-observability-agent-hosted)\n\nTo deploy the hosted version:\n\n``` git clone https://github.com/seligj95/app-service-observability-agent-hosted.git cd app-service-observability-agent-hosted azd up ```\n\nTo run the local version, see the [Getting Started section in Part 1](https://techcommunity.microsoft.com/blog/appsonazureblog/chat-with-your-app-service-logs-using-github-copilot/4491573).\n\n## What's Next?\n\nThis is still a proof-of-concept, and we're continuing to explore how AI-powered observability can become a first-class part of the App Service platform. Some things we're thinking about:\n\n- **More tools** — Resource health, autoscale history, certificate expiration, network diagnostics\n- **Multi-app investigations** — Correlate issues across multiple apps in a resource group\n- **Proactive monitoring** — Agents that watch your apps and alert you before users notice\n- **Deeper integration** — What if every App Service came with a built-in observability endpoint?\n\nWe'd love your feedback. Try it out, open an issue, or submit a PR if you have ideas for additional tools or debugging patterns. And if you build something interesting on top of these MCP tools — a Teams bot, a CLI agent, anything — we'd love to hear about it.\n\nUpdated Feb 09, 2026\n\nVersion 1.0\n\n[azure app service](/tag/azure%20app%20service?nodeId=board%3AAppsonAzureBlog)\n\n[best practices](/tag/best%20practices?nodeId=board%3AAppsonAzureBlog)\n\n[modern apps](/tag/modern%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[web apps](/tag/web%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[jordanselig&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0xMTg1ODUyLTQwNTU5Mmk4NTY0MjQ3RTE3NURDNzJC?image-dimensions=50x50)](/users/jordanselig/1185852) [jordanselig](/users/jordanselig/1185852) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined October 14, 2021\n\n[View Profile](/users/jordanselig/1185852)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity"
}
