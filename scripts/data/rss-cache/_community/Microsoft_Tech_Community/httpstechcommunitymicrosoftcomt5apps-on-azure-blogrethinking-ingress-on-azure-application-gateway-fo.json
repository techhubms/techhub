{
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "PubDate": "2026-02-23T10:49:29+00:00",
  "ProcessedDate": "2026-02-23 11:14:46",
  "Tags": [],
  "Author": "rgarofalo",
  "Title": "Rethinking Ingress on Azure: Application Gateway for Containers Explained",
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/rethinking-ingress-on-azure-application-gateway-for-containers/ba-p/4492277",
  "EnhancedContent": "## Azure Application Gateway for Containers is a modern Azure service that helps you expose containerized applications in a secure and scalable way. By moving ingress, routing, and web protection outside the Kubernetes cluster, it simplifies operations while keeping traffic management fully Azure-managed. This article walks through how the service works, what problems it solves, and when it’s the right choice for your container platforms.\n\n## Introduction\n\n[Azure Application Gateway for Containers](https://learn.microsoft.com/en-us/azure/application-gateway/for-containers/) is a managed Azure service designed to handle incoming traffic for container-based applications. It brings Layer-7 load balancing, routing, TLS termination, and web application protection outside of the Kubernetes cluster and into an Azure-managed data plane. By separating traffic management from the cluster itself, the service reduces operational complexity while providing a more consistent, secure, and scalable way to expose container workloads on Azure.\n\nImages and Visualizations All images and visualizations in this articles have been generated using GEN AI technologies.\n\n## Service Overview\n\n### What Application Gateway for Containers does\n\nOverview of Application Gateway for Containers\n\nAzure Application Gateway for Containers is a **managed Layer-7 load balancing and ingress service** built specifically for containerized workloads. Its main job is to receive incoming application traffic (HTTP/HTTPS), apply routing and security rules, and forward that traffic to the right backend containers running in your Kubernetes cluster.\n\nInstead of deploying and operating an ingress controller inside the cluster, Application Gateway for Containers runs **outside the cluster**, as an Azure-managed data plane. It integrates natively with Kubernetes through the **Gateway API** (and Ingress API), translating Kubernetes configuration into fully managed Azure networking behavior.\n\nIn practical terms, it handles:\n\n- HTTP/HTTPS routing based on hostnames, paths, headers, and methods\n- TLS termination and certificate management\n- Web Application Firewall (WAF) protection\n- Scaling and high availability of the ingress layer\n\nAll of this is provided as a managed Azure service, without running ingress pods in your cluster.\n\n### What problems it solves\n\nApplication Gateway for Containers addresses several common challenges teams face with traditional Kubernetes ingress setups:\n\n- **Operational overhead**Running ingress controllers inside the cluster means managing upgrades, scaling, certificates, and availability yourself. Moving ingress to a managed Azure service significantly reduces this burden.\n- **Security boundaries**By keeping traffic management and WAF outside the cluster, you reduce the attack surface of the Kubernetes environment and keep security controls aligned with Azure-native services.\n- **Consistency across environments**Platform teams can offer a standard, Azure-managed ingress layer that behaves the same way across clusters and environments, instead of relying on different in-cluster ingress configurations.\n- **Separation of responsibilities**Infrastructure teams manage the gateway and security policies, while application teams focus on Kubernetes resources like routes and services.\n\n### How it differs from classic Application Gateway\n\nWhile both services share the “Application Gateway” name, they target **different use cases and operating models**.\n\nIn the traditional model of using [Azure Application Gateway](https://learn.microsoft.com/en-us/azure/application-gateway/overview) is a general-purpose Layer-7 load balancer primarily designed for VM-based or service-based backends. It relies on centralized configuration through Azure resources and is not Kubernetes-native by design.\n\nApplication Gateway for Containers, on the other hand:\n\n- Is **designed specifically for container platforms**\n- Uses **Kubernetes APIs (Gateway API / Ingress)** instead of manual listener and rule configuration\n- Separates **control plane and data plane** more cleanly\n- Enables **faster, near real-time updates** driven by Kubernetes changes\n- Avoids running ingress components inside the cluster\n\nIn short, classic Application Gateway is infrastructure-first, while Application Gateway for Containers is **platform- and Kubernetes-first**.\n\n## Architecture at a Glance\n\nShared responsibility model of Azure Application Gateway for Containers\n\n> >\n> At a high level, Azure Application Gateway for Containers is built around a **clear separation between control plane and data plane**. This separation is one of the key architectural ideas behind the service and explains many of its benefits.\n> >\n\n### Control plane and data plane\n\nThe **control plane** is responsible for configuration and orchestration. It listens to Kubernetes resources—such as Gateway API or Ingress objects—and translates them into a running gateway configuration. When you create or update routing rules, TLS settings, or security policies in Kubernetes, the control plane picks up those changes and applies them automatically.\n\nThe **data plane** is where traffic actually flows. It handles incoming HTTP and HTTPS requests, applies routing rules, performs TLS termination, and forwards traffic to the correct backend services inside your cluster. This data plane is fully managed by Azure and runs outside of the Kubernetes cluster, providing isolation and high availability by design.\n\nBecause the data plane is not deployed as pods inside the cluster, it does not consume cluster resources and does not need to be scaled or upgraded by the customer.\n\n### Managed components vs customer responsibilities\n\nOne of the goals of Application Gateway for Containers is to **reduce what customers need to operate**, while still giving them control where it matters.\n\n**Managed by Azure**\n\n- Application Gateway for Containers data plane\n- Scaling, availability, and patching of the gateway\n- Integration with Azure networking\n- Web Application Firewall engine and updates\n- Translation of Kubernetes configuration into gateway rules\n\n**Customer-managed**\n\n- Kubernetes resources (Gateway API or Ingress)\n- Backend services and workloads\n- TLS certificates and references\n- Routing and security intent (hosts, paths, policies)\n- Network design and connectivity to the cluster\n\nThis split allows platform teams to keep ownership of the underlying Azure infrastructure, while application teams interact with the gateway using familiar Kubernetes APIs. The result is a cleaner operating model with fewer moving parts inside the cluster.\n\n> >\n> In short, Application Gateway for Containers acts as an **Azure-managed ingress layer**, driven by Kubernetes configuration but operated outside the cluster. This architecture keeps traffic management simple, scalable, and aligned with Azure-native networking and security services.\n> >\n\n## Traffic Handling and Routing\n\nThis section explains what happens to a request from the moment it reaches Azure until it is forwarded to a container running in your cluster.\n\nTraffic flow for Application Gateway for Containers\n\n### Traffic Flow: From Internet to Pod\n\nAzure Application Gateway for Containers (AGC) acts as the specialized \"front door\" for your Kubernetes workloads. By sitting outside the cluster, it manages high-volume traffic ingestion so your environment remains focused on application logic rather than networking overhead.\n\n#### The Request Journey\n\nOnce a request is initiated by a client—such as a browser or an API—it follows a streamlined path to your container:\n\n- **1. Entry via Public Frontend:** The request reaches AGC’s **public frontend**endpoint.\n- **Note:** While private frontends are currently the most requested feature and are under high-priority development, the service currently supports public-facing endpoints.\n- **2. Rule Evaluation:** AGC evaluates the incoming request against the routing rules you’ve defined using standard Kubernetes resources (Gateway API or Ingress).\n- **3. Direct Pod Proxying:** Once a rule is matched, AGC forwards the traffic **directly to the backend pods** within your cluster.\n- **4. Azure Native Delivery:** Because AGC operates as a managed data plane outside the cluster, traffic reaches your workloads via Azure networking. This removes the need for managing scaling or resource contention for in-cluster ingress pods.\n\n### Flexibility in Security and Routing\n\nThe architecture is designed to be as \"hands-off\" or as \"hands-on\" as your security policy requires:\n\n- **Optional TLS Offloading:** You have full control over the encryption lifecycle. Depending on your specific use case, you can choose to perform **TLS termination** at the gateway to offload the compute-intensive decryption, or maintain encryption all the way to the container for end-to-end security.\n- **Simplified Infrastructure:** By using AGC, you eliminate the \"hop\" typically required by in-cluster controllers, allowing the gateway to communicate with pods with minimal latency and high predictability.\n\n## Kubernetes Integration\n\nApplication Gateway for Containers is designed to integrate **natively with Kubernetes**, allowing teams to manage ingress behavior using familiar Kubernetes resources instead of Azure-specific configuration. This makes the service feel like a natural extension of the Kubernetes platform rather than an external load balancer.\n\nKubernetes integrations options\n\n### Gateway API as the primary integration model\n\nThe [Gateway API](https://learn.microsoft.com/en-us/azure/application-gateway/for-containers/api-specification-kubernetes) is the preferred and recommended way to integrate Application Gateway for Containers with Kubernetes.\n\nWith the Gateway API:\n\n- Platform teams define the **Gateway** and control how traffic enters the cluster.\n- Application teams define **routes** (such as HTTPRoute) to expose their services.\n- Responsibilities are clearly separated, supporting multi-team and multi-namespace environments.\n\nApplication Gateway for Containers supports core Gateway API resources such as:\n\n- GatewayClass\n- Gateway\n- HTTPRoute\n\nWhen these resources are created or updated, Application Gateway for Containers automatically translates them into gateway configuration and applies the changes in near real time.\n\n### Ingress API support\n\nFor teams that already use the traditional Kubernetes [Ingress API](https://learn.microsoft.com/en-us/azure/application-gateway/for-containers/how-to-end-to-end-tls-ingress-api?tabs=alb-managed), Application Gateway for Containers also provides Ingress support.\n\nThis allows:\n\n- Reuse of existing Ingress manifests\n- A smoother migration path from older ingress controllers\n- Gradual adoption of Gateway API over time\n\nIngress resources are associated with Application Gateway for Containers using a specific ingress class. While fully functional, the Ingress API offers fewer capabilities and less flexibility compared to the Gateway API.\n\n### How teams interact with the service\n\nA key benefit of this integration model is the **clean separation of responsibilities**:\n\n- **Platform teams**\n- Provision and manage Application Gateway for Containers\n- Define gateways, listeners, and security boundaries\n- Own network and security policies\n- **Application teams**\n- Define routes using Kubernetes APIs\n- Control how their applications are exposed\n- Do not need direct access to Azure networking resources\n\nThis approach enables self-service for application teams while keeping governance and security centralized.\n\n> >\n> **Why this matters**\n> > >\n> By integrating deeply with Kubernetes APIs, Application Gateway for Containers avoids custom controllers, sidecars, or ingress pods inside the cluster. Configuration stays declarative, changes are automated, and the operational model stays consistent with Kubernetes best practices.\n> >\n\n## Security Capabilities\n\nSecurity is a core part of Azure Application Gateway for Containers and one of the main reasons teams choose it over in-cluster ingress controllers. The service brings **Azure-native security controls** directly in front of your container workloads, without adding complexity inside the cluster.\n\n### Web Application Firewall (WAF)\n\nApplication Gateway for Containers integrates with [Azure Web Application Firewall (WAF)](https://azure.microsoft.com/en-us/products/web-application-firewall) to protect applications against common web attacks such as SQL injection, cross-site scripting, and other OWASP Top 10 threats.\n\nA key differentiator of this service is that it leverages [Microsoft's global threat intelligence](https://www.microsoft.com/en-us/security/business/siem-and-xdr/microsoft-defender-threat-intelligence). This provides an enterprise-grade layer of security that constantly evolves to block emerging threats, a significant advantage over many open-source or standard competitor WAF solutions.\n\nBecause the WAF operates within the **managed data plane**, it offers several operational benefits:\n\n- **Zero Cluster Footprint:** No WAF-specific pods or components are required to run inside your Kubernetes cluster, saving resources for your actual applications.\n- **Edge Protection:** Security rules and policies are applied at the Azure network edge, ensuring malicious traffic is blocked before it ever reaches your workloads.\n- **Automated Maintenance:** All rule updates, patching, and engine maintenance are handled entirely by Azure.\n- **Centralized Governance:** WAF policies can be managed centrally, ensuring consistent security enforcement across multiple teams and namespaces—a critical requirement for regulated environments.\n\nTLS and certificate handling\n\nTLS termination happens directly at the gateway. HTTPS traffic is decrypted at the edge, inspected, and then forwarded to backend services.\n\nKey points:\n\n- Certificates are referenced from Kubernetes configuration\n- TLS policies are enforced by the Azure-managed gateway\n- Applications receive plain HTTP traffic, keeping workloads simpler\n\nThis approach allows teams to standardize TLS behavior across clusters and environments, while avoiding certificate logic inside application pods.\n\n### Network isolation and exposure control\n\nBecause Application Gateway for Containers runs outside the cluster, it provides a **clear security boundary** between external traffic and Kubernetes workloads.\n\nCommon patterns include:\n\n- Internet-facing gateways with WAF protection\n- Private gateways for internal or zero-trust access\n- Controlled exposure of only selected services\n\nBy keeping traffic management and security at the gateway layer, clusters remain more isolated and easier to protect.\n\n> >\n> **Security by design**\n> > >\n> Overall, the security model follows a simple principle: **inspect, protect, and control traffic before it enters the cluster**.\n> > >\n> This reduces the attack surface of Kubernetes, centralizes security controls, and aligns container ingress with Azure’s broader security ecosystem.\n> >\n\n## Scale, Performance, and Limits\n\nAzure Application Gateway for Containers is built to handle **production-scale traffic** without requiring customers to manage capacity, scaling rules, or availability of the ingress layer. Scalability and performance are handled as part of the managed service.\n\nVarious aspects of the scaling capabilities\n\n## Interoperability: The Best of Both Worlds\n\nA common hesitation when adopting cloud-native networking is the fear of **vendor lock-in**. Many organizations worry that using a provider-specific ingress service will tie their application logic too closely to a single cloud’s proprietary configuration.\n\nAzure Application Gateway for Containers (AGC) addresses this directly by utilizing the **Kubernetes Gateway API** as its primary integration model. This creates a powerful decoupling between how you define your traffic and how that traffic is actually delivered.\n\n### Standardized API, Managed Execution\n\nBy adopting this model, you gain two critical advantages simultaneously:\n\n- **Zero Vendor Lock-In (Standardized API):** Your routing logic is defined using the open-source Kubernetes Gateway API standard. Because HTTPRoute and Gateway resources are community-driven standards, your configuration remains portable and familiar to any Kubernetes professional, regardless of the underlying infrastructure.\n- **Zero Operational Overhead (Managed Implementation):** While the *interface* is a standard Kubernetes API, the *implementation* is a high-performance Azure-managed service. You gain the benefits of an enterprise-grade load balancer—automatic scaling, high availability, and integrated security—without the burden of managing, patching, or troubleshooting proxy pods inside your cluster.\n\n### The \"Pragmatic\" Advantage\n\nAs highlighted in recent architectural discussions, moving from traditional Ingress to the Gateway API is about more than just new features; it’s about **interoperability**. It allows platform teams to offer a consistent, self-service experience to developers while retaining the ability to leverage the best-in-class performance and security that only a native cloud provider can offer.\n\nThe result is a future-proof architecture: your teams use the industry-standard language of Kubernetes to describe what they need, and Azure provides the managed muscle to make it happen.\n\n### Scaling model\n\nApplication Gateway for Containers uses an [automatic scaling model](https://learn.microsoft.com/en-us/azure/application-gateway/for-containers/scaling-zone-resiliency). The gateway data plane scales up or down based on incoming traffic patterns, without manual intervention.\n\nFrom an operator’s perspective:\n\n- There are no ingress pods to scale\n- No node capacity planning for ingress\n- No separate autoscaler to configure\n\nScaling is handled entirely by Azure, allowing teams to focus on application behavior rather than ingress infrastructure.\n\n### Performance characteristics\n\nBecause the data plane runs outside the Kubernetes cluster, ingress traffic does not compete with application workloads for CPU or memory. This often results in:\n\n- More predictable latency\n- Better isolation between traffic management and application execution\n- Consistent performance under load\n\nThe service supports common production requirements such as:\n\n- High concurrent connections\n- Low-latency HTTP and HTTPS traffic\n- Near real-time configuration updates driven by Kubernetes changes\n\n### Service limits and considerations\n\nLike any managed service, Application Gateway for Containers has [defined limits](https://learn.microsoft.com/en-us/azure/application-gateway/for-containers/understanding-pricing) that architects should be aware of when designing solutions. These include limits around:\n\n- Number of listeners and routes\n- Backend service associations\n- Certificates and TLS configurations\n- Throughput and connection scaling thresholds\n\nThese limits are documented and enforced by the platform to ensure stability and predictable behavior.\n\nFor most application platforms, these limits are well above typical usage. However, they should be reviewed early when designing large multi-tenant or high-traffic environments.\n\n> >\n> **Designing with scale in mind**\n> > >\n> The key takeaway is that Application Gateway for Containers removes ingress scaling from the cluster and turns it into an **Azure-managed concern**. This simplifies operations and provides a stable, high-performance entry point for container workloads.\n> >\n\n### When to Use (and When Not to Use)\n\n| **Scenario** | Use it? | **Why** | | --- | --- | --- | | **Kubernetes workloads on Azure** | ✅ Yes | The service is designed specifically for container platforms and integrates natively with Kubernetes APIs. | | **Need for managed Layer-7 ingress** | ✅ Yes | Routing, TLS, and scaling are handled by Azure without in-cluster components. | | **Enterprise security requirements (WAF, TLS policies)** | ✅ Yes | Built-in Azure WAF and centralized TLS enforcement simplify security. | | **Platform team managing ingress for multiple apps** | ✅ Yes | Clear separation between platform and application responsibilities. | | **Multi-tenant Kubernetes clusters** | ✅ Yes | Gateway API model supports clean ownership boundaries and isolation. | | **Desire to avoid running ingress controllers in the cluster** | ✅ Yes | No ingress pods, no cluster resource consumption. | | **VM-based or non-container backends** | ❌ No | Classic Application Gateway is a better fit for non-container workloads. | | **Simple, low-traffic test or dev environments** | ❌ Maybe not | A lightweight in-cluster ingress may be simpler and more cost-effective. | | **Need for custom or unsupported L7 features** | ❌ Maybe not | Some advanced or niche ingress features may not yet be available. | | **Non-Kubernetes platforms** | ❌ No | The service is tightly integrated with Kubernetes APIs. |\n\n## When to Choose a Different Path: Azure Container Apps\n\nWhile Application Gateway for Containers provides the ultimate control for Kubernetes environments, not every project requires that level of infrastructure management.\n\nFor teams that don't need the full flexibility of Kubernetes and are looking for the fastest path to running containers on Azure without managing clusters or ingress infrastructure at all, [Azure Container Apps](https://azure.microsoft.com/en-us/products/container-apps) offers a specialized alternative. It provides a fully managed, serverless container platform that handles scaling, ingress, and networking automatically \"out of the box\".\n\n### Key Differences at a Glance\n\n| Feature | AGC + Kubernetes | Azure Container Apps | | --- | --- | --- | | **Control** | Granular control over cluster and ingress. | Fully managed, serverless experience. | | **Management** | You manage the cluster; Azure manages the gateway. | Azure manages both the platform and ingress. | | **Best For** | Complex, multi-team, or highly regulated environments. | Rapid development and simplified operations. |\n\n## Appendix - Routing configuration examples\n\nThe following examples show how Application Gateway for Containers can be configured using both Gateway API and Ingress API for common routing and TLS scenarios. More examples can be found [here, in the detailed documentation](https://learn.microsoft.com/en-us/azure/application-gateway/for-containers/how-to-backend-mtls-gateway-api?tabs=alb-managed).\n\n#### HTTP listener\n\n``` apiVersion: gateway.networking.k8s.io/v1 kind: HTTPRoute metadata: name: app-route spec: parentRefs: - name: agc-gateway rules: - backendRefs: - name: app-service port: 80 ```\n\n#### Path routing logic\n\n``` apiVersion: gateway.networking.k8s.io/v1 kind: HTTPRoute metadata: name: path-routing spec: parentRefs: - name: agc-gateway rules: - matches: - path: type: PathPrefix value: /api backendRefs: - name: api-service port: 80 - backendRefs: - name: web-service port: 80 ```\n\n#### Weighted canary / rollout\n\n``` apiVersion: gateway.networking.k8s.io/v1 kind: HTTPRoute metadata: name: canary-route spec: parentRefs: - name: agc-gateway rules: - backendRefs: - name: app-v1 port: 80 weight: 80 - name: app-v2 port: 80 weight: 20 ```\n\n### TLS Termination\n\n``` apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: app-ingress spec: ingressClassName: azure-alb-external tls: - hosts: - app.contoso.com secretName: tls-cert rules: - host: app.contoso.com http: paths: - path: / pathType: Prefix backend: service: name: app-service port: number: 80 ```\n\n###\n\nUpdated Feb 23, 2026\n\nVersion 1.0\n\n[azure app service](/tag/azure%20app%20service?nodeId=board%3AAppsonAzureBlog)\n\n[azure container apps](/tag/azure%20container%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[azure container instances](/tag/azure%20container%20instances?nodeId=board%3AAppsonAzureBlog)\n\n[azure container registry](/tag/azure%20container%20registry?nodeId=board%3AAppsonAzureBlog)\n\n[azure kubernetes service](/tag/azure%20kubernetes%20service?nodeId=board%3AAppsonAzureBlog)\n\n[containers](/tag/containers?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[rgarofalo&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0zMzM5NTgzLVF2eGxJQQ?image-coordinates=160%2C0%2C1270%2C1109&amp;image-dimensions=50x50)](/users/rgarofalo/3339583) [rgarofalo](/users/rgarofalo/3339583) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined January 18, 2026\n\n[View Profile](/users/rgarofalo/3339583)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "Description": "## Introduction\n\n[Azure Application Gateway for Containers](https://learn.microsoft.com/en-us/azure/application-gateway/for-containers/) is a managed Azure service designed to handle incoming traffic for container-based applications. It brings Layer-7 load balancing, routing, TLS termination, and web application protection outside of the Kubernetes cluster and into an Azure-managed data plane. By separating traffic management from the cluster itself, the service reduces operational complexity while providing a more consistent, secure, and scalable way to expose container workloads on Azure.\n\n- All images and visualizations in this articles have been generated using GEN AI technologies.\n\n## Service Overview\n\n### What Application Gateway for Containers does\n\n![]()Overview of Application Gateway for Containers\n\nAzure Application Gateway for Containers is a **managed Layer-7 load balancing and ingress service** built specifically for containerized workloads. Its main job is to receive incoming application traffic (HTTP/HTTPS), apply routing and security rules, and forward that traffic to the right backend containers running in your Kubernetes cluster.\n\nInstead of deploying and operating an ingress controller inside the cluster, Application Gateway for Containers runs **outside the cluster**, as an Azure-managed data plane. It integrates natively with Kubernetes through the **Gateway API** (and Ingress API), translating Kubernetes configuration into fully managed Azure networking behavior.\n\nIn practical terms, it handles:\n\n- HTTP/HTTPS routing based on hostnames, paths, headers, and methods\n- TLS termination and certificate management\n- Web Application Firewall (WAF) protection\n- Scaling and high availability of the ingress layer\n\nAll of this is provided as a managed Azure service, without running ingress pods in your cluster.\n\n### What problems it solves\n\nApplication Gateway for Containers addresses several common challenges teams face with traditional Kubernetes ingress setups:\n\n- **Operational overhead**Running ingress controllers inside the cluster means managing upgrades, scaling, certificates, and availability yourself. Moving ingress to a managed Azure service significantly reduces this burden.\n- **Security boundaries**By keeping traffic management and WAF outside the cluster, you reduce the attack surface of the Kubernetes environment and keep security controls aligned with Azure-native services.\n- **Consistency across environments**Platform teams can offer a standard, Azure-managed ingress layer that behaves the same way across clusters and environments, instead of relying on different in-cluster ingress configurations.\n- **Separation of responsibilities**Infrastructure teams manage the gateway and security policies, while application teams focus on Kubernetes resources like routes and services.\n\n### How it differs from classic Application Gateway\n\nWhile both services share the “Application Gateway” name, they target **different use cases and operating models**.\n\nIn the traditional model of using [Azure Application Gateway](https://learn.microsoft.com/en-us/azure/application-gateway/overview) is a general-purpose Layer-7 load balancer primarily designed for VM-based or service-based backends. It relies on centralized configuration through Azure resources and is not Kubernetes-native by design.\n\nApplication Gateway for Containers, on the other hand:\n\n- Is **designed specifically for container platforms**\n- Uses **Kubernetes APIs (Gateway API / Ingress)** instead of manual listener and rule configuration\n- Separates **control plane and data plane** more cleanly\n- Enables **faster, near real-time updates** driven by Kubernetes changes\n- Avoids running ingress components inside the cluster\n\nIn short, classic Application Gateway is infrastructure-first, while Application Gateway for Containers is **platform- and Kubernetes-first**.\n\n## Architecture at a Glance\n\n![]()Shared responsibility model of Azure Application Gateway for Containers\n\n> >\n> At a high level, Azure Application Gateway for Containers is built around a **clear separation between control plane and data plane**. This separation is one of the key architectural ideas behind the service and explains many of its benefits.\n> >\n\n### Control plane and data plane\n\nThe **control plane** is responsible for configuration and orchestration. It listens to Kubernetes resources—such as Gateway API or Ingress objects—and translates them into a running gateway configuration. When you create or update routing rules, TLS settings, or security policies in Kubernetes, the control plane picks up those changes and applies them automatically.\n\nThe **data plane** is where traffic actually flows. It handles incoming HTTP and HTTPS requests, applies routing rules, performs TLS termination, and forwards traffic to the correct backend services inside your cluster. This data plane is fully managed by Azure and runs outside of the Kubernetes cluster, providing isolation and high availability by design.\n\nBecause the data plane is not deployed as pods inside the cluster, it does not consume cluster resources and does not need to be scaled or upgraded by the customer.\n\n### Managed components vs customer responsibilities\n\nOne of the goals of Application Gateway for Containers is to **reduce what customers need to operate**, while still giving them control where it matters.\n\n**Managed by Azure**\n\n- Application Gateway for Containers data plane\n- Scaling, availability, and patching of the gateway\n- Integration with Azure networking\n- Web Application Firewall engine and updates\n- Translation of Kubernetes configuration into gateway rules\n\n**Customer-managed**\n\n- Kubernetes resources (Gateway API or Ingress)\n- Backend services and workloads\n- TLS certificates and references\n- Routing and security intent (hosts, paths, policies)\n- Network design and connectivity to the cluster\n\nThis split allows platform teams to keep ownership of the underlying Azure infrastructure, while application teams interact with the gateway using familiar Kubernetes APIs. The result is a cleaner operating model with fewer moving parts inside the cluster.\n\n> >\n> In short, Application Gateway for Containers acts as an **Azure-managed ingress layer**, driven by Kubernetes configuration but operated outside the cluster. This architecture keeps traffic management simple, scalable, and aligned with Azure-native networking and security services.\n> >\n\n## Traffic Handling and Routing\n\nThis section explains what happens to a request from the moment it reaches Azure until it is forwarded to a container running in your cluster.\n\n![]()Traffic flow for Application Gateway for Containers\n\n### Traffic Flow: From Internet to Pod\n\nAzure Application Gateway for Containers (AGC) acts as the specialized \"front door\" for your Kubernetes workloads. By sitting outside the cluster, it manages high-volume traffic ingestion so your environment remains focused on application logic rather than networking overhead.\n\n#### The Request Journey\n\nOnce a request is initiated by a client—such as a browser or an API—it follows a streamlined path to your container:\n\n- **1. Entry via Public Frontend:** The request reaches AGC’s **public frontend**endpoint.\n- **Note:** While private frontends are currently the most requested feature and are under high-priority development, the service currently supports public-facing endpoints.\n- **2. Rule Evaluation:** AGC evaluates the incoming request against the routing rules you’ve defined using standard Kubernetes resources (Gateway API or Ingress).\n- **3. Direct Pod Proxying:** Once a rule is matched, AGC forwards the traffic **directly to the backend pods** within your cluster.\n- **4. Azure Native Delivery:** Because AGC operates as a managed data plane outside the cluster, traffic reaches your workloads via Azure networking. This removes the need for managing scaling or resource contention for in-cluster ingress pods.\n\n### Flexibility in Security and Routing\n\nThe architecture is designed to be as \"hands-off\" or as \"hands-on\" as your security policy requires:\n\n- **Optional TLS Offloading:** You have full control over the encryption lifecycle. Depending on your specific use case, you can choose to perform **TLS termination** at the gateway to offload the compute-intensive decryption, or maintain encryption all the way to the container for end-to-end security.\n- **Simplified Infrastructure:** By using AGC, you eliminate the \"hop\" typically required by in-cluster controllers, allowing the gateway to communicate with pods with minimal latency and high predictability.\n\n## Kubernetes Integration\n\nApplication Gateway for Containers is designed to integrate **natively with Kubernetes**, allowing teams to manage ingress behavior using familiar Kubernetes resources instead of Azure-specific configuration. This makes the service feel like a natural extension of the Kubernetes platform rather than an external load balancer.\n\n![]()Kubernetes integrations options\n\n### Gateway API as the primary integration model\n\nThe [Gateway API](https://learn.microsoft.com/en-us/azure/application-gateway/for-containers/api-specification-kubernetes) is the preferred and recommended way to integrate Application Gateway for Containers with Kubernetes.\n\nWith the Gateway API:\n\n- Platform teams define the **Gateway** and control how traffic enters the cluster.\n- Application teams define **routes** (such as HTTPRoute) to expose their services.\n- Responsibilities are clearly separated, supporting multi-team and multi-namespace environments.\n\nApplication Gateway for Containers supports core Gateway API resources such as:\n\n- GatewayClass\n- Gateway\n- HTTPRoute\n\nWhen these resources are created or updated, Application Gateway for Containers automatically translates them into gateway configuration and applies the changes in near real time.\n\n### Ingress API support\n\nFor teams that already use the traditional Kubernetes [Ingress API](https://learn.microsoft.com/en-us/azure/application-gateway/for-containers/how-to-end-to-end-tls-ingress-api?tabs=alb-managed), Application Gateway for Containers also provides Ingress support.\n\nThis allows:\n\n- Reuse of existing Ingress manifests\n- A smoother migration path from older ingress controllers\n- Gradual adoption of Gateway API over time\n\nIngress resources are associated with Application Gateway for Containers using a specific ingress class. While fully functional, the Ingress API offers fewer capabilities and less flexibility compared to the Gateway API.\n\n### How teams interact with the service\n\nA key benefit of this integration model is the **clean separation of responsibilities**:\n\n- **Platform teams**\n- Provision and manage Application Gateway for Containers\n- Define gateways, listeners, and security boundaries\n- Own network and security policies\n- **Application teams**\n- Define routes using Kubernetes APIs\n- Control how their applications are exposed\n- Do not need direct access to Azure networking resources\n\nThis approach enables self-service for application teams while keeping governance and security centralized.\n\n> >\n> **Why this matters**\n> > >\n> By integrating deeply with Kubernetes APIs, Application Gateway for Containers avoids custom controllers, sidecars, or ingress pods inside the cluster. Configuration stays declarative, changes are automated, and the operational model stays consistent with Kubernetes best practices.\n> >\n\n## Security Capabilities\n\nSecurity is a core part of Azure Application Gateway for Containers and one of the main reasons teams choose it over in-cluster ingress controllers. The service brings **Azure-native security controls** directly in front of your container workloads, without adding complexity inside the cluster.\n\n### Web Application Firewall (WAF)\n\nApplication Gateway for Containers integrates with [Azure Web Application Firewall (WAF)](https://azure.microsoft.com/en-us/products/web-application-firewall) to protect applications against common web attacks such as SQL injection, cross-site scripting, and other OWASP Top 10 threats.\n\nA key differentiator of this service is that it leverages [Microsoft's global threat intelligence](https://www.microsoft.com/en-us/security/business/siem-and-xdr/microsoft-defender-threat-intelligence). This provides an enterprise-grade layer of security that constantly evolves to block emerging threats, a significant advantage over many open-source or standard competitor WAF solutions.\n\nBecause the WAF operates within the **managed data plane**, it offers several operational benefits:\n\n- **Zero Cluster Footprint:** No WAF-specific pods or components are required to run inside your Kubernetes cluster, saving resources for your actual applications.\n- **Edge Protection:** Security rules and policies are applied at the Azure network edge, ensuring malicious traffic is blocked before it ever reaches your workloads.\n- **Automated Maintenance:** All rule updates, patching, and engine maintenance are handled entirely by Azure.\n- **Centralized Governance:** WAF policies can be managed centrally, ensuring consistent security enforcement across multiple teams and namespaces—a critical requirement for regulated environments.\n\nTLS and certificate handling\n\nTLS termination happens directly at the gateway. HTTPS traffic is decrypted at the edge, inspected, and then forwarded to backend services.\n\nKey points:\n\n- Certificates are referenced from Kubernetes configuration\n- TLS policies are enforced by the Azure-managed gateway\n- Applications receive plain HTTP traffic, keeping workloads simpler\n\nThis approach allows teams to standardize TLS behavior across clusters and environments, while avoiding certificate logic inside application pods.\n\n### Network isolation and exposure control\n\nBecause Application Gateway for Containers runs outside the cluster, it provides a **clear security boundary** between external traffic and Kubernetes workloads.\n\nCommon patterns include:\n\n- Internet-facing gateways with WAF protection\n- Private gateways for internal or zero-trust access\n- Controlled exposure of only selected services\n\nBy keeping traffic management and security at the gateway layer, clusters remain more isolated and easier to protect.\n\n> >\n> **Security by design**\n> > >\n> Overall, the security model follows a simple principle: **inspect, protect, and control traffic before it enters the cluster**.\n> > >\n> This reduces the attack surface of Kubernetes, centralizes security controls, and aligns container ingress with Azure’s broader security ecosystem.\n> >\n\n## Scale, Performance, and Limits\n\nAzure Application Gateway for Containers is built to handle **production-scale traffic** without requiring customers to manage capacity, scaling rules, or availability of the ingress layer. Scalability and performance are handled as part of the managed service.\n\n![]()Various aspects of the scaling capabilities\n\n## Interoperability: The Best of Both Worlds\n\nA common hesitation when adopting cloud-native networking is the fear of **vendor lock-in**. Many organizations worry that using a provider-specific ingress service will tie their application logic too closely to a single cloud’s proprietary configuration.\n\nAzure Application Gateway for Containers (AGC) addresses this directly by utilizing the **Kubernetes Gateway API** as its primary integration model. This creates a powerful decoupling between how you define your traffic and how that traffic is actually delivered.\n\n### Standardized API, Managed Execution\n\nBy adopting this model, you gain two critical advantages simultaneously:\n\n- **Zero Vendor Lock-In (Standardized API):** Your routing logic is defined using the open-source Kubernetes Gateway API standard. Because HTTPRoute and Gateway resources are community-driven standards, your configuration remains portable and familiar to any Kubernetes professional, regardless of the underlying infrastructure.\n- **Zero Operational Overhead (Managed Implementation):** While the *interface* is a standard Kubernetes API, the *implementation* is a high-performance Azure-managed service. You gain the benefits of an enterprise-grade load balancer—automatic scaling, high availability, and integrated security—without the burden of managing, patching, or troubleshooting proxy pods inside your cluster.\n\n### The \"Pragmatic\" Advantage\n\nAs highlighted in recent architectural discussions, moving from traditional Ingress to the Gateway API is about more than just new features; it’s about **interoperability**. It allows platform teams to offer a consistent, self-service experience to developers while retaining the ability to leverage the best-in-class performance and security that only a native cloud provider can offer.\n\nThe result is a future-proof architecture: your teams use the industry-standard language of Kubernetes to describe what they need, and Azure provides the managed muscle to make it happen.\n\n### Scaling model\n\nApplication Gateway for Containers uses an [automatic scaling model](https://learn.microsoft.com/en-us/azure/application-gateway/for-containers/scaling-zone-resiliency). The gateway data plane scales up or down based on incoming traffic patterns, without manual intervention.\n\nFrom an operator’s perspective:\n\n- There are no ingress pods to scale\n- No node capacity planning for ingress\n- No separate autoscaler to configure\n\nScaling is handled entirely by Azure, allowing teams to focus on application behavior rather than ingress infrastructure.\n\n### Performance characteristics\n\nBecause the data plane runs outside the Kubernetes cluster, ingress traffic does not compete with application workloads for CPU or memory. This often results in:\n\n- More predictable latency\n- Better isolation between traffic management and application execution\n- Consistent performance under load\n\nThe service supports common production requirements such as:\n\n- High concurrent connections\n- Low-latency HTTP and HTTPS traffic\n- Near real-time configuration updates driven by Kubernetes changes\n\n### Service limits and considerations\n\nLike any managed service, Application Gateway for Containers has [defined limits](https://learn.microsoft.com/en-us/azure/application-gateway/for-containers/understanding-pricing) that architects should be aware of when designing solutions. These include limits around:\n\n- Number of listeners and routes\n- Backend service associations\n- Certificates and TLS configurations\n- Throughput and connection scaling thresholds\n\nThese limits are documented and enforced by the platform to ensure stability and predictable behavior.\n\nFor most application platforms, these limits are well above typical usage. However, they should be reviewed early when designing large multi-tenant or high-traffic environments.\n\n> >\n> **Designing with scale in mind**\n> > >\n> The key takeaway is that Application Gateway for Containers removes ingress scaling from the cluster and turns it into an **Azure-managed concern**. This simplifies operations and provides a stable, high-performance entry point for container workloads.\n> >\n\n### When to Use (and When Not to Use)\n\n| **Scenario** | Use it? | **Why** | | --- | --- | --- | | **Kubernetes workloads on Azure** | ✅ Yes | The service is designed specifically for container platforms and integrates natively with Kubernetes APIs. | | **Need for managed Layer-7 ingress** | ✅ Yes | Routing, TLS, and scaling are handled by Azure without in-cluster components. | | **Enterprise security requirements (WAF, TLS policies)** | ✅ Yes | Built-in Azure WAF and centralized TLS enforcement simplify security. | | **Platform team managing ingress for multiple apps** | ✅ Yes | Clear separation between platform and application responsibilities. | | **Multi-tenant Kubernetes clusters** | ✅ Yes | Gateway API model supports clean ownership boundaries and isolation. | | **Desire to avoid running ingress controllers in the cluster** | ✅ Yes | No ingress pods, no cluster resource consumption. | | **VM-based or non-container backends** | ❌ No | Classic Application Gateway is a better fit for non-container workloads. | | **Simple, low-traffic test or dev environments** | ❌ Maybe not | A lightweight in-cluster ingress may be simpler and more cost-effective. | | **Need for custom or unsupported L7 features** | ❌ Maybe not | Some advanced or niche ingress features may not yet be available. | | **Non-Kubernetes platforms** | ❌ No | The service is tightly integrated with Kubernetes APIs. |\n\n## When to Choose a Different Path: Azure Container Apps\n\nWhile Application Gateway for Containers provides the ultimate control for Kubernetes environments, not every project requires that level of infrastructure management.\n\nFor teams that don't need the full flexibility of Kubernetes and are looking for the fastest path to running containers on Azure without managing clusters or ingress infrastructure at all, [Azure Container Apps](https://azure.microsoft.com/en-us/products/container-apps) offers a specialized alternative. It provides a fully managed, serverless container platform that handles scaling, ingress, and networking automatically \"out of the box\".\n\n### Key Differences at a Glance\n\n| Feature | AGC + Kubernetes | Azure Container Apps | | --- | --- | --- | | **Control** | Granular control over cluster and ingress. | Fully managed, serverless experience. | | **Management** | You manage the cluster; Azure manages the gateway. | Azure manages both the platform and ingress. | | **Best For** | Complex, multi-team, or highly regulated environments. | Rapid development and simplified operations. |\n\n## Appendix - Routing configuration examples\n\nThe following examples show how Application Gateway for Containers can be configured using both Gateway API and Ingress API for common routing and TLS scenarios. More examples can be found [here, in the detailed documentation](https://learn.microsoft.com/en-us/azure/application-gateway/for-containers/how-to-backend-mtls-gateway-api?tabs=alb-managed).\n\n#### HTTP listener\n- apiVersion: gateway.networking.k8s.io/v1 kind: HTTPRoute metadata: name: app-route spec: parentRefs: - name: agc-gateway rules: - backendRefs: - name: app-service port: 80\n\n#### Path routing logic\n- apiVersion: gateway.networking.k8s.io/v1 kind: HTTPRoute metadata: name: path-routing spec: parentRefs: - name: agc-gateway rules: - matches: - path: type: PathPrefix value: /api backendRefs: - name: api-service port: 80 - backendRefs: - name: web-service port: 80\n\n#### Weighted canary / rollout\n- apiVersion: gateway.networking.k8s.io/v1 kind: HTTPRoute metadata: name: canary-route spec: parentRefs: - name: agc-gateway rules: - backendRefs: - name: app-v1 port: 80 weight: 80 - name: app-v2 port: 80 weight: 20\n\n### TLS Termination\n- apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: app-ingress spec: ingressClassName: azure-alb-external tls: - hosts: - app.contoso.com secretName: tls-cert rules: - host: app.contoso.com http: paths: - path: / pathType: Prefix backend: service: name: app-service port: number: 80\n\n###",
  "FeedName": "Microsoft Tech Community",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "OutputDir": "_community"
}
