{
  "Author": "Lee_Stott",
  "Title": "Building a Smart Building HVAC Digital Twin with AI Copilot Using Foundry Local",
  "FeedName": "Microsoft Tech Community",
  "PubDate": "2026-02-17T08:00:00+00:00",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Description": "## Introduction\n\nBuilding operations teams face a constant challenge: optimizing HVAC systems for energy efficiency while maintaining occupant comfort and air quality. Traditional building management systems display raw sensor data, temperatures, pressures, CO₂ levels—but translating this into actionable insights requires deep HVAC expertise. What if operators could simply ask \"Why is the third floor so warm?\" and get an intelligent answer grounded in real building state?\n\nThis article demonstrates building a sample smart building digital twin with an AI-powered operations copilot, implemented using [DigitalTwin](https://github.com/leestott/DigitalTwin), React, Three.js, and Microsoft Foundry Local. You'll learn how to architect physics-based simulators that model thermal dynamics, implement 3D visualizations of building systems, integrate natural language AI control, and design fault injection systems for testing and training.\n\nWhether you're building IoT platforms for commercial real estate, designing energy management systems, or implementing predictive maintenance for building automation, this sample provides proven patterns for intelligent facility operations.\n\n## Why Digital Twins Matter for Building Operations\n\nPhysical buildings generate enormous operational data but lack intelligent interpretation layers. A 50,000 square foot office building might have 500+ sensors streaming metrics every minute, zone temperatures, humidity levels, equipment runtimes, energy consumption. Traditional BMS (Building Management Systems) visualize this data as charts and gauges, but operators must manually correlate patterns, diagnose issues, and predict failures.\n\nDigital twins solve this through physics-based simulation coupled with AI interpretation. Instead of just displaying current temperature readings, a digital twin models thermal dynamics, heat transfer rates, HVAC response characteristics, occupancy impacts. When conditions deviate from expectations, the twin compares observed versus predicted states, identifying root causes. Layer AI on top, and operators get natural language explanations: \"The conference room is 3 degrees too warm because the VAV damper is stuck at 40% open, reducing airflow by 60%.\"\n\nThis application focuses on HVAC, the largest building energy consumer, typically 40-50% of total usage. Optimizing HVAC by just 10% through better controls can save thousands of dollars monthly while improving occupant satisfaction. The digital twin enables \"what-if\" scenarios before making changes: \"What happens to energy consumption and comfort if we raise the cooling setpoint by 2 degrees during peak demand response events?\"\n\n## Architecture: Three-Tier Digital Twin System\n\nThe application implements a clean three-tier architecture separating visualization, simulation, and state management:\n\nThe frontend uses React with Three.js for 3D visualization. Users see an interactive 3D model of the three-floor building with color-coded zones indicating temperature and CO₂ levels. Click any equipment, AHUs, VAVs, chillers, to see detailed telemetry. The control panel enables adjusting setpoints, running simulation steps, and activating demand response scenarios. Real-time charts display KPIs: energy consumption, comfort compliance, air quality levels.\n\nThe backend Node.js/Express server orchestrates simulation and state management. It maintains the digital twin state as JSON, the single source of truth for all equipment, zones, and telemetry. REST API endpoints handle control requests, simulation steps, and AI copilot queries. WebSocket connections push real-time updates to the frontend for live monitoring. The HVAC simulator implements physics-based models: 1R1C thermal models for zones, affinity laws for fan power, chiller COP calculations, CO₂ mass balance equations.\n\n[Foundry Local](https://foundrylocal.ai) provides AI copilot capabilities. The backend uses foundry-local-sdk to query locally running models. Natural language queries (\"How's the lobby temperature?\") get answered with building state context. The copilot can explain anomalies, suggest optimizations, and even execute commands when explicitly requested.\n\n## Implementing Physics-Based HVAC Simulation\n\nAccurate simulation requires modeling actual HVAC physics. The simulator implements several established building energy models:\n\n``` // backend/src/simulator/thermal-model.js\n\nclass ZoneThermalModel { // 1R1C (one resistance, one capacitance) thermal model static calculateTemperatureChange(zone, delta_t_seconds) { const C_thermal = zone.volume * 1.2 * 1000; // Heat capacity (J/K) const R_thermal = zone.r_value * zone.envelope_area; // Thermal resistance\n\n// Internal heat gains (occupancy, equipment, lighting) const Q_internal = zone.occupancy * 100 + // 100W per person zone.equipment_load + zone.lighting_load;\n\n// Cooling/heating from HVAC const airflow_kg_s = zone.vav.airflow_cfm * 0.0004719; // CFM to kg/s const c_p_air = 1006; // Specific heat of air (J/kg·K) const Q_hvac = airflow_kg_s * c_p_air * (zone.vav.supply_temp - zone.temperature);\n\n// Envelope losses const Q_envelope = (zone.outdoor_temp - zone.temperature) / R_thermal;\n\n// Net energy balance const Q_net = Q_internal + Q_hvac + Q_envelope;\n\n// Temperature change: Q = C * dT/dt const dT = (Q_net / C_thermal) * delta_t_seconds;\n\nreturn zone.temperature + dT; } } ```\n\nThis model captures essential thermal dynamics while remaining computationally fast enough for real-time simulation. It accounts for internal heat generation from occupants and equipment, HVAC cooling/heating contributions, and heat loss through the building envelope.\n\nThe CO₂ model uses mass balance equations:\n\n``` class AirQualityModel { static calculateCO2Change(zone, delta_t_seconds) { // CO₂ generation from occupants const G_co2 = zone.occupancy * 0.0052; // L/s per person at rest\n\n// Outdoor air ventilation rate const V_oa = zone.vav.outdoor_air_cfm * 0.000471947; // CFM to m³/s\n\n// CO₂ concentration difference (indoor - outdoor) const delta_CO2 = zone.co2_ppm - 400; // Outdoor ~400ppm\n\n// Mass balance: dC/dt = (G - V*ΔC) / Volume const dCO2_dt = (G_co2 - V_oa * delta_CO2) / zone.volume;\n\nreturn zone.co2_ppm + (dCO2_dt * delta_t_seconds); } } ```\n\nThese models execute every simulation step, updating the entire building state:\n\n``` async function simulateStep(twin, timestep_minutes) { const delta_t = timestep_minutes * 60; // Convert to seconds\n\n// Update each zone for (const zone of twin.zones) { zone.temperature = ZoneThermalModel.calculateTemperatureChange(zone, delta_t); zone.co2_ppm = AirQualityModel.calculateCO2Change(zone, delta_t); }\n\n// Update equipment based on zone demands for (const vav of twin.vavs) { updateVAVOperation(vav, twin.zones); }\n\nfor (const ahu of twin.ahus) { updateAHUOperation(ahu, twin.vavs); }\n\nupdateChillerOperation(twin.chiller, twin.ahus); updateBoilerOperation(twin.boiler, twin.ahus);\n\n// Calculate system KPIs twin.kpis = calculateSystemKPIs(twin);\n\n// Detect alerts twin.alerts = detectAnomalies(twin);\n\n// Persist updated state await saveTwinState(twin);\n\nreturn twin; } ```\n\n## 3D Visualization with React and Three.js\n\nThe frontend renders an interactive 3D building view that updates in real-time as conditions change. Using React Three Fiber simplifies Three.js integration with React's component model:\n\n``` // frontend/src/components/BuildingView3D.jsx import { Canvas } from '@react-three/fiber'; import { OrbitControls } from '@react-three/drei';\n\nexport function BuildingView3D({ twinState }) { return (\n\n{/* Render building floors */} {twinState.zones.map(zone => ( selectZone(zone.id)} /> ))}\n\n{/* Render equipment */} {twinState.ahus.map(ahu => (\n\n))}\n\n); }\n\nfunction ZoneMesh({ zone, onClick }) { const color = getTemperatureColor(zone.temperature, zone.setpoint);\n\nreturn (\n\n); }\n\nfunction getTemperatureColor(current, setpoint) { const deviation = current - setpoint; if (Math.abs(deviation) This visualization immediately shows building state at a glance, operators see \"hot spots\" in red, comfortable zones in green, and can click any area for detailed metrics.\n\nIntegrating AI Copilot for Natural Language Control\n\nThe AI copilot transforms building data into conversational insights. Instead of navigating multiple screens, operators simply ask questions:\n\n// backend/src/routes/copilot.js import { FoundryLocalClient } from 'foundry-local-sdk';\n\nconst foundry = new FoundryLocalClient({ endpoint: process.env.FOUNDRY_LOCAL_ENDPOINT });\n\nrouter.post('/api/copilot/chat', async (req, res) => { const { message } = req.body;\n\n// Load current building state const twin = await loadTwinState();\n\n// Build context for AI const context = buildBuildingContext(twin);\n\nconst completion = await foundry.chat.completions.create({ model: 'phi-4', messages: [ { role: 'system', content: `You are an HVAC operations assistant for a 3-floor office building.\n\nCurrent Building State: ${context}\n\nAnswer questions about equipment status, comfort conditions, and energy usage. Provide specific, actionable information based on the current data. Do not speculate beyond provided information.` }, { role: 'user', content: message } ], temperature: 0.3, max_tokens: 300 });\n\nres.json({ response: completion.choices[0].message.content, model: 'phi-4', timestamp: new Date().toISOString() }); });\n\nfunction buildBuildingContext(twin) { const alerts = twin.alerts.filter(a => a.active); const zoneStatus = twin.zones.map(z => `${z.name}: ${z.temperature.toFixed(1)}°F (setpoint: ${z.setpoint}°F), CO₂: ${z.co2_ppm}ppm, ${z.occupancy} people` );\n\nreturn ` Zones: ${zoneStatus.join('\\n')}\n\nActive Alerts: ${alerts.length} ${alerts.map(a => `- ${a.severity}: ${a.message}`).join('\\n')}\n\nEnergy: ${twin.kpis.total_power_kw.toFixed(1)} kW Chiller: ${twin.chiller.percent_load}% load, ${twin.chiller.cop.toFixed(2)} COP `.trim(); }\n\nExample interactions:\n\nUser: \"Why is the third floor conference room warm?\"\n\nAI: \"The Executive Suite on Floor 3 is currently 75.2°F, 3 degrees above the 72°F setpoint. This is due to high occupancy (8 people) and VAV-F3-EXEC operating at reduced airflow (285 CFM vs 450 CFM capacity). AHU-2 is supplying adequate cool air at 55°F. Recommend checking VAV damper position—it may be partially stuck.\"\n\nUser: \"What's our current energy usage?\"\n\nAI: \"Total building power consumption is 47.3 kW. Breakdown: Chiller (24.1 kW, 51%), AHU fans (12.8 kW, 27%), Pumps (7.2 kW, 15%), Other (3.2 kW, 7%). Chiller is operating at 62% load with a COP of 4.8, which is efficient for current conditions.\"\n\nUser: \"Activate demand response level 2\"\n\nAI: \"I cannot directly control building systems for safety reasons. To activate DR Level 2, use the Control Panel and click 'Demand Response' → 'Level 2'. This will raise cooling setpoints by 3°F and reduce auxiliary loads, targeting 15% energy reduction.\"\n\nThe AI provides grounded, specific answers citing actual equipment IDs and metrics. It refuses to directly execute control commands, instead guiding operators to explicit control interfaces, a critical safety pattern for building systems.\n\nFault Injection for Testing and Training\n\nReal building operations experience equipment failures, stuck dampers, sensor drift, communication losses. The digital twin includes comprehensive fault injection capabilities to train operators and test control logic:\n\n// backend/src/simulator/fault-injector.js\n\nconst FAULT_CATALOG = { chillerFailure: { description: 'Chiller compressor failure', apply: (twin) => { twin.chiller.status = 'FAULT'; twin.chiller.cooling_output = 0; twin.alerts.push({ id: 'chiller-fault', severity: 'CRITICAL', message: 'Chiller compressor failure - no cooling available', equipment: 'CHILLER-01' }); } },\n\nstuckVAVDamper: { description: 'VAV damper stuck at current position', apply: (twin, vavId) => { const vav = twin.vavs.find(v => v.id === vavId); vav.damper_stuck = true; vav.damper_position_fixed = vav.damper_position; twin.alerts.push({ id: `vav-stuck-${vavId}`, severity: 'HIGH', message: `VAV ${vavId} damper stuck at ${vav.damper_position}%`, equipment: vavId }); } },\n\nsensorDrift: { description: 'Temperature sensor reading 5°F high', apply: (twin, zoneId) => { const zone = twin.zones.find(z => z.id === zoneId); zone.sensor_drift = 5.0; zone.temperature_measured = zone.temperature_actual + 5.0; } },\n\ncommunicationLoss: { description: 'Equipment communication timeout', apply: (twin, equipmentId) => { const equipment = findEquipmentById(twin, equipmentId); equipment.comm_status = 'OFFLINE'; equipment.stale_data = true; twin.alerts.push({ id: `comm-loss-${equipmentId}`, severity: 'MEDIUM', message: `Lost communication with ${equipmentId}`, equipment: equipmentId }); } } };\n\nrouter.post('/api/twin/fault', async (req, res) => { const { faultType, targetEquipment } = req.body;\n\nconst twin = await loadTwinState(); const fault = FAULT_CATALOG[faultType];\n\nif (!fault) { return res.status(400).json({ error: 'Unknown fault type' }); }\n\nfault.apply(twin, targetEquipment); await saveTwinState(twin);\n\nres.json({ message: `Applied fault: ${fault.description}`, affectedEquipment: targetEquipment, timestamp: new Date().toISOString() }); });\n\nOperators can inject faults to practice diagnosis and response. Training scenarios might include: \"The chiller just failed during a heat wave, how do you maintain comfort?\" or \"Multiple VAV dampers are stuck, which zones need immediate attention?\"\n\nKey Takeaways and Production Deployment\n\nBuilding a physics-based digital twin with AI capabilities requires balancing simulation accuracy with computational performance, providing intuitive visualization while maintaining technical depth, and enabling AI assistance without compromising safety.\n\nKey architectural lessons:\n\nPhysics models enable prediction: Comparing predicted vs observed behavior identifies anomalies that simple thresholds miss\n\n3D visualization improves spatial understanding: Operators immediately see which floors or zones need attention\n\nAI copilots accelerate diagnosis: Natural language queries get answers in seconds vs. minutes of manual data examination\n\nFault injection validates readiness: Testing failure scenarios prepares operators for real incidents\n\nJSON state enables integration: Simple file-based state makes connecting to real BMS systems straightforward\n\nFor production deployment, connect the twin to actual building systems via BACnet, Modbus, or MQTT integrations. Replace simulated telemetry with real sensor streams. Calibrate model parameters against historical building performance. Implement continuous learning where the twin's predictions improve as it observes actual building behavior.\n\nThe complete implementation with simulation engine, 3D visualization, AI copilot, and fault injection system is available at github.com/leestott/DigitalTwin. Clone the repository and run the startup scripts to explore the digital twin, no building hardware required.\n\nResources and Further Reading\n\nSmart Building HVAC Digital Twin Repository - Complete source code and simulation engine\n\nSetup and Quick Start Guide - Installation instructions and usage examples\n\nMicrosoft Foundry Local Documentation - AI integration reference\n\nHVAC Simulation Documentation - Physics model details and calibration\n\nThree.js Documentation - 3D visualization framework\n\nASHRAE Standards - Building energy modeling standards\n\n```",
  "Tags": [],
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "ProcessedDate": "2026-02-17 08:11:33",
  "OutputDir": "_community",
  "Link": "https://techcommunity.microsoft.com/t5/microsoft-developer-community/building-a-smart-building-hvac-digital-twin-with-ai-copilot/ba-p/4490784",
  "EnhancedContent": "## Introduction\n\nBuilding operations teams face a constant challenge: optimizing HVAC systems for energy efficiency while maintaining occupant comfort and air quality. Traditional building management systems display raw sensor data, temperatures, pressures, CO₂ levels—but translating this into actionable insights requires deep HVAC expertise. What if operators could simply ask \"Why is the third floor so warm?\" and get an intelligent answer grounded in real building state?\n\nThis article demonstrates building a sample smart building digital twin with an AI-powered operations copilot, implemented using [DigitalTwin](https://github.com/leestott/DigitalTwin), React, Three.js, and Microsoft Foundry Local. You'll learn how to architect physics-based simulators that model thermal dynamics, implement 3D visualizations of building systems, integrate natural language AI control, and design fault injection systems for testing and training.\n\nWhether you're building IoT platforms for commercial real estate, designing energy management systems, or implementing predictive maintenance for building automation, this sample provides proven patterns for intelligent facility operations.\n\n## Why Digital Twins Matter for Building Operations\n\nPhysical buildings generate enormous operational data but lack intelligent interpretation layers. A 50,000 square foot office building might have 500+ sensors streaming metrics every minute, zone temperatures, humidity levels, equipment runtimes, energy consumption. Traditional BMS (Building Management Systems) visualize this data as charts and gauges, but operators must manually correlate patterns, diagnose issues, and predict failures.\n\nDigital twins solve this through physics-based simulation coupled with AI interpretation. Instead of just displaying current temperature readings, a digital twin models thermal dynamics, heat transfer rates, HVAC response characteristics, occupancy impacts. When conditions deviate from expectations, the twin compares observed versus predicted states, identifying root causes. Layer AI on top, and operators get natural language explanations: \"The conference room is 3 degrees too warm because the VAV damper is stuck at 40% open, reducing airflow by 60%.\"\n\nThis application focuses on HVAC, the largest building energy consumer, typically 40-50% of total usage. Optimizing HVAC by just 10% through better controls can save thousands of dollars monthly while improving occupant satisfaction. The digital twin enables \"what-if\" scenarios before making changes: \"What happens to energy consumption and comfort if we raise the cooling setpoint by 2 degrees during peak demand response events?\"\n\n## Architecture: Three-Tier Digital Twin System\n\nThe application implements a clean three-tier architecture separating visualization, simulation, and state management:\n\nThe frontend uses React with Three.js for 3D visualization. Users see an interactive 3D model of the three-floor building with color-coded zones indicating temperature and CO₂ levels. Click any equipment, AHUs, VAVs, chillers, to see detailed telemetry. The control panel enables adjusting setpoints, running simulation steps, and activating demand response scenarios. Real-time charts display KPIs: energy consumption, comfort compliance, air quality levels.\n\nThe backend Node.js/Express server orchestrates simulation and state management. It maintains the digital twin state as JSON, the single source of truth for all equipment, zones, and telemetry. REST API endpoints handle control requests, simulation steps, and AI copilot queries. WebSocket connections push real-time updates to the frontend for live monitoring. The HVAC simulator implements physics-based models: 1R1C thermal models for zones, affinity laws for fan power, chiller COP calculations, CO₂ mass balance equations.\n\n[Foundry Local](https://foundrylocal.ai) provides AI copilot capabilities. The backend uses foundry-local-sdk to query locally running models. Natural language queries (\"How's the lobby temperature?\") get answered with building state context. The copilot can explain anomalies, suggest optimizations, and even execute commands when explicitly requested.\n\n## Implementing Physics-Based HVAC Simulation\n\nAccurate simulation requires modeling actual HVAC physics. The simulator implements several established building energy models:\n\n``` // backend/src/simulator/thermal-model.js\n\nclass ZoneThermalModel { // 1R1C (one resistance, one capacitance) thermal model static calculateTemperatureChange(zone, delta_t_seconds) { const C_thermal = zone.volume * 1.2 * 1000; // Heat capacity (J/K) const R_thermal = zone.r_value * zone.envelope_area; // Thermal resistance\n\n// Internal heat gains (occupancy, equipment, lighting) const Q_internal = zone.occupancy * 100 + // 100W per person zone.equipment_load + zone.lighting_load;\n\n// Cooling/heating from HVAC const airflow_kg_s = zone.vav.airflow_cfm * 0.0004719; // CFM to kg/s const c_p_air = 1006; // Specific heat of air (J/kg·K) const Q_hvac = airflow_kg_s * c_p_air * (zone.vav.supply_temp - zone.temperature);\n\n// Envelope losses const Q_envelope = (zone.outdoor_temp - zone.temperature) / R_thermal;\n\n// Net energy balance const Q_net = Q_internal + Q_hvac + Q_envelope;\n\n// Temperature change: Q = C * dT/dt const dT = (Q_net / C_thermal) * delta_t_seconds;\n\nreturn zone.temperature + dT; } } ```\n\nThis model captures essential thermal dynamics while remaining computationally fast enough for real-time simulation. It accounts for internal heat generation from occupants and equipment, HVAC cooling/heating contributions, and heat loss through the building envelope.\n\nThe CO₂ model uses mass balance equations:\n\n``` class AirQualityModel { static calculateCO2Change(zone, delta_t_seconds) { // CO₂ generation from occupants const G_co2 = zone.occupancy * 0.0052; // L/s per person at rest\n\n// Outdoor air ventilation rate const V_oa = zone.vav.outdoor_air_cfm * 0.000471947; // CFM to m³/s\n\n// CO₂ concentration difference (indoor - outdoor) const delta_CO2 = zone.co2_ppm - 400; // Outdoor ~400ppm\n\n// Mass balance: dC/dt = (G - V*ΔC) / Volume const dCO2_dt = (G_co2 - V_oa * delta_CO2) / zone.volume;\n\nreturn zone.co2_ppm + (dCO2_dt * delta_t_seconds); } } ```\n\nThese models execute every simulation step, updating the entire building state:\n\n``` async function simulateStep(twin, timestep_minutes) { const delta_t = timestep_minutes * 60; // Convert to seconds\n\n// Update each zone for (const zone of twin.zones) { zone.temperature = ZoneThermalModel.calculateTemperatureChange(zone, delta_t); zone.co2_ppm = AirQualityModel.calculateCO2Change(zone, delta_t); }\n\n// Update equipment based on zone demands for (const vav of twin.vavs) { updateVAVOperation(vav, twin.zones); }\n\nfor (const ahu of twin.ahus) { updateAHUOperation(ahu, twin.vavs); }\n\nupdateChillerOperation(twin.chiller, twin.ahus); updateBoilerOperation(twin.boiler, twin.ahus);\n\n// Calculate system KPIs twin.kpis = calculateSystemKPIs(twin);\n\n// Detect alerts twin.alerts = detectAnomalies(twin);\n\n// Persist updated state await saveTwinState(twin);\n\nreturn twin; } ```\n\n## 3D Visualization with React and Three.js\n\nThe frontend renders an interactive 3D building view that updates in real-time as conditions change. Using React Three Fiber simplifies Three.js integration with React's component model:\n\n``` // frontend/src/components/BuildingView3D.jsx import { Canvas } from '@react-three/fiber'; import { OrbitControls } from '@react-three/drei';\n\nexport function BuildingView3D({ twinState }) { return (\n\n{/* Render building floors */} {twinState.zones.map(zone => ( selectZone(zone.id)} /> ))}\n\n{/* Render equipment */} {twinState.ahus.map(ahu => (\n\n))}\n\n); }\n\nfunction ZoneMesh({ zone, onClick }) { const color = getTemperatureColor(zone.temperature, zone.setpoint);\n\nreturn (\n\n); }\n\nfunction getTemperatureColor(current, setpoint) { const deviation = current - setpoint; if (Math.abs(deviation) < 1) return '#00ff00'; // Green: comfortable if (Math.abs(deviation) < 3) return '#ffff00'; // Yellow: acceptable return '#ff0000'; // Red: uncomfortable } ```\n\nThis visualization immediately shows building state at a glance, operators see \"hot spots\" in red, comfortable zones in green, and can click any area for detailed metrics.\n\n## Integrating AI Copilot for Natural Language Control\n\nThe AI copilot transforms building data into conversational insights. Instead of navigating multiple screens, operators simply ask questions:\n\n``` // backend/src/routes/copilot.js import { FoundryLocalClient } from 'foundry-local-sdk';\n\nconst foundry = new FoundryLocalClient({ endpoint: process.env.FOUNDRY_LOCAL_ENDPOINT });\n\nrouter.post('/api/copilot/chat', async (req, res) => { const { message } = req.body;\n\n// Load current building state const twin = await loadTwinState();\n\n// Build context for AI const context = buildBuildingContext(twin);\n\nconst completion = await foundry.chat.completions.create({ model: 'phi-4', messages: [ { role: 'system', content: `You are an HVAC operations assistant for a 3-floor office building.\n\nCurrent Building State: ${context}\n\nAnswer questions about equipment status, comfort conditions, and energy usage. Provide specific, actionable information based on the current data. Do not speculate beyond provided information.` }, { role: 'user', content: message } ], temperature: 0.3, max_tokens: 300 });\n\nres.json({ response: completion.choices[0].message.content, model: 'phi-4', timestamp: new Date().toISOString() }); });\n\nfunction buildBuildingContext(twin) { const alerts = twin.alerts.filter(a => a.active); const zoneStatus = twin.zones.map(z => `${z.name}: ${z.temperature.toFixed(1)}°F (setpoint: ${z.setpoint}°F), CO₂: ${z.co2_ppm}ppm, ${z.occupancy} people` );\n\nreturn ` Zones: ${zoneStatus.join('\\n')}\n\nActive Alerts: ${alerts.length} ${alerts.map(a => `- ${a.severity}: ${a.message}`).join('\\n')}\n\nEnergy: ${twin.kpis.total_power_kw.toFixed(1)} kW Chiller: ${twin.chiller.percent_load}% load, ${twin.chiller.cop.toFixed(2)} COP `.trim(); } ```\n\nExample interactions:\n\n``` User: \"Why is the third floor conference room warm?\"\n\nAI: \"The Executive Suite on Floor 3 is currently 75.2°F, 3 degrees above the 72°F setpoint. This is due to high occupancy (8 people) and VAV-F3-EXEC operating at reduced airflow (285 CFM vs 450 CFM capacity). AHU-2 is supplying adequate cool air at 55°F. Recommend checking VAV damper position—it may be partially stuck.\"\n\nUser: \"What's our current energy usage?\"\n\nAI: \"Total building power consumption is 47.3 kW. Breakdown: Chiller (24.1 kW, 51%), AHU fans (12.8 kW, 27%), Pumps (7.2 kW, 15%), Other (3.2 kW, 7%). Chiller is operating at 62% load with a COP of 4.8, which is efficient for current conditions.\"\n\nUser: \"Activate demand response level 2\"\n\nAI: \"I cannot directly control building systems for safety reasons. To activate DR Level 2, use the Control Panel and click 'Demand Response' → 'Level 2'. This will raise cooling setpoints by 3°F and reduce auxiliary loads, targeting 15% energy reduction.\" ```\n\nThe AI provides grounded, specific answers citing actual equipment IDs and metrics. It refuses to directly execute control commands, instead guiding operators to explicit control interfaces, a critical safety pattern for building systems.\n\n## Fault Injection for Testing and Training\n\nReal building operations experience equipment failures, stuck dampers, sensor drift, communication losses. The digital twin includes comprehensive fault injection capabilities to train operators and test control logic:\n\n``` // backend/src/simulator/fault-injector.js\n\nconst FAULT_CATALOG = { chillerFailure: { description: 'Chiller compressor failure', apply: (twin) => { twin.chiller.status = 'FAULT'; twin.chiller.cooling_output = 0; twin.alerts.push({ id: 'chiller-fault', severity: 'CRITICAL', message: 'Chiller compressor failure - no cooling available', equipment: 'CHILLER-01' }); } },\n\nstuckVAVDamper: { description: 'VAV damper stuck at current position', apply: (twin, vavId) => { const vav = twin.vavs.find(v => v.id === vavId); vav.damper_stuck = true; vav.damper_position_fixed = vav.damper_position; twin.alerts.push({ id: `vav-stuck-${vavId}`, severity: 'HIGH', message: `VAV ${vavId} damper stuck at ${vav.damper_position}%`, equipment: vavId }); } },\n\nsensorDrift: { description: 'Temperature sensor reading 5°F high', apply: (twin, zoneId) => { const zone = twin.zones.find(z => z.id === zoneId); zone.sensor_drift = 5.0; zone.temperature_measured = zone.temperature_actual + 5.0; } },\n\ncommunicationLoss: { description: 'Equipment communication timeout', apply: (twin, equipmentId) => { const equipment = findEquipmentById(twin, equipmentId); equipment.comm_status = 'OFFLINE'; equipment.stale_data = true; twin.alerts.push({ id: `comm-loss-${equipmentId}`, severity: 'MEDIUM', message: `Lost communication with ${equipmentId}`, equipment: equipmentId }); } } };\n\nrouter.post('/api/twin/fault', async (req, res) => { const { faultType, targetEquipment } = req.body;\n\nconst twin = await loadTwinState(); const fault = FAULT_CATALOG[faultType];\n\nif (!fault) { return res.status(400).json({ error: 'Unknown fault type' }); }\n\nfault.apply(twin, targetEquipment); await saveTwinState(twin);\n\nres.json({ message: `Applied fault: ${fault.description}`, affectedEquipment: targetEquipment, timestamp: new Date().toISOString() }); }); ```\n\nOperators can inject faults to practice diagnosis and response. Training scenarios might include: \"The chiller just failed during a heat wave, how do you maintain comfort?\" or \"Multiple VAV dampers are stuck, which zones need immediate attention?\"\n\n## Key Takeaways and Production Deployment\n\nBuilding a physics-based digital twin with AI capabilities requires balancing simulation accuracy with computational performance, providing intuitive visualization while maintaining technical depth, and enabling AI assistance without compromising safety.\n\nKey architectural lessons:\n\n- **Physics models enable prediction**: Comparing predicted vs observed behavior identifies anomalies that simple thresholds miss\n- **3D visualization improves spatial understanding**: Operators immediately see which floors or zones need attention\n- **AI copilots accelerate diagnosis**: Natural language queries get answers in seconds vs. minutes of manual data examination\n- **Fault injection validates readiness**: Testing failure scenarios prepares operators for real incidents\n- **JSON state enables integration**: Simple file-based state makes connecting to real BMS systems straightforward\n\nFor production deployment, connect the twin to actual building systems via BACnet, Modbus, or MQTT integrations. Replace simulated telemetry with real sensor streams. Calibrate model parameters against historical building performance. Implement continuous learning where the twin's predictions improve as it observes actual building behavior.\n\nThe complete implementation with simulation engine, 3D visualization, AI copilot, and fault injection system is available at [github.com/leestott/DigitalTwin](https://github.com/leestott/DigitalTwin). Clone the repository and run the startup scripts to explore the digital twin, no building hardware required.\n\n## Resources and Further Reading\n\n- [Smart Building HVAC Digital Twin Repository](https://github.com/leestott/DigitalTwin) - Complete source code and simulation engine\n- [Setup and Quick Start Guide](https://github.com/leestott/DigitalTwin/blob/master/README.md) - Installation instructions and usage examples\n- [Microsoft Foundry Local Documentation](https://foundrylocal.ai) - AI integration reference\n- [HVAC Simulation Documentation](https://github.com/leestott/DigitalTwin/blob/master/backend/src/simulator/README.md) - Physics model details and calibration\n- [Three.js Documentation](https://threejs.org/docs/) - 3D visualization framework\n- [ASHRAE Standards](https://www.ashrae.org/)- Building energy modeling standards\n\nUpdated Jan 30, 2026\n\nVersion 1.0\n\n[ai](/tag/ai?nodeId=board%3AAzureDevCommunityBlog)\n\n[ai foundry](/tag/ai%20foundry?nodeId=board%3AAzureDevCommunityBlog)\n\n[genai](/tag/genai?nodeId=board%3AAzureDevCommunityBlog)\n\n[get started](/tag/get%20started?nodeId=board%3AAzureDevCommunityBlog)\n\n[java](/tag/java?nodeId=board%3AAzureDevCommunityBlog)\n\n[mcp](/tag/mcp?nodeId=board%3AAzureDevCommunityBlog)\n\n[performance](/tag/performance?nodeId=board%3AAzureDevCommunityBlog)\n\n[phi-3](/tag/phi-3?nodeId=board%3AAzureDevCommunityBlog)\n\n[slm](/tag/slm?nodeId=board%3AAzureDevCommunityBlog)\n\n[software architecture](/tag/software%20architecture?nodeId=board%3AAzureDevCommunityBlog)\n\n[!\\[Lee_Stott&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0yMTA1NDYtODM5MjVpMDI2ODNGQTMwMzAwNDFGQQ?image-dimensions=50x50)](/users/lee_stott/210546) [Lee_Stott](/users/lee_stott/210546) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined September 25, 2018\n\n[View Profile](/users/lee_stott/210546)\n\n/category/azure/blog/azuredevcommunityblog [Microsoft Developer Community Blog](/category/azure/blog/azuredevcommunityblog) Follow this blog board to get notified when there's new activity"
}
