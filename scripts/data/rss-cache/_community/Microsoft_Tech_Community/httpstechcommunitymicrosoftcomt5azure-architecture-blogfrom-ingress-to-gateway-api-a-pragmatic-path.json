{
  "PubDate": "2026-01-28T23:19:40+00:00",
  "EnhancedContent": "*If you operate Kubernetes at scale, you've felt it: \"Ingress YAML sprawl\", annotation archaeology, and the creeping sense that your edge configuration is one upstream change away from becoming fragile.* Over the last couple of years, the Kubernetes networking community has been steadily moving toward a clearer, more expressive model for north-south traffic management: **Gateway API**.\n\nThat shift has accelerated recently for a very practical reason: **Ingress NGINX (the community ingress-nginx controller) is on a retirement timeline**. For many teams, that controller wasn't a \"nice to have\" - it was *the* default ingress path. Now, you have to make two decisions in short order:\n\n1. **Pick a proxy / gateway implementation** that you can run confidently for years.\n2. **Learn Gateway API** (or at least build a migration plan toward it).\n\nThis post addresses both challenges constructively, without turning it into a \"rip-and-replace\" story. The goal is to help you make the shift to **Gateway API** with a clear plan, and to show how **Azure Application Gateway for Containers** can serve as a stable landing zone for teams seeking an Azure-native path forward.\n\n## Why the community is moving: Gateway API is the new center of gravity\n\nThe original Kubernetes **Ingress** API did one job well: provide a basic, portable way to route HTTP/S to services. Over time, real-world production needs outgrew what a single resource plus controller-specific annotations could express. The Kubernetes community designed **Gateway API** to address those gaps.\n\nThe change is more than \"Ingress but newer.\" Gateway API splits responsibilities across multiple resources so it's easier to reason about ownership, multi-tenancy, and safe delegation:\n\n- **GatewayClass**: the \"provider\" of gateway capability.\n- **Gateway**: the actual entry point (listeners, addresses, TLS).\n- **HTTPRoute / TCPRoute / GRPCRoute**: app-owned routing rules attached to gateways.\n\nThat separation matches how most organizations actually operate: platform teams manage shared ingress infrastructure, while application teams manage routes.\n\nThe ingress-nginx project maintainers have made this shift explicit. Their [README now states](https://github.com/kubernetes/ingress-nginx): *\"If you are not already using ingress-nginx, you should not be deploying it... Instead you should identify a Gateway API implementation and use it.\"* The broader Kubernetes networking community has rallied around Gateway API for its richer features, cleaner extensibility model, and explicit role separation.\n\n## The catalyst: Ingress NGINX retirement forces a decision\n\nThe Kubernetes SIG Network and the Security Response Committee [announced the retirement plan](https://kubernetes.io/blog/2025/11/11/ingress-nginx-retirement/) for the **Ingress NGINX** project, with best-effort maintenance until **March 2026**, after which there are no further releases or security updates.\n\n- **This is about the community \"ingress-nginx\" controller project**, but it's worth noting that the [Ingress API itself is also frozen](https://kubernetes.io/docs/concepts/services-networking/ingress/) - no new features will be added as Gateway API is the intended successor.\n- Your clusters may keep routing traffic after retirement, but you'll be running an unmaintained edge component.\n\nFor Azure Kubernetes Service (AKS) customers, Microsoft has also [published guidance](https://blog.aks.azure.com/2025/11/13/ingress-nginx-update): if you're using the **AKS Application Routing add-on** with NGINX to manage Ingress NGINX resources, official support for the current NGINX Ingress will remain until **November 2026** (critical security patches only during that period), after which the future direction will focus on **Gateway API**.\n\nThe practical implication: **you now have a clear timeline to act**, and the ecosystem is aligned on Gateway API as the future.\n\n## The two challenges (and why they're intertwined)\n\nWhen you hear \"migrate from ingress-nginx,\" you might be thinking about two different projects:\n\n### Challenge 1: Picking a proxy\n\nIngress NGINX had a simple value proposition: \"install it and route traffic.\" But it also became a catch-all for features via annotations - rewrites, headers, canary, auth, rate limits, mTLS, and more.\n\nWhen choosing your next proxy/gateway, you now have to weigh:\n\n- **Support model**: community vs. vendor-backed vs. managed service.\n- **Operational burden**: patching cadence, upgrades, incident response.\n- **Ecosystem integration**: observability, identity, policy, security tooling.\n- **Feature parity**: what's native vs. what requires extensions.\n\n### Challenge 2: Learning Gateway API\n\nEven if you keep the same data plane technology, moving to Gateway API changes how you model traffic:\n\n- You'll think in **Gateways and Routes**, not just \"an Ingress per app.\"\n- You'll formalize **who owns TLS and listeners** vs. who owns routing rules.\n- You'll reduce \"annotation magic,\" which is good - but it's still a learning curve.\n\nIn other words: **the proxy choice and the API choice are linked**. You want to avoid migrating twice.\n\n## A practical approach to both challenges\n\n### Treat the gateway layer as a platform capability\n\nIf you're currently running **Ingress NGINX** or **Application Gateway Ingress Controller (AGIC)**, now is the time to start planning your migration. Both rely on the Ingress API, which is frozen, and the ingress-nginx controller is heading toward end-of-life.\n\nInstead of coupling your applications tightly to a specific ingress implementation, consider treating the gateway layer as a **platform-managed capability**. With **Gateway API**, teams can express routing intent as standard resources, while the platform handles lifecycle and operational concerns (patching, upgrades, policy enforcement) at the gateway layer. This separation keeps application routing policy stable even as the underlying gateway implementation evolves.\n\nThis is particularly valuable when you consider how much operational overhead ingress controllers add: patching cadence, security response, compatibility testing with each Kubernetes upgrade. A managed gateway shifts that burden off your team.\n\n### Adopt Gateway API for interoperability, not lock-in\n\nA common concern when adopting any managed service is vendor lock-in. Gateway API addresses this directly.\n\nIf your managed gateway implements the **Kubernetes Gateway API standard**, your routing configuration (Gateways, HTTPRoutes, etc.) stays portable. For multi-cloud or hybrid deployments, your core configuration follows the same spec. You're not locked into proprietary annotations or custom resources for basic routing—you're using the API that the entire Kubernetes ecosystem is converging on.\n\nFor Azure customers, this is exactly where **Application Gateway for Containers** comes in.\n\n## Application Gateway for Containers: The next step\n\nWhile Gateway API is the *model* the Kubernetes community is investing in, you still need a *gateway implementation* that can carry production traffic safely. For many AKS customers, **Azure Application Gateway for Containers** is attractive because it's designed specifically for Kubernetes ingress, while fitting naturally into Azure's application delivery portfolio.\n\nAt a high level, Application Gateway for Containers is an **L7 (application layer) load balancer and dynamic traffic management product for Kubernetes workloads**, positioned as the evolution of **Application Gateway Ingress Controller (AGIC)**. It supports **Kubernetes Ingress and Kubernetes Gateway API**, it's managed by an **ALB controller** running in-cluster that adheres to Kubernetes Gateway APIs, and has native integration with **Web Application Firewall**.\n\n### What sets Application Gateway for Containers apart from DIY open source options\n\nWhen comparing Application Gateway for Containers to self-managed open source ingress controllers, several architectural and operational differences stand out:\n\n**Enterprise support, SLA, and security patching** Application Gateway for Containers is a fully supported Azure service with:\n\n- **Microsoft support** - file tickets, get engineering assistance, escalate when needed.\n- **Enterprise SLA** - financially-backed availability guarantees for production workloads.\n- **Security patching handled by Microsoft** - when CVEs emerge in the underlying proxy or platform, Azure patches the service.\n\n**Out-of-cluster architecture** Unlike in-cluster proxies (NGINX, Envoy, etc.), Application Gateway for Containers runs the data plane *outside* your AKS cluster. This means:\n\n- **No proxy pods consuming your cluster's CPU and memory** - those resources stay available for your workloads.\n- **Independent scaling** - the gateway scales based on traffic, not tied to your cluster's node capacity.\n- **Blast radius separation** - a misconfiguration or overload at the edge doesn't starve your application pods.\n\n**Azure-native Web Application Firewall (WAF)** Application Gateway for Containers integrates with Azure WAF, giving you OWASP protection, bot mitigation, and custom rules without bolting on a separate security layer. But it's not just about convenience - Azure WAF benefits from **Microsoft's global threat intelligence**, drawing on signals from trillions of daily transactions across Azure, Microsoft 365, and other services to keep rulesets current against emerging attack patterns. With open source options, WAF typically means running yet another component (ModSecurity, Coraza, etc.) that you patch and tune yourself - and you're responsible for staying ahead of the threat landscape.\n\n**Deep Azure Ecosystem Integration** Because Application Gateway for Containers is a first-party Azure service, you get:\n\n- **Azure Monitor and Log Analytics** for metrics, logs, and alerting - no sidecar exporters needed.\n- **Azure Service Health** notifications for platform incidents.\n- **Portal, CLI, PowerShell, Bicep, and Terraform** for provisioning and management.\n- **Azure Policy and RBAC** for governance at scale.\n\nThis matters operationally: instead of stitching together your own monitoring and alerting pipelines for your ingress layer, you inherit the same observability stack you already use for the rest of Azure.\n\n### And the expected bases are covered\n\nBeyond the architectural advantages, Application Gateway for Containers delivers the routing capabilities you'd expect from a modern gateway:\n\n- **Support for both Ingress and Gateway API** - migrate incrementally without a hard cutover.\n- **Traffic splitting and weighted round robin** - enable canary deployments and progressive rollouts.\n- **Mutual authentication (mTLS)** - secure service-to-service communication.\n- **Near real-time configuration updates** - pod, route, and probe changes propagate in seconds, not minutes.\n- **Flexible deployment strategies** - manage the Azure resource lifecycle via ARM/Bicep/Terraform, or let the ALB Controller handle it entirely via Kubernetes CRDs.\n\nNo gaps, no surprises, just a solid foundation for production traffic.\n\n## Migrating today: A safe, incremental plan\n\nWhether you're coming from AGIC or ingress-nginx, the practical goal is the same: **reduce risk while maintaining traffic parity**.\n\nA conservative migration pattern looks like this:\n\n1. **Inventory your Ingresses** (hosts, paths, TLS patterns, annotations).\n2. **Stand up Application Gateway for Containers in parallel** (choose BYO vs. managed deployment strategy).\n3. **Convert a low-risk service first**, validate end-to-end.\n4. **Migrate iteratively** (service-by-service), monitor and roll back if needed.\n5. **Cut traffic over** once parity is proven, then retire the old controller.\n\nThis approach is consistent with both:\n\n- Microsoft's goal of \"incremental migration + validation + no downtime\" for AGIC to Application Gateway for Containers migrations.\n- Gateway API guidance that you can run a Gateway API controller alongside Ingress-NGINX to test in isolation.\n\n## The Missing Piece: Translating Years of Annotations (and How Tooling Helps)\n\nFor many teams, the hardest part isn't \"create a Gateway\" - it's **annotation archaeology**.\n\nThat's why Microsoft has built and open-sourced the **Application Gateway for Containers Migration Utility**: a command-line utility that helps translate existing Kubernetes Ingress configuration (including controller-specific annotations) into **Gateway API YAML** for Application Gateway for Containers.\n\nYou can find the tool at [aka.ms/agc/migrationutility](https://aka.ms/agc/migrationutility).\n\n### What the utility does\n\nThe tool is a **command-line utility** that:\n\n- **Reads your existing NGINX Ingress configuration from a cluster** (read-only),\n- **Outputs the equivalent Gateway API YAML**, and\n- Translates AGIC / NGINX annotations into Gateway API resources and (where needed) Application Gateway for Containers-specific custom resources.\n\nThe utility is **fully open source**, and we welcome your contributions! If you encounter missing annotation support, edge cases, or have ideas for improvement, please open an issue or submit a pull request at [aka.ms/agc/migrationutility](https://aka.ms/agc/migrationutility). Your feedback helps make the tool better for everyone navigating this migration.\n\n**Important note:** Any migration tool should be used as a *starting point* - the output is meant to be reviewed, tested, and adjusted based on your environment's specifics (auth, WAF rules, TLS policies, edge cases).\n\n## A practical phased rollout checklist\n\nTo make this actionable for teams planning the next few months, here's a simple rollout scaffold:\n\n### Phase 1: Decide your target state\n\n- Choose whether your end state is **Gateway API-first** (recommended) or **Ingress-first** as a short bridge.\n- Choose Application Gateway for Containers deployment strategy:\n- **BYO (Bring Your Own)**: Create and manage Application Gateway for Containers via Azure Portal, CLI, or Terraform, then reference it in Kubernetes. Best when your CI/CD pipelines already manage Azure resource lifecycle.\n- **Managed by ALB Controller**: The in-cluster ALB Controller handles Application Gateway for Containers lifecycle based on Kubernetes CRDs. Best when you want a fully Kubernetes-native experience.\n\n### Phase 2: Stand up the parallel path\n\n- Deploy ALB Controller.\n- Create Application Gateway for Containers using your chosen strategy.\n- Create a test Gateway + HTTPRoute for a single service.\n\n### Phase 3: Convert + validate incrementally\n\n- Use translation tooling to generate initial Gateway API resources.\n- Validate routing parity (hosts, paths, rewrites, headers).\n- Validate security posture (TLS, backend mTLS if needed, policy/WAF).\n- Cut traffic over only when observability and SLOs look equivalent.\n\n## Migrate once - onto the model the ecosystem is backing\n\nThe retirement of the community ingress-nginx controller is forcing planning work across the industry. The best long-term outcome is to migrate once onto the model Kubernetes is actively evolving: **Gateway API**.\n\nFor AKS customers, Microsoft's direction is clear: support continuity for the existing add-on through November 2026 (critical security patches), while investing in the future centered on Gateway API.\n\nThe combination of **Application Gateway for Containers + Gateway API + migration tooling** is meant to reduce friction: pick a supported path forward, adopt the modern API, validate safely, and minimize the number of migrations.\n\n## Further Reading\n\n- [Learn more about Application Gateway for Containers](https://aka.ms/agc)\n- [GitHub Repo for Application Gateway for Containers Migration Utility](https://aka.ms/agc/migrationutility)\n- [Kubernetes: Ingress NGINX Retirement](https://kubernetes.io/blog/2025/11/11/ingress-nginx-retirement/)\n- [AKS Engineering Blog: Application Routing Add-on Update](https://blog.aks.azure.com/2025/11/13/ingress-nginx-update)\n- [Microsoft Learn: Migration Overview (AGIC to AGC)](https://aka.ms/agc/migrate)\n- [Microsoft Learn: Application Gateway for Containers Quickstart (Managed by ALB Controller)](https://learn.microsoft.com/azure/application-gateway/for-containers/quickstart-managed-by-alb-controller)\n- [Microsoft Learn: Application Gateway for Containers Quickstart (Bring Your Own Deployment)](https://learn.microsoft.com/azure/application-gateway/for-containers/quickstart-bring-your-own-deployment)\n\nUpdated Jan 27, 2026\n\nVersion 1.0\n\n[!\\[Jack Stromberg&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/m_assets/avatars/default/avatar-5.svg?image-dimensions=50x50)](/users/jack%20stromberg/116295) [Jack Stromberg](/users/jack%20stromberg/116295) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined February 06, 2018\n\n[View Profile](/users/jack%20stromberg/116295)\n\n/category/azure/blog/azurearchitectureblog [Azure Architecture Blog](/category/azure/blog/azurearchitectureblog) Follow this blog board to get notified when there's new activity",
  "Description": "*If you operate Kubernetes at scale, you've felt it: \"Ingress YAML sprawl\", annotation archaeology, and the creeping sense that your edge configuration is one upstream change away from becoming fragile.* Over the last couple of years, the Kubernetes networking community has been steadily moving toward a clearer, more expressive model for north-south traffic management: **Gateway API**.\n\nThat shift has accelerated recently for a very practical reason: **Ingress NGINX (the community ingress-nginx controller) is on a retirement timeline**. For many teams, that controller wasn't a \"nice to have\" - it was *the* default ingress path. Now, you have to make two decisions in short order:\n\n1. **Pick a proxy / gateway implementation** that you can run confidently for years.\n2. **Learn Gateway API** (or at least build a migration plan toward it).\n\nThis post addresses both challenges constructively, without turning it into a \"rip-and-replace\" story. The goal is to help you make the shift to **Gateway API** with a clear plan, and to show how **Azure Application Gateway for Containers** can serve as a stable landing zone for teams seeking an Azure-native path forward.\n\n## Why the community is moving: Gateway API is the new center of gravity\n\nThe original Kubernetes **Ingress** API did one job well: provide a basic, portable way to route HTTP/S to services. Over time, real-world production needs outgrew what a single resource plus controller-specific annotations could express. The Kubernetes community designed **Gateway API** to address those gaps.\n\nThe change is more than \"Ingress but newer.\" Gateway API splits responsibilities across multiple resources so it's easier to reason about ownership, multi-tenancy, and safe delegation:\n\n- **GatewayClass**: the \"provider\" of gateway capability.\n- **Gateway**: the actual entry point (listeners, addresses, TLS).\n- **HTTPRoute / TCPRoute / GRPCRoute**: app-owned routing rules attached to gateways.\n\nThat separation matches how most organizations actually operate: platform teams manage shared ingress infrastructure, while application teams manage routes.\n\nThe ingress-nginx project maintainers have made this shift explicit. Their [README now states](https://github.com/kubernetes/ingress-nginx): *\"If you are not already using ingress-nginx, you should not be deploying it... Instead you should identify a Gateway API implementation and use it.\"* The broader Kubernetes networking community has rallied around Gateway API for its richer features, cleaner extensibility model, and explicit role separation.\n\n## The catalyst: Ingress NGINX retirement forces a decision\n\nThe Kubernetes SIG Network and the Security Response Committee [announced the retirement plan](https://kubernetes.io/blog/2025/11/11/ingress-nginx-retirement/) for the **Ingress NGINX** project, with best-effort maintenance until **March 2026**, after which there are no further releases or security updates.\n\n- **This is about the community \"ingress-nginx\" controller project**, but it's worth noting that the [Ingress API itself is also frozen](https://kubernetes.io/docs/concepts/services-networking/ingress/) - no new features will be added as Gateway API is the intended successor.\n- Your clusters may keep routing traffic after retirement, but you'll be running an unmaintained edge component.\n\nFor Azure Kubernetes Service (AKS) customers, Microsoft has also [published guidance](https://blog.aks.azure.com/2025/11/13/ingress-nginx-update): if you're using the **AKS Application Routing add-on** with NGINX to manage Ingress NGINX resources, official support for the current NGINX Ingress will remain until **November 2026** (critical security patches only during that period), after which the future direction will focus on **Gateway API**.\n\nThe practical implication: **you now have a clear timeline to act**, and the ecosystem is aligned on Gateway API as the future.\n\n## The two challenges (and why they're intertwined)\n\nWhen you hear \"migrate from ingress-nginx,\" you might be thinking about two different projects:\n\n### Challenge 1: Picking a proxy\n\nIngress NGINX had a simple value proposition: \"install it and route traffic.\" But it also became a catch-all for features via annotations - rewrites, headers, canary, auth, rate limits, mTLS, and more.\n\nWhen choosing your next proxy/gateway, you now have to weigh:\n\n- **Support model**: community vs. vendor-backed vs. managed service.\n- **Operational burden**: patching cadence, upgrades, incident response.\n- **Ecosystem integration**: observability, identity, policy, security tooling.\n- **Feature parity**: what's native vs. what requires extensions.\n\n### Challenge 2: Learning Gateway API\n\nEven if you keep the same data plane technology, moving to Gateway API changes how you model traffic:\n\n- You'll think in **Gateways and Routes**, not just \"an Ingress per app.\"\n- You'll formalize **who owns TLS and listeners** vs. who owns routing rules.\n- You'll reduce \"annotation magic,\" which is good - but it's still a learning curve.\n\nIn other words: **the proxy choice and the API choice are linked**. You want to avoid migrating twice.\n\n## A practical approach to both challenges\n\n### Treat the gateway layer as a platform capability\n\nIf you're currently running **Ingress NGINX** or **Application Gateway Ingress Controller (AGIC)**, now is the time to start planning your migration. Both rely on the Ingress API, which is frozen, and the ingress-nginx controller is heading toward end-of-life.\n\nInstead of coupling your applications tightly to a specific ingress implementation, consider treating the gateway layer as a **platform-managed capability**. With **Gateway API**, teams can express routing intent as standard resources, while the platform handles lifecycle and operational concerns (patching, upgrades, policy enforcement) at the gateway layer. This separation keeps application routing policy stable even as the underlying gateway implementation evolves.\n\nThis is particularly valuable when you consider how much operational overhead ingress controllers add: patching cadence, security response, compatibility testing with each Kubernetes upgrade. A managed gateway shifts that burden off your team.\n\n### Adopt Gateway API for interoperability, not lock-in\n\nA common concern when adopting any managed service is vendor lock-in. Gateway API addresses this directly.\n\nIf your managed gateway implements the **Kubernetes Gateway API standard**, your routing configuration (Gateways, HTTPRoutes, etc.) stays portable. For multi-cloud or hybrid deployments, your core configuration follows the same spec. You're not locked into proprietary annotations or custom resources for basic routing—you're using the API that the entire Kubernetes ecosystem is converging on.\n\nFor Azure customers, this is exactly where **Application Gateway for Containers** comes in.\n\n## Application Gateway for Containers: The next step\n\nWhile Gateway API is the *model* the Kubernetes community is investing in, you still need a *gateway implementation* that can carry production traffic safely. For many AKS customers, **Azure Application Gateway for Containers** is attractive because it's designed specifically for Kubernetes ingress, while fitting naturally into Azure's application delivery portfolio.\n\nAt a high level, Application Gateway for Containers is an **L7 (application layer) load balancer and dynamic traffic management product for Kubernetes workloads**, positioned as the evolution of **Application Gateway Ingress Controller (AGIC)**. It supports **Kubernetes Ingress and Kubernetes Gateway API**, it's managed by an **ALB controller** running in-cluster that adheres to Kubernetes Gateway APIs, and has native integration with **Web Application Firewall**.\n\n### What sets Application Gateway for Containers apart from DIY open source options\n\nWhen comparing Application Gateway for Containers to self-managed open source ingress controllers, several architectural and operational differences stand out:\n\n**Enterprise support, SLA, and security patching** Application Gateway for Containers is a fully supported Azure service with:\n\n- **Microsoft support** - file tickets, get engineering assistance, escalate when needed.\n- **Enterprise SLA** - financially-backed availability guarantees for production workloads.\n- **Security patching handled by Microsoft** - when CVEs emerge in the underlying proxy or platform, Azure patches the service.\n\n**Out-of-cluster architecture** Unlike in-cluster proxies (NGINX, Envoy, etc.), Application Gateway for Containers runs the data plane *outside* your AKS cluster. This means:\n\n- **No proxy pods consuming your cluster's CPU and memory** - those resources stay available for your workloads.\n- **Independent scaling** - the gateway scales based on traffic, not tied to your cluster's node capacity.\n- **Blast radius separation** - a misconfiguration or overload at the edge doesn't starve your application pods.\n\n**Azure-native Web Application Firewall (WAF)** Application Gateway for Containers integrates with Azure WAF, giving you OWASP protection, bot mitigation, and custom rules without bolting on a separate security layer. But it's not just about convenience - Azure WAF benefits from **Microsoft's global threat intelligence**, drawing on signals from trillions of daily transactions across Azure, Microsoft 365, and other services to keep rulesets current against emerging attack patterns. With open source options, WAF typically means running yet another component (ModSecurity, Coraza, etc.) that you patch and tune yourself - and you're responsible for staying ahead of the threat landscape.\n\n**Deep Azure Ecosystem Integration** Because Application Gateway for Containers is a first-party Azure service, you get:\n\n- **Azure Monitor and Log Analytics** for metrics, logs, and alerting - no sidecar exporters needed.\n- **Azure Service Health** notifications for platform incidents.\n- **Portal, CLI, PowerShell, Bicep, and Terraform** for provisioning and management.\n- **Azure Policy and RBAC** for governance at scale.\n\nThis matters operationally: instead of stitching together your own monitoring and alerting pipelines for your ingress layer, you inherit the same observability stack you already use for the rest of Azure.\n\n### And the expected bases are covered\n\nBeyond the architectural advantages, Application Gateway for Containers delivers the routing capabilities you'd expect from a modern gateway:\n\n- **Support for both Ingress and Gateway API** - migrate incrementally without a hard cutover.\n- **Traffic splitting and weighted round robin** - enable canary deployments and progressive rollouts.\n- **Mutual authentication (mTLS)** - secure service-to-service communication.\n- **Near real-time configuration updates** - pod, route, and probe changes propagate in seconds, not minutes.\n- **Flexible deployment strategies** - manage the Azure resource lifecycle via ARM/Bicep/Terraform, or let the ALB Controller handle it entirely via Kubernetes CRDs.\n\nNo gaps, no surprises, just a solid foundation for production traffic.\n\n## Migrating today: A safe, incremental plan\n\nWhether you're coming from AGIC or ingress-nginx, the practical goal is the same: **reduce risk while maintaining traffic parity**.\n\nA conservative migration pattern looks like this:\n\n1. **Inventory your Ingresses** (hosts, paths, TLS patterns, annotations).\n2. **Stand up Application Gateway for Containers in parallel** (choose BYO vs. managed deployment strategy).\n3. **Convert a low-risk service first**, validate end-to-end.\n4. **Migrate iteratively** (service-by-service), monitor and roll back if needed.\n5. **Cut traffic over** once parity is proven, then retire the old controller.\n\nThis approach is consistent with both:\n\n- Microsoft's goal of \"incremental migration + validation + no downtime\" for AGIC to Application Gateway for Containers migrations.\n- Gateway API guidance that you can run a Gateway API controller alongside Ingress-NGINX to test in isolation.\n\n## The Missing Piece: Translating Years of Annotations (and How Tooling Helps)\n\nFor many teams, the hardest part isn't \"create a Gateway\" - it's **annotation archaeology**.\n\nThat's why Microsoft has built and open-sourced the **Application Gateway for Containers Migration Utility**: a command-line utility that helps translate existing Kubernetes Ingress configuration (including controller-specific annotations) into **Gateway API YAML** for Application Gateway for Containers.\n\nYou can find the tool at [aka.ms/agc/migrationutility](https://aka.ms/agc/migrationutility).\n\n### What the utility does\n\nThe tool is a **command-line utility** that:\n\n- **Reads your existing NGINX Ingress configuration from a cluster** (read-only),\n- **Outputs the equivalent Gateway API YAML**, and\n- Translates AGIC / NGINX annotations into Gateway API resources and (where needed) Application Gateway for Containers-specific custom resources.\n\nThe utility is **fully open source**, and we welcome your contributions! If you encounter missing annotation support, edge cases, or have ideas for improvement, please open an issue or submit a pull request at [aka.ms/agc/migrationutility](https://aka.ms/agc/migrationutility). Your feedback helps make the tool better for everyone navigating this migration.\n\n**Important note:** Any migration tool should be used as a *starting point* - the output is meant to be reviewed, tested, and adjusted based on your environment's specifics (auth, WAF rules, TLS policies, edge cases).\n\n## A practical phased rollout checklist\n\nTo make this actionable for teams planning the next few months, here's a simple rollout scaffold:\n\n### Phase 1: Decide your target state\n\n- Choose whether your end state is **Gateway API-first** (recommended) or **Ingress-first** as a short bridge.\n- Choose Application Gateway for Containers deployment strategy:\n- **BYO (Bring Your Own)**: Create and manage Application Gateway for Containers via Azure Portal, CLI, or Terraform, then reference it in Kubernetes. Best when your CI/CD pipelines already manage Azure resource lifecycle.\n- **Managed by ALB Controller**: The in-cluster ALB Controller handles Application Gateway for Containers lifecycle based on Kubernetes CRDs. Best when you want a fully Kubernetes-native experience.\n\n### Phase 2: Stand up the parallel path\n\n- Deploy ALB Controller.\n- Create Application Gateway for Containers using your chosen strategy.\n- Create a test Gateway + HTTPRoute for a single service.\n\n### Phase 3: Convert + validate incrementally\n\n- Use translation tooling to generate initial Gateway API resources.\n- Validate routing parity (hosts, paths, rewrites, headers).\n- Validate security posture (TLS, backend mTLS if needed, policy/WAF).\n- Cut traffic over only when observability and SLOs look equivalent.\n\n## Migrate once - onto the model the ecosystem is backing\n\nThe retirement of the community ingress-nginx controller is forcing planning work across the industry. The best long-term outcome is to migrate once onto the model Kubernetes is actively evolving: **Gateway API**.\n\nFor AKS customers, Microsoft's direction is clear: support continuity for the existing add-on through November 2026 (critical security patches), while investing in the future centered on Gateway API.\n\nThe combination of **Application Gateway for Containers + Gateway API + migration tooling** is meant to reduce friction: pick a supported path forward, adopt the modern API, validate safely, and minimize the number of migrations.\n\n## Further Reading\n\n- [Learn more about Application Gateway for Containers](https://aka.ms/agc)\n- [GitHub Repo for Application Gateway for Containers Migration Utility](https://aka.ms/agc/migrationutility)\n- [Kubernetes: Ingress NGINX Retirement](https://kubernetes.io/blog/2025/11/11/ingress-nginx-retirement/)\n- [AKS Engineering Blog: Application Routing Add-on Update](https://blog.aks.azure.com/2025/11/13/ingress-nginx-update)\n- [Microsoft Learn: Migration Overview (AGIC to AGC)](https://aka.ms/agc/migrate)\n- [Microsoft Learn: Application Gateway for Containers Quickstart (Managed by ALB Controller)](https://learn.microsoft.com/azure/application-gateway/for-containers/quickstart-managed-by-alb-controller)\n- [Microsoft Learn: Application Gateway for Containers Quickstart (Bring Your Own Deployment)](https://learn.microsoft.com/azure/application-gateway/for-containers/quickstart-bring-your-own-deployment)",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Link": "https://techcommunity.microsoft.com/t5/azure-architecture-blog/from-ingress-to-gateway-api-a-pragmatic-path-forward-and-why-it/ba-p/4489779",
  "ProcessedDate": "2026-01-29 00:06:32",
  "OutputDir": "_community",
  "Title": "From Ingress to Gateway API: A pragmatic path forward (and why it matters now)",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "FeedName": "Microsoft Tech Community",
  "Tags": [],
  "Author": "Jack Stromberg"
}
