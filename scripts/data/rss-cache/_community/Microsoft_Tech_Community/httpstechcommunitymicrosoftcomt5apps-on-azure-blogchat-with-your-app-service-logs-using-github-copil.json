{
  "Description": "## The Problem\n\nWe know that logs and observability on App Service can be tricky—it's feedback we hear from customers all the time. There are many sources of information: Kudu container logs, Log Analytics tables (AppServiceHTTPLogs, ConsoleLogs, PlatformLogs, AppLogs), deployment logs, metrics, and more. It's not always obvious where to look, especially when you're troubleshooting under pressure.\n\nToday, debugging production issues often involves:\n\n1. Opening the Azure Portal\n2. Figuring out which blade or log source has the information you need\n3. Navigating to Log Analytics and remembering (or searching for) the right KQL syntax\n4. Interpreting results and manually correlating across multiple log tables\n5. Repeating this process until you find the root cause\n\nThis proof-of-concept is one of our attempts to simplify this experience, **using AI to bridge the gap between your question and the answer**—no matter where that answer lives.\n\nWhat if you could just ask: *\"Why did my app stop?\"* and get an answer without ever having to leave your IDE or terminal?\n\n## The Solution: App Service Observability MCP Server\n\nWe've built a proof-of-concept [MCP (Model Context Protocol)](https://modelcontextprotocol.io/) server that exposes App Service observability tools directly to AI assistants like GitHub Copilot in VS Code. It can be accessed from your preferred IDE like VS Code, or directly in your CLI such as GitHub Copilot CLI or Claude Code. You now don't even have to leave your coding environment to get answers to your App Service issues.\n\n**Key capabilities:**\n\n- **Query logs** from Log Analytics (HTTP logs, Console logs, Platform logs)\n- **Fetch container logs** directly from Kudu (no setup required!)\n- **Analyze HTTP errors** grouped by status code and endpoint\n- **Find slow requests** exceeding latency thresholds\n- **Diagnose deployment issues** — automatically correlate deploys with startup failures and errors\n- **Check logging setup** — runtime-specific recommendations (Python, Node.js, .NET, Java)\n- **View deployment history** and correlate with issues\n- **Investigate container restarts** and identify root causes\n\n## Demo\n\nTo see how the tool works, here are a series of screenshots going over a real-world scenario where a deployment issue breaks an app. The first screenshot is from when the app was functioning with no issues. You can see the tool calls one of MCP tools to get the app info.\n\n![]()\n\nI then asked if there were any issues. It found a couple issues early on, but they were all transient and after reviewing logs and errors, it determined the app was functional.\n\n![]()\n\nI then introduced a bug into my app and redeployed. I changed the name of a reference to a config file to one that didn't exist, thereby causing the app to crash because it was trying to load a file that didn't exist. GitHub Copilot was easily able to pick up the issue based on the deployment logs tooling. Also, because GitHub Copliot has direct access to my codebase for the app it was analyzing, it was able to see that the file that I was referencing didn't exist and knew what to change it to to get the app working again. This is one of the benefits of running this tool locally alongside your codebase - in addition to the tooling, it can also keep an eye on your codebase. Now if you've ever used GitHub Copilot to help deploy one of your apps, you may know that it can natively make calls using the Azure CLI for example to pull logs. But in my experience, these actions don't always work, take multiple attempts, and take a significant amount of time to complete. With the tooling and skills here, this operation becomes seamless because the agent knows exactly what to do and how to do it. It takes away the guesswork and multiple attempts that an agent without this tool would have to go through.\n\nIn the following screenshot, I asked why the deployment was taking so long. Usually a deployment with azd for an app like the demo app here takes under a minute, so I wanted it to help me understand what the delay was caused by. Within a couple seconds, it was able to pickup the bug I introduced.\n\n![]()\n\nLastly, I then asked it to correlate the error with a deployment. One of the major problem areas our customers have is determining which deployment led to a specific error. We've built a tool into this feature that can correlate deployements and errors. Here's what the tool found. You can see I did a couple deployments with config file names that didn't exist. The tool was able to pinpoint the exact deployments that caused the issue and also tell me what to change to remediate the issue. This is a major benefit that was only possible with the help of AI and it's reasoning capabilities.\n\n![]()\n\n## How It Works\n\nThe MCP server sits between your AI assistant and Azure, translating natural language requests into API calls:\n\n![]()\n\n**Important:** Some tools require Log Analytics diagnostic settings to be enabled, but `get_recent_logs` and `get_deployments` work out of the box by calling Kudu and ARM directly.\n\n## Security: Your Credentials, Your Access\n\nA common question when connecting AI tools to cloud resources: *\"What access does this have?\"*\n\nThe MCP server here uses `DefaultAzureCredential` from the Azure SDK, which means it leverages your existing Azure identity—typically from `az login`. **It can only access resources you already have permission to access.** There are no stored secrets, no service principals with elevated privileges, and no additional credentials required.\n\nIn other words: if you could run the investigation yourself in the portal or via Azure CLI, the MCP server can do it. If you don't have access to a resource, neither does the server.\n\nThis design ensures:\n\n- **No privilege escalation** — The AI operates with your exact permissions\n- **Existing RBAC applies** — Your organization's access controls are respected\n- **Audit trail intact** — All API calls use your identity and appear in Azure activity logs\n\n**Looking ahead:** For production scenarios with fully autonomous agents (running unattended or on a schedule), you'd want to apply least-privilege principles—create a dedicated service principal or managed identity with only the specific permissions needed (e.g., Reader on the App Service, Log Analytics Reader on the workspace). This limits blast radius and follows security best practices for any automated system accessing cloud resources.\n\n## The Agent Skill: Domain Expertise for Debugging\n\nBeyond just exposing tools, we've included an **Agent Skill** file ([SKILL.md](https://github.com/seligj95/app-service-observability-agent/blob/main/SKILL.md%29)) that gives the AI domain expertise for App Service debugging.\n\n### What's an Agent Skill?\n\n[Agent Skills](https://agentskills.io) are markdown files that provide structured knowledge to AI assistants. When GitHub Copilot has access to our SKILL.md, it gains:\n\n- **Debugging workflows** — Step-by-step approaches for investigating issues\n- **Common error patterns** — OOM crashes, Always On issues, HTTP 500/503 errors\n- **KQL query templates** — Ready-to-use queries for each scenario\n- **SKU reference** — Which features are available on each pricing tier\n- **Best practices** — How to present findings with actionable recommendations\n\n### Tools + Knowledge = Better Debugging\n\nThe MCP tools and Agent Skill work together:\n\n| **Component** | **Role** | | --- | --- | | MCP Tools | Fetch real data from your Azure resources | | Agent Skill | Interpret results and guide investigations |\n\nFor example, when investigating a container restart, the Agent Skill teaches Copilot to:\n\n1. Check for OOM patterns in platform logs\n2. Look for crash loops vs. graceful terminations\n3. Consider Always On settings based on the SKU\n4. Provide the right `az` command to fix the issue\n\n## Example: Investigating a Container Stop\n\nHere's a real conversation showing AI-assisted debugging:\n\n> >\n> **User:** \"Show me the recent logs\"\n> > >\n> **Copilot:** *calls get\\_recent\\_logs*\n> > >\n> 2026-01-30T19:52:42Z Container start method called.\n> > >\n> 2026-01-30T19:52:43Z Container is running.\n> > >\n> 2026-01-30T19:52:57Z Site started.\n> > >\n> 2026-01-30T19:53:17Z Container is terminating. Grace period: 5 seconds.\n> > >\n> 2026-01-30T19:53:22Z Site stopped.\n> > >\n> **Copilot:** The site started but stopped after 20 seconds. Want me to investigate?\n> > >\n> **User:** \"Please investigate\"\n> > >\n> **Copilot:** *calls check\\_diagnostics, get\\_http\\_errors, query\\_logs, get\\_app\\_info*\n> > >\n> **Root Cause:** Your container is stopping because **\"Always On\" is disabled**. With low traffic (only 14 requests in 24 hours), App Service terminates idle containers to save resources.\n> > >\n> **Evidence:**\n>\n> - ✅ No errors in platform or application logs\n> - ✅ No HTTP 5xx errors\n> - Container terminated gracefully (not a crash)\n> > >\n> **Fix:**\n> >\n> - az webapp config set --name your-app --resource-group your-rg --always-on true\n>\n> Note: Requires Basic tier or higher.\n\nNo portal. No manual KQL. Just ask and get answers.\n\n## Getting Started\n\n### Prerequisites\n\n- Node.js 20+\n- Azure CLI (`az login` for authentication)\n- VS Code with GitHub Copilot\n\n### Installation\n\n- git clone https://github.com/seligj95/app-service-observability-agent.git\ncd app-service-observability-agent npm install && npm run build\n\n### Configure VS Code\n\nCreate `.vscode/mcp.json` in your workspace:\n- {\n\"servers\": { \"appservice-logs\": { \"command\": \"node\", \"args\": [\"/path/to/app-service-observability-agent/dist/index.js\"], \"type\": \"stdio\", \"env\": { \"AZURE\\_SUBSCRIPTION\\_ID\": \"your-subscription-id\", \"AZURE\\_RESOURCE\\_GROUP\": \"your-resource-group\", \"AZURE\\_APP\\_NAME\": \"your-app-name\" } } } }\n\nReload VS Code, click \"Start\" next to the server, and start chatting with Copilot about your App Service!\n\n## What's Next?\n\nThis is a **proof-of-concept** demonstrating what an App Service AI observability tool could look like. We're exploring how this pattern could become a first-class feature of the platform.\n\nImagine a future where every App Service has a built-in MCP endpoint for observability: *https://my-app.scm.azurewebsites.net/mcp*.\n\nStay tuned for part 2 of this blog where we will show how to host this tool on App Service so that not just you, but you're whole team can leverage this tool for your workloads.\n\n## Try It Out\n\n- **GitHub Repo:** [github.com/seligj95/app-service-observability-agent](https://github.com/seligj95/app-service-observability-agent)\n- **Agent Skill:** Check out [SKILL.md](https://github.com/seligj95/app-service-observability-agent/blob/main/SKILL.md) for the debugging knowledge base\n\nWe'd love your feedback! Use the comments below or open an issue or PR if you have ideas for additional tools or debugging patterns.",
  "PubDate": "2026-02-06T16:51:33+00:00",
  "OutputDir": "_community",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Title": "Chat with Your App Service Logs Using GitHub Copilot",
  "Author": "jordanselig",
  "EnhancedContent": "## TL;DR: We built an open-source MCP server that lets GitHub Copilot (and other AI assistants) directly query your App Service logs, analyze errors, and help you debug issues—all through natural language conversation.\n\n## The Problem\n\nWe know that logs and observability on App Service can be tricky—it's feedback we hear from customers all the time. There are many sources of information: Kudu container logs, Log Analytics tables (AppServiceHTTPLogs, ConsoleLogs, PlatformLogs, AppLogs), deployment logs, metrics, and more. It's not always obvious where to look, especially when you're troubleshooting under pressure.\n\nToday, debugging production issues often involves:\n\n1. Opening the Azure Portal\n2. Figuring out which blade or log source has the information you need\n3. Navigating to Log Analytics and remembering (or searching for) the right KQL syntax\n4. Interpreting results and manually correlating across multiple log tables\n5. Repeating this process until you find the root cause\n\nThis proof-of-concept is one of our attempts to simplify this experience, **using AI to bridge the gap between your question and the answer**—no matter where that answer lives.\n\nWhat if you could just ask: *\"Why did my app stop?\"* and get an answer without ever having to leave your IDE or terminal?\n\n## The Solution: App Service Observability MCP Server\n\nWe've built a proof-of-concept [MCP (Model Context Protocol)](https://modelcontextprotocol.io/) server that exposes App Service observability tools directly to AI assistants like GitHub Copilot in VS Code. It can be accessed from your preferred IDE like VS Code, or directly in your CLI such as GitHub Copilot CLI or Claude Code. You now don't even have to leave your coding environment to get answers to your App Service issues.\n\n**Key capabilities:**\n\n- **Query logs** from Log Analytics (HTTP logs, Console logs, Platform logs)\n- **Fetch container logs** directly from Kudu (no setup required!)\n- **Analyze HTTP errors** grouped by status code and endpoint\n- **Find slow requests** exceeding latency thresholds\n- **Diagnose deployment issues** — automatically correlate deploys with startup failures and errors\n- **Check logging setup** — runtime-specific recommendations (Python, Node.js, .NET, Java)\n- **View deployment history** and correlate with issues\n- **Investigate container restarts** and identify root causes\n\n## Demo\n\nTo see how the tool works, here are a series of screenshots going over a real-world scenario where a deployment issue breaks an app. The first screenshot is from when the app was functioning with no issues. You can see the tool calls one of MCP tools to get the app info.\n\nI then asked if there were any issues. It found a couple issues early on, but they were all transient and after reviewing logs and errors, it determined the app was functional.\n\nI then introduced a bug into my app and redeployed. I changed the name of a reference to a config file to one that didn't exist, thereby causing the app to crash because it was trying to load a file that didn't exist. GitHub Copilot was easily able to pick up the issue based on the deployment logs tooling. Also, because GitHub Copliot has direct access to my codebase for the app it was analyzing, it was able to see that the file that I was referencing didn't exist and knew what to change it to to get the app working again. This is one of the benefits of running this tool locally alongside your codebase - in addition to the tooling, it can also keep an eye on your codebase. Now if you've ever used GitHub Copilot to help deploy one of your apps, you may know that it can natively make calls using the Azure CLI for example to pull logs. But in my experience, these actions don't always work, take multiple attempts, and take a significant amount of time to complete. With the tooling and skills here, this operation becomes seamless because the agent knows exactly what to do and how to do it. It takes away the guesswork and multiple attempts that an agent without this tool would have to go through.\n\nIn the following screenshot, I asked why the deployment was taking so long. Usually a deployment with azd for an app like the demo app here takes under a minute, so I wanted it to help me understand what the delay was caused by. Within a couple seconds, it was able to pickup the bug I introduced.\n\nLastly, I then asked it to correlate the error with a deployment. One of the major problem areas our customers have is determining which deployment led to a specific error. We've built a tool into this feature that can correlate deployements and errors. Here's what the tool found. You can see I did a couple deployments with config file names that didn't exist. The tool was able to pinpoint the exact deployments that caused the issue and also tell me what to change to remediate the issue. This is a major benefit that was only possible with the help of AI and it's reasoning capabilities.\n\n## How It Works\n\nThe MCP server sits between your AI assistant and Azure, translating natural language requests into API calls:\n\n**Important:** Some tools require Log Analytics diagnostic settings to be enabled, but `get_recent_logs` and `get_deployments` work out of the box by calling Kudu and ARM directly.\n\n## Security: Your Credentials, Your Access\n\nA common question when connecting AI tools to cloud resources: *\"What access does this have?\"*\n\nThe MCP server here uses `DefaultAzureCredential` from the Azure SDK, which means it leverages your existing Azure identity—typically from `az login`. **It can only access resources you already have permission to access.** There are no stored secrets, no service principals with elevated privileges, and no additional credentials required.\n\nIn other words: if you could run the investigation yourself in the portal or via Azure CLI, the MCP server can do it. If you don't have access to a resource, neither does the server.\n\nThis design ensures:\n\n- **No privilege escalation** — The AI operates with your exact permissions\n- **Existing RBAC applies** — Your organization's access controls are respected\n- **Audit trail intact** — All API calls use your identity and appear in Azure activity logs\n\n**Looking ahead:** For production scenarios with fully autonomous agents (running unattended or on a schedule), you'd want to apply least-privilege principles—create a dedicated service principal or managed identity with only the specific permissions needed (e.g., Reader on the App Service, Log Analytics Reader on the workspace). This limits blast radius and follows security best practices for any automated system accessing cloud resources.\n\n## The Agent Skill: Domain Expertise for Debugging\n\nBeyond just exposing tools, we've included an **Agent Skill** file ([SKILL.md](https://github.com/seligj95/app-service-observability-agent/blob/main/SKILL.md%29)) that gives the AI domain expertise for App Service debugging.\n\n### What's an Agent Skill?\n\n[Agent Skills](https://agentskills.io) are markdown files that provide structured knowledge to AI assistants. When GitHub Copilot has access to our SKILL.md, it gains:\n\n- **Debugging workflows** — Step-by-step approaches for investigating issues\n- **Common error patterns** — OOM crashes, Always On issues, HTTP 500/503 errors\n- **KQL query templates** — Ready-to-use queries for each scenario\n- **SKU reference** — Which features are available on each pricing tier\n- **Best practices** — How to present findings with actionable recommendations\n\n### Tools + Knowledge = Better Debugging\n\nThe MCP tools and Agent Skill work together:\n\n| **Component** | **Role** | | --- | --- | | MCP Tools | Fetch real data from your Azure resources | | Agent Skill | Interpret results and guide investigations |\n\nFor example, when investigating a container restart, the Agent Skill teaches Copilot to:\n\n1. Check for OOM patterns in platform logs\n2. Look for crash loops vs. graceful terminations\n3. Consider Always On settings based on the SKU\n4. Provide the right `az` command to fix the issue\n\n## Example: Investigating a Container Stop\n\nHere's a real conversation showing AI-assisted debugging:\n\n> >\n> **User:** \"Show me the recent logs\"\n> > >\n> **Copilot:** *calls get\\_recent\\_logs*\n> > >\n> 2026-01-30T19:52:42Z Container start method called.\n> > >\n> 2026-01-30T19:52:43Z Container is running.\n> > >\n> 2026-01-30T19:52:57Z Site started.\n> > >\n> 2026-01-30T19:53:17Z Container is terminating. Grace period: 5 seconds.\n> > >\n> 2026-01-30T19:53:22Z Site stopped.\n> > >\n> **Copilot:** The site started but stopped after 20 seconds. Want me to investigate?\n> > >\n> **User:** \"Please investigate\"\n> > >\n> **Copilot:** *calls check\\_diagnostics, get\\_http\\_errors, query\\_logs, get\\_app\\_info*\n> > >\n> **Root Cause:** Your container is stopping because **\"Always On\" is disabled**. With low traffic (only 14 requests in 24 hours), App Service terminates idle containers to save resources.\n> > >\n> **Evidence:**\n>\n> - ✅ No errors in platform or application logs\n> - ✅ No HTTP 5xx errors\n> - Container terminated gracefully (not a crash)\n> > >\n> **Fix:**\n> > > >\n> ```\n> az webapp config set --name your-app --resource-group your-rg --always-on true\n> ```\n> >\n> Note: Requires Basic tier or higher.\n> >\n\nNo portal. No manual KQL. Just ask and get answers.\n\n## Getting Started\n\n### Prerequisites\n\n- Node.js 20+\n- Azure CLI (`az login` for authentication)\n- VS Code with GitHub Copilot\n\n### Installation\n\n``` git clone https://github.com/seligj95/app-service-observability-agent.git cd app-service-observability-agent npm install && npm run build ```\n\n### Configure VS Code\n\nCreate `.vscode/mcp.json` in your workspace:\n\n``` { \"servers\": { \"appservice-logs\": { \"command\": \"node\", \"args\": [\"/path/to/app-service-observability-agent/dist/index.js\"], \"type\": \"stdio\", \"env\": { \"AZURE_SUBSCRIPTION_ID\": \"your-subscription-id\", \"AZURE_RESOURCE_GROUP\": \"your-resource-group\", \"AZURE_APP_NAME\": \"your-app-name\" } } } } ```\n\nReload VS Code, click \"Start\" next to the server, and start chatting with Copilot about your App Service!\n\n## What's Next?\n\nThis is a **proof-of-concept** demonstrating what an App Service AI observability tool could look like. We're exploring how this pattern could become a first-class feature of the platform.\n\nImagine a future where every App Service has a built-in MCP endpoint for observability: *https://my-app.scm.azurewebsites.net/mcp*.\n\nStay tuned for part 2 of this blog where we will show how to host this tool on App Service so that not just you, but you're whole team can leverage this tool for your workloads.\n\n## Try It Out\n\n- **GitHub Repo:** [github.com/seligj95/app-service-observability-agent](https://github.com/seligj95/app-service-observability-agent)\n- **Agent Skill:** Check out [SKILL.md](https://github.com/seligj95/app-service-observability-agent/blob/main/SKILL.md) for the debugging knowledge base\n\nWe'd love your feedback! Use the comments below or open an issue or PR if you have ideas for additional tools or debugging patterns.\n\nUpdated Feb 06, 2026\n\nVersion 1.0\n\n[azure app service](/tag/azure%20app%20service?nodeId=board%3AAppsonAzureBlog)\n\n[web apps](/tag/web%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[jordanselig&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0xMTg1ODUyLTQwNTU5Mmk4NTY0MjQ3RTE3NURDNzJC?image-dimensions=50x50)](/users/jordanselig/1185852) [jordanselig](/users/jordanselig/1185852) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined October 14, 2021\n\n[View Profile](/users/jordanselig/1185852)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/chat-with-your-app-service-logs-using-github-copilot/ba-p/4491573",
  "FeedName": "Microsoft Tech Community",
  "ProcessedDate": "2026-02-06 17:16:24",
  "Tags": []
}
