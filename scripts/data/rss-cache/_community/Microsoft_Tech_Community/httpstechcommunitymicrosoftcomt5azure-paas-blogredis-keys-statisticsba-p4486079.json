{
  "ProcessedDate": "2026-01-21 16:07:43",
  "Tags": [],
  "FeedName": "Microsoft Tech Community",
  "EnhancedContent": "## Collect Redis Key TTL and Key sizes\n\nRedis Keys statistics including Key Time-to-Live (TTL) statistics and Key sizes are useful for troubleshooting cache usage and performance, from client side.\n\n**Key Time-to-Live (TTL):**\n\nTTL may have impact on memory usage and memory available on Redis services.\n\nData Loss on Redis services may happened unexpectedly due to some issue on backend, but may also happen due to Memory eviction policy, or Time-to-Live (TTL) expired. Memory eviction policy may remove some keys from Redis service, but only when used capacity (the space used by Redis keys) reach 100% on memory available.\n\nNot having any unexpected issue on Redis backend side or not reaching the maximum memory available, the only reason for having some keys removed from cache is due to TTL value.\n\n- TTL may not be defined at all, and in that case the key remains in the cache forever (persistent)\n- TTL can be set while setting a new key\n- TTL can be set / re-set later after key creation\n\nTTL is defined in seconds or milliseconds, or with a negative value:\n\n- **-1**, the key exists but has no expiration (it’s persistent); this happens when the TTL was not defined or it was removed using PERSIST command\n- **-2**, if the key does not exist.\n- any other value\n\nRelated commands:\n\n- **SET key1 value1 EX 60**- defines TTL as 60 seconds\n- **SET key1 value1 PX 60000** - defines TTL as 60000 milliseconds (60 seconds)\n- **EXPIRE key1 60** - Set a timeout of 60 seconds on key1\n- **TTL key1** - returns the current TTL value, in seconds\n- **PTTL key1** - returns the current TTL value, in milliseconds\n- **PERSIST key1** removes TTL from that key and make the key persistent\n\nNotes:\n\n- TTL counts down in real time, but Redis expiration is **lazy + active**, so exact timing isn’t guaranteed to the millisecond.\n- A TTL of 0 is basically a race condition, that usually are not seen, it because the key expires immediately.\n- EXPIRE key 0 deletes the key right away.\n\nThere is no guarantee the deletion happens exactly at expiration time. Redis **lazy + active** expiration means the key is checked only when someone touches it (**lazy**), but to avoid memory filling up with expired junk, Redis also runs a background job to periodically scan a subset of keys and delete the expired ones (**active**). So, some expired keys may survive a bit longer, not accessible anymore but still im memory.\n\nExample Redis lazy:\n\n- at 11:59:00 **SET key1 value1** **EX 60** - 60 seconds expiration time\n- key1 expires at 12:00:00\n- no one accesses it until 12:00:05 - when someone try to access key1 at 12:00:05, Redis identify the key1 expired and delete it.\n\nExample Redis active:\n\n- for the same key1, after 12:00:00. if during the periodically background job Redis scan the subset of keys containing key1, that key1 will be actively deleted.\n\nFor that reason, we may see some higher memory usage than the real memory used by active keys in the cache. For more information about Redis commands, check [Redis Inc - Commands](https://redis.io/docs/latest/commands/)\n\n**Key Sizes:**\n\nLarge key value sizes in the cache, may have high impact on Redis performance. Redis service is designed to 1KB response size, and Microsoft recommends to use up to 100KB on Azure Redis services, to get a better performance. Redis response size may not be exactly the same as key size, as Response size is the sum of the response from each operation sent to Redis. While the response size can be the size of only one key requested (like GET), we can see very often response size being a sum of more than one key, as result of multikey operations (like MGET and others).\n\nThe scope of this article is the focus on each key size; so, we will not discuss on this article the implications of multikey commands.\n\nBy design Redis service is a single thread system per shard, and this is not a Microsoft/Azure limitation but a Redis design feature. To be very quick on processing requests, Redis is optimized to work and process small keys, and for that is more efficient using a single thread instead of the need of context switching. In a multi threaded system, context switching happens when the processor stops executing one thread and starts executing another. When that happens, the OS saves the current thread’s state (registers, program counter, stack pointer, etc.) and restores the state of the next thread. To save time on that process, Redis service is designed to run in a single thread system.\n\nDue to the single thread nature, all operations sent to Redis service, are waiting in a queue to be processed. To minimize latency, all keys must remain small so they can be processed efficiently and responses can be transmitted to the client quickly over the network.\n\nFor that reason, it's important to understand the key sizes we have on our Redis service, and maintain all keys as small as possible.\n\n**Scripts Provided**\n\nTo help on identifying some specific TTL values and Keys sizes in a Redis cache, two solutions are provided below:\n\n**1. Get Key statistics** - that scans all cache and return only the amount of Redis keys with:\n\n- - Number of keys with **TTL** no set\n- Number of keys with **TTL** higher or equal to a user defined TTL threshold\n- Number of keys with **TTL** lower than a user defined TTL threshold\n- Number of keys with value **size** higher or equal than a user defined Size threshold\n- Number of keys with value **size** lower than a user defined Size threshold\n- **Total** number of keys in the cache.\n- It also includes start and end time, and the total time spent on the keys scan.\n\n**2. List Key Names** - this script returns a list of Redis Keys names, based on parameters provided:\n\n- - No **TTL** set, or\n- **TTL** higher or equal to a user defined TTL threshold, or\n- **TTL** lower than to a user defined TTL threshold\n- Key value **size** higher or equal than a user defined Size threshold, or\n- Key value **size** lower than a user defined Size threshold\n- **Total** number of keys in the cache\n- It also includes start and end time, and the total time spent on the keys scan.\n\n**WARNING:**\n\nDue to the need to read all keys in the cache, both solutions can cause high workload on Redis side, specially for high datasets on the cache, with high number of keys. Both solutions are using LUA script that runs on Redis side, and depending on the amount of keys in the cache, may block all other commands to be processed, while the script is running. The duration time on the output from each script run, may help to identify the impact of the scripts to run. Run it carefully and do some tests first on your developing environment, before using in a production.\n\n| **1- Get Key statistics** | | --- |\n\nTo get Redis key statistics, we use Linux Bash shell and Redis-cli tool to run LUA script on Redis side, to get TTL values and sizes from each key. This solution is very fast, but needs to scan all keys in the cache during the LUA script run. This may block Redis to process other requests, due to the single-thread nature of Redis service.\n\nThe below script scans all cache and return only the amount of Redis keys with:\n\n- - Number of keys with **TTL** no set\n- Number of keys with **TTL** higher or equal to a user defined TTL threshold\n- Number of keys with **TTL** lower than a user defined TTL threshold\n- Number of keys with value **size** higher or equal than a user defined Size threshold\n- Number of keys with value **size** lower than a user defined Size threshold\n- **Total** number of keys in the cache.\n- It also includes start and end time, and the total time spent on the keys scan.\n\n**Output:**\n\n> >\n> ========================================================\n> Scanning number of keys with TTL threshold 100 Seconds, and Key size threshold 500 Bytes\n> Start time: dd-mm-YY 18:12:15\n> -----------------------\n> Total keys scanned: 1227\n> ------------\n> TTL not set : 2\n> TTL &gt;= 100 seconds: 1225\n> TTL &lt; 100 seconds: 0\n> TTL invalid/error : 0\n> Non existent key : 0\n> ------------\n> Keys with Size &gt;= 500 Bytes: 1225\n> Keys with Size &lt; 500 Bytes: 2\n> Keys with invalid Size : 0\n> ------------------------\n> End time: dd-mm-YY 19:12:16\n> Duration : 0 days 00:00:00.630\n> ========================================================\n> >\n\n**How to run:**\n\n- create the below **getKeyStats.sh** and **getKeyStats** **.lua** files on same folder, on your Linux environment (Ubuntu 20.04.6 LTS used)\n- give permissions to run Shell script, with command **chmod 700** **getKeyStats** **.sh**\n- Call the script using the syntax:\n\n> >\n> ./getKeyStats.sh host password [port] [ttl\\_threshold] [size\\_threshold]\n> >\n\n**Script parameters:**\n\n- **host** (mandatory) : the URI for the cache\n- **password** (mandatory) : the Redis access key from the cache\n- **port** (optional - default 10000) : TCP port used to access the cache\n- **ttl\\_threshold** (optional - default 600 - 10 minutes) : Key TTL threshold (in seconds) to be used on the results (use -1 to 1 to get Keys with no TTL set)\n- **size\\_threshold** (optional - default 102400 - 100KB) : Key Size threshold to be used on the results\n\n**Tested with:**\n\n- Ubuntu 20.04.6 LTS\n- redis-cli -v\nredis-cli 7.4.2\n- Redis services:\n- Azure Managed Redis Balanced B0 OSSMode\n- Azure Cache for Redis Standard C1\n\n**getKeyStats.sh**\n\n``` #!/usr/bin/env bash #============================== LUA script version =================\n# Linux Bash Script to get statistics from Redis Keys TTL values and Key value sizes\n# It returns the Number of:\n# - keys with TTL no set\n# - keys with TTL higher or equal to TTL_treshold\n# - keys with TTL lower TTL_threshold\n# - keys with value size higher or equal than Size_threshold\n# - keys with value size lower than Size_threshold\n# - total number of keys in the cache.\n#-------------------------------------------------------\n# WARNING:\n# It uses LUA script to run on Redis server side.\n# Use it carefully, during low Redis workoads.\n# Do your tests first on a Dev environment, before use it on production.\n#-------------------------------------------------------\n# It requires :\n# redis-cli v7 or above\n#--------------------------------------------------------\n# Usage:\n# getRedisTTL.sh <cacheuri> <cacheaccesskey> [<accessport>(10000)] [<ttl_treashold>(600)] [<size_threshold>(102400)]\n#========================================================\n\n#------------------------------------------------------\n# To use non-ssl port requites to remove --tls parameter from Redis-cli command below\n#------------------------------------------------------\n\n# Parameters\nREDIS_HOST=\"${1:?Usage: $0 <host> <password> [port] [ttl_threshold] [Size_Threshold]}\" REDISCLI_AUTH=\"${2:?Usage: $0 <host> <password> [port] [ttl_threshold] [Size_Threshold]}\" REDIS_PORT=\"${3:-10000}\" # 10000 / 6380 / 6379 REDIS_TTL_THRESHOLD=\"${4:-600}\" # 10 minutes REDIS_SIZE_THRESHOLD=\"${5:-102400}\" # 100KB\n\n# Port number must be numeric\nif ! [[ \"$REDIS_PORT\" =~ ^[0-9]+$ ]]; then echo \"ERROR: Redis Port must be numeric\" exit 1 fi\n\n# TTL threshold must be numeric\nif ! [[ \"$REDIS_TTL_THRESHOLD\" =~ ^[0-9]+$ ]]; then echo \"ERROR: TTL threshold must be numeric\" exit 1 fi\n\n# Size threshold must be numeric\nif ! [[ \"$REDIS_SIZE_THRESHOLD\" =~ ^[0-9]+$ ]]; then echo \"ERROR: Size threshold must be numeric\" exit 1 fi\n\necho \"\"\n\necho \"========================================================\" echo \"Scaning number of keys with TTL threshold $REDIS_TTL_THRESHOLD Seconds, and Key size threshold $REDIS_SIZE_THRESHOLD Bytes\"\n\n# Start time\nstart_ts=$(date +%s.%3N) echo \"Start time: $(date \"+%d-%m-%Y %H:%M:%S\")\" echo \"------------------------\"\n\necho \"\"\n\n# Procesing\nresult=$(redis-cli \\ -h \"$REDIS_HOST\" \\ -a \"$REDISCLI_AUTH\" \\ -p \"$REDIS_PORT\" \\ --tls \\ --no-auth-warning \\ --raw \\ --eval getKeyStats.lua , \"$REDIS_TTL_THRESHOLD\" \"$REDIS_SIZE_THRESHOLD\" \\ | tr '\\n' ' ')\n\nread no_ttl nonexist ttl_high ttl_low ttl_invalid size_high size_low size_nil total <<< \"$result\"\n\nif [[ $result == ERR* ]]; then echo \"Redis Lua error:\" echo \"$result\" else echo \"Total keys scanned: $total\" echo \"------------\" echo \"TTL not set : $no_ttl\" echo \"TTL >= $REDIS_TTL_THRESHOLD seconds: $ttl_high\" echo \"TTL < $REDIS_TTL_THRESHOLD seconds: $ttl_low\" echo \"TTL invalid/error : $ttl_invalid\" echo \"Non existent key : $nonexist\" echo \"------------\" echo \"Keys with Size >= $REDIS_SIZE_THRESHOLD Bytes: $size_high\" echo \"Keys with Size < $REDIS_SIZE_THRESHOLD Bytes: $size_low\" echo \"Keys with invalid Size : $size_nil\" fi\n\necho \"\" echo \"------------------------\" end_ts=$(date +%s.%3N) echo \"End time: $(date \"+%d-%m-%Y %H:%M:%S\")\"\n\n# Duration - Extract days, hours, minutes, seconds, milliseconds\nduration=$(awk \"BEGIN {print $end_ts - $start_ts}\") days=$(awk \"BEGIN {print int($duration/86400)}\") hours=$(awk \"BEGIN {print int(($duration%86400)/3600)}\") minutes=$(awk \"BEGIN {print int(($duration%3600)/60)}\") seconds=$(awk \"BEGIN {print int($duration%60)}\") milliseconds=$(awk \"BEGIN {printf \\\"%03d\\\", ($duration - int($duration))*1000}\") echo \"Duration : ${days} days $(printf \"%02d\" \"$hours\"):$(printf \"%02d\" \"$minutes\"):$(printf \"%02d\" \"$seconds\").$milliseconds\" echo \"========================================================\"\n\n```\n\n**getKeyStats.lua**\n\n``` local ttl_threshold = tonumber(ARGV[1]) local size_threshold = tonumber(ARGV[2]) local cursor = \"0\"\n\n-- Counters local no_ttl = 0 local nonexist = 0 local ttl_high = 0 local ttl_low = 0 local ttl_invalid = 0 local size_high = 0 local size_low = 0 local size_nil = 0 local total = 0\n\nrepeat local scan = redis.call(\"SCAN\", cursor, \"COUNT\", 1000) cursor = scan[1] local keys = scan[2] for _, key in ipairs(keys) do\n\nlocal ttl = redis.call(\"TTL\", key) local size = redis.call(\"MEMORY\",\"USAGE\", key) total = total + 1\n\nif ttl == -1 then no_ttl = no_ttl + 1 elseif ttl == -2 then nonexist = nonexist + 1 elseif type(ttl) ~= \"number\" then ttl_invalid = ttl_invalid + 1 elseif ttl >= ttl_threshold then ttl_high = ttl_high + 1 else ttl_low = ttl_low + 1 end\n\nif size == nil then size_nil = size_nil + 1 elseif size >= size_threshold then size_high = size_high + 1 else size_low = size_low + 1 end\n\nend until cursor == \"0\"\n\nreturn { no_ttl, nonexist, ttl_high, ttl_low, ttl_invalid, size_high, size_low, size_nil, total }\n\n```\n\n**Performance:**\n\n> >\n> **Redis service used:**Azure Managed Redis - Balanced B0 - OSSMode\n> > >\n> Scanning number of keys with TTL threshold 600 Seconds, and Key size threshold 102400 Bytes\n> > >\n> **Total keys scanned: 46161**\n> > >\n> TTL not set : 0\n> TTL &gt;= 600 seconds: 46105\n> TTL &lt; 600 seconds: 56\n> TTL invalid/error : 0\n> Non existent key : 0\n> > >\n> Keys with Size &gt;= 102400 Bytes: 0\n> Keys with Size &lt; 102400 Bytes: 46161\n> Keys with invalid Size : 0\n> > >\n> Duration : 0 days **00:00:00.602**\n> # ------------------\n>\n> **Redis service used:** Azure Cache for Redis - Standard - C1\n> > >\n> Scanning number of keys with TTL threshold 100 Seconds, and Key size threshold 500 Bytes\n> > >\n> **Total keys scanned: 1227**\n> > >\n> TTL not set : 2\n> TTL &gt;= 100 seconds: 1225\n> TTL &lt; 100 seconds: 0\n> TTL invalid/error : 0\n> Non existent key : 0\n> > >\n> Keys with Size &gt;= 500 Bytes: 1225\n> Keys with Size &lt; 500 Bytes: 2\n> Keys with invalid Size : 0\n> > >\n> Duration : 0 days **00:00:00.630**# ------------------\n> >\n\n**WARNING:** The above scripts uses LUA script, that runs on Redis side, and may block you normal workload. Use it carefully when have a large number of keys in the cache, and during low workload times.\n\n| **2 - List Key Names** | | --- |\n\nOnce we identify some amount of keys in the cache with some specific threshold, we may want to list that key names. The below script can help on that, and returns a list of Redis Keys names with:\n\n- No **TTL** set\n- **TTL** higher or equal to a user defined TTL threshold\n- **TTL** lower than to a user defined TTL threshold\n- Key value **size** higher or equal than a user defined Size threshold\n- Key value **size** lower than a user defined Size threshold\n- **Total** number of keys in the cache\n- It also includes start and end time, and the total time spent on the keys scan.\n\n**Output:**\n\n> >\n> List all key names with TTL above 100 Seconds, and Key size larger 500 Bytes\n> > >\n> Start time: dd-mm-YY 18:30:22\n> ------------------------\n> 1) \"--------------------------------------\"\n> 2) \"Key\\_1787\\_1022: TTL: 461837 seconds, Size: 1336 Bytes\"\n>             (...)\n> 1551) \"Key\\_1173\\_1022: TTL: 389795 seconds, Size: 1336 Bytes\"\n> 1552) \"--------------------------------------\"\n> 1553) \"Scan completed.\"\n> 1554) \"Total of 1550 keys scanned.\"\n> 1555) \"1225 keys found with TTL &gt;= 100 seconds, and size larger than 500 Bytes\"\n> 1556) \"--------------------------------------\"\n> End time: dd-mm-YY 18:30:22\n> Duration : 0 days 00:00:00.545\n> ========================================================\n> >\n\n**How to run:**\n\n- create the below **listKeys** **.sh** ****file under some folder, on your Linux environment (Ubuntu 20.04.6 LTS used)\n- give permissions to run Shell script, with command **chmod 700** **listKeys** **.sh**\n- Call the script using the syntax:\n\n> >\n> ./listKeys.sh host password [port] [+/-][ttl\\_threshold] [+/-][size\\_threshold]\n> >\n\n**Script parameters:**\n\n- **host**(mandatory) : the URI for the cache\n- **password**(mandatory) : the Redis access key from the cache\n- **port**(optional - default 10000) : TCP port used to access the cache\n- **[+/-]** (optional) before ttl\\_threshold: indicates if we want return keys with lower \"-\", or higher TTL \"+\" or \"\" than ttl\\_threshold\n- **ttl\\_threshold**(optional - default 600 - 10 minutes) : Key TTL threshold (in seconds) to be used on the results (use -1 to get Keys with no TTL set)\n- **[+/-]** (optional) **** before size\\_threshold: indicates if we want return keys with small size \"-\", or large size \"+\" or \"\" than size\\_threshold\n- **size\\_threshold**(optional - default 102400 - 100KB) : Key Size threshold to be used on the results\n\n**Tips:**\n\n- use **ttl\\_threshold** **= -1** to return key names with no TTL (ex: /listKeys.sh [port] **-1** [+/-][size\\_Threshold])\n- use **ttl\\_threshold = 0** to return key names with any TTL (ex: /listKeys.sh [port] **0** [+/-][size\\_Threshold])\n- use **ttl\\_threshold** **= -500** to return key names with TTL below 500 seconds (ex: /listKeys.sh [port] **-500** [+/-][size\\_Threshold])\n- use **ttl\\_threshold** **= 500** to return key names with TTL above or equal to 500 seconds (ex: /listKeys.sh [port] **500** [+/-][size\\_Threshold])\n\n- use **size\\_threshold** **= 0**  to return key names with any size in the cache (ex: /listKeys.sh [port] [+/-][ttl\\_threshold] **0**)\n- use **size\\_threshold** **= -1000**  to return key names with size below 1000 Bytes (ex: /listKeys.sh [port] [+/-][ttl\\_threshold] **-1000**)\n- use **size\\_threshold** **= 1000**  to return key names with size above or equal to 1000 Bytes (ex: /listKeys.sh [port] [+/-][ttl\\_threshold] **1000**)\n\n- use **ttl\\_threshold** **= 0** AND **size\\_threshold** **= 0** to return all key names with any TTL and any size in the cache (ex: /listKeys.sh [port] **0** **0**)\n- use **ttl\\_threshold** **= -1** AND **size\\_threshold** **= 0** to return all key names with no TTL and any size in the cache (ex: /listKeys.sh [port] **-1** **0**)\n\n**Tested with:**\n\n- Ubuntu 20.04.6 LTS\n- redis-cli -v\nredis-cli 7.4.2\n- Redis services:\n- Azure Managed Redis Balanced B0 OSSMode\n- Azure Cache for Redis Standard C1\n\n**listKeys.sh**\n\n``` #!/usr/bin/env bash set -euo pipefail #============================== LUA script version =================\n# Linux Bash Script to list Redis Keys names\n# It returns key names with:\n# - No TTL set\n# - with TTL higher or equal to TTL_treshold\n# - with TTL lower TTL_threshold\n# - with value size higher or equal than Size_threshold\n# - with value size lower than Size_threshold\n# - total number of keys in the cache.\n#-------------------------------------------------------\n# WARNING:\n# It uses LUA script (included on Bash code) to run on Redis server side.\n# Use it carefully, during low Redis workoads.\n# Do your tests first on a Dev environment, before use it on production.\n#-------------------------------------------------------\n# It requires :\n# redis-cli v7 or above\n#--------------------------------------------------------\n# Usage:\n# listKeys.sh <cacheuri> <cacheaccesskey> [<accessport>(10000)] [+/-][<ttl_treashold>(-1)] [+/-][<size_treashold>(102400)]\n#========================================================\n\n#------------------------------------------------------\n# Using non-ssl port requires to remove --tls parameter on Redis-cli command below\n#------------------------------------------------------\n\nsintax=\"<redis_host> <password> [redis_port] [+/-][ttl_threshold] [+/-][size_threshold]\" REDIS_HOST=\"${1:?Usage: $0 $sintax}\" REDISCLI_AUTH=\"${2:?Usage: $0 $sintax}\" REDIS_PORT=\"${3:-10000}\" # Redis port (10000, 6380, 6379) KEYTTL_THRESHOLD=${4:-\"-1\"} # -1, +TTL_threshold, TTL_threashold, -TTL_threshold KEYSIZE_THRESHOLD=\"${5:-102400}\" # +Size_threshold, Size_threashold, -Size_threshold\n\n# Port number must be numeric\nif ! [[ \"$REDIS_PORT\" =~ ^[0-9]+$ ]]; then echo \"ERROR: Redis Port must be numeric\" exit 1 fi\n\n# Check if KEYTTL_THRESHOLD is a valid integer\nif ! [[ \"$KEYTTL_THRESHOLD\" =~ ^[-+]?[0-9]+$ ]]; then echo \"Error: ttl_threshold $KEYTTL_THRESHOLD is not an integer\" exit 1 fi\n\n# Check if KEYSIZE_THRESHOLD is a valid integer\nif ! [[ \"$KEYSIZE_THRESHOLD\" =~ ^[-+]?[0-9]+$ ]]; then echo \"Error: Size_threshold $KEYSIZE_THRESHOLD is not an integer\" exit 1 fi\n\n# Check if TTL Threasold is positive (or zero), or negative\nif [ \"$KEYTTL_THRESHOLD\" -ge 0 ]; then TTLSIGN=\"+\" else TTLSIGN=\"-\" fi\n\n# Check if Size Threshold is positive (or zero), or negative\nif [ \"$KEYSIZE_THRESHOLD\" -ge 0 ]; then SIZESIGN=\"+\" size_text=\"larger\" else SIZESIGN=\"-\" size_text=\"smaler\" fi\n\n# specific with no TTL set\nif [ \"$KEYTTL_THRESHOLD\" -eq -1 ]; then ttl_text=\"No TTL set\" fi if [ \"$KEYTTL_THRESHOLD\" -ge 0 ]; then ttl_text=\"TTL above $KEYTTL_THRESHOLD Seconds\" fi if [ \"$KEYTTL_THRESHOLD\" -lt -1 ]; then ttl_text=\"TTL below ${KEYTTL_THRESHOLD#[-+]} Seconds\" fi\n\n# remove any sign\nKEYTTL_THRESHOLD=\"${KEYTTL_THRESHOLD#[-+]}\" KEYSIZE_THRESHOLD=\"${KEYSIZE_THRESHOLD#[-+]}\"\n\necho \"========================================================\" echo \"List all key names with $ttl_text, and Key size $size_text $KEYSIZE_THRESHOLD Bytes\"\n\n# Start time\nstart_ts=$(date +%s.%3N) echo \"Start time: $(date \"+%d-%m-%Y %H:%M:%S\")\" echo \"------------------------\"\n\necho \"\"\n\n# Procesing\nredis-cli -h \"$REDIS_HOST\" -p \"$REDIS_PORT\" -a \"$REDISCLI_AUTH\" --tls --no-auth-warning EVAL \" local cursor = '0' local ttl_threshold = tonumber(ARGV[1]) -- KEYTTL_THRESHOLD local ttl_sign = ARGV[2] -- TTLSIGN local size_threshold = tonumber(ARGV[3]) -- KEYSIZE_THRESHOLD local size_sign = ARGV[4] -- SIZESIGN local output = {} local count = 0 local totalKeys = 0 local strKeyTTL = '' local strKeySize = '' -- Scanning keys in the cache table.insert(output, '--------------------------------------')\n\nrepeat local res = redis.call('SCAN', cursor, 'COUNT', 100) cursor = res[1]\n\nfor _, k in ipairs(res[2]) do local ttl = redis.call('TTL', k) local size = redis.call('MEMORY','USAGE', k) totalKeys = totalKeys + 1\n\nif (size_sign == '+' and size >= size_threshold) or (size_sign == '-' and size < size_threshold) then -- TTL == -1 → no expiration if ttl_sign == '-' and ttl_threshold == 1 then if ttl == -1 then table.insert(output, k .. ': TTL: -1, Size: ' .. size .. ' Bytes') count = count + 1 end\n\n-- TTL comparisons (exclude -1 and -2) else if ttl >= 0 then table.insert(output, k .. ': TTL: ' .. ttl .. ' seconds, Size: ' .. size .. ' Bytes') if ttl_sign == '-' and ttl < ttl_threshold then count = count + 1 elseif ttl_sign == '+' and ttl >= ttl_threshold then count = count + 1 end end end end end until cursor == '0' -- Adding summary to output table.insert(output, '--------------------------------------')\n\nif (size_sign == '+') then strKeySize = 'larger' else strKeySize = 'smaler' end strKeySize = 'size ' .. strKeySize .. ' than ' .. size_threshold .. ' Bytes'\n\nif ttl_sign == '-' and ttl_threshold == 1 then strKeyTTL = 'No TTL' elseif ttl_sign == '-' then strKeyTTL = 'TTL < ' .. ttl_threshold .. ' seconds' elseif ttl_sign == '+' then strKeyTTL = 'TTL >= ' .. ttl_threshold .. ' seconds' end strKeyTTL = ' keys found with ' .. strKeyTTL\n\ntable.insert(output, 'Scan completed.') table.insert(output, 'Total of ' .. totalKeys .. ' keys scanned.') table.insert(output, count .. strKeyTTL .. ', and ' .. strKeySize) table.insert(output, '--------------------------------------')\n\nreturn output \" 0 \"$KEYTTL_THRESHOLD\" \"$TTLSIGN\" \"$KEYSIZE_THRESHOLD\" \"$SIZESIGN\"\n\necho \" \"\n\nend_ts=$(date +%s.%3N) echo \"End time: $(date \"+%d-%m-%Y %H:%M:%S\")\"\n\n# Duration - Extract days, hours, minutes, seconds, milliseconds\nduration=$(awk \"BEGIN {print $end_ts - $start_ts}\") days=$(awk \"BEGIN {print int($duration/86400)}\") hours=$(awk \"BEGIN {print int(($duration%86400)/3600)}\") minutes=$(awk \"BEGIN {print int(($duration%3600)/60)}\") seconds=$(awk \"BEGIN {print int($duration%60)}\") milliseconds=$(awk \"BEGIN {printf \\\"%03d\\\", ($duration - int($duration))*1000}\") echo \"Duration : ${days} days $(printf \"%02d\" \"$hours\"):$(printf \"%02d\" \"$minutes\"):$(printf \"%02d\" \"$seconds\").$milliseconds\" echo \"========================================================\"\n\n```\n\n**Performance:**\n\nThis script is much cleaner and more connection-efficient than the previous one, for the same results. It creates only one connection to Redis service, and all processing is made on Redis side on LUA script. Despite much more efficient, LUA script may block normal workload on Redis, namely having a large dataset, with high number of keys in the cache.\n\n> >\n> **Redis service used:** Azure Managed Redis Balanced B0 OSSMode\n> > >\n> # ------------------\n> Scan completed. Total keys listed: **46005**\n> Duration : 0 days **00:00:01.437**\n> > >\n> # ------------------\n> **Redis service used:**Azure Cache for Redis - Standard - C1\n> Scan completed. Total keys listed: **1225**\n> Duration : 0 days **00:00:00.545**\n> > >\n> # ------------------\n> >\n\n**WARNING:** The above script uses LUA script, that runs on Redis side, and may block you normal workload. Use it carefully when have a large number of keys in the cache, and during low workload times.\n\n| **References** | | --- |\n\n- [Azure Managed Redis](https://learn.microsoft.com/en-us/azure/redis/overview)\n- [Azure Best Practice for Development](https://learn.microsoft.com/en-us/azure/azure-cache-for-redis/cache-best-practices-development)\n- [Redis Inc - Commands](https://redis.io/docs/latest/commands/)\n- [Redis LUA - Lua API reference](https://redis.io/docs/latest/develop/programmability/lua-api/)\n- [Redis Inc - How Redis expires keys](https://redis.io/docs/latest/commands/expire/#how-redis-expires-keys)\n- [Redis CLI](https://redis.io/docs/latest/develop/tools/cli/)\n- [Bash Script](https://www.w3schools.com/bash/bash_script.php)\n- [xargs man page](https://manpages.org/xargs)\n- [awk man page](https://manpages.org/awk)\n\nI hope this can be useful !!!\n\nUpdated Jan 20, 2026\n\nVersion 1.0\n\n[azure cache for redis](/tag/azure%20cache%20for%20redis?nodeId=board%3AAzurePaaSBlog)\n\n[azure redis](/tag/azure%20redis?nodeId=board%3AAzurePaaSBlog)\n\n[!\\[LuisFilipe&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS03NDExOTktMjA4MzgyaTEyNUE1NTQ0RTU0REQ4OTY?image-dimensions=50x50)](/users/luisfilipe/741199) [LuisFilipe](/users/luisfilipe/741199) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined July 27, 2020\n\n[View Profile](/users/luisfilipe/741199)\n\n/category/azure/blog/azurepaasblog [Azure PaaS Blog](/category/azure/blog/azurepaasblog) Follow this blog board to get notified when there's new activity",
  "PubDate": "2026-01-21T15:50:34+00:00",
  "Description": "Redis Keys statistics including Key Time-to-Live (TTL) statistics and Key sizes are useful for troubleshooting cache usage and performance, from client side.\n\n**Key Time-to-Live (TTL):**\n\nTTL may have impact on memory usage and memory available on Redis services.\n\nData Loss on Redis services may happened unexpectedly due to some issue on backend, but may also happen due to Memory eviction policy, or Time-to-Live (TTL) expired. Memory eviction policy may remove some keys from Redis service, but only when used capacity (the space used by Redis keys) reach 100% on memory available.\n\nNot having any unexpected issue on Redis backend side or not reaching the maximum memory available, the only reason for having some keys removed from cache is due to TTL value.\n\n- TTL may not be defined at all, and in that case the key remains in the cache forever (persistent)\n- TTL can be set while setting a new key\n- TTL can be set / re-set later after key creation\n\nTTL is defined in seconds or milliseconds, or with a negative value:\n\n- **-1**, the key exists but has no expiration (it’s persistent); this happens when the TTL was not defined or it was removed using PERSIST command\n- **-2**, if the key does not exist.\n- any other value\n\nRelated commands:\n\n- **SET key1 value1 EX 60** - defines TTL as 60 seconds\n- **SET key1 value1 PX 60000** - defines TTL as 60000 milliseconds (60 seconds)\n- **EXPIRE key1 60** - Set a timeout of 60 seconds on key1\n- **TTL key1** - returns the current TTL value, in seconds\n- **PTTL key1** - returns the current TTL value, in milliseconds\n- **PERSIST key1** removes TTL from that key and make the key persistent\n\nNotes:\n\n- TTL counts down in real time, but Redis expiration is **lazy + active**, so exact timing isn’t guaranteed to the millisecond.\n- A TTL of 0 is basically a race condition, that usually are not seen, it because the key expires immediately.\n- EXPIRE key 0 deletes the key right away.\n\nThere is no guarantee the deletion happens exactly at expiration time. Redis **lazy + active** expiration means the key is checked only when someone touches it (**lazy**), but to avoid memory filling up with expired junk, Redis also runs a background job to periodically scan a subset of keys and delete the expired ones (**active**). So, some expired keys may survive a bit longer, not accessible anymore but still im memory.\n\nExample Redis lazy:\n\n- at 11:59:00 **SET key1 value1** **EX 60** - 60 seconds expiration time\n- key1 expires at 12:00:00\n- no one accesses it until 12:00:05 - when someone try to access key1 at 12:00:05, Redis identify the key1 expired and delete it.\n\nExample Redis active:\n\n- for the same key1, after 12:00:00. if during the periodically background job Redis scan the subset of keys containing key1, that key1 will be actively deleted.\n\nFor that reason, we may see some higher memory usage than the real memory used by active keys in the cache. For more information about Redis commands, check [Redis Inc - Commands](https://redis.io/docs/latest/commands/)\n\n**Key Sizes:**\n\nLarge key value sizes in the cache, may have high impact on Redis performance. Redis service is designed to 1KB response size, and Microsoft recommends to use up to 100KB on Azure Redis services, to get a better performance. Redis response size may not be exactly the same as key size, as Response size is the sum of the response from each operation sent to Redis. While the response size can be the size of only one key requested (like GET), we can see very often response size being a sum of more than one key, as result of multikey operations (like MGET and others).\n\nThe scope of this article is the focus on each key size; so, we will not discuss on this article the implications of multikey commands.\n\nBy design Redis service is a single thread system per shard, and this is not a Microsoft/Azure limitation but a Redis design feature. To be very quick on processing requests, Redis is optimized to work and process small keys, and for that is more efficient using a single thread instead of the need of context switching. In a multi threaded system, context switching happens when the processor stops executing one thread and starts executing another. When that happens, the OS saves the current thread’s state (registers, program counter, stack pointer, etc.) and restores the state of the next thread. To save time on that process, Redis service is designed to run in a single thread system.\n\nDue to the single thread nature, all operations sent to Redis service, are waiting in a queue to be processed. To minimize latency, all keys must remain small so they can be processed efficiently and responses can be transmitted to the client quickly over the network.\n\nFor that reason, it's important to understand the key sizes we have on our Redis service, and maintain all keys as small as possible.\n\n**Scripts Provided**\n\nTo help on identifying some specific TTL values and Keys sizes in a Redis cache, two solutions are provided below:\n\n**1. Get Key statistics** - that scans all cache and return only the amount of Redis keys with:\n\n- - Number of keys with **TTL** no set\n- Number of keys with **TTL** higher or equal to a user defined TTL threshold\n- Number of keys with **TTL** lower than a user defined TTL threshold\n- Number of keys with value **size** higher or equal than a user defined Size threshold\n- Number of keys with value **size** lower than a user defined Size threshold\n- **Total** number of keys in the cache.\n- It also includes start and end time, and the total time spent on the keys scan.\n\n**2. List Key Names** - this script returns a list of Redis Keys names, based on parameters provided:\n\n- - No **TTL** set, or\n- **TTL** higher or equal to a user defined TTL threshold, or\n- **TTL** lower than to a user defined TTL threshold\n- Key value **size** higher or equal than a user defined Size threshold, or\n- Key value **size** lower than a user defined Size threshold\n- **Total** number of keys in the cache\n- It also includes start and end time, and the total time spent on the keys scan.\n\n**WARNING:**\n\nDue to the need to read all keys in the cache, both solutions can cause high workload on Redis side, specially for high datasets on the cache, with high number of keys. Both solutions are using LUA script that runs on Redis side, and depending on the amount of keys in the cache, may block all other commands to be processed, while the script is running. The duration time on the output from each script run, may help to identify the impact of the scripts to run. Run it carefully and do some tests first on your developing environment, before using in a production.\n\n| **1- Get Key statistics** | | --- |\n\nTo get Redis key statistics, we use Linux Bash shell and Redis-cli tool to run LUA script on Redis side, to get TTL values and sizes from each key. This solution is very fast, but needs to scan all keys in the cache during the LUA script run. This may block Redis to process other requests, due to the single-thread nature of Redis service.\n\nThe below script scans all cache and return only the amount of Redis keys with:\n\n- - Number of keys with **TTL** no set\n- Number of keys with **TTL** higher or equal to a user defined TTL threshold\n- Number of keys with **TTL** lower than a user defined TTL threshold\n- Number of keys with value **size** higher or equal than a user defined Size threshold\n- Number of keys with value **size** lower than a user defined Size threshold\n- **Total** number of keys in the cache.\n- It also includes start and end time, and the total time spent on the keys scan.\n\n**Output:**\n\n> >\n> ========================================================\n> Scanning number of keys with TTL threshold 100 Seconds, and Key size threshold 500 Bytes\n> Start time: dd-mm-YY 18:12:15\n> -----------------------\n> Total keys scanned: 1227\n> ------------\n> TTL not set : 2\n> TTL >= 100 seconds: 1225\n> TTL TTL invalid/error : 0\n> Non existent key : 0\n> ------------\n> Keys with Size >= 500 Bytes: 1225\n> Keys with Size Keys with invalid Size : 0\n> ------------------------\n> End time: dd-mm-YY 19:12:16\n> Duration : 0 days 00:00:00.630\n> ========================================================\n> >\n\n**How to run:**\n\n- create the below **getKeyStats.sh** and **getKeyStats** **.lua** files on same folder, on your Linux environment (Ubuntu 20.04.6 LTS used)\n- give permissions to run Shell script, with command **chmod 700** **getKeyStats** **.sh**\n- Call the script using the syntax:\n\n> >\n> ./getKeyStats.sh host password [port] [ttl\\_threshold] [size\\_threshold]\n> >\n\n**Script parameters:**\n\n- **host** (mandatory) : the URI for the cache\n- **password** (mandatory) : the Redis access key from the cache\n- **port** (optional - default 10000) : TCP port used to access the cache\n- **ttl\\_threshold** (optional - default 600 - 10 minutes) : Key TTL threshold (in seconds) to be used on the results (use -1 to 1 to get Keys with no TTL set)\n- **size\\_threshold** (optional - default 102400 - 100KB) : Key Size threshold to be used on the results\n\n**Tested with:**\n\n- Ubuntu 20.04.6 LTS\n- redis-cli -v\nredis-cli 7.4.2\n- Redis services:\n- Azure Managed Redis Balanced B0 OSSMode\n- Azure Cache for Redis Standard C1\n\n**getKeyStats.sh**\n\n- #!/usr/bin/env bash\n#============================== LUA script version =================\n# Linux Bash Script to get statistics from Redis Keys TTL values and Key value sizes\n# It returns the Number of:\n# - keys with TTL no set\n# - keys with TTL higher or equal to TTL\\_treshold\n# - keys with TTL lower TTL\\_threshold\n# - keys with value size higher or equal than Size\\_threshold\n# - keys with value size lower than Size\\_threshold\n# - total number of keys in the cache.\n#-------------------------------------------------------\n# WARNING:\n# It uses LUA script to run on Redis server side.\n# Use it carefully, during low Redis workoads.\n# Do your tests first on a Dev environment, before use it on production.\n#-------------------------------------------------------\n# It requires :\n# redis-cli v7 or above\n#--------------------------------------------------------\n# Usage:\n# getRedisTTL.sh [(10000)] [(600)] [(102400)]\n#========================================================\n\n#------------------------------------------------------\n# To use non-ssl port requites to remove --tls parameter from Redis-cli command below\n#------------------------------------------------------\n\n# Parameters\nREDIS\\_HOST=\"${1:?Usage: $0 [port] [ttl\\_threshold] [Size\\_Threshold]}\" REDISCLI\\_AUTH=\"${2:?Usage: $0 [port] [ttl\\_threshold] [Size\\_Threshold]}\" REDIS\\_PORT=\"${3:-10000}\" # 10000 / 6380 / 6379 REDIS\\_TTL\\_THRESHOLD=\"${4:-600}\" # 10 minutes REDIS\\_SIZE\\_THRESHOLD=\"${5:-102400}\" # 100KB\n\n# Port number must be numeric\nif ! [[ \"$REDIS\\_PORT\" =~ ^[0-9]+$ ]]; then echo \"ERROR: Redis Port must be numeric\" exit 1 fi\n\n# TTL threshold must be numeric\nif ! [[ \"$REDIS\\_TTL\\_THRESHOLD\" =~ ^[0-9]+$ ]]; then echo \"ERROR: TTL threshold must be numeric\" exit 1 fi\n\n# Size threshold must be numeric\nif ! [[ \"$REDIS\\_SIZE\\_THRESHOLD\" =~ ^[0-9]+$ ]]; then echo \"ERROR: Size threshold must be numeric\" exit 1 fi\n\necho \"\"\n\necho \"========================================================\" echo \"Scaning number of keys with TTL threshold $REDIS\\_TTL\\_THRESHOLD Seconds, and Key size threshold $REDIS\\_SIZE\\_THRESHOLD Bytes\"\n\n# Start time\nstart\\_ts=$(date +%s.%3N) echo \"Start time: $(date \"+%d-%m-%Y %H:%M:%S\")\" echo \"------------------------\"\n\necho \"\"\n\n# Procesing\nresult=$(redis-cli \\ -h \"$REDIS\\_HOST\" \\ -a \"$REDISCLI\\_AUTH\" \\ -p \"$REDIS\\_PORT\" \\ --tls \\ --no-auth-warning \\ --raw \\ --eval getKeyStats.lua , \"$REDIS\\_TTL\\_THRESHOLD\" \"$REDIS\\_SIZE\\_THRESHOLD\" \\ | tr '\\n' ' ')\n\nread no\\_ttl nonexist ttl\\_high ttl\\_low ttl\\_invalid size\\_high size\\_low size\\_nil total = $REDIS\\_TTL\\_THRESHOLD seconds: $ttl\\_high\" echo \"TTL = $REDIS\\_SIZE\\_THRESHOLD Bytes: $size\\_high\" echo \"Keys with Size\n\n**getKeyStats.lua**\n- local ttl\\_threshold = tonumber(ARGV[1])\nlocal size\\_threshold = tonumber(ARGV[2]) local cursor = \"0\"\n\n-- Counters local no\\_ttl = 0 local nonexist = 0 local ttl\\_high = 0 local ttl\\_low = 0 local ttl\\_invalid = 0 local size\\_high = 0 local size\\_low = 0 local size\\_nil = 0 local total = 0\n\nrepeat local scan = redis.call(\"SCAN\", cursor, \"COUNT\", 1000) cursor = scan[1] local keys = scan[2] for \\_, key in ipairs(keys) do\n\nlocal ttl = redis.call(\"TTL\", key) local size = redis.call(\"MEMORY\",\"USAGE\", key) total = total + 1\n\nif ttl == -1 then no\\_ttl = no\\_ttl + 1 elseif ttl == -2 then nonexist = nonexist + 1 elseif type(ttl) ~= \"number\" then ttl\\_invalid = ttl\\_invalid + 1 elseif ttl >= ttl\\_threshold then ttl\\_high = ttl\\_high + 1 else ttl\\_low = ttl\\_low + 1 end\n\nif size == nil then size\\_nil = size\\_nil + 1 elseif size >= size\\_threshold then size\\_high = size\\_high + 1 else size\\_low = size\\_low + 1 end\n\nend until cursor == \"0\"\n\nreturn { no\\_ttl, nonexist, ttl\\_high, ttl\\_low, ttl\\_invalid, size\\_high, size\\_low, size\\_nil, total }\n\n**Performance:**\n\n> >\n> **Redis service used:** Azure Managed Redis - Balanced B0 - OSSMode\n> > >\n> Scanning number of keys with TTL threshold 600 Seconds, and Key size threshold 102400 Bytes\n> > >\n> **Total keys scanned: 46161**\n> > >\n> TTL not set : 0\n> TTL >= 600 seconds: 46105\n> TTL TTL invalid/error : 0\n> Non existent key : 0\n> > >\n> Keys with Size >= 102400 Bytes: 0\n> Keys with Size Keys with invalid Size : 0\n> > >\n> Duration : 0 days **00:00:00.602**\n> # ------------------\n>\n> **Redis service used:** Azure Cache for Redis - Standard - C1\n> > >\n> Scanning number of keys with TTL threshold 100 Seconds, and Key size threshold 500 Bytes\n> > >\n> **Total keys scanned: 1227**\n> > >\n> TTL not set : 2\n> TTL >= 100 seconds: 1225\n> TTL TTL invalid/error : 0\n> Non existent key : 0\n> > >\n> Keys with Size >= 500 Bytes: 1225\n> Keys with Size Keys with invalid Size : 0\n> > >\n> Duration : 0 days **00:00:00.630**# ------------------\n> >\n\n**WARNING:** The above scripts uses LUA script, that runs on Redis side, and may block you normal workload. Use it carefully when have a large number of keys in the cache, and during low workload times.\n\n| **2 - List Key Names** | | --- |\n\nOnce we identify some amount of keys in the cache with some specific threshold, we may want to list that key names. The below script can help on that, and returns a list of Redis Keys names with:\n\n- No **TTL** set\n- **TTL** higher or equal to a user defined TTL threshold\n- **TTL** lower than to a user defined TTL threshold\n- Key value **size** higher or equal than a user defined Size threshold\n- Key value **size** lower than a user defined Size threshold\n- **Total** number of keys in the cache\n- It also includes start and end time, and the total time spent on the keys scan.\n\n**Output:**\n\n> >\n> List all key names with TTL above 100 Seconds, and Key size larger 500 Bytes\n> > >\n> Start time: dd-mm-YY 18:30:22\n> ------------------------\n> 1) \"--------------------------------------\"\n> 2) \"Key\\_1787\\_1022: TTL: 461837 seconds, Size: 1336 Bytes\"\n> (...)\n> 1551) \"Key\\_1173\\_1022: TTL: 389795 seconds, Size: 1336 Bytes\"\n> 1552) \"--------------------------------------\"\n> 1553) \"Scan completed.\"\n> 1554) \"Total of 1550 keys scanned.\"\n> 1555) \"1225 keys found with TTL >= 100 seconds, and size larger than 500 Bytes\"\n> 1556) \"--------------------------------------\"\n> End time: dd-mm-YY 18:30:22\n> Duration : 0 days 00:00:00.545\n> ========================================================\n> >\n\n**How to run:**\n\n- create the below **listKeys** **.sh** **** file under some folder, on your Linux environment (Ubuntu 20.04.6 LTS used)\n- give permissions to run Shell script, with command **chmod 700** **listKeys** **.sh**\n- Call the script using the syntax:\n\n> >\n> ./listKeys.sh host password [port] [+/-][ttl\\_threshold] [+/-][size\\_threshold]\n> >\n\n**Script parameters:**\n\n- **host** (mandatory) : the URI for the cache\n- **password** (mandatory) : the Redis access key from the cache\n- **port** (optional - default 10000) : TCP port used to access the cache\n- **[+/-]** (optional) before ttl\\_threshold: indicates if we want return keys with lower \"-\", or higher TTL \"+\" or \"\" than ttl\\_threshold\n- **ttl\\_threshold** (optional - default 600 - 10 minutes) : Key TTL threshold (in seconds) to be used on the results (use -1 to get Keys with no TTL set)\n- **[+/-]** (optional) **** before size\\_threshold: indicates if we want return keys with small size \"-\", or large size \"+\" or \"\" than size\\_threshold\n- **size\\_threshold** (optional - default 102400 - 100KB) : Key Size threshold to be used on the results\n\n**Tips:**\n\n- use **ttl\\_threshold** **= -1** to return key names with no TTL (ex: /listKeys.sh [port] **-1** [+/-][size\\_Threshold])\n- use **ttl\\_threshold = 0** to return key names with any TTL (ex: /listKeys.sh [port] **0** [+/-][size\\_Threshold])\n- use **ttl\\_threshold** **= -500** to return key names with TTL below 500 seconds (ex: /listKeys.sh [port] **-500** [+/-][size\\_Threshold])\n- use **ttl\\_threshold** **= 500** to return key names with TTL above or equal to 500 seconds (ex: /listKeys.sh [port] **500** [+/-][size\\_Threshold])\n\n- use **size\\_threshold** **= 0** to return key names with any size in the cache (ex: /listKeys.sh [port] [+/-][ttl\\_threshold] **0**)\n- use **size\\_threshold** **= -1000** to return key names with size below 1000 Bytes (ex: /listKeys.sh [port] [+/-][ttl\\_threshold] **-1000**)\n- use **size\\_threshold** **= 1000** to return key names with size above or equal to 1000 Bytes (ex: /listKeys.sh [port] [+/-][ttl\\_threshold] **1000**)\n\n- use **ttl\\_threshold** **= 0** AND **size\\_threshold** **= 0** to return all key names with any TTL and any size in the cache (ex: /listKeys.sh [port] **0** **0**)\n- use **ttl\\_threshold** **= -1** AND **size\\_threshold** **= 0** to return all key names with no TTL and any size in the cache (ex: /listKeys.sh [port] **-1** **0**)\n\n**Tested with:**\n\n- Ubuntu 20.04.6 LTS\n- redis-cli -v\nredis-cli 7.4.2\n- Redis services:\n- Azure Managed Redis Balanced B0 OSSMode\n- Azure Cache for Redis Standard C1\n\n**listKeys.sh**\n- #!/usr/bin/env bash\nset -euo pipefail #============================== LUA script version =================\n# Linux Bash Script to list Redis Keys names\n# It returns key names with:\n# - No TTL set\n# - with TTL higher or equal to TTL\\_treshold\n# - with TTL lower TTL\\_threshold\n# - with value size higher or equal than Size\\_threshold\n# - with value size lower than Size\\_threshold\n# - total number of keys in the cache.\n#-------------------------------------------------------\n# WARNING:\n# It uses LUA script (included on Bash code) to run on Redis server side.\n# Use it carefully, during low Redis workoads.\n# Do your tests first on a Dev environment, before use it on production.\n#-------------------------------------------------------\n# It requires :\n# redis-cli v7 or above\n#--------------------------------------------------------\n# Usage:\n# listKeys.sh [(10000)] [+/-][(-1)] [+/-][(102400)]\n#========================================================\n\n#------------------------------------------------------\n# Using non-ssl port requires to remove --tls parameter on Redis-cli command below\n#------------------------------------------------------\n\nsintax=\" [redis\\_port] [+/-][ttl\\_threshold] [+/-][size\\_threshold]\" REDIS\\_HOST=\"${1:?Usage: $0 $sintax}\" REDISCLI\\_AUTH=\"${2:?Usage: $0 $sintax}\" REDIS\\_PORT=\"${3:-10000}\" # Redis port (10000, 6380, 6379) KEYTTL\\_THRESHOLD=${4:-\"-1\"} # -1, +TTL\\_threshold, TTL\\_threashold, -TTL\\_threshold KEYSIZE\\_THRESHOLD=\"${5:-102400}\" # +Size\\_threshold, Size\\_threashold, -Size\\_threshold\n\n# Port number must be numeric\nif ! [[ \"$REDIS\\_PORT\" =~ ^[0-9]+$ ]]; then echo \"ERROR: Redis Port must be numeric\" exit 1 fi\n\n# Check if KEYTTL\\_THRESHOLD is a valid integer\nif ! [[ \"$KEYTTL\\_THRESHOLD\" =~ ^[-+]?[0-9]+$ ]]; then echo \"Error: ttl\\_threshold $KEYTTL\\_THRESHOLD is not an integer\" exit 1 fi\n\n# Check if KEYSIZE\\_THRESHOLD is a valid integer\nif ! [[ \"$KEYSIZE\\_THRESHOLD\" =~ ^[-+]?[0-9]+$ ]]; then echo \"Error: Size\\_threshold $KEYSIZE\\_THRESHOLD is not an integer\" exit 1 fi\n\n# Check if TTL Threasold is positive (or zero), or negative\nif [ \"$KEYTTL\\_THRESHOLD\" -ge 0 ]; then TTLSIGN=\"+\" else TTLSIGN=\"-\" fi\n\n# Check if Size Threshold is positive (or zero), or negative\nif [ \"$KEYSIZE\\_THRESHOLD\" -ge 0 ]; then SIZESIGN=\"+\" size\\_text=\"larger\" else SIZESIGN=\"-\" size\\_text=\"smaler\" fi\n\n# specific with no TTL set\nif [ \"$KEYTTL\\_THRESHOLD\" -eq -1 ]; then ttl\\_text=\"No TTL set\" fi if [ \"$KEYTTL\\_THRESHOLD\" -ge 0 ]; then ttl\\_text=\"TTL above $KEYTTL\\_THRESHOLD Seconds\" fi if [ \"$KEYTTL\\_THRESHOLD\" -lt -1 ]; then ttl\\_text=\"TTL below ${KEYTTL\\_THRESHOLD#[-+]} Seconds\" fi\n\n# remove any sign\nKEYTTL\\_THRESHOLD=\"${KEYTTL\\_THRESHOLD#[-+]}\" KEYSIZE\\_THRESHOLD=\"${KEYSIZE\\_THRESHOLD#[-+]}\"\n\necho \"========================================================\" echo \"List all key names with $ttl\\_text, and Key size $size\\_text $KEYSIZE\\_THRESHOLD Bytes\"\n\n# Start time\nstart\\_ts=$(date +%s.%3N) echo \"Start time: $(date \"+%d-%m-%Y %H:%M:%S\")\" echo \"------------------------\"\n\necho \"\"\n\n# Procesing\nredis-cli -h \"$REDIS\\_HOST\" -p \"$REDIS\\_PORT\" -a \"$REDISCLI\\_AUTH\" --tls --no-auth-warning EVAL \" local cursor = '0' local ttl\\_threshold = tonumber(ARGV[1]) -- KEYTTL\\_THRESHOLD local ttl\\_sign = ARGV[2] -- TTLSIGN local size\\_threshold = tonumber(ARGV[3]) -- KEYSIZE\\_THRESHOLD local size\\_sign = ARGV[4] -- SIZESIGN local output = {} local count = 0 local totalKeys = 0 local strKeyTTL = '' local strKeySize = '' -- Scanning keys in the cache table.insert(output, '--------------------------------------')\n\nrepeat local res = redis.call('SCAN', cursor, 'COUNT', 100) cursor = res[1]\n\nfor \\_, k in ipairs(res[2]) do local ttl = redis.call('TTL', k) local size = redis.call('MEMORY','USAGE', k) totalKeys = totalKeys + 1\n\nif (size\\_sign == '+' and size >= size\\_threshold) or (size\\_sign == '-' and size = 0 then table.insert(output, k .. ': TTL: ' .. ttl .. ' seconds, Size: ' .. size .. ' Bytes') if ttl\\_sign == '-' and ttl = ttl\\_threshold then count = count + 1 end end end end end until cursor == '0' -- Adding summary to output table.insert(output, '--------------------------------------')\n\nif (size\\_sign == '+') then strKeySize = 'larger' else strKeySize = 'smaler' end strKeySize = 'size ' .. strKeySize .. ' than ' .. size\\_threshold .. ' Bytes'\n\nif ttl\\_sign == '-' and ttl\\_threshold == 1 then strKeyTTL = 'No TTL' elseif ttl\\_sign == '-' then strKeyTTL = 'TTL = ' .. ttl\\_threshold .. ' seconds' end strKeyTTL = ' keys found with ' .. strKeyTTL\n\ntable.insert(output, 'Scan completed.') table.insert(output, 'Total of ' .. totalKeys .. ' keys scanned.') table.insert(output, count .. strKeyTTL .. ', and ' .. strKeySize) table.insert(output, '--------------------------------------')\n\nreturn output \" 0 \"$KEYTTL\\_THRESHOLD\" \"$TTLSIGN\" \"$KEYSIZE\\_THRESHOLD\" \"$SIZESIGN\"\n\necho \" \"\n\nend\\_ts=$(date +%s.%3N) echo \"End time: $(date \"+%d-%m-%Y %H:%M:%S\")\"\n\n# Duration - Extract days, hours, minutes, seconds, milliseconds\nduration=$(awk \"BEGIN {print $end\\_ts - $start\\_ts}\") days=$(awk \"BEGIN {print int($duration/86400)}\") hours=$(awk \"BEGIN {print int(($duration%86400)/3600)}\") minutes=$(awk \"BEGIN {print int(($duration%3600)/60)}\") seconds=$(awk \"BEGIN {print int($duration%60)}\") milliseconds=$(awk \"BEGIN {printf \\\"%03d\\\", ($duration - int($duration))\\*1000}\") echo \"Duration : ${days} days $(printf \"%02d\" \"$hours\"):$(printf \"%02d\" \"$minutes\"):$(printf \"%02d\" \"$seconds\").$milliseconds\" echo \"========================================================\"\n\n**Performance:**\n\nThis script is much cleaner and more connection-efficient than the previous one, for the same results. It creates only one connection to Redis service, and all processing is made on Redis side on LUA script. Despite much more efficient, LUA script may block normal workload on Redis, namely having a large dataset, with high number of keys in the cache.\n\n> >\n> **Redis service used:** Azure Managed Redis Balanced B0 OSSMode\n> > >\n> # ------------------\n> Scan completed. Total keys listed: **46005**\n> Duration : 0 days **00:00:01.437**\n> > >\n> # ------------------\n> **Redis service used:** Azure Cache for Redis - Standard - C1\n> Scan completed. Total keys listed: **1225**\n> Duration : 0 days **00:00:00.545**\n> > >\n> # ------------------\n> >\n\n**WARNING:** The above script uses LUA script, that runs on Redis side, and may block you normal workload. Use it carefully when have a large number of keys in the cache, and during low workload times.\n\n| **References** | | --- |\n\n- [Azure Managed Redis](https://learn.microsoft.com/en-us/azure/redis/overview)\n- [Azure Best Practice for Development](https://learn.microsoft.com/en-us/azure/azure-cache-for-redis/cache-best-practices-development)\n- [Redis Inc - Commands](https://redis.io/docs/latest/commands/)\n- [Redis LUA - Lua API reference](https://redis.io/docs/latest/develop/programmability/lua-api/)\n- [Redis Inc - How Redis expires keys](https://redis.io/docs/latest/commands/expire/#how-redis-expires-keys)\n- [Redis CLI](https://redis.io/docs/latest/develop/tools/cli/)\n- [Bash Script](https://www.w3schools.com/bash/bash_script.php)\n- [xargs man page](https://manpages.org/xargs)\n- [awk man page](https://manpages.org/awk)\n\nI hope this can be useful !!!",
  "Link": "https://techcommunity.microsoft.com/t5/azure-paas-blog/redis-keys-statistics/ba-p/4486079",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Author": "LuisFilipe",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "OutputDir": "_community",
  "Title": "Redis Keys Statistics"
}
