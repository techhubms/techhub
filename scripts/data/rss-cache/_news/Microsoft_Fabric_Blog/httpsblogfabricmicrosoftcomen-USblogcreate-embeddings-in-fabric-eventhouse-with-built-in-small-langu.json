{
  "Author": "Microsoft Fabric Blog",
  "Tags": [],
  "FeedUrl": "https://blog.fabric.microsoft.com/en-us/blog/feed/",
  "PubDate": "2026-01-08T11:00:00+00:00",
  "Description": "What if generating embeddings in Eventhouse didn’t require an external endpoint, callout policies, throttling management, or per‑request costs? That’s exactly what slm\\_embeddings\\_fl() delivers: a new user-defined function (UDF) that generates text embeddings using local Small Language Models (SLMs) from within the Kusto Python sandbox, returning vectors that you can immediately use for semantic search, similarity …\n\n[Continue reading “Create Embeddings in Fabric Eventhouse with built-in Small Language Models (SLMs)”](https://blog.fabric.microsoft.com/en-us/blog/create-embeddings-in-fabric-eventhouse-with-built-in-small-language-models-slms/)",
  "FeedName": "Microsoft Fabric Blog",
  "OutputDir": "_news",
  "EnhancedContent": "What if generating embeddings in Eventhouse didn’t require an external endpoint, callout policies, throttling management, or per‑request costs?\n\nThat’s exactly what [**slm\\_embeddings\\_fl()**](https://learn.microsoft.com/en-us/kusto/functions-library/slm-embeddings-fl) delivers: a new user-defined function (UDF) that generates text embeddings using local Small Language Models (SLMs) from within the Kusto Python sandbox, returning vectors that you can immediately use for semantic search, similarity analysis, and broader NLP workflows across Fabric Eventhouse and Azure Data Explorer. This function currently supports [jina-v2-small](https://huggingface.co/jinaai/jina-embeddings-v2-small-en) and [e5-small-v2](https://huggingface.co/intfloat/e5-small-v2) models.\n\nAnd the timing couldn’t be better. Vector similarity search in Eventhouse has been getting rapid adoption, making “Eventhouse as a vector store” a genuinely practical architecture for RAG, semantic exploration, and agent memory patterns.\n\n## Embeddings without callouts is a workflow unlock\n\nUntil now, generating embedding vectors in KQL query typically meant calling an external (Azure OpenAI) endpoint by the [ai_embeddings](https://learn.microsoft.com/en-us/kusto/query/ai-embeddings-plugin)() plugin. That’s powerful, but it introduces operational overhead and cost:\n\n- You must provision an Azure OpenAI resource and deploy an embedding model.\n- You’ll likely hit throttling at scale and need to handle batching, retries and timeouts.\n- Using AOAI models is not free.\n\n[**slm\\_embeddings\\_fl()**](https://learn.microsoft.com/en-us/kusto/functions-library/slm-embeddings-fl) flips that script. The model runs locally using (Eventhouse [python()](https://learn.microsoft.com/en-us/kusto/query/python-plugin) plugin), so embedding becomes a natural part of your KQL transformation pipeline, particularly appealing for privacy-sensitive workflows, rapid prototyping, and high-volume embedding generation.\n\n## What is slm\\_embeddings\\_fl()?\n\nslm\\_embeddings\\_fl() is a tabular UDF you invoke on any table-like expression. You tell it which column contains text, which column should receive the embedding vectors, and (optionally) batch/model configuration:\n\n``` T | invoke slm_embeddings_fl(text_col, embeddings_col [, batch_size ] [, model_name ] [, prefix ]) ```\n\n- batch\\_size defaults to 32\n- model\\_name defaults to ‘jina-v2-small’\n- prefix defaults to ‘query:’ (relevant only for the e5 model)\n\nThe [python()](https://learn.microsoft.com/en-us/kusto/query/python-plugin) plugin must be enabled on the Eventhouse; the UDF uses inline Python executed per node, so it scales naturally with your cluster for larger embedding jobs.\n\n## The two embedding models\n\n- **e5-small-v2: retrieval-optimized “query/passsage” embeddings**\n\nE5 was trained with a simple but important convention: for retrieval-style tasks, prefix inputs with “query:” for the search term and “passage:” for the text corpus (otherwise quality can degrade). This is why slm\\_embeddings\\_fl() exposes a prefix parameter.\n\n- **jina-v2-small: long-context embeddings**\n\nJina supports long inputs (up to 8192 tokens), making it very compelling for long documents where chunking overhead is painful.\n\n## End-to-end: semantic search in pure KQL\n\nEmbed your documents:\n\n``` .set stored_query_result slm_e5_test_tbl <| datatable(text:string) [ \"Machine learning models can process natural language efficiently.\", \"Python is a versatile programming language for data science.\", \"Azure Data Explorer provides fast analytics on large datasets.\", \"Embeddings convert text into numerical vector representations.\", \"Neural networks learn patterns from training data.\" ] | extend text_embeddings=dynamic(null) | invoke slm_embeddings_fl('text', 'text_embeddings', model_name='e5-small-v2', prefix='passage:') // prefix is optional, default is 'query:' ```\n\nEmbed a query, compute cosine similarity using KQL native [series_cosine_similarity()](https://nam06.safelinks.protection.outlook.com/?url=https%3A%2F%2Flearn.microsoft.com%2Fen-us%2Fkusto%2Fquery%2Fseries-cosine-similarity-function%3Fview%3Dazure-data-explorer&amp;data=05%7C02%7Cv-phillipsal%40microsoft.com%7Cd4f5cfc94bff4911635908de4e347d50%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C639034184723910753%7CUnknown%7CTWFpbGZsb3d8eyJFbXB0eU1hcGkiOnRydWUsIlYiOiIwLjAuMDAwMCIsIlAiOiJXaW4zMiIsIkFOIjoiTWFpbCIsIldUIjoyfQ%3D%3D%7C0%7C%7C%7C&amp;sdata=UGWuZ%2F8Wz4c5uh6TRdDD4mZX2I61Jxb59GoFjmG3ScE%3D&amp;reserved=0) function and retrieve the top matches:\n\n``` let item = \"Embeddings vectors are used for semantic search.\"; let embedding = toscalar(print query=item | extend embedding=dynamic(null) | invoke slm_embeddings_fl(text_col='query', embeddings_col='embedding', model_name='e5-small-v2', prefix='query:') | project embedding); stored_query_result('slm_e5_test_tbl') | extend item, embedding | extend similarity=series_cosine_similarity(embedding, text_embeddings, 1.0, 1.0) | project item, text, similarity | top 2 by similarity ```\n\n| item | Text | similarity | | --- | --- | --- | | Embeddings vectors are used for semantic search. | Embeddings convert text into numerical vector representations. | 0.85286472533815 | | Embeddings vectors are used for semantic search. | Machine learning models can process natural language efficiently. | 0.768244175222851 |\n\n## Scenarios unlocked for Fabric Eventhouse\n\n1. **Instant semantic search over logs, tickets, traces, and text columns** — Because embedding is now “just another KQL transform,” you can add semantic retrieval capabilities to nearly any dataset: error messages, system logs, incident descriptions, support tickets, app feedback, etc. Pair it with series\\_cosine\\_similarity() and you have a compact semantic search implementation inside your Eventhouse.\n2. **Low-friction RAG retrieval store and agent memory** — Eventhouse’s vector similarity performance makes it realistic to use it as a retrieval store at scale in RAG pipelines (especially when you follow recommended practices (Vector16 encoding, and shard distribution tuning, see [Optimizing Vector Similarity Search on Azure Data Explorer](https://techcommunity.microsoft.com/blog/azuredataexplorer/optimizing-vector-similarity-search-on-azure-data-explorer-%E2%80%93-performance-update/4033082)).\n3. **High-volume embedding generation without endpoint throttling** — The [ai_embeddings](https://learn.microsoft.com/en-us/kusto/query/ai-embeddings-plugin) plugin documentation calls out throttling risks and recommends controlling request sizes, timeouts, and retries. Local SLM embeddings shift the constraint from remote rate limits to your cluster resources, which is easier to plan for high volumes.\n4. **Long-document semantics with fewer chunks (Jina advantage)** — If you’ve ever chunked large documents into dozens of 512-token blocks just to embed them, you know it can lead to more vectors, more storage, more compute, and slower retrieval. Jina v2 Small’s long-context capability (8192 tokens) can reduce chunk proliferation. That can translate directly into a smaller vector table and faster similarity search.\n5. **Real-Time Vector Ingestion with Update Policy** — The “killer app” for local embedding is combining it with Eventhouse’s [Update Policy](https://learn.microsoft.com/kusto/management/update-policy). You can configure a policy to automatically calculate embeddings as data is ingested. Thus, your data is automatically indexed and ready for semantic search as soon as it’s ingested.\n\n## slm\\_embeddings\\_fl() vs. ai\\_embeddings\n\nChoose **ai\\_embeddings** plugin when you want:\n\n- **Azure OpenAI managed embeddings** with top quality LLM embedding models\n- Centralized model deployment and governance\n\nBut expect:\n\n- dependency on external connectivity and callout policies\n- identity configuration (impersonation or managed identity)\n- throttling management (batching/retries/timeouts)\n\nChoose **slm\\_embeddings\\_fl()** when you want:\n\n- no callouts (simplicity, privacy, compliance)\n- minimal and predictable cost (no cost per embedding)\n- high throughput embedding jobs without AOAI rate constraints\n\n**The two options** are complementary tools that let you choose the best operational and quality point per your scenario.\n\n## **Summary**\n\nThe addition of slm\\_embeddings\\_fl() makes semantic intelligence in Fabric Eventhouse dramatically simpler and more scalable. Whether you’re building RAG pipelines, powering semantic search, or enriching operational data with vector intelligence, local SLM‑based embeddings let you move faster with fewer dependencies and lower cost. Combined with native vector search and Eventhouse’s ingestion pipeline, this marks a significant step toward making AI‑powered analytics first‑class in the Eventhouse ecosystem.",
  "Title": "Create Embeddings in Fabric Eventhouse with built-in Small Language Models (SLMs)",
  "FeedLevelAuthor": "Microsoft Fabric Blog",
  "Link": "https://blog.fabric.microsoft.com/en-US/blog/create-embeddings-in-fabric-eventhouse-with-built-in-small-language-models-slms/",
  "ProcessedDate": "2026-01-08 19:03:28"
}
