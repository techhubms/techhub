{
  "Tags": [
    "TypeScript"
  ],
  "FeedUrl": "https://devblogs.microsoft.com/typescript/feed/",
  "Link": "https://devblogs.microsoft.com/typescript/announcing-typescript-6-0-beta/",
  "Title": "Announcing TypeScript 6.0 Beta",
  "FeedName": "Microsoft TypeScript Blog",
  "Author": "Daniel Rosenwasser",
  "EnhancedContent": "Today we are announcing the beta release of TypeScript 6.0! To get started using the beta, you can get it through npm with the following command:\n\n``` npm install -D typescript@beta\n\n```\n\nTypeScript 6.0 is a unique release in that we intend for it to be the last release based on the current JavaScript codebase. [As announced last year](https://devblogs.microsoft.com/typescript/typescript-native-port/) (with [recent updates here](https://devblogs.microsoft.com/typescript/progress-on-typescript-7-december-2025/)), we are working on a new codebase for the TypeScript compiler and language service written in Go that takes advantage of the speed of native code and shared-memory multi-threading. This new codebase will be the foundation of TypeScript 7.0 and beyond. TypeScript 6.0 will be the immediate precursor to that release, and in many ways it will act as the bridge between TypeScript 5.9 and 7.0. As such, most changes in TypeScript 6.0 are meant to help align and prepare for adopting TypeScript 7.0.\n\nWith that said, there are some new features and improvements that are not just about alignment. Let’s take a look at some of the highlights of this release, followed by a more detailed look at what’s changing for 7.0 and how to prepare for it.\n\n## Less Context-Sensitivity on `this`\n-less Functions\n\nWhen parameters don’t have explicit types written out, TypeScript can usually infer them based on an expected type, or even through other arguments in the same function call.\n\n``` declare function callIt<T>(obj: { produce: (x: number) => T, consume: (y: T) => void, }): void;\n\n// Works, no issues. callIt({ produce: (x: number) => x * 2, consume: y => y.toFixed(), });\n\n// Works, no issues even though the order of the properties is flipped. callIt({ consume: y => y.toFixed(), produce: (x: number) => x * 2, });\n\n```\n\nHere, TypeScript can infer the type of `y` in the `consume` function based on the inferred `T` from the `produce` function, regardless of the order of the properties. But what about if these functions were written using *method syntax* instead of arrow function syntax?\n\n``` declare function callIt<T>(obj: { produce: (x: number) => T, consume: (y: T) => void, }): void;\n\n// Works fine, `x` is inferred to be a number. callIt({ produce(x: number) { return x * 2; }, consume(y) { return y.toFixed(); }, });\n\ncallIt({ consume(y) { return y.toFixed(); }, // ~ // error: 'y' is of type 'unknown'.\n\nproduce(x: number) { return x * 2; }, });\n\n```\n\nStrangely enough, the second call to `callIt` results in an error because TypeScript is not able to infer the type of `y` in the `consume` method. What’s happening here is that when TypeScript is trying to find candidates for `T` , it will first skip over functions whose parameters don’t have explicit types. It does this because certain functions may need the inferred type of `T` to be correctly checked – in our case, we need to know the type of `T` to analyze our `consume` function.\n\nThese functions are called *contextually sensitive functions* – basically, functions that have parameters without explicit types. Eventually the type system will need to figure out types for these parameters – but this is a bit at odds with how inference works in generic functions because the two “pull” on types in different directions.\n\n``` function callFunc<T>(callback: (x: T) => void, value: T) { return callback(value); }\n\ncallFunc(x => x.toFixed(), 42); // ^ // We need to figure out the type of `x` here, // but we also need to figure out the type of `T` to check the callback.\n\n```\n\nTo solve this, TypeScript skips over contextually sensitive functions during type argument inference, and instead checks and infers from other arguments first. If skipping over contextually sensitive functions doesn’t work, inference just continues across any unchecked arguments, going left-to-right in the argument list. In the example immediately above, TypeScript will skip over the callback during inference for `T` , but will then look at the second argument, `42` , and infer that `T` is `number` . Then, when it comes back to check the callback, it will have a contextual type of `(x: number) => void` , which allows it to infer that `x` is a `number` as well.\n\nSo what’s going on in our earlier examples?\n\n``` // Arrow syntax - no errors. callIt({ consume: y => y.toFixed(), produce: (x: number) => x * 2, });\n\n// Method syntax - errors! callIt({ consume(y) { return y.toFixed(); }, // ~ // error: 'y' is of type 'unknown'.\n\nproduce(x: number) { return x * 2; }, });\n\n```\n\nIn both examples, `produce` is assigned a function with an explicitly-typed `x` parameter. Shouldn’t they be checked identically?\n\nThe issue is subtle: most functions (like the ones using method syntax) have an implicit `this` parameter, but arrow functions do not. Any usage of `this` could require “pulling” on the type of `T` – for example, knowing the type of the containing object literal could in turn require the type of `consume` , which uses `T` .\n\nBut we’re not using `this` ! Sure, the function might have a `this` value at runtime, but it’s never used!\n\nTypeScript 6.0 takes this into account when it decides if a function is contextually sensitive or not. If `this` is never actually *used* in a function, then it is not considered contextually sensitive. That means these functions will be seen as higher-priority when it comes to type inference, and all of our examples above now work!\n\n[This change was provided](https://github.com/microsoft/TypeScript/pull/62243) thanks to the work of [Mateusz Burzyński](https://github.com/Andarist).\n\n## Subpath Imports Starting with `#/`\n\nWhen Node.js added support for modules, it added a feature called [“subpath imports”](https://nodejs.org/api/packages.html#subpath-imports). This is basically [a field called `imports`](https://nodejs.org/api/packages.html#imports) which allows packages to create internal aliases for modules within their package.\n\n``` { \"name\": \"my-package\", \"type\": \"module\", \"imports\": { \"#root\": \"./dist/index.js\", \"#root/*\": \"./dist/*\" } }\n\n```\n\nThis allows modules in `my-package` to import from `#root` instead of having to use a relative path like `../../index.js` , and basically allows any other module to write something like\n\n``` import * as utils from \"#root/utils.js\";\n\n```\n\ninstead of using a relative path like the following.\n\n``` import * as utils from \"../../utils.js\";\n\n```\n\nOne minor annoyance with this feature has been that developers always had to write *something* after the `#` when specifying a subpath import. Here, we used `root` , but it is a bit useless since there is no directory we’re mapping over other than `./dist/`\n\nDevelopers who have used bundlers are also accustomed to using path-mapping to avoid long relative paths. A familiar convention with bundlers has been to use a simple `@/` as the prefix. Unfortunately, subpath imports could not start with `#/` at all, leading to a lot of confusion for developers trying to adopt them in their projects.\n\nBut more recently, [Node.js added support for subpath imports starting with `#/`](https://github.com/nodejs/node/pull/60864). This allows packages to use a simple `#/` prefix for their subpath imports without needing to add an extra segment.\n\n``` { \"name\": \"my-package\", \"type\": \"module\", \"imports\": { \"#\": \"./dist/index.js\", \"#/*\": \"./dist/*\" } }\n\n```\n\nThis is supported in newer Node.js 20 releases, and so TypeScript now supports it under the options `node20` , `nodenext` , and `bundler` for the `--moduleResolution` setting.\n\nThis work was done thanks to [magic-akari](https://github.com/magic-akari), and [the implementing pull request can be found here](https://github.com/microsoft/TypeScript/pull/62844).\n\n## Combining `--moduleResolution bundler`\nwith `--module commonjs`\n\nTypeScript’s `--moduleResolution bundler` setting was previously only allowed to be used with `--module esnext` or `--module preserve` ; however, with the deprecation of `--moduleResolution node` (a.k.a. `--moduleResolution node10` ), this new combination is often the most suitable upgrade path for many projects.\n\nProjects will often want to instead plan out a migration towards either\n\n- `--module preserve`\nand `--moduleResolution bundler`\n- `--module nodenext`\n\ndepending on your project type (e.g. bundled web app, Bun app, or Node.js app).\n\nMore information can be found at [this implementing pull request](https://github.com/microsoft/TypeScript/pull/62320).\n\n## The `--stableTypeOrdering`\nFlag\n\nAs part of our ongoing work on [TypeScript’s native port](https://devblogs.microsoft.com/typescript/typescript-native-port/), we’ve introduced a new flag called `--stableTypeOrdering` intended to assist with 6.0-to-7.0 migrations.\n\nToday, TypeScript assigns type IDs (internal tracking numbers) to types in the order they are encountered, and uses these IDs to sort union types in a consistent manner. A similar process occurs for properties. As a result, the order in which things are declared in a program can have possibly surprising effects on things like declaration emit.\n\nFor example, consider the declaration emit from this file:\n\n``` // Input: some-file.ts export function foo(condition: boolean) { return condition ? 100 : 500; }\n\n// Output: some-file.d.ts export declare function foo(condition: boolean): 100 | 500; // ^^^^^^^^^ // Note the order of this union: 100, then 500.\n\n```\n\nIf we add an unrelated `const` *above* `foo` , the declaration emit changes:\n\n``` // Input: some-file.ts const x = 500; export function foo(condition: boolean) { return condition ? 100 : 500; }\n\n// Output: some-file.d.ts export declare function foo(condition: boolean): 500 | 100; // ^^^^^^^^^ // Note the change in order here.\n\n```\n\nThis happens because the literal type `500` gets a lower type ID than `100` because it was processed first when analyzing the `const x` declaration. In very rare cases this change in ordering can even cause errors to appear or disappear based on program processing order, but in general, the main place you might notice this ordering is in the emitted declaration files, or in the way types are displayed in your editor.\n\nOne of the major architectural improvements in TypeScript 7 is parallel type checking, which dramatically improves overall check time. However, parallelism introduces a challenge: when different type-checkers visit nodes, types, and symbols in different orders, the internal IDs assigned to these constructs become non-deterministic. This in turn leads to confusing non-deterministic output, where two files with identical contents in the same program can produce different declaration files, or even calculate different errors when analyzing the same file. To fix this, TypeScript 7.0 sorts its internal objects (e.g. types and symbols) according to a deterministic algorithm based on the content of the object. This ensures that all checkers encounter the same object order regardless of how and when they were created. As a consequence, in the given example, TypeScript 7 will *always* print `100 | 500` , removing the ordering instability entirely.\n\nThis means that TypeScript 6 and 7 can and do sometimes display different ordering. While these ordering changes are almost always benign, if you’re comparing compiler outputs between runs (for example, checking emitted declaration files in 6.0 vs 7.0), these different orderings can produce a lot of noise that makes it difficult to assess correctness. Occasionally though, you may witness a change in ordering that causes a type error to appear or disappear, which can be even more confusing.\n\nTo help with this situation, in 6.0, you can specify the new `--stableTypeOrdering` flag. This makes 6.0’s type ordering behavior match 7.0’s, reducing the number of differences between the two codebases. Note that we don’t necessarily encourage using this flag all the time as it can add a substantial slowdown to type-checking (up to 25% depending on codebase).\n\nIf you encounter a type error using `--stableTypeOrdering` , this is typically due to inference differences. The previous inference without `--stableTypeOrdering` *happened* to work based on the current ordering of types in your program. To help with this, you’ll often benefit from providing an explicit type somewhere. Often, this will be a type argument\n\n```\n- someFunctionCall(/*...*/);\n+ someFunctionCall<SomeExplicitType>(/*...*/);\n\n```\n\nor a variable annotation for an argument you intend to pass into a call.\n\n```\n- const someVariable = { /*... some complex object ...*/ };\n+ const someVariable: SomeExplicitType = { /*... some complex object ...*/ };\n\nsomeFunctionCall(someVariable);\n\n```\n\n**Note that this flag is only intended to help diagnose differences between 6.0 and 7.0 – it is not intended to be used as a long-term feature**\n\n[See more at this pull-request](https://github.com/microsoft/TypeScript/pull/63084).\n\n### The `dom`\nlib now contains `dom.iterable` and `dom.asynciterable`\n\nTypeScript’s `lib` option allows you to specify which global declarations your target runtime has. One option is `dom` to represent web environments (i.e. browsers, who implement [the DOM APIs](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model)). Previously, the DOM APIs were partially split out into `dom.iterable` and `dom.asynciterable` for environments that didn’t support `Iterable` s and `AsyncIterable` s. This meant that you had to explicitly add `dom.iterable` to use iteration methods on DOM collections like `NodeList` or `HTMLCollection` .\n\nIn TypeScript 6.0, the contents of `lib.dom.iterable.d.ts` and `lib.dom.asynciterable.d.ts` are fully included in `lib.dom.d.ts` . You can still reference `dom.iterable` and `dom.asynciterable` in your configuration file’s `\"lib\"` array, but they are now just empty files.\n\n``` // Before TypeScript 6.0, this required \"lib\": [\"dom\", \"dom.iterable\"] // Now it works with just \"lib\": [\"dom\"] for (const element of document.querySelectorAll(\"div\")) { console.log(element.textContent); }\n\n```\n\nThis is a quality-of-life improvement that eliminates a common point of confusion, since no major modern browser lacks these capabilities. If you were already including both `dom` and `dom.iterable` , you can now simplify to just `dom` .\n\nSee more [at this issue](https://github.com/microsoft/TypeScript/issues/60959) and its [corresponding pull request](https://github.com/microsoft/TypeScript/pull/62111).\n\n## Breaking Changes and Deprecations in TypeScript 6.0\n\nTypeScript 6.0 arrives as a significant transition release, designed to prepare developers for TypeScript 7.0, the upcoming native port of the TypeScript compiler. While TypeScript 6.0 maintains full compatibility with your existing TypeScript knowledge and continues to be API compatible with TypeScript 5.9, this release introduces a number of breaking changes and deprecations that reflect the evolving JavaScript ecosystem and set the stage for TypeScript 7.0.\n\nIn the two years since TypeScript 5.0, we’ve seen ongoing shifts in how developers write and ship JavaScript:\n\n- Virtually every runtime environment is now “evergreen”. True legacy environments (ES5) are vanishingly rare.\n- Bundlers and ESM have become the most common module targets for new projects, though CommonJS remains a major target. AMD and other in-browser userland module systems are much rarer than they were in 2012.\n- Almost all packages can be consumed through some module system. UMD packages still exist, but virtually no new code is available *only* as a global variable.\n- `tsconfig.json`\nis nearly universal as a configuration mechanism.\n- Appetite for “stricter” typing continues to grow.\n- TypeScript build performance is top of mind. Despite the gains of TypeScript 7, performance must always remain a key goal, and options which can’t be supported in a performant way need to be more strongly justified.\n\nSo TypeScript 6.0 and 7.0 are designed with these realities in mind. For TypeScript 6.0, these deprecations can be ignored by setting `\"ignoreDeprecations\": \"6.0\"` in your tsconfig; however, note that TypeScript 7.0 *will not* support any of these deprecated options.\n\nSome necessary adjustments can be automatically performed with a codemod or tool. For example, the [experimental `ts5to6` tool](https://github.com/andrewbranch/ts5to6) can automatically adjust `baseUrl` and `rootDir` across your codebase.\n\n### Up-Front Adjustments\n\nWe’ll cover specific adjustments below, but we have to note that some deprecations and behavior changes do not necessarily have an error message that directly points to the underlying issue. So we’ll note up-front that **many projects will need to do at least one of the following**:\n\n- Set the `\"types\"`\narray in tsconfig, typically to `\"types\": [\"node\"]` .\n\n`\"types\": [\"*\"]` will restore the 5.9 behavior, but we recommend using an explicit array to improve build performance and predictability.\n\nYou’ll typically know this is the issue if you see a *lot* of type errors related to missing identifiers or unresolved built-in modules.\n- Set `\"rootDir\": \"./src\"`\nif you were previously relying on this being inferred\n\nYou’ll often know this is the issue if you see files being written to `./dist/src/index.js` instead of `./dist/index.js` .\n\n### Simple Default Changes\n\nSeveral compiler options now have updated default values that better reflect modern development practices.\n\n- **`strict` is now `true` by default**:\nThe appetite for stricter typing continues to grow, and we’ve found that most new projects want `strict` mode enabled. If you were already using `\"strict\": true` , nothing changes for you. If you were relying on the previous default of `false` , you’ll need to explicitly set `\"strict\": false` in your `tsconfig.json` .\n- **`module` defaults to `esnext`**:\nSimilarly, the new default `module` is `esnext` , acknowledging that ESM is now the dominant module format.\n- **`target` defaults to current-year ES version**:\nThe new default `target` is the most recent supported ECMAScript spec version (effectively a floating target). Right now, that target is `es2025` . This reflects the reality that most developers are shipping to evergreen runtimes and don’t need to transpile down to older ECMAScript versions.\n- **`noUncheckedSideEffectImports` is now `true` by default**:\nThis helps catch issues with typos in side-effect-only imports.\n- **`libReplacement` is now `false` by default**:\nThis flag previously incurred a large number of failed module resolutions for every run, which in turn increased the number of locations we needed to watch under `--watch` and editor scenarios. In a new project, `libReplacement` never does anything until other explicit configuration takes place, so it makes sense to turn this off by default for the sake of better performance by default.\n\nIf these new defaults break your project, you can specify the previous values explicitly in your `tsconfig.json` .\n\n### `rootDir`\nnow defaults to `.`\n\n`rootDir` controls the directory structure of your output files relative to the output directory. Previously, if you did not specify a `rootDir` , it was inferred based on the common directory of all non-declaration input files. But this often meant that it was impossible to know if a file belonged to a project without trying to load and parse that project. It also meant that TypeScript had to spend more time inferring that common source directory by analyzing every file path in the program.\n\nIn TypeScript 6.0, the default `rootDir` will always be the directory containing the `tsconfig.json` file. `rootDir` will only be inferred when using `tsc` from the command line without a `tsconfig.json` file.\n\nIf you have source files any level deeper than your `tsconfig.json` directory and were relying on TypeScript to infer a common root directory for source files, you’ll need to explicitly set `rootDir` :\n\n``` { \"compilerOptions\": { // ...\n+ \"rootDir\": \"./src\"\n}, \"include\": [\"./src\"] }\n\n```\n\nLikewise, if your `tsconfig.json` referenced files outside of the containing `tsconfig.json` , you would need to adjust your `rootDir` to include those files.\n\n``` { \"compilerOptions\": { // ...\n+ \"rootDir\": \"../src\"\n}, \"include\": [\"../src/**/*.tests.ts\"] }\n\n```\n\nSee more at [the discussion here](https://github.com/microsoft/TypeScript/issues/62194) and [the implementation here](https://github.com/microsoft/TypeScript/pull/62418).\n\n### `types`\nnow defaults to `[]`\n\nIn a `tsconfig.json` , the `types` field of `compilerOptions` specifies a list of package names to be included in the global scope during compilation. Typically, packages in `node_modules` are automatically included via imports in your source code; but for convenience, TypeScript would also include all packages in `node_modules/@types` by default, so that you can get global declarations like `process` or the `\"fs\"` module from `@types/node` , or `describe` and `it` from `@types/jest` , without needing to import them directly.\n\nIn a sense, the `types` value previously defaulted to “enumerate everything in `node_modules/@types` “. This can be *very* expensive, as a normal repository setup these days might transitively pull in hundreds of `@types` packages, especially in multi-project workspaces with flattened `node_modules` . Modern projects almost always need only `@types/node` , `@types/jest` , or a handful of other common global-affecting packages.\n\nIn TypeScript 6.0, the default `types` value will be `[]` (an empty array). This change prevents projects from unintentionally pulling in hundreds or even thousands of unneeded declaration files at build time. Many projects we’ve looked at have improved their build time anywhere from 20-50% just by setting `types` appropriately.\n\n**This will affect many projects.** You will likely need to add `\"types\": [\"node\"]` or a few others:\n\n``` { \"compilerOptions\": { // Explicitly list the @types packages you need\n+ \"types\": [\"node\", \"jest\"]\n} }\n\n```\n\nYou can also specify a `*` entry to re-enable the old enumeration behavior:\n\n``` { \"compilerOptions\": { // Load ALL the types - the default from TypeScript 5.9 and before.\n+ \"types\": [\"*\"]\n} }\n\n```\n\nIf you end up with new error messages like the following:\n\n``` Cannot find module '...' or its corresponding type declarations. Cannot find name 'fs'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node` and then add 'node' to the types field in your tsconfig. Cannot find name 'path'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node` and then add 'node' to the types field in your tsconfig. Cannot find name 'process'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node` and then add 'node' to the types field in your tsconfig. Cannot find name 'Bun'. Do you need to install type definitions for Bun? Try `npm i --save-dev @types/bun` and then add 'bun' to the types field in your tsconfig. Cannot find name 'describe'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.\n\n```\n\nit’s likely that you need to add some entries to your `types` field.\n\nSee more at [the proposal here](https://github.com/microsoft/TypeScript/issues/62195) along with [the implementing pull request here](https://github.com/microsoft/TypeScript/pull/63054).\n\n### Deprecated: `target: es5`\n\nThe ECMAScript 5 target was important for a long time to support legacy browsers; but its successor, ECMAScript 2015 (ES6), was released over a decade ago, and all modern browsers have supported it for many years. With Internet Explorer’s retirement, and the universality of evergreen browsers, there are very few use cases for ES5 output today.\n\nTypeScript’s lowest target will now be ES2015, and the `target: es5` option is deprecated. If you were using `target: es5` , you’ll need to migrate to a newer target or use an external compiler. If you still need ES5 output, we recommend using an external compiler to either directly compile your TypeScript source, or to post-process TypeScript’s outputs.\n\n[See more about this deprecation here](https://github.com/microsoft/TypeScript/issues/62196) along with [its implementing pull request](https://github.com/microsoft/TypeScript/pull/63067).\n\n### Deprecated: `--downlevelIteration`\n\n`--downlevelIteration` only has effects on ES5 emit, and since `--target es5` has been deprecated, `--downlevelIteration` no longer serves a purpose.\n\nSubtly, using `--downlevelIteration false` with `--target es2015` did not error in TypeScript 5.9 and earlier, even though it had no effect. In TypeScript 6.0, setting `--downlevelIteration` at all will lead to a deprecation error.\n\nSee [the implementation here](https://github.com/microsoft/TypeScript/pull/63071).\n\n### Deprecated: `amd`\n, `umd` , and `systemjs` values of `module`\n\nThe following flag values are no longer supported\n\n- `--module amd`\n- `--module umd`\n- `--module systemjs`\n\nAMD, UMD, and SystemJS were important during the early days of JavaScript modules when browsers lacked native module support. Today, ESM is universally supported in browsers and Node.js, and both import maps and bundlers have become favored ways for filling in the gaps. If you’re still targeting these module systems, consider migrating to an appropriate ECMAScript module-emitting target, adopt a bundler or different compiler, or stay on TypeScript 5.x until you can migrate.\n\nThis also implies dropped support for the `amd-module` directive, which will no longer have any effect.\n\nSee more at [the proposal issue](https://github.com/microsoft/TypeScript/issues/62199) along with [the implementing pull request](https://github.com/microsoft/TypeScript/pull/62669).\n\n### Deprecated: `--baseUrl`\n\nThe `baseUrl` option is most-commonly used in conjunction with `paths` , and is typically used as a prefix for every value in `paths` . Unfortunately, `baseUrl` is also considered a look-up root for module resolution.\n\nFor example, given the following `tsconfig.json`\n\n``` { \"compilerOptions\": { // ... \"baseUrl\": \"./src\", \"paths\": { \"@app/*\": [\"app/*\"], \"@lib/*\": [\"lib/*\"] } } }\n\n```\n\nand an import like\n\n``` import * as someModule from \"someModule.js\";\n\n```\n\nTypeScript will probably resolve this to `src/someModule.js` , even if the developer only intended to add mappings for modules starting with `@app/` and `@lib/` .\n\nIn the best case, this also often leads to “worse-looking” paths that bundlers would ignore; but it often meant that that many import paths that would never have worked at runtime are considered “just fine” by TypeScript.\n\n`path` mappings have not required specifying `baseUrl` for a long time, and in practice, most projects that use `baseUrl` only use it as a prefix for their `paths` entries. In TypeScript 6.0, `baseUrl` is deprecated and will no longer be considered a look-up root for module resolution.\n\nDevelopers who used `baseUrl` as a prefix for path-mapping entries can simply remove `baseUrl` and add the prefix to their `paths` entries:\n\n``` { \"compilerOptions\": { // ...\n- \"baseUrl\": \"./src\",\n\"paths\": {\n- \"@app/*\": [\"app/*\"],\n- \"@lib/*\": [\"lib/*\"]\n+ \"@app/*\": [\"./src/app/*\"],\n+ \"@lib/*\": [\"./src/lib/*\"]\n} } }\n\n```\n\nDevelopers who actually *did* use `baseUrl` as a look-up root can also add an explicit path mapping to preserve the old behavior:\n\n``` { \"compilerOptions\": { // ... \"paths\": { // A new catch-all that replaces the baseUrl: \"*\": [\"./src/*\"],\n\n// Every other path now has an explicit common prefix: \"@app/*\": [\"./src/app/*\"], \"@lib/*\": [\"./src/lib/*\"], } } }\n\n```\n\nHowever, this is extremely rare. We recommend most developers simply remove `baseUrl` and add the appropriate prefixes to their `paths` entries.\n\nSee more [at this issue](https://github.com/microsoft/TypeScript/issues/62207) and [the corresponding pull request](https://github.com/microsoft/TypeScript/pull/62509).\n\n### Deprecated: `--moduleResolution classic`\n\nThe `moduleResolution: classic` setting has been removed. The `classic` resolution strategy was TypeScript’s original module resolution algorithm, and predates Node.js’s resolution algorithm becoming a de facto standard. Today, all practical use cases are served by `nodenext` or `bundler` . If you were using `classic` , migrate to one of these modern resolution strategies.\n\nSee more at [this issue](https://github.com/microsoft/TypeScript/issues/62206) and [the implementing pull request](https://github.com/microsoft/TypeScript/pull/62669).\n\n### Deprecated: `--esModuleInterop false`\nand `--allowSyntheticDefaultImports false`\n\nThe following settings can no longer be set to `false` :\n\n- `esModuleInterop`\n- `allowSyntheticDefaultImports`\n\n`esModuleInterop` and `allowSyntheticDefaultImports` were originally opt-in to avoid breaking existing projects. However, the behavior they enable has been the recommended default for years. Setting them to `false` often led to subtle runtime issues when consuming CommonJS modules from ESM. In TypeScript 6.0, the safer interop behavior is always enabled.\n\nIf you have imports that rely on the old behavior, you may need to adjust them:\n\n``` // Before (with esModuleInterop: false) import * as express from \"express\";\n\n// After (with esModuleInterop always enabled) import express from \"express\";\n\n```\n\nSee more at [this issue](https://github.com/microsoft/TypeScript/issues/62529) and [its implementing pull request](https://github.com/microsoft/TypeScript/pull/62567).\n\n### Deprecated: `--alwaysStrict false`\n\nThe `alwaysStrict` flag refers to inference and emit of the `\"use strict\";` directive. In TypeScript 6.0, all code will be assumed to be in [JavaScript strict mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode), which is a set of JS semantics that most-noticeably affects syntactic corner cases around reserved words. If you have “sloppy mode” code that uses reserved words like `await` , `static` , `private` , or `public` as regular identifiers, you’ll need to rename them. If you relied on subtle semantics around the meaning of `this` in non-strict code, you may need to adjust your code as well.\n\nSee more [at this issue](https://github.com/microsoft/TypeScript/issues/62213) and [its corresponding pull request](https://github.com/microsoft/TypeScript/pull/63089).\n\n### Deprecated: `outFile`\n\nThe `--outFile` option has been removed from TypeScript 6.0. This option was originally designed to concatenate multiple input files into a single output file. However, external bundlers like Webpack, Rollup, esbuild, Vite, Parcel, and others now do this job faster, better, and with far more configurability. Removing this option simplifies the implementation and allows us to focus on what TypeScript does best: type-checking and declaration emit. If you’re currently using `--outFile` , you’ll need to migrate to an external bundler. Most modern bundlers have excellent TypeScript support out of the box.\n\n### Deprecated: legacy `module`\nSyntax for namespaces\n\nEarly versions of TypeScript used the `module` keyword to declare namespaces:\n\n``` // ❌ Deprecated syntax - now an error module Foo { export const bar = 10; }\n\n```\n\nThis syntax was later aliased to the modern preferred form using the `namespace` keyword:\n\n``` // ✅ The correct syntax namespace Foo { export const bar = 10; }\n\n```\n\nWhen `namespace` was introduced, the `module` syntax was simply discouraged. A few years ago, the TypeScript language service started marking the keyword as deprecated, suggesting `namespace` in its place.\n\nIn TypeScript 6.0, using `module` where `namespace` is expected is now a hard deprecation. This change is necessary because `module` blocks are a potential ECMAScript proposal that would conflict with the legacy TypeScript syntax.\n\nThe ambient module declaration form remains fully supported:\n\n``` // ✅ Still works perfectly declare module \"some-module\" { export function doSomething(): void; }\n\n```\n\nSee [this issue](https://github.com/microsoft/TypeScript/issues/62211) and its [corresponding pull request](https://github.com/microsoft/TypeScript/pull/62876) for more details.\n\n### Deprecated: `asserts`\nKeyword on Imports\n\nThe `asserts` keyword was proposed to the JavaScript language via the import assertions proposal; however, the proposal eventually morphed into [the import attributes proposal](https://github.com/tc39/proposal-import-attributes), which uses the `with` keyword instead of `asserts` .\n\nThus, the `asserts` syntax is now deprecated in TypeScript 6.0, and using it will lead to an error:\n\n``` // ❌ Deprecated syntax - now an error. import blob from \"./blahb.json\" asserts { type: \"json\" } // ~~~~~~~ // error: Import assertions have been replaced by import attributes. Use 'with' instead of 'asserts'.\n\n```\n\nInstead, use the `with` syntax for import attributes:\n\n``` // ✅ Works with the new import attributes syntax. import blob from \"./blahb.json\" with { type: \"json\" }\n\n```\n\nSee more at [this issue](https://github.com/microsoft/TypeScript/issues/62210) and its [corresponding pull request](https://github.com/microsoft/TypeScript/pull/63077).\n\n### Deprecated: `no-default-lib`\nDirectives\n\nThe `/// <reference no-default-lib=\"true\"/>` directive has been largely misunderstood and misused. In TypeScript 6.0, this directive is no longer supported. If you were using it, consider using `--noLib` or `--libReplacement` instead.\n\n[See more here](https://github.com/microsoft/TypeScript/issues/62209) and at [the corresponding pull request](https://github.com/microsoft/TypeScript/pull/62435).\n\n### Specifying Command-Line Files When `tsconfig.json`\nExists is Now an Error\n\nCurrently, if you run `tsc foo.ts` in a folder where a `tsconfig.json` exists, the config file is completely ignored. This was often very confusing if you expected checking and emit options to apply to the input file.\n\nIn TypeScript 6.0, if you run `tsc` with file arguments in a directory containing a `tsconfig.json` , an error will be issued to make this behavior explicit:\n\n``` error TS5112: tsconfig.json is present but will not be loaded if files are specified on commandline. Use '--ignoreConfig' to skip this error.\n\n```\n\nIf it is the case that you wanted to ignore the `tsconfig.json` and just compile `foo.ts` with TypeScript’s defaults, you can use the new `--ignoreConfig` flag.\n\n``` tsc --ignoreConfig foo.ts\n\n```\n\nSee more [at this issue](https://github.com/microsoft/TypeScript/issues/62197) and its [corresponding pull request](https://github.com/microsoft/TypeScript/pull/62477).\n\n## Preparing for TypeScript 7.0\n\nTypeScript 6.0 is designed as a transition release. While the options deprecated in TypeScript 6.0 will continue to work without errors when `\"ignoreDeprecations\": \"6.0\"` is set, they will be **removed entirely in TypeScript 7.0** (the native TypeScript port). If you’re seeing deprecation warnings after upgrading to TypeScript 6.0, we strongly recommend addressing them before trying to adopt TypeScript 7 ([or its native previews](https://www.npmjs.com/package/@typescript/native-preview)) in your project.\n\nAs to the schedule between TypeScript 6.0 and 7.0, we plan for 7.0 to be released soon after 6.0. This should help us keep some continuity in our development with the chance to address issues sooner after the release of 7.0.\n\n## What’s Next?\n\nAt this point, TypeScript 6.0 is “feature stable”, and we don’t plan on any new features or breaking changes. Over the next few weeks, we’ll be addressing any new issues reported on the 6.0 codebase, so we encourage you to leave feedback and report any issues you encounter. And while the beta release is a great way to try out the next version of TypeScript, we also publish nightly builds [on npm](https://www.typescriptlang.org/docs/handbook/nightly-builds.html) and [in your editor](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next) which are typically very stable. These releases can often give you a better snapshot of which issues have been fixed.\n\nWe are also continuing to work on TypeScript 7.0, and publish nightly builds of [our native previews](https://www.npmjs.com/package/@typescript/native-preview) along with a [VS Code extension too](https://marketplace.visualstudio.com/items?itemName=TypeScriptTeam.native-preview). Feedback on both 6.0 and 7.0 are very much appreciated, and we encourage you to try out both if you can.\n\nSo try TypeScript 6.0 beta in your project today, and let us know what you think!\n\nHappy Hacking!\n\n– Daniel Rosenwasser and the TypeScript Team",
  "OutputDir": "_news",
  "FeedLevelAuthor": "TypeScript",
  "Description": "Today we are announcing the beta release of TypeScript 6.0! To get started using the beta, you can get it through npm with the following command: npm install -D typescript@beta TypeScript 6.0 is a unique release in that we intend for it to be the last release based on the current JavaScript codebase. As announced […]\n\nThe post [Announcing TypeScript 6.0 Beta](https://devblogs.microsoft.com/typescript/announcing-typescript-6-0-beta/) appeared first on [TypeScript](https://devblogs.microsoft.com/typescript).",
  "PubDate": "2026-02-11T18:50:26+00:00",
  "ProcessedDate": "2026-02-11 19:21:41"
}
