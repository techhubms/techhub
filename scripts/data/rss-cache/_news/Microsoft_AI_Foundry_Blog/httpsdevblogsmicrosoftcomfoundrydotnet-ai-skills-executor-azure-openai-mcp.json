{
  "EnhancedContent": "When Anthropic released their Agent Skills framework, they didn’t just introduce a new feature. They published a blueprint for how enterprise organizations should structure AI agent capabilities. The pattern is elegant: package procedural knowledge into composable skills that AI agents can discover and apply contextually.\n\nBut here’s the challenge enterprise developers face: most implementations assume you’re working in Python or TypeScript. If your organization has invested in the Microsoft ecosystem—Azure, .NET, C#—you need an implementation that speaks your language.\n\nThis article walks through building a complete AI Skills Executor in .NET that combines Azure OpenAI for LLM capabilities with the official Model Context Protocol (MCP) C# SDK for tool execution. The result is an architecture that lets you create skills once and run them anywhere in your Microsoft-based infrastructure.\n\n## The Problem Skills Solve\n\nEvery enterprise developer has experienced this frustration: you deploy a powerful AI model, craft a clever prompt for a specific task, and it works beautifully—once. Then the prompt gets lost in a Slack thread, someone modifies it for their use case, and within a month you have fifteen variations scattered across your organization with no way to standardize or improve them.\n\nSkills solve this by treating AI instructions as first-class engineering artifacts. A skill is a folder containing a SKILL.md file with structured instructions, optionally accompanied by scripts, reference documents, and configuration. Think of it as a job description for an AI agent—one that can be version-controlled, reviewed, tested, and improved over time.\n\nThe architecture operates on a principle Anthropic calls **progressive disclosure**. Skill metadata loads at startup (roughly 100 tokens per skill), full instructions load when a user’s request matches the skill’s domain, and resources load only when the agent determines they’re needed. This means you can equip agents with extensive organizational knowledge without overwhelming their context window.\n\n## Understanding the Architecture\n\nBefore diving into code, let’s understand what we’re building. The Skills Executor consists of four cooperating components:\n\nThe **Skill Loader** discovers and parses SKILL.md files from a configured directory, extracting YAML frontmatter for metadata and markdown body for the system prompt.\n\nThe **Azure OpenAI Service** handles all LLM interactions, including chat completions with function calling support.\n\nThe **MCP Client Service** connects to one or more MCP servers, discovers their available tools, and routes tool execution requests.\n\nThe **Skill Executor** orchestrates the agentic loop—taking user input, managing the conversation with the LLM, executing tool calls when requested, and returning final responses.\n\n![Skills Executor Architecture Diagram](https://matthewkruczek.ai/assets/blog-images/dotnet-skills-executor-architecture.png)\n\n*Figure: The Skills Executor architecture showing how skills, Azure OpenAI, and MCP servers work together.*\n\nThe critical insight is that the orchestrator doesn’t contain any business logic about when to use specific tools. It simply provides the LLM with available tools, executes whatever the LLM requests, feeds results back, and repeats until the LLM produces a final response. All the intelligence comes from the LLM guided by the skill’s instructions.\n\n## Setting Up the Project\n\nStart by creating a new .NET solution with three projects:\n\n```bash dotnet new sln -n SkillsQuickstart dotnet new classlib -n SkillsCore -f net8.0 dotnet new console -n SkillsQuickstart -f net8.0 dotnet new console -n SkillsMcpServer -f net8.0\n\ndotnet sln add SkillsCore dotnet sln add SkillsQuickstart dotnet sln add SkillsMcpServer ```\n\nAdd the required NuGet packages to each project. For SkillsCore:\n\n```bash cd SkillsCore dotnet add package YamlDotNet ```\n\nFor SkillsQuickstart (the main orchestrator):\n\n```bash cd SkillsQuickstart dotnet add package Azure.AI.OpenAI --version 2.1.0 dotnet add package ModelContextProtocol --prerelease dotnet add package Spectre.Console dotnet add package Microsoft.Extensions.Hosting dotnet add package Microsoft.Extensions.Configuration.UserSecrets ```\n\nFor SkillsMcpServer (your custom tools):\n\n```bash cd SkillsMcpServer dotnet add package ModelContextProtocol --prerelease dotnet add package Microsoft.Extensions.Hosting ```\n\nThe ModelContextProtocol package is the official C# SDK maintained by Microsoft in partnership with Anthropic. It provides everything you need to create MCP clients that connect to servers and MCP servers that expose tools.\n\n## Parsing SKILL.md Files\n\nSkills are defined in markdown files with YAML frontmatter. Here’s a typical skill definition:\n\n```markdown --- name: Code Reviewer description: Reviews code for bugs, security issues, and best practices. version: 1.0.0 author: Platform Team category: development tags:\n- code\n- review\n- quality\n---\n\n# Code Reviewer\n\nYou are an expert code reviewer. Your job is to analyze code for potential issues and provide constructive feedback.\n\n## Your Approach\n\nWhen reviewing code, examine:\n1. Logic errors and edge cases\n2. Security vulnerabilities\n3. Performance issues\n4. Code style and maintainability\n5. Test coverage gaps\n\n## Guidelines\n\n- Be constructive, not critical\n- Explain the \"why\" behind each suggestion\n- Prioritize issues by severity\n```\n\nThe SkillDefinition model captures both the metadata and instructions:\n\n```csharp public class SkillDefinition { // From YAML frontmatter public string Id { get; set; } = string.Empty; public string Name { get; set; } = string.Empty; public string Description { get; set; } = string.Empty; public string? Version { get; set; } public string? Author { get; set; } public string? Category { get; set; } public List<string> Tags { get; set; } = new();\n\n// From markdown body public string? Instructions { get; set; }\n\n// File location public string FilePath { get; set; } = string.Empty; public string BaseDirectory { get; set; } = string.Empty; } ```\n\nThe SkillLoaderService discovers all SKILL.md files and parses them:\n\n```csharp public class SkillLoaderService : ISkillLoaderService { private readonly IDeserializer _yamlDeserializer;\n\npublic SkillLoaderService() { _yamlDeserializer = new DeserializerBuilder() .WithNamingConvention(CamelCaseNamingConvention.Instance) .IgnoreUnmatchedProperties() .Build(); }\n\npublic async Task<List<SkillDefinition>> LoadSkillsAsync(string skillsDirectory) { var skills = new List<SkillDefinition>(); var skillFolders = Directory.GetDirectories(skillsDirectory);\n\nforeach (var folder in skillFolders) { var skillFile = Path.Combine(folder, \"SKILL.md\"); if (!File.Exists(skillFile)) continue;\n\nvar skill = await ParseSkillFileAsync(skillFile, folder); if (skill != null) skills.Add(skill); }\n\nreturn skills; }\n\nprivate async Task<SkillDefinition?> ParseSkillFileAsync(string filePath, string baseDir) { var content = await File.ReadAllTextAsync(filePath); var (frontmatter, body) = ExtractFrontmatter(content);\n\nif (string.IsNullOrEmpty(frontmatter)) return null;\n\nvar skill = _yamlDeserializer.Deserialize<SkillDefinition>(frontmatter); skill.Id = Path.GetFileName(baseDir); skill.Instructions = body?.Trim(); skill.FilePath = filePath; skill.BaseDirectory = baseDir;\n\nreturn skill; }\n\nprivate (string? frontmatter, string? body) ExtractFrontmatter(string content) { if (!content.StartsWith(\"---\")) return (null, content);\n\nvar endIndex = content.IndexOf(\"---\", 3); if (endIndex == -1) return (null, content);\n\nvar frontmatter = content.Substring(3, endIndex - 3).Trim(); var body = content.Substring(endIndex + 3).Trim();\n\nreturn (frontmatter, body); } } ```\n\n## Connecting to MCP Servers\n\nThe MCP Client Service manages connections to one or more MCP servers, discovers their tools, and routes execution requests. Here’s the core implementation:\n\n```csharp public class McpClientService : IMcpClientService, IAsyncDisposable { private readonly List<IMcpClient> _clients = new(); private readonly Dictionary<string, (IMcpClient Client, McpClientTool Tool)> _toolMap = new();\n\npublic async Task ConnectAsync(IEnumerable<McpServerConfig> serverConfigs) { foreach (var config in serverConfigs) { var client = await McpClientFactory.CreateAsync( new StdioClientTransport(new StdioClientTransportOptions { Command = config.Command, Arguments = config.Arguments, WorkingDirectory = config.WorkingDirectory }));\n\n_clients.Add(client);\n\n// Discover and register tools var tools = await client.ListToolsAsync(); foreach (var tool in tools) { _toolMap[tool.Name] = (client, tool); } } }\n\npublic IReadOnlyList<McpClientTool> GetAllTools() { return _toolMap.Values.Select(x => x.Tool).ToList(); }\n\npublic async Task<string> ExecuteToolAsync(string toolName, Dictionary<string, object?> args) { if (!_toolMap.TryGetValue(toolName, out var entry)) throw new InvalidOperationException($\"Tool '{toolName}' not found\");\n\nvar result = await entry.Client.CallToolAsync(toolName, args); return result.Content.FirstOrDefault()?.Text ?? string.Empty; }\n\npublic async ValueTask DisposeAsync() { foreach (var client in _clients) { if (client is IAsyncDisposable disposable) await disposable.DisposeAsync(); } } } ```\n\nThe configuration for MCP servers typically lives in your appsettings.json:\n\n```json { \"McpServers\": { \"Servers\": [ { \"Name\": \"skills-mcp-server\", \"Command\": \"dotnet\", \"Arguments\": [\"../../../../SkillsMcpServer/bin/Debug/net8.0/SkillsMcpServer.dll\"], \"Environment\": {}, \"Enabled\": true }, { \"Name\": \"github-mcp-server\", \"Command\": \"npx\", \"Arguments\": [\"-y\", \"@modelcontextprotocol/server-github\"], \"Environment\": { \"GITHUB_PERSONAL_ACCESS_TOKEN\": \"\" }, \"Enabled\": true } ] } } ```\n\nNote that the `GITHUB_PERSONAL_ACCESS_TOKEN` is intentionally left empty. The McpClientService resolves empty environment values from .NET User Secrets at runtime, keeping sensitive tokens out of source control:\n\n```bash dotnet user-secrets set \"GITHUB_PERSONAL_ACCESS_TOKEN\" \"ghp_your_token_here\" ```\n\n## The Agentic Loop\n\nThe SkillExecutor orchestrates the conversation between the user, the LLM, and MCP tools. Here’s the core execution loop:\n\n```csharp public class SkillExecutor : ISkillExecutor { private readonly IAzureOpenAIService _openAI; private readonly IMcpClientService _mcpClient; private const int MaxIterations = 10;\n\npublic async Task<SkillResult> ExecuteAsync(SkillDefinition skill, string userInput) { var messages = new List<ChatMessage> { new SystemChatMessage(skill.Instructions ?? \"You are a helpful assistant.\"), new UserChatMessage(userInput) };\n\nvar tools = BuildToolDefinitions(_mcpClient.GetAllTools()); var iterations = 0;\n\nwhile (iterations++ < MaxIterations) { var response = await _openAI.GetCompletionAsync(messages, tools); messages.Add(new AssistantChatMessage(response));\n\n// Check if the LLM wants to call tools var toolCalls = response.ToolCalls; if (toolCalls == null || toolCalls.Count == 0) { // No tool calls = final response return new SkillResult { Response = response.Content.FirstOrDefault()?.Text ?? \"\", ToolCallCount = iterations - 1 }; }\n\n// Execute each tool call foreach (var toolCall in toolCalls) { var args = JsonSerializer.Deserialize<Dictionary<string, object?>>( toolCall.FunctionArguments);\n\nvar result = await _mcpClient.ExecuteToolAsync(toolCall.FunctionName, args);\n\nmessages.Add(new ToolChatMessage(toolCall.Id, result)); } }\n\nthrow new InvalidOperationException(\"Max iterations exceeded\"); }\n\nprivate IList<ChatTool> BuildToolDefinitions(IReadOnlyList<McpClientTool> mcpTools) { return mcpTools.Select(tool => ChatTool.CreateFunctionTool( tool.Name, tool.Description, BinaryData.FromString(tool.JsonSchema.GetRawText()) )).ToList(); } } ```\n\nThe loop continues until the LLM produces a response without requesting any tool calls, or until we hit a safety limit on iterations. Each tool call result gets added to the conversation history, giving the LLM full context of what it has learned.\n\n## Building Custom MCP Server Tools\n\nThe MCP C# SDK makes it easy to expose custom tools. Create a class with methods decorated with the `[McpServerTool]` attribute:\n\n```csharp [McpServerToolType] public static class ProjectAnalysisTools { [McpServerTool, Description(\"Analyzes a directory structure and returns a tree view\")] public static string AnalyzeDirectory( [Description(\"Path to the directory to analyze\")] string path, [Description(\"Maximum depth to traverse\")] int maxDepth = 3) { if (!Directory.Exists(path)) return $\"Error: Directory '{path}' does not exist\";\n\nvar sb = new StringBuilder(); BuildTree(path, sb, \"\", maxDepth, 0); return sb.ToString(); }\n\n[McpServerTool, Description(\"Counts lines of code by file extension\")] public static string CountLines( [Description(\"Path to the directory to analyze\")] string path, [Description(\"File extensions to include (e.g., .cs,.js)\")] string? extensions = null) { var extList = extensions?.Split(',').Select(e => e.Trim()).ToHashSet() ?? new HashSet<string> { \".cs\", \".js\", \".ts\", \".py\", \".json\" };\n\nvar counts = new Dictionary<string, int>(); foreach (var file in Directory.EnumerateFiles(path, \"*.*\", SearchOption.AllDirectories)) { var ext = Path.GetExtension(file).ToLower(); if (!extList.Contains(ext)) continue;\n\nvar lines = File.ReadAllLines(file).Length; counts[ext] = counts.GetValueOrDefault(ext) + lines; }\n\nreturn string.Join(\"\\n\", counts.OrderByDescending(x => x.Value) .Select(x => $\"{x.Key}: {x.Value:N0} lines\")); }\n\n[McpServerTool, Description(\"Finds TODO, FIXME, and HACK comments in code\")] public static string FindPatterns( [Description(\"Path to the directory to search\")] string path) { var patterns = new[] { \"TODO\", \"FIXME\", \"HACK\", \"BUG\" }; var results = new List<string>();\n\nforeach (var file in Directory.EnumerateFiles(path, \"*.*\", SearchOption.AllDirectories)) { var lines = File.ReadAllLines(file); for (int i = 0; i < lines.Length; i++) { foreach (var pattern in patterns) { if (lines[i].Contains(pattern, StringComparison.OrdinalIgnoreCase)) { var relativePath = Path.GetRelativePath(path, file); results.Add($\"[{pattern}] {relativePath}:{i + 1} - {lines[i].Trim()}\"); } } } }\n\nreturn results.Count > 0 ? string.Join(\"\\n\", results) : \"No patterns found.\"; }\n\nprivate static void BuildTree(string path, StringBuilder sb, string indent, int maxDepth, int depth) { if (depth >= maxDepth) return;\n\nvar dirName = Path.GetFileName(path); sb.AppendLine($\"{indent}{dirName}/\");\n\nforeach (var file in Directory.GetFiles(path)) sb.AppendLine($\"{indent} {Path.GetFileName(file)}\");\n\nforeach (var dir in Directory.GetDirectories(path)) { if (Path.GetFileName(dir).StartsWith(\".\")) continue; BuildTree(dir, sb, indent + \" \", maxDepth, depth + 1); } } } ```\n\nThe server Program.cs is minimal:\n\n```csharp using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using ModelContextProtocol.Server;\n\nvar builder = Host.CreateApplicationBuilder(args);\n\nbuilder.Services .AddMcpServer() .WithStdioServerTransport() .WithToolsFromAssembly();\n\nawait builder.Build().RunAsync(); ```\n\nWhen the Skills Executor starts your MCP server, the SDK automatically discovers all methods marked with `[McpServerTool]` and exposes them through the MCP protocol.\n\n## Three Skills, Three Patterns\n\nTo demonstrate the flexibility of this architecture, let’s look at three skills that use tools differently:\n\n**Code Explainer** uses no tools at all—pure LLM reasoning:\n\n```markdown --- name: Code Explainer description: Explains code in plain English. No tools required. tags: [code, explanation, no-tools] ---\n\n# Code Explainer\n\nYou are an expert code explainer. Your job is to take any code snippet and explain it clearly so developers of all skill levels can understand it.\n\n## Your Approach\n\nWhen explaining code:\n1. Start with a high-level summary (2-3 sentences)\n2. Walk through the code step by step\n3. Identify key patterns and concepts\n4. Explain any design decisions\n\nRemember: Use only your knowledge—no external tools needed. ```\n\n**Project Analyzer** uses your custom MCP server tools:\n\n```markdown --- name: Project Analyzer description: Analyzes codebases using custom MCP tools. tags: [analysis, custom-tools, mcp] ---\n\n# Project Analyzer\n\nYou are a codebase analyst with access to powerful analysis tools.\n\n## Available Tools\n\n- **analyze_directory**: Shows file structure as a tree\n- **count_lines**: Counts lines of code by file type\n- **find_patterns**: Finds TODO, FIXME, HACK in code\n\n## Workflow\n\n1. Use analyze_directory to understand the project structure\n2. Use count_lines to get size metrics by language\n3. Use find_patterns to identify technical debt markers\n4. Synthesize findings into an actionable report\n\n**ALWAYS call tools to gather real data. Do not make assumptions about the codebase.** ```\n\n**GitHub Assistant** uses the external GitHub MCP server:\n\n```markdown --- name: GitHub Assistant description: Interacts with GitHub using the GitHub MCP Server. tags: [github, external-mcp, repositories] ---\n\n# GitHub Assistant\n\nYou have access to tools from the **GitHub MCP Server**.\n\n## Available Tools\n\n- **search_repositories** - Search for repositories by topic/language\n- **list_issues** - List issues in a repository\n- **get_file_contents** - Get contents of a file from a repo\n- **search_code** - Search for code patterns across GitHub\n\n## How to Help Users\n\nWhen users ask about repositories, issues, or code:\n1. Identify which tool is needed\n2. Call the tool with appropriate parameters\n3. Summarize the results clearly\n\nThese are EXTERNAL tools from the GitHub MCP server—not local tools. ```\n\nNotice how the skill instructions guide the LLM’s tool usage. The Code Explainer never mentions tools, so the LLM relies on pure reasoning. The Project Analyzer explicitly requires tool usage and provides a workflow. The GitHub Assistant explains tool purposes and provides mapping from user requests to tool calls.\n\n## Running the Skills Executor\n\nWith everything wired up, using the Skills Executor is straightforward:\n\n```csharp // Load available skills var skills = await skillLoader.LoadSkillsAsync(\"./skills\");\n\n// Display skill menu and let user select var selectedSkill = PromptForSkillSelection(skills);\n\n// Get user input var userInput = Console.ReadLine();\n\n// Execute the skill var result = await skillExecutor.ExecuteAsync(selectedSkill, userInput);\n\n// Display results Console.WriteLine(result.Response); ```\n\nWhen the user selects the Project Analyzer skill and asks “Analyze the structure of my project at C:\\MyProject”, the executor:\n\n1. Loads the Project Analyzer skill’s instructions as the system prompt\n2. Sends the user’s request to Azure OpenAI along with available tools\n3. The LLM responds with a tool call: `analyze_directory(path=\"C:\\MyProject\")`\n4. The executor routes the call to the MCP server and returns results\n5. The LLM processes results and calls additional tools as needed\n6. Eventually the LLM produces a final analysis report\n\nThe entire interaction flows naturally from the skill’s instructions guiding the LLM’s decisions.\n\n## Why This Architecture Matters for Enterprise\n\nThis isn’t just a technical exercise. The pattern solves real problems enterprises face when scaling AI adoption.\n\n**Standardization without rigidity.** Skills let you standardize how AI performs common tasks without hardcoding business logic into application code. When your code review standards change, you update the skill—not the orchestrator.\n\n**Tool reusability.** MCP servers expose tools that any skill can use. Your project analysis tools work whether invoked by a code reviewer skill, a documentation generator skill, or a migration planning skill.\n\n**Ecosystem compatibility.** Because skills follow Anthropic’s open standard, they’re portable. Skills you create work in VS Code, GitHub Copilot, and any other tool that supports the standard. Your investment compounds across your development toolchain.\n\n**Separation of concerns.** Domain experts can write skills without understanding the orchestration layer. Platform teams can enhance the executor without touching individual skills. Tool developers can add capabilities without affecting existing skills.\n\n**Testability.** Each component can be tested independently. Unit test skill parsing, integration test MCP server tools, end-to-end test complete skill execution—all with standard .NET testing patterns.\n\n## What’s Next\n\nThis implementation provides a foundation you can extend in several directions.\n\nAdd skill chaining to allow one skill to invoke another, enabling complex workflows like “analyze the codebase, then generate documentation based on findings.”\n\nImplement skill versioning to manage updates without breaking existing workflows, critical for enterprise environments where stability matters.\n\nBuild a skill registry service that centralizes skill discovery across your organization, making it easy for teams to share and reuse skills.\n\nAdd observability hooks to track skill usage, tool invocation patterns, and execution metrics—essential for understanding how AI is being used across your organization.\n\nThe Skills Executor is a starting point. The real value comes from the skills your organization creates—encoding your specific procedures, standards, and expertise into composable components that make AI actually work the way your business works.\n\n## Get the Code\n\nThe complete implementation discussed in this article is available on GitHub at [github.com/MCKRUZ/DotNetSkills](https://github.com/MCKRUZ/DotNetSkills). Clone the repository to explore the full source code, run the examples, or use it as a foundation for building your own skills executor.\n\n## References\n\n- Model Context Protocol Specification. [modelcontextprotocol.io](https://modelcontextprotocol.io/)\n- MCP C# SDK (Microsoft/Anthropic). [github.com/modelcontextprotocol/csharp-sdk](https://github.com/modelcontextprotocol/csharp-sdk)\n- Azure OpenAI Service Documentation. [learn.microsoft.com](https://learn.microsoft.com/en-us/azure/ai-services/openai/)\n- Building MCP Servers in .NET. [devblogs.microsoft.com](https://devblogs.microsoft.com/dotnet/build-a-model-context-protocol-mcp-server-in-csharp/)\n- Anthropic Agent Skills Framework. [anthropic.com/news/skills](https://www.anthropic.com/news/skills)\n- DotNetSkills – Complete Example Implementation. [github.com/MCKRUZ/DotNetSkills](https://github.com/MCKRUZ/DotNetSkills)",
  "Link": "https://devblogs.microsoft.com/foundry/dotnet-ai-skills-executor-azure-openai-mcp/",
  "FeedName": "Microsoft AI Foundry Blog",
  "FeedUrl": "https://devblogs.microsoft.com/foundry/feed/",
  "Description": "We welcome guest author, Matt Kruczek, to share how to build a complete Skills Executor in .NET, combining Azure OpenAI with the Model Context Protocol (MCP) C# SDK to bring the same agentic patterns to the Microsoft ecosystem. You’ll see how to define reusable skills, connect local and external tools, and orchestrate intelligent agent loops—so enterprise teams can standardize AI behavior without hardcoding business logic.\n\nThe post [Building an AI Skills Executor in .NET: Bringing Anthropic’s Agent Pattern to the Microsoft Ecosystem](https://devblogs.microsoft.com/foundry/dotnet-ai-skills-executor-azure-openai-mcp/) appeared first on [Microsoft Foundry Blog](https://devblogs.microsoft.com/foundry).",
  "Author": "Matt Kruczek",
  "FeedLevelAuthor": "Microsoft Foundry Blog",
  "Title": "Building an AI Skills Executor in .NET: Bringing Anthropic’s Agent Pattern to the Microsoft Ecosystem",
  "PubDate": "2026-02-06T19:11:04+00:00",
  "Tags": [
    ".NET",
    "Agentic Architecture",
    "AI Development",
    "ai-agents",
    "AIAgent",
    "MCP",
    "Microsoft Foundry"
  ],
  "ProcessedDate": "2026-02-06 19:14:27",
  "OutputDir": "_news"
}
