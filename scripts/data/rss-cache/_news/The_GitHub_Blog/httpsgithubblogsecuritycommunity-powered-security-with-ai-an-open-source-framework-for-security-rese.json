{
  "FeedUrl": "https://github.blog/feed/",
  "Author": "Kevin Backhouse",
  "Link": "https://github.blog/security/community-powered-security-with-ai-an-open-source-framework-for-security-research/",
  "ProcessedDate": "2026-01-14 19:03:08",
  "OutputDir": "_news",
  "EnhancedContent": "Since its [founding in 2019](https://github.blog/changelog/2019-11-14-security-lab/), GitHub Security Lab has had one primary goal: *community-powered security*. We believe that the best way to improve software security is by sharing knowledge and tools, and by using open source software so that everybody is empowered to audit the code and report any vulnerabilities that they find.\n\nSix years later, a new opportunity has emerged to take community-powered security to the next level. Thanks to AI, we can now use natural language to encode, share, and scale our security knowledge, which will make it even easier to build and share new security tools. And under the hood, we can use [Model Context Protocol (MCP) interfaces](https://modelcontextprotocol.io/) to build on existing security tools like [CodeQL](https://codeql.github.com/).\n\nAs a community, we can eliminate software vulnerabilities far more quickly if we share our knowledge of how to find them. With that goal in mind, our team has been experimenting with an agentic framework called the [GitHub Security Lab Taskflow Agent](https://github.com/GitHubSecurityLab/seclab-taskflow-agent). We‚Äôve been using it internally for a while, and we also recently shared it with the participants of the [GitHub Secure Open Source Fund](https://github.com/open-source/github-secure-open-source-fund). Although it‚Äôs still experimental, it‚Äôs ready for others to use.\n\n# Demo: Variant analysis\n\nIt takes only a few steps to get started with seclab-taskflow-agent:\n\n1. Create a personal access token.\n2. Add codespace secrets.\n3. Start a codespace.\n4. Run a taskflow with a one-line command.\n\nPlease follow along and give it a try!\n\n*Note: This demo will use some of your token quota, and it‚Äôs possible that you‚Äôll hit* [*rate limits*](https://docs.github.com/en/github-models/use-github-models/prototyping-with-ai-models#rate-limits)*, particularly if you‚Äôre using a free GitHub account. But I‚Äôve tried to design the demo so that it will work on a free account. The quotas will refresh after one day if you do hit the rate limits.*\n\n## Create a fine-grained personal access token\n\nGo to your [developer settings page](https://github.com/settings/personal-access-tokens/new) and create a personal access token (PAT).\n\n![Screenshot of the developer settings page where I am creating a new PAT.](https://github.blog/wp-content/uploads/2026/01/fine-grained-pat.png?resize=1024%2C496)\n\nScroll down and add the ‚Äúmodels‚Äù permission:\n\n![Screenshot of the developer settings page where I am adding the \"Models\" permission to my new PAT.](https://github.blog/wp-content/uploads/2026/01/public-repos.png?resize=1024%2C954)\n\n## Add codespaces secrets\n\nFor security reasons, it‚Äôs not a good idea to save the PAT that you just created in a file on disk. Instead, I recommend saving it as a ‚Äúcodespace secret,‚Äù which means it‚Äôll be available as an environment variable when you start a codespace in the next step.\n\nGo to [your codespaces settings](https://github.com/settings/codespaces/secrets/new) and create a secret named `GH_TOKEN` :\n\n![Screenshot of the codespaces settings page, where I am adding a new secret.](https://github.blog/wp-content/uploads/2026/01/new-secret.png?resize=1024%2C879)\n\nUnder ‚ÄúRepository access,‚Äù add [`GitHubSecurityLab/seclab-taskflows`](https://github.com/GitHubSecurityLab/seclab-taskflows), which is the repo that we‚Äôll start the codespace from.\n\nNow go back to [your codespaces settings](https://github.com/settings/codespaces/secrets/new) and create a second secret named `AI_API_TOKEN` . You can use the same PAT for both secrets.\n\nWe want to use two secrets so that `GH_TOKEN` is used to access GitHub‚Äôs API and do things like read the code, whereas `AI_API_TOKEN` can access the AI API. Only one PAT is needed for this demo because it uses the GitHub Models API, but the framework also supports using other (not GitHub) APIs for the AI requests.\n\n## Start a codespace\n\nNow go to the [seclab-taskflows repo](https://github.com/GitHubSecurityLab/seclab-taskflows) and start a codespace:\n\n![Screenshot of starting a new codespace from the seclab-taskflows repo.](https://github.blog/wp-content/uploads/2026/01/codespaces.png?resize=1024%2C820)\n\nAfter the codespace starts, wait a few minutes until you see a prompt like this:\n\n![Screenshot of the terminal window in the newly started codespace, showing the (.venv) prompt.](https://github.blog/wp-content/uploads/2026/01/terminal.png?resize=1024%2C163)\n\nIt‚Äôs important to wait until you see (`.venv` ) before the prompt, as it indicates that the [Python virtual environment](https://docs.python.org/3/library/venv.html) has been created.\n\n## Run a taskflow with a one-line command\n\nIn the codespace terminal, enter this command to run the variant analysis demo taskflow:\n\n``` python -m seclab_taskflow_agent -t seclab_taskflows.taskflows.audit.ghsa_variant_analysis_demo -g repo=github/cmark-gfm -g ghsa=GHSA-c944-cv5f-hpvr ```\n\nAnswer ‚Äúyes‚Äù when it asks for permission to run `memcache_clear_cache` ; this is the first run so the cache is already empty. The demo downloads and analyzes a [security advisory](https://docs.github.com/en/code-security/security-advisories/working-with-repository-security-advisories/about-repository-security-advisories) from the repository (in this example, [`GHSA-c944-cv5f-hpvr`](https://github.com/github/cmark-gfm/security/advisories/GHSA-c944-cv5f-hpvr) from [cmark-gfm](https://github.com/github/cmark-gfm)). It tries to identify the source code file that caused the vulnerability, then it downloads that source code file and audits it for other similar bugs. It‚Äôs not a sophisticated demo, and (thankfully) it has not found any new bugs in cmark-gfm ü´£. But it‚Äôs short and simple, and I‚Äôll use it later to explain what a taskflow is. You can also try it out on a different repository, maybe one of your own, by changing the repo name at the end of the command.\n\n# Other ways to run\n\nI recommend using a codespace because it‚Äôs a quick, reliable way to get started. It‚Äôs also a sandboxed environment, which is good for security. But there are other ways to run the framework if you prefer.\n\n## Running in a Linux terminal\n\nThese are the commands to install and run the demo locally on a Linux system:\n\n``` export AI_API_TOKEN=github_pat_XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX export GH_TOKEN=$AI_API_TOKEN python3 -m venv .venv source .venv/bin/activate pip install seclab-taskflows python -m seclab_taskflow_agent -t seclab_taskflows.taskflows.audit.ghsa_variant_analysis_demo -g repo=github/cmark-gfm -g ghsa=GHSA-c944-cv5f-hpvr ```\n\nThese commands download our latest release from [PyPI](https://pypi.org/). Note that some of the toolboxes included with the framework may not work out-of-the-box with this approach because they depend on other software being installed. For example, the [CodeQL toolbox](https://github.com/GitHubSecurityLab/seclab-taskflow-agent/blob/v0.0.9/src/seclab_taskflow_agent/toolboxes/codeql.yaml) depends on [CodeQL](https://codeql.github.com/) being installed. You can copy the installation instructions from the [devcontainer configuration](https://github.com/GitHubSecurityLab/seclab-taskflows/tree/v0.0.3/.devcontainer) that we use to build our codespaces environment.\n\n## Running in docker\n\nWe publish a [docker image](https://github.com/GitHubSecurityLab/seclab-taskflow-agent/pkgs/container/seclab-taskflow-agent) with tools like CodeQL pre-installed. You can run it with [this script](https://github.com/GitHubSecurityLab/seclab-taskflow-agent/blob/v0.0.9/docker/run.sh). Be aware that this docker image only includes [seclab-taskflow-agent](https://github.com/GitHubSecurityLab/seclab-taskflow-agent). We are planning to publish a second ‚Äúbatteries included‚Äù image that also includes [seclab-taskflows](https://github.com/GitHubSecurityLab/seclab-taskflows) in the future. Note: I‚Äôll explain the relationship between seclab-taskflow-agent and seclab-taskflows in the section about the collaboration model.\n\n# Taskflows\n\nA taskflow is a YAML file containing a list of tasks for the framework to execute. Let‚Äôs look at the taskflow for my demo ([source](https://github.com/GitHubSecurityLab/seclab-taskflows/blob/v0.0.3/src/seclab_taskflows/taskflows/audit/ghsa_variant_analysis_demo.yaml)):\n\n``` seclab-taskflow-agent: filetype: taskflow version: 1\n\nglobals: repo: ghsa:\n\ntaskflow:\n- task:\nmust_complete: true agents:\n- seclab_taskflow_agent.personalities.assistant\ntoolboxes:\n- seclab_taskflow_agent.toolboxes.memcache\nuser_prompt: | Clear the memory cache.\n\n- task:\nmust_complete: true agents:\n- seclab_taskflow_agent.personalities.assistant\ntoolboxes:\n- seclab_taskflows.toolboxes.ghsa\n- seclab_taskflows.toolboxes.gh_file_viewer\n- seclab_taskflow_agent.toolboxes.memcache\nuser_prompt: | Fetch the details of the GHSA {{ GLOBALS_ghsa }} of the repo {{ GLOBALS_repo }}.\n\nAnalyze the description to understand what type of bug caused the vulnerability. DO NOT perform a code audit at this stage, just look at the GHSA details.\n\nCheck if any source file is mentioned as the cause of the GHSA. If so, identify the precise file path and line number.\n\nIf no file path is mentioned, then report back to the user that you cannot find any file path and end the task here.\n\nThe GHSA may not specify the full path name of the source file, or it may mention the name of a function or method instead, so if you have difficulty finding the file, try searching for the most likely match.\n\nOnly identify the file path for now, do not look at the code or fetch the file contents yet.\n\nStore a summary of your findings in the memcache with the GHSA ID as the key. That should include the file path and the function that the file is in.\n\n- task:\nmust_complete: true agents:\n- seclab_taskflow_agent.personalities.assistant\ntoolboxes:\n- seclab_taskflows.toolboxes.gh_file_viewer\n- seclab_taskflow_agent.toolboxes.memcache\nuser_prompt: | Fetch the GHSA ID and summary that were stored in the memcache by the previous task.\n\nLook at the file path and function that were identified. Use the get_file_lines_from_gh tool to fetch a small portion of the file instead of fetching the entire file.\n\nFetch the source file that was identified as the cause of the GHSA in repo {{ GLOBALS_repo }}.\n\nDo a security audit of the code in the source file, focusing particularly on the type of bug that was identified as the cause of the GHSA. ```\n\nYou can see that it‚Äôs quite similar in structure to a GitHub Actions workflow. There‚Äôs a header at the top, followed by the body, which contains a series of tasks. The tasks are completed one by one by the agent framework. Let‚Äôs go through the sections one by one, focusing on the most important bits:\n\n## Header\n\nThe first part of the header defines the file type. The most frequently used file types are:\n\n- `taskflow`\n: Describes a sequence of tasks for the framework to execute.\n- `personality`\n: It‚Äôs often useful to ask to assume a particular personality while executing a task. For example, we have an [`action_expert`](https://github.com/GitHubSecurityLab/seclab-taskflows/blob/v0.0.3/src/seclab_taskflows/personalities/action_expert.yaml) personality that is useful for auditing actions workflows.\n- toolbox: Contains instructions for running an MCP server. For example, the demo uses the [`gh_file_viewer`](https://github.com/GitHubSecurityLab/seclab-taskflows/blob/v0.0.3/src/seclab_taskflows/toolboxes/gh_file_viewer.yaml) toolbox for downloading source code files from GitHub.\n\nThe globals section defines global variables named ‚Äúrepo‚Äù and ‚Äúghsa,‚Äù which we initialized with the command-line arguments `-g repo=github/cmark-gfm` and `-g ghsa=GHSA-c944-cv5f-hpvr` . It‚Äôs a crude way to parameterize a taskflow.\n\n## Task 1\n\nTasks always specify a ‚Äúpersonality‚Äù to use. For non-specialized tasks, we often just use the [`assistant`](https://github.com/GitHubSecurityLab/seclab-taskflow-agent/blob/v0.0.9/src/seclab_taskflow_agent/personalities/assistant.yaml) personality.\n\nEach task starts with a fresh context, so the only way to communicate a result from one task to the next is by using a toolbox as an intermediary. In this demo, I‚Äôve used the [`memcache`](https://github.com/GitHubSecurityLab/seclab-taskflow-agent/blob/v0.0.9/src/seclab_taskflow_agent/toolboxes/memcache.yaml) toolbox, which is a simple key-value store. We find that this approach is better for debugging, because it means that you can rerun an individual task with consistent inputs when you‚Äôre testing it.\n\nThis task also demonstrates that toolboxes can [ask for confirmation](https://github.com/GitHubSecurityLab/seclab-taskflow-agent/blob/v0.0.9/src/seclab_taskflow_agent/toolboxes/memcache.yaml#L17-L18) before doing something potentially destructive, which is an important protection against [prompt injection](https://genai.owasp.org/llmrisk/llm01-prompt-injection/) attacks.\n\n## Task 2\n\nThis task uses the [`ghsa`](https://github.com/GitHubSecurityLab/seclab-taskflows/blob/v0.0.3/src/seclab_taskflows/toolboxes/ghsa.yaml) toolbox to download the security advisory from the repository and the [`gh_file_viewer`](https://github.com/GitHubSecurityLab/seclab-taskflows/blob/v0.0.3/src/seclab_taskflows/toolboxes/gh_file_viewer.yaml) toolbox to find the source file that‚Äôs mentioned in the advisory. It creates a summary and uses the [`memcache`](https://github.com/GitHubSecurityLab/seclab-taskflow-agent/blob/v0.0.9/src/seclab_taskflow_agent/toolboxes/memcache.yaml) toolbox to pass it to the next task.\n\n## Task 3\n\nThis task uses the [`memcache`](https://github.com/GitHubSecurityLab/seclab-taskflow-agent/blob/v0.0.9/src/seclab_taskflow_agent/toolboxes/memcache.yaml) toolbox to fetch the results from the previous task and the [`gh_file_viewer`](https://github.com/GitHubSecurityLab/seclab-taskflows/blob/v0.0.3/src/seclab_taskflows/toolboxes/gh_file_viewer.yaml) toolbox to download the source code and audit it.\n\nOften, the wording of a prompt is more subtle than it looks, and this third task is an example of that. Previous versions of this task tried to analyze the entire source file in one go, which used too many tokens. So the second paragraph, which asks to analyze a ‚Äúsmall portion of the file,‚Äù is very important to make this task work successfully.\n\n## Taskflows summary\n\nI hope this demo has given you a sense of what a taskflow is. You can find more detailed documentation in [`README.md`](https://github.com/GitHubSecurityLab/seclab-taskflow-agent/blob/v0.0.9/README.md) and [`GRAMMAR.md`](https://github.com/GitHubSecurityLab/seclab-taskflow-agent/blob/v0.0.9/doc/GRAMMAR.md). You can also find more examples in [this subdirectory](https://github.com/GitHubSecurityLab/seclab-taskflow-agent/tree/v0.0.9/examples/taskflows) of seclab-taskflow-agent and [this subdirectory](https://github.com/GitHubSecurityLab/seclab-taskflows/tree/v0.0.3/src/seclab_taskflows/taskflows) of seclab-taskflows.\n\n# Collaboration model\n\nWe would love for members of the community to publish their own suites of taskflows. To make collaboration easy, we have built on top of Python‚Äôs packaging ecosystem. Our own two repositories are published as packages on [PyPI](https://pypi.org/):\n\n1. [seclab-taskflow-agent](https://pypi.org/project/seclab-taskflow-agent/): the implementation of the taskflow framework.\n2. [seclab-taskflows](https://pypi.org/project/seclab-taskflows/): a suite of taskflows written by our team.\n\nThe reason why we have two repositories is that we want to separate the ‚Äúengine‚Äù from the suites of taskflows that use it. Also, [seclab-taskflows](https://pypi.org/project/seclab-taskflows/) is intended to be an easy-to-copy template for anybody who would like to publish their own suite of taskflows. To get started on your package, we recommend using the [hatch new](https://hatch.pypa.io/latest/cli/reference/#hatch-new) command to create the initial project structure. It will generate things like the pyproject.toml file, which you‚Äôll need for uploading to PyPI. Next we recommend creating a [directory structure like ours](https://github.com/GitHubSecurityLab/seclab-taskflows/tree/v0.0.3/src/seclab_taskflows), with sub-directories for taskflows, toolboxes, etc. Feel free to also copy other parts of seclab-taskflows, such as our [publish-to-pypi.yaml](https://github.com/GitHubSecurityLab/seclab-taskflows/blob/v0.0.3/.github/workflows/publish-to-pypi.yaml) workflow, which automatically uploads your package to PyPI when you push a tag with a name like ‚Äúv1.0.0.‚Äù\n\nAn important feature of the collaboration model is that it is also easy to share MCP servers. For example, check out [the MCP servers that are included with the seclab-taskflows package](https://github.com/GitHubSecurityLab/seclab-taskflows/tree/v0.0.3/src/seclab_taskflows/mcp_servers). Each MCP server has a corresponding toolbox YAML file (in the [toolboxes](https://github.com/GitHubSecurityLab/seclab-taskflows/tree/v0.0.3/src/seclab_taskflows/toolboxes) directory) which contains the instructions for running it.\n\n## The import system\n\nTaskflows often need to refer to other files, like personalities or toolboxes. And for the collaboration model to work well, we want you to be able to reuse personalities and toolboxes from other packages. We are leveraging Python‚Äôs [importlib](https://docs.python.org/3/library/importlib.html) to make it easy to reference a file from a different package. To illustrate how it works, here‚Äôs an [example](https://github.com/GitHubSecurityLab/seclab-taskflows/blob/v0.0.3/src/seclab_taskflows/taskflows/audit/ghsa_variant_analysis_demo.yaml#L22-L23) in which seclab-taskflows is using a toolbox from seclab-taskflow-agent:\n\n``` toolboxes:\n- seclab_taskflow_agent.toolboxes.memcache\n```\n\nThe [implementation](https://github.com/GitHubSecurityLab/seclab-taskflow-agent/blob/v0.0.9/src/seclab_taskflow_agent/available_tools.py#L58-L69) splits the name `seclab_taskflow_agent.toolboxes.memcache` into a directory (`seclab_taskflow_agent.toolboxes` ) and a filename (`memcache` ). Then it uses Python‚Äôs [`importlib.resources.files`](https://docs.python.org/3/library/importlib.resources.html#importlib.resources.files) to locate the directory and loads the file named `memcache.yaml` from that directory. The only quirk of this system is that names always need to have at least two parts, which means that your files always need to be stored at least one directory deep. But apart from that, we‚Äôre using Python‚Äôs import system as is, which means that there‚Äôs plenty of documentation and advice available online.\n\n# Project vision\n\nWe have two main goals with this project. First is to **encourage community-powered security**. Many of the agentic security tools that are currently popping up are closed-source black boxes, which is the antithesis of what we stand for as a team. We want people to be able to look under the hood and see how the taskflows work. And we want people to be able to easily create and share their own taskflows. As a community, we can eliminate software vulnerabilities far more quickly if we share our knowledge of how to find them. We‚Äôre hoping that taskflows can be an effective tool for that.\n\nSecond is to **create a tool that we want to use ourselves**. As a research team, we want a tool that‚Äôs good for rapid experimentation. We need to be able to quickly create a new security rule and try it out. With that in mind, we‚Äôre not trying to create the world‚Äôs most polished or efficient tool, but rather something that‚Äôs easy to modify.\n\n[Check out the latest security news &gt;](https://github.blog/security/)",
  "PubDate": "2026-01-14T18:45:09+00:00",
  "Title": "Community-powered security with AI: an open source framework for security research",
  "Tags": [
    "agentic AI",
    "AI & ML",
    "GitHub Security Lab",
    "MCP",
    "Open Source",
    "Security"
  ],
  "FeedLevelAuthor": "The GitHub Blog",
  "Description": "Announcing GitHub Security Lab Taskflow Agent, an open source and collaborative framework for security research with AI.\n\nThe post [Community-powered security with AI: an open source framework for security research](https://github.blog/security/community-powered-security-with-ai-an-open-source-framework-for-security-research/) appeared first on [The GitHub Blog](https://github.blog).",
  "FeedName": "The GitHub Blog"
}
