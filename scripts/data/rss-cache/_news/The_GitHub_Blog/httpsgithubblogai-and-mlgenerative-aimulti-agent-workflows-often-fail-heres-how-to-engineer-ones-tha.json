{
  "ProcessedDate": "2026-02-24 16:19:16",
  "Link": "https://github.blog/ai-and-ml/generative-ai/multi-agent-workflows-often-fail-heres-how-to-engineer-ones-that-dont/",
  "Tags": [
    "agentic AI",
    "AI & ML",
    "AI agents",
    "Generative AI",
    "GitHub Copilot"
  ],
  "Author": "Gwen Davis",
  "OutputDir": "_news",
  "EnhancedContent": "If youâ€™ve built a multi-agent workflow, youâ€™ve probably seen it fail in a way thatâ€™s hard to explain.\n\nThe system completes, and agents take actions. But somewhere along the way, something subtle goes wrong. You might see an agent close an issue that another agent just opened, or ship a change that fails a downstream check it didnâ€™t know existed.\n\nThatâ€™s because the moment agents begin handling related tasksâ€”triaging issues, proposing changes, running checks, and opening pull requestsâ€”they start making implicit assumptions about state, ordering, and validation. Without providing explicit instructions, data formats, and interfaces, things wonâ€™t go the way you planned.\n\nThrough our work on agentic experiences at GitHub across GitHub Copilot, internal automations, and emerging multi-agent orchestration patterns, weâ€™ve seen multi-agent systems behave much less like chat interfaces and much more like distributed systems.\n\nThis post is for engineers building multi-agent systems. Weâ€™ll walk through the most common reasons they fail and the engineering patterns that make them more reliable.\n\n## 1. Natural language is messy. Typed schemas make it reliable.\n\nMulti-agent workflows often fail early because agents exchange messy language or inconsistent JSON. Field names change, data types donâ€™t match, formatting shifts, and nothing enforces consistency.\n\nJust like establishing contracts early in development helps teams collaborate without stepping on each other, typed interfaces and strict schemas add structure at every boundary. Agents pass machine-checkable data, invalid messages fail fast, and downstream steps donâ€™t have to guess what a payload means.\n\nMost teams start by defining the data shape they expect agents to return:\n\n``` type UserProfile = { id: number; email: string; plan: \"free\" | \"pro\" | \"enterprise\"; }; ```\n\nThis changes debugging from â€œinspect logs and guessâ€ to â€œthis payload violated schema X.â€ Treat schema violations like contract failures: retry, repair, or escalate before bad state propagates.\n\n**The bottom line:** Typed schemas are table stakes in multi-agent workflows. Without them, nothing else works. [See how GitHub Models enable structured, repeatable AI workflows in real projects.](https://github.blog/open-source/maintainers/how-github-models-can-help-open-source-maintainers-focus-on-what-matters/) ğŸ‘‰\n\n## 2. Vague intent breaks agents. Action schemas make it clear.\n\nEven with typed data, multi-agent workflows still fail because LLMs donâ€™t follow implied intent, only explicit instructions.\n\nâ€œAnalyze this issue and help the team take actionâ€ sounds clear. But different agents may close, assign, escalate, or do nothingâ€”each reasonable, none automatable.\n\nAction schemas fix this by defining the exact set of allowed actions and their structure. Not every step needs structure, but the outcome must always resolve to a small, explicit set of actions.\n\nHereâ€™s what an action schema might look like:\n\n``` const ActionSchema = z.discriminatedUnion(\"type\", [ { type: \"request-more-info\", missing: string[] }, { type: \"assign\", assignee: string }, { type: \"close-as-duplicate\", duplicateOf: number }, { type: \"no-action\" } ]); ```\n\nWith this in place, agents must return exactly one valid action. Anything else fails validation and is retried or escalated.\n\n**The bottom line:** Most agent failures are action failures. [For reducing ambiguity even earlier in the workflowâ€”at the instruction levelâ€”this guide to writing effective custom instructions is helpful.](https://github.blog/ai-and-ml/github-copilot/5-tips-for-writing-better-custom-instructions-for-copilot/) ğŸ‘‰\n\n## 3. Loose interfaces create errors. MCP adds the structure agents need.\n\nTyped schemas, constrained actions, and structured reasoning only work if theyâ€™re consistently enforced. Without enforcement, theyâ€™re conventions, not guarantees.\n\n[Model Context Protocol (MCP)](https://github.com/modelcontextprotocol) is the enforcement layer that turns these patterns into contracts.\n\nMCP defines explicit input and output schemas for every tool and resource, validating calls before execution.\n\n``` { \"name\": \"create_issue\", \"input_schema\": { ... }, \"output_schema\": { ... } } ```\n\nWith MCP, agents canâ€™t invent fields, omit required inputs, or drift across interfaces. Validation happens before execution, which prevents bad state from ever reaching production systems.\n\n**The bottom line:** Schemas define structure whereas action schemas define intent. MCP enforces both. [Learn more about how MCP works and why it matters.](https://github.blog/ai-and-ml/llms/what-the-heck-is-mcp-and-why-is-everyone-talking-about-it/) ğŸ‘‰\n\n## Moving forward together\n\nMulti-agent systems work when structure is explicit. When you add typed schemas, constrained actions, and structured interfaces enforced by MCP, agents start behaving like reliable system components.\n\nThe shift is simple but powerful: treat agents like code, not chat interfaces.\n\n[Learn how MCP enables structured, deterministic agent-tool interactions.](https://docs.github.com/en/copilot/concepts/agents/coding-agent/mcp-and-coding-agent) ğŸ‘‰",
  "PubDate": "2026-02-24T16:00:00+00:00",
  "Description": "Most multi-agent workflow failures come down to missing structure, not model capability. Learn the three engineering patterns that make agent systems reliable.\n\nThe post [Multi-agent workflows often fail. Hereâ€™s how to engineer ones that donâ€™t.](https://github.blog/ai-and-ml/generative-ai/multi-agent-workflows-often-fail-heres-how-to-engineer-ones-that-dont/) appeared first on [The GitHub Blog](https://github.blog).",
  "FeedUrl": "https://github.blog/feed/",
  "FeedLevelAuthor": "The GitHub Blog",
  "Title": "Multi-agent workflows often fail. Hereâ€™s how to engineer ones that donâ€™t.",
  "FeedName": "The GitHub Blog"
}
