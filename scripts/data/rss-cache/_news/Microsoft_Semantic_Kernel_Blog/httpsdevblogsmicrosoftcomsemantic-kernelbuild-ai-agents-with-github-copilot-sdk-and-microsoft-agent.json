{
  "ProcessedDate": "2026-01-27 22:02:19",
  "Link": "https://devblogs.microsoft.com/semantic-kernel/build-ai-agents-with-github-copilot-sdk-and-microsoft-agent-framework/",
  "FeedName": "Microsoft Semantic Kernel Blog",
  "Title": "Build AI Agents with GitHub Copilot SDK and Microsoft Agent Framework",
  "OutputDir": "_news",
  "FeedUrl": "https://devblogs.microsoft.com/semantic-kernel/feed/",
  "Description": "Microsoft Agent Framework now integrates with the GitHub Copilot SDK, enabling you to build AI agents powered by GitHub Copilot. This integration brings together the Agent Framework’s consistent agent abstraction with GitHub Copilot’s capabilities, including function calling, streaming responses, multi-turn conversations, shell command execution, file operations, URL fetching, and Model Context Protocol (MCP) server integration […]\n\nThe post [Build AI Agents with GitHub Copilot SDK and Microsoft Agent Framework](https://devblogs.microsoft.com/semantic-kernel/build-ai-agents-with-github-copilot-sdk-and-microsoft-agent-framework/) appeared first on [Semantic Kernel](https://devblogs.microsoft.com/semantic-kernel).",
  "PubDate": "2026-01-27T21:37:26+00:00",
  "Tags": [
    ".NET",
    "Agent Framework",
    "Announcement",
    "Python"
  ],
  "Author": "Dmytro Struk",
  "FeedLevelAuthor": "Semantic Kernel",
  "EnhancedContent": "Microsoft Agent Framework now integrates with the [GitHub Copilot SDK](https://github.com/github/copilot-sdk), enabling you to build AI agents powered by GitHub Copilot. This integration brings together the Agent Framework’s consistent agent abstraction with GitHub Copilot’s capabilities, including function calling, streaming responses, multi-turn conversations, shell command execution, file operations, URL fetching, and Model Context Protocol (MCP) server integration — all available in both .NET and Python.\n\n## **Why Use Agent Framework with GitHub Copilot SDK?**\n\nYou can use the GitHub Copilot SDK on its own to build agents. So why use it through Agent Framework? Here are the key reasons:\n\n- **Consistent agent abstraction** — GitHub Copilot agents implement the same `AIAgent`\n(.NET) / `BaseAgent` (Python) interface as every other agent type in the framework. You can swap providers or combine them without restructuring your code.\n- **Multi-agent workflows** — Compose GitHub Copilot agents with other agents (Azure OpenAI, OpenAI, Anthropic, and more) in sequential, concurrent, handoff, and group chat workflows using built-in orchestrators.\n- **Ecosystem integration** — Access the full Agent Framework ecosystem: declarative agent definitions, A2A protocol support, and consistent patterns for function tools, sessions, and streaming across all providers.\n\nIn short, Agent Framework lets you treat GitHub Copilot as one building block in a larger agentic system rather than a standalone tool.\n\n## **Install the GitHub Copilot Integration**\n\n**.NET**\n\n``` dotnet add package Microsoft.Agents.AI.GithubCopilot --prerelease ```\n\n**Python**\n\n``` pip install agent-framework-github-copilot --pre ```\n\n## **Create a GitHub Copilot Agent**\n\nGetting started is straightforward. Create a `CopilotClient` (in .NET) or a `GithubCopilotAgent` (in Python) and start interacting with the agent.\n\n**.NET**\n\n```cs using GitHub.Copilot.SDK; using Microsoft.Agents.AI;\n\nawait using CopilotClient copilotClient = new(); await copilotClient.StartAsync();\n\nAIAgent agent = copilotClient.AsAIAgent();\n\nConsole.WriteLine(await agent.RunAsync(\"What is Microsoft Agent Framework?\")); ```\n\n**Python**\n\n```py from agent_framework.github import GithubCopilotAgent\n\nasync def main(): agent = GithubCopilotAgent( default_options={\"instructions\": \"You are a helpful assistant.\"}, )\n\nasync with agent: result = await agent.run(\"What is Microsoft Agent Framework?\") print(result) ```\n\n## **Add Function Tools**\n\nExtend your agent with custom function tools to give it domain-specific capabilities.\n\n**.NET**\n\n```cs using GitHub.Copilot.SDK; using Microsoft.Agents.AI; using Microsoft.Extensions.AI;\n\nAIFunction weatherTool = AIFunctionFactory.Create((string location) => { return $\"The weather in {location} is sunny with a high of 25C.\"; }, \"GetWeather\", \"Get the weather for a given location.\");\n\nawait using CopilotClient copilotClient = new(); await copilotClient.StartAsync();\n\nAIAgent agent = copilotClient.AsAIAgent( tools: [weatherTool], instructions: \"You are a helpful weather agent.\");\n\nConsole.WriteLine(await agent.RunAsync(\"What's the weather like in Seattle?\")); ```\n\n**Python**\n\n```py from typing import Annotated from pydantic import Field from agent_framework.github import GithubCopilotAgent\n\ndef get_weather( location: Annotated[str, Field(description=\"The location to get the weather for.\")], ) -> str: \"\"\"Get the weather for a given location.\"\"\" return f\"The weather in {location} is sunny with a high of 25C.\"\n\nasync def main(): agent = GithubCopilotAgent( default_options={\"instructions\": \"You are a helpful weather agent.\"}, tools=[get_weather], )\n\nasync with agent: result = await agent.run(\"What's the weather like in Seattle?\") print(result) ```\n\n## **Stream Responses**\n\nFor a better user experience, you can stream responses as they are generated instead of waiting for the complete result.\n\n**.NET**\n\n```cs await using CopilotClient copilotClient = new(); await copilotClient.StartAsync();\n\nAIAgent agent = copilotClient.AsAIAgent();\n\nawait foreach (AgentResponseUpdate update in agent.RunStreamingAsync(\"Tell me a short story.\")) { Console.Write(update); }\n\nConsole.WriteLine(); ```\n\n**Python**\n\n```py from agent_framework.github import GithubCopilotAgent\n\nasync def main(): agent = GithubCopilotAgent( default_options={\"instructions\": \"You are a helpful assistant.\"}, )\n\nasync with agent: print(\"Agent: \", end=\"\", flush=True) async for chunk in agent.run_stream(\"Tell me a short story.\"): if chunk.text: print(chunk.text, end=\"\", flush=True) print() ```\n\n## **Multi-Turn Conversations**\n\nMaintain conversation context across multiple interactions using sessions (.NET) or threads (Python).\n\n**.NET**\n\n```cs await using CopilotClient copilotClient = new(); await copilotClient.StartAsync();\n\nawait using GithubCopilotAgent agent = new( copilotClient, instructions: \"You are a helpful assistant. Keep your answers short.\");\n\nAgentSession session = await agent.GetNewSessionAsync();\n\n// First turn await agent.RunAsync(\"My name is Alice.\", session);\n\n// Second turn - agent remembers the context AgentResponse response = await agent.RunAsync(\"What is my name?\", session); Console.WriteLine(response); // Should mention \"Alice\" ```\n\n**Python**\n\n```py from agent_framework.github import GithubCopilotAgent\n\nasync def main(): agent = GithubCopilotAgent( default_options={\"instructions\": \"You are a helpful assistant.\"}, )\n\nasync with agent: thread = agent.get_new_thread()\n\n# First interaction\nresult1 = await agent.run(\"My name is Alice.\", thread=thread) print(f\"Agent: {result1}\")\n\n# Second interaction - agent remembers the context\nresult2 = await agent.run(\"What's my name?\", thread=thread) print(f\"Agent: {result2}\") # Should remember \"Alice\" ```\n\n## **Enable Permissions**\n\nBy default, the agent cannot execute shell commands, read/write files, or fetch URLs. To enable these capabilities, provide a permission handler that approves or denies requests.\n\n**.NET**\n\n```cs static Task<PermissionRequestResult> PromptPermission( PermissionRequest request, PermissionInvocation invocation) { Console.WriteLine($\"\\n[Permission Request: {request.Kind}]\"); Console.Write(\"Approve? (y/n): \");\n\nstring? input = Console.ReadLine()?.Trim().ToUpperInvariant(); string kind = input is \"Y\" or \"YES\" ? \"approved\" : \"denied-interactively-by-user\";\n\nreturn Task.FromResult(new PermissionRequestResult { Kind = kind }); }\n\nawait using CopilotClient copilotClient = new(); await copilotClient.StartAsync();\n\nSessionConfig sessionConfig = new() { OnPermissionRequest = PromptPermission, };\n\nAIAgent agent = copilotClient.AsAIAgent(sessionConfig);\n\nConsole.WriteLine(await agent.RunAsync(\"List all files in the current directory\")); ```\n\n**Python**\n\n```py from agent_framework.github import GithubCopilotAgent from copilot.types import PermissionRequest, PermissionRequestResult\n\ndef prompt_permission( request: PermissionRequest, context: dict[str, str] ) -> PermissionRequestResult: kind = request.get(\"kind\", \"unknown\") print(f\"\\n[Permission Request: {kind}]\")\n\nresponse = input(\"Approve? (y/n): \").strip().lower() if response in (\"y\", \"yes\"): return PermissionRequestResult(kind=\"approved\") return PermissionRequestResult(kind=\"denied-interactively-by-user\")\n\nasync def main(): agent = GithubCopilotAgent( default_options={ \"instructions\": \"You are a helpful assistant that can execute shell commands.\", \"on_permission_request\": prompt_permission, }, )\n\nasync with agent: result = await agent.run(\"List the Python files in the current directory\") print(result) ```\n\n## **Connect MCP Servers**\n\nGitHub Copilot agents support connecting to local (stdio) and remote (HTTP) MCP servers, giving the agent access to external tools and data sources.\n\n**.NET**\n\n```cs await using CopilotClient copilotClient = new(); await copilotClient.StartAsync();\n\nSessionConfig sessionConfig = new() { OnPermissionRequest = PromptPermission, McpServers = new Dictionary<string, object> { // Local stdio server [\"filesystem\"] = new McpLocalServerConfig { Type = \"stdio\", Command = \"npx\", Args = [\"-y\", \"@modelcontextprotocol/server-filesystem\", \".\"], Tools = [\"*\"], }, // Remote HTTP server [\"microsoft-learn\"] = new McpRemoteServerConfig { Type = \"http\", Url = \"https://learn.microsoft.com/api/mcp\", Tools = [\"*\"], }, }, };\n\nAIAgent agent = copilotClient.AsAIAgent(sessionConfig);\n\nConsole.WriteLine(await agent.RunAsync(\"Search Microsoft Learn for 'Azure Functions' and summarize the top result\")); ```\n\n**Python**\n\n```py from agent_framework.github import GithubCopilotAgent from copilot.types import MCPServerConfig\n\nasync def main(): mcp_servers: dict[str, MCPServerConfig] = {\n# Local stdio server\n\"filesystem\": { \"type\": \"stdio\", \"command\": \"npx\", \"args\": [\"-y\", \"@modelcontextprotocol/server-filesystem\", \".\"], \"tools\": [\"*\"], },\n# Remote HTTP server\n\"microsoft-learn\": { \"type\": \"http\", \"url\": \"https://learn.microsoft.com/api/mcp\", \"tools\": [\"*\"], }, }\n\nagent = GithubCopilotAgent( default_options={ \"instructions\": \"You are a helpful assistant with access to the filesystem and Microsoft Learn.\", \"on_permission_request\": prompt_permission, \"mcp_servers\": mcp_servers, }, )\n\nasync with agent: result = await agent.run(\"Search Microsoft Learn for 'Azure Functions' and summarize the top result\") print(result) ```\n\n## **Use GitHub Copilot in a Multi-Agent Workflow**\n\nOne of the key benefits of using Agent Framework is the ability to combine GitHub Copilot with other agents in a multi-agent workflow. In this example, an Azure OpenAI agent drafts a marketing tagline and a GitHub Copilot agent reviews it — all orchestrated as a sequential pipeline.\n\n**.NET**\n\n```cs using Azure.AI.OpenAI; using Azure.Identity; using GitHub.Copilot.SDK; using Microsoft.Agents.AI; using Microsoft.Agents.AI.GithubCopilot; using Microsoft.Agents.AI.Workflows; using Microsoft.Extensions.AI;\n\n// Create an Azure OpenAI agent as a copywriter var endpoint = Environment.GetEnvironmentVariable(\"AZURE_OPENAI_ENDPOINT\")!; var deploymentName = Environment.GetEnvironmentVariable(\"AZURE_OPENAI_DEPLOYMENT_NAME\") ?? \"gpt-4o-mini\"; var chatClient = new AzureOpenAIClient(new Uri(endpoint), new AzureCliCredential()) .GetChatClient(deploymentName) .AsIChatClient();\n\nChatClientAgent writer = new(chatClient, \"You are a concise copywriter. Provide a single, punchy marketing sentence based on the prompt.\", \"writer\");\n\n// Create a GitHub Copilot agent as a reviewer await using CopilotClient copilotClient = new(); await copilotClient.StartAsync();\n\nGithubCopilotAgent reviewer = new(copilotClient, instructions: \"You are a thoughtful reviewer. Give brief feedback on the previous assistant message.\");\n\n// Build a sequential workflow: writer -> reviewer Workflow workflow = AgentWorkflowBuilder.BuildSequential([writer, reviewer]);\n\n// Run the workflow await using StreamingRun run = await InProcessExecution.StreamAsync(workflow, input: prompt); await run.TrySendMessageAsync(new TurnToken(emitEvents: true));\n\nawait foreach (WorkflowEvent evt in run.WatchStreamAsync()) { if (evt is AgentResponseUpdateEvent e) { Console.Write(e.Update.Text); } } ```\n\n**Python**\n\n```py import asyncio from typing import cast\n\nfrom agent_framework import ChatMessage, Role, SequentialBuilder, WorkflowOutputEvent from agent_framework.azure import AzureOpenAIChatClient from agent_framework.github import GithubCopilotAgent from azure.identity import AzureCliCredential\n\nasync def main():\n# Create an Azure OpenAI agent as a copywriter\nchat_client = AzureOpenAIChatClient(credential=AzureCliCredential())\n\nwriter = chat_client.as_agent( instructions=\"You are a concise copywriter. Provide a single, punchy marketing sentence based on the prompt.\", name=\"writer\", )\n\n# Create a GitHub Copilot agent as a reviewer\nreviewer = GithubCopilotAgent( default_options={\"instructions\": \"You are a thoughtful reviewer. Give brief feedback on the previous assistant message.\"}, name=\"reviewer\", )\n\n# Build a sequential workflow: writer -> reviewer\nworkflow = SequentialBuilder().participants([writer, reviewer]).build()\n\n# Run the workflow\nasync for event in workflow.run_stream(\"Write a tagline for a budget-friendly electric bike.\"): if isinstance(event, WorkflowOutputEvent): messages = cast(list[ChatMessage], event.data) for msg in messages: name = msg.author_name or (\"assistant\" if msg.role == Role.ASSISTANT else \"user\") print(f\"[{name}]: {msg.text}\\n\")\n\nasyncio.run(main()) ```\n\nThis example shows how a single workflow can combine agents from different providers. You can extend this pattern to concurrent, handoff, and group chat workflows as well.\n\n## **More Information**\n\n- [GitHub Copilot SDK](https://github.com/github/copilot-sdk)\n- [Microsoft Agent Framework on GitHub](https://github.com/microsoft/agent-framework)\n- [Agent Framework Getting Started Tutorials](https://learn.microsoft.com/agent-framework/tutorials/overview)\n\n## **Summary**\n\nThe GitHub Copilot SDK integration for Microsoft Agent Framework makes it easy to build AI agents that leverage GitHub Copilot’s capabilities. With support for function tools, streaming, multi-turn conversations, permissions, and MCP servers in both .NET and Python, you can build powerful agentic applications that interact with code, files, shell commands, and external services.\n\nWe’re always interested in hearing from you. If you have feedback, questions or want to discuss further, feel free to reach out to us and the community on the [discussion boards](https://github.com/microsoft/agent-framework/discussions) on GitHub! We would also love your support, if you’ve enjoyed using Agent Framework, give us a star on [GitHub](https://github.com/microsoft/agent-framework)."
}
