{
  "Description": "Introduction: A New Paradigm for AI Application Development In enterprise AI application development, we often face this dilemma: while cloud-based large language models are powerful, issues such as data privacy, network latency, and cost control make many scenarios difficult to implement. Traditional local small models, although lightweight, lack complete development, evaluation, and orchestration frameworks. The […]\n\nThe post [From Local Models to Agent Workflows: Building a Deep Research Solution with Microsoft Agent Framework on Microsoft Foundry Local](https://devblogs.microsoft.com/semantic-kernel/from-local-models-to-agent-workflows-building-a-deep-research-solution-with-microsoft-agent-framework-on-microsoft-foundry-local/) appeared first on [Semantic Kernel](https://devblogs.microsoft.com/semantic-kernel).",
  "EnhancedContent": "## Introduction: A New Paradigm for AI Application Development\n\nIn enterprise AI application development, we often face this dilemma: while cloud-based large language models are powerful, issues such as data privacy, network latency, and cost control make many scenarios difficult to implement. Traditional local small models, although lightweight, lack complete development, evaluation, and orchestration frameworks.\n\nThe combination of Microsoft Foundry Local and Agent Framework (MAF) provides an elegant solution to this dilemma. This article will guide you from zero to one in building a complete Deep Research agent workflow, covering the entire pipeline from model safety evaluation, workflow orchestration, interactive debugging to performance optimization.\n\n## [![bg image](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIAAQMAAADOtka5AAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAANklEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8G4IAAAHSeInwAAAAAElFTkSuQmCC)](https://devblogs.microsoft.com/semantic-kernel/wp-content/uploads/sites/78/2026/02/bg.webp)\n\n## Why Choose Foundry Local?\n\nFoundry Local is not just a local model runtime, but an extension of Microsoft’s AI ecosystem to the edge:\n\n- **Privacy First**: All data and inference processes are completed locally, meeting strict compliance requirements\n- **Zero Latency**: No network round trips required, suitable for real-time interactive scenarios\n- **Cost Control**: Avoid cloud API call fees, suitable for high-frequency calling scenarios\n- **Rapid Iteration**: Local development and debugging, shortening feedback cycles\n\nCombined with the Microsoft Agent Framework, you can build complex agent applications just like using Azure OpenAI.\n\nExample Code:\n\n```py agent = FoundryLocalClient(model_id=\"qwen2.5-1.5b-instruct-generic-cpu:4\").as_agent( name=\"LocalAgent\", instructions=\"\"\"You are an assistant.\n\nYour responsibilities:\n- Answering questions and providing professional advice\n- Helping users understand concepts\n- Offering users different suggestions\n\"\"\", ) ```\n\n## How to Evaluate an Agent?\n[![eval image](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABQYAAAQeAQMAAACwn3WsAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAvElEQVR4nO3BAQ0AAADCoPdPbQ8HFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG8GmxoAAQpqUyAAAAAASUVORK5CYII=)](https://devblogs.microsoft.com/semantic-kernel/wp-content/uploads/sites/78/2026/02/eval.webp)\n\nBased on the Agent Framework evaluation samples, here are three complementary evaluation methods, with corresponding implementations and configurations in this repository:\n\n1. **Red Teaming (Security and Robustness)**\n\n- Purpose: Use systematic adversarial prompts to cover high-risk content and test the agent’s security boundaries.\n- Method: Execute multiple attack strategies against the target agent, covering risk categories such as violence, hate/unfairness, sexual content, and self-harm.\n2. **Self-Reflection (Quality Verification)**\n\n- Purpose: Let the agent perform secondary review of its own output, checking factual consistency, coverage, citation completeness, and answer structure.\n- Method: Add a “reflection round” after task output, where the agent provides self-assessment and improvement suggestions based on fixed dimensions, producing a revised version.\n- *This content is temporarily omitted in the example*\n3. **Observability (Performance Metrics)**\n\n- Purpose: Measure end-to-end latency, stage-wise time consumption, and tool invocation overhead using metrics and distributed tracing.\n- Method: Enable OpenTelemetry to report workflow execution processes and tool invocations.\n\n## Complete Development Process: From Security to Production\n\n### Step 1: Red Team Evaluation – Securing the Safety Baseline\n\nBefore putting any model into production, security evaluation is an essential step. MAF provides out-of-the-box Red Teaming capabilities, combined with Microsoft Foundry to complete Red Team evaluation:\n\n```py\n# 01.foundrylocal_maf_evaluation.py\nfrom azure.ai.evaluation.red_team import AttackStrategy, RedTeam, RiskCategory from azure.identity import AzureCliCredential from agent_framework_foundry_local import FoundryLocalClient\n\ncredential = AzureCliCredential() agent = FoundryLocalClient(model_id=\"qwen2.5-1.5b-instruct-generic-cpu:4\").as_agent( name=\"LocalAgent\", instructions=\"\"\"You are an assistant.\n\nYour responsibilities:\n- Answering questions and providing professional advice\n- Helping users understand concepts\n- Offering users different suggestions\n\"\"\", )\n\ndef agent_callback(query: str) -> str: async def _run(): return await agent.run(query) response = asyncio.get_event_loop().run_until_complete(_run()) return response.text\n\nred_team = RedTeam( azure_ai_project=os.environ[\"AZURE_AI_PROJECT_ENDPOINT\"], credential=credential, risk_categories=[ RiskCategory.Violence, RiskCategory.HateUnfairness, RiskCategory.Sexual, RiskCategory.SelfHarm, ], num_objectives=2, )\n\nresults = await red_team.scan( target=agent_callback, scan_name=\"Qwen2.5-1.5B-Agent\", attack_strategies=[ AttackStrategy.EASY, AttackStrategy.MODERATE, AttackStrategy.CharacterSpace, AttackStrategy.ROT13, AttackStrategy.UnicodeConfusable, AttackStrategy.CharSwap, AttackStrategy.Morse, AttackStrategy.Leetspeak, AttackStrategy.Url, AttackStrategy.Binary, AttackStrategy.Compose([AttackStrategy.Base64, AttackStrategy.ROT13]), ], output_path=\"Qwen2.5-1.5B-Redteam-Results.json\", ) ```\n\n**Evaluation Dimensions**:\n\n- **Risk Categories**: Violence, hate/unfairness, sexual content, self-harm\n- **Attack Strategies**: Encoding obfuscation, character substitution, prompt injection, etc.\n- **Output Analysis**: Generate detailed risk scorecards and response samples\n\nEvaluation results are saved as JSON for traceability and continuous monitoring. This step ensures the model’s robustness when facing malicious inputs.\n\nThis is a screenshot after running ***01.foundrylocal\\_maf\\_evaluation.py***. You can improve results by adjusting the prompt.\n\n[![redteam image](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAACEgAAAFsAQMAAADvqozVAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAdUlEQVR4nO3BMQEAAADCoPVPbQlPoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICXAXpHAAGN+U0CAAAAAElFTkSuQmCC)](https://devblogs.microsoft.com/semantic-kernel/wp-content/uploads/sites/78/2026/02/redteam.webp)\n\n### Step 2: Deep Research Workflow Design – Multi-Round Iterative Intelligence\n\nThe core of Deep Research is the “research-judge-research again” iterative loop. MAF Workflows makes this complex logic clear and maintainable:\n\n[![workflow image](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOsAAAKfAQMAAAC16K1oAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAK0lEQVR4nO3BMQEAAADCoPVPbQ0PoAAAAAAAAAAAAAAAAAAAAAAAAAAAzg1RQQABPh0A0AAAAABJRU5ErkJggg==)](https://devblogs.microsoft.com/semantic-kernel/wp-content/uploads/sites/78/2026/02/workflow.webp)\n\n**Key Components**:\n\n1. **Research Agent**\n\n- Equipped with `search_web`\ntool for real-time external information retrieval\n- Generates summaries and identifies knowledge gaps in each round\n- Accumulates context to avoid redundant searches\n2. **Iteration Controller**\n\n- Evaluates current information completeness\n- Decision-making: Continue deeper vs Generate report\n- Prevents infinite loops (sets maximum rounds)\n3. **Final Reporter**\n\n- Integrates findings from all iterations\n- Generates structured reports with citations\n\n**Code Implementation** (simplified):\n\n```py from agent_framework import WorkflowBuilder from agent_framework_foundry_local import FoundryLocalClient\n\nworkflow_builder = WorkflowBuilder( name=\"Deep Research Workflow\", description=\"Multi-agent deep research workflow with iterative web search\" )\n\nworkflow_builder.register_executor(lambda: StartExecutor(state=state), name=\"start_executor\") workflow_builder.register_executor(lambda: ResearchAgentExecutor(), name=\"research_executor\") workflow_builder.register_executor(lambda: iteration_control, name=\"iteration_control\") workflow_builder.register_executor(lambda: FinalReportExecutor(), name=\"final_report\") workflow_builder.register_executor(lambda: OutputExecutor(), name=\"output_executor\")\n\nworkflow_builder.register_agent( lambda: FoundryLocalClient(model_id=\"qwen2.5-1.5b-instruct-generic-cpu:4\").as_agent( name=\"research_agent\", instructions=\"...\", tools=search_web, default_options={\"temperature\": 0.7, \"max_tokens\": 4096}, ), name=\"research_agent\", )\n\nworkflow_builder.add_edge(\"start_executor\", \"research_executor\") workflow_builder.add_edge(\"research_executor\", \"research_agent\") workflow_builder.add_edge(\"research_agent\", \"iteration_control\") workflow_builder.add_edge( \"iteration_control\", \"research_executor\", condition=lambda decision: decision.signal == ResearchSignal.CONTINUE, ) workflow_builder.add_edge( \"iteration_control\", \"final_report\", condition=lambda decision: decision.signal == ResearchSignal.COMPLETE, ) workflow_builder.add_edge(\"final_report\", \"final_reporter_agent\") workflow_builder.add_edge(\"final_reporter_agent\", \"output_executor\") ```\n\nThe beauty of this design lies in:\n\n- **Modularity**: Each executor has a single responsibility, easy to test and replace\n- **Observability**: Inputs and outputs of each node can be tracked\n- **Extensibility**: Easy to add new tools or decision logic\n\n### Step 3: DevUI Interactive Debugging – Making Workflows Visible\n\nTraditional agent debugging is often a “black box” experience. MAF DevUI visualizes the entire execution process:\n\n```default python 02.foundrylocal_maf_workflow_deep_research_devui.py\n# DevUI starts at http://localhost:8093\n```\n\n**DevUI Provides**:\n\n- **Workflow Topology Diagram**: Intuitively see node and edge relationships\n- **Step-by-Step Execution**: View input, output, and status of each node\n- **Real-time Injection**: Dynamically modify input parameters to test different scenarios\n- **Log Aggregation**: Unified view of all agent logs and tool invocations\n\n**Debugging Scenario Example**:\n\n- Input: “GPT-5.3-Codex vs Anthropic Claud 4.6”\n- Observe: Evolution of search keywords across 3 rounds by the research agent\n- Verify: Whether the iteration controller’s decision basis is reasonable\n- Check: Whether the final report covers all sub-topics\n\nThis interactive experience significantly shortens the time from discovering problems to solving them.\n\n[![devui image](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAACcQAAASPAQMAAAAQ9fwRAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABeklEQVR4nO3BMQEAAADCoPVPbQlPoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACeBpexAAGaR+8oAAAAAElFTkSuQmCC)](https://devblogs.microsoft.com/semantic-kernel/wp-content/uploads/sites/78/2026/02/devui-scaled.webp)\n\n### Step 4: Performance Evaluation and Optimization – .NET Aspire Integration\n\nIn production environments, performance is a dimension that cannot be ignored. MAF’s integration with .NET Aspire provides enterprise-grade observability:\n\n**Enable Telemetry**:\n\n```default\n# Configure OpenTelemetry\nexport OTLP_ENDPOINT=\"http://localhost:4317\"\n\n# Workflow automatically reports\n- Latency: Time consumption of each executor\n- Throughput: Concurrent request processing capacity\n- Tool Usage: search_web call frequency and time consumption\n```\n\n**Key Metrics**:\n\n- **End-to-End Latency**: Time from user input to final report\n- **Model Inference Time**: Response speed of local model\n- **Tool Invocation Overhead**: Impact of external APIs (such as search)\n- **Memory Usage**: Context accumulation across multiple iterations\n\n**Optimization Strategies**:\n\n- Use smaller models (such as Qwen2.5-1.5B) to balance speed and quality\n- Cache common search results to reduce API calls\n- Limit iteration depth to avoid excessive research\n- Streaming output to improve user experience\n\nThrough distributed tracing, you can precisely locate bottlenecks and make data-driven optimization decisions.\n\n[![tracing image](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABzwAAATmAQMAAABu40XoAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABMklEQVR4nO3BMQEAAADCoPVPbQwfoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACeBnWSAAF42GNTAAAAAElFTkSuQmCC)](https://devblogs.microsoft.com/semantic-kernel/wp-content/uploads/sites/78/2026/02/tracing.webp)\n\n## Practical Guide: Quick Start\n\n### GitHub Repo : [https://github.com/microsoft/Agent-Framework-Samples/blob/main/09.Cases/FoundryLocalPipeline/](https://github.com/microsoft/Agent-Framework-Samples/blob/main/09.Cases/FoundryLocalPipeline/)\n\nEnvironment Setup\n\n```default\n# 1. Set environment variables\nexport FOUNDRYLOCAL_ENDPOINT=\"http://localhost:8000\" export FOUNDRYLOCAL_MODEL_DEPLOYMENT_NAME=\"qwen2.5-1.5b-instruct-generic-cpu:4\" export SERPAPI_API_KEY=\"your_serpapi_key\" export AZURE_AI_PROJECT_ENDPOINT=\"your_azure_endpoint\" export OTLP_ENDPOINT=\"http://localhost:4317\"\n\n# 2. Azure authentication (for evaluation)\naz login\n\n# 3. Install dependencies (example)\npip install azure-ai-evaluation azure-ai-evaluation[redteam] agent-framework agent-framework-foundry-local ```\n\n### Three-Step Launch\n\n**Step 1: Security Evaluation**\n\n```default python 01.foundrylocal_maf_evaluation.py\n# View results: Qwen2.5-1.5B-Redteam-Results.json\n```\n\n**Step 2: DevUI Mode (Recommended)**\n\n```default python 02.foundrylocal_maf_workflow_deep_research_devui.py\n# Open in browser: http://localhost:8093\n# Enter research topic, observe iteration process\n```\n\n**Step 3: CLI Mode (Production)**\n\n```default python 02.foundrylocal_maf_workflow_deep_research_devui.py --cli\n# Directly output final report\n```\n\n## Architectural Insights: Evolution from Model to Agent\n\nThis case demonstrates three levels of modern AI application development:\n\n1. **Model Layer (Foundation)**: Foundry Local provides reliable inference capabilities\n2. **Agent Layer**: ChatAgent + Tools encapsulate business logic\n3. **Orchestration Layer**: MAF Workflows handle complex processes\n\nTraditional development often stops at model invocation, while MAF allows you to stand at a higher level of abstraction:\n\n- No more manual loops and state management\n- Automatic handling of tool invocations and result parsing\n- Built-in observability and error handling\n\nThis “framework-first” approach is key to moving enterprise AI from POC to production.\n\n## Use Cases and Extension Directions\n\n**Current Solution Suitable For**:\n\n- Research tasks requiring multi-round information synthesis\n- Enterprise scenarios sensitive to data privacy\n- Cost optimization needs for high-frequency calls\n- Offline or weak network environments\n\n**Extension Directions**:\n\n- **Multi-Agent Collaboration**: Add expert agents (such as data analysts, code generators)\n- **Knowledge Base Integration**: Combine with vector databases to retrieve private documents\n- **Human-in-the-Loop**: Add manual review at critical decision points\n- **Multimodal Support**: Process rich media inputs such as images, PDFs\n\n## Conclusion: The Infinite Possibilities of Localized AI\n\nThe combination of Microsoft Foundry Local + Agent Framework proves that local small models can also build production-grade intelligent applications. Through this Deep Research case, we see:\n\n- **Security and Control**: Red Team evaluation ensures model behavior meets expectations\n- **Efficient Orchestration**: Workflows make complex logic clear and maintainable\n- **Rapid Iteration**: DevUI provides instant feedback, shortening development cycles\n- **Performance Transparency**: Aspire integration makes optimization evidence-based\n\nMore importantly, this solution is **open and composable**. You can:\n\n- Integrate custom tools (database queries, internal APIs)\n- Deploy to edge devices or private clouds\n\nThe future of AI applications lies not only in the cloud, but in the **flexible architecture of cloud-edge collaboration**. Foundry Local provides enterprises with a practical path, enabling every developer to build agent systems that are both powerful and controllable.\n\n**Related Resources**:\n\n- [Microsoft Agent Framework GitHub](https://github.com/microsoft/agent-framework)\n- [Microsoft Agent Framework Samples GitHub](https://github.com/microsoft/agent-framework-samples)\n- [Foundry Local Official Documentation](https://learn.microsoft.com/en-us/azure/ai-foundry/foundry-local/what-is-foundry-local)",
  "Title": "From Local Models to Agent Workflows: Building a Deep Research Solution with Microsoft Agent Framework on Microsoft Foundry Local",
  "FeedUrl": "https://devblogs.microsoft.com/semantic-kernel/feed/",
  "Tags": [
    "Agent Framework",
    "Agents",
    "Python"
  ],
  "ProcessedDate": "2026-02-10 11:17:22",
  "Author": "Kinfey Lo",
  "FeedLevelAuthor": "Semantic Kernel",
  "FeedName": "Microsoft Semantic Kernel Blog",
  "OutputDir": "_news",
  "Link": "https://devblogs.microsoft.com/semantic-kernel/from-local-models-to-agent-workflows-building-a-deep-research-solution-with-microsoft-agent-framework-on-microsoft-foundry-local/",
  "PubDate": "2026-02-10T11:12:33+00:00"
}
