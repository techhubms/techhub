{
  "Link": "https://www.microsoft.com/en-us/security/blog/2026/02/19/running-openclaw-safely-identity-isolation-runtime-risk/",
  "FeedName": "Microsoft Security Blog",
  "FeedUrl": "https://www.microsoft.com/en-us/security/blog/feed/",
  "OutputDir": "_news",
  "PubDate": "2026-02-19T16:27:00+00:00",
  "Author": "Microsoft Defender Security Research Team",
  "Description": "Self-hosted agents execute code with durable credentials and process untrusted input. This creates dual supply chain risk, where skills and external instructions converge in the same runtime. As OpenClaw-like systems enter enterprises, governance and runtime isolation become critical.\n\nThe post [Running OpenClaw safely: identity, isolation, and runtime risk](https://www.microsoft.com/en-us/security/blog/2026/02/19/running-openclaw-safely-identity-isolation-runtime-risk/) appeared first on [Microsoft Security Blog](https://www.microsoft.com/en-us/security/blog).",
  "Tags": [],
  "Title": "Running OpenClaw safely: identity, isolation, and runtime risk",
  "EnhancedContent": "Self-hosted agent runtimes like OpenClaw are showing up fast in enterprise pilots, and they introduce a blunt reality: OpenClaw includes limited built-in security controls. The runtime can ingest untrusted text, download and execute skills (i.e. code) from external sources, and perform actions using the credentials assigned to it.\n\nThis effectively shifts the execution boundary from static application code to dynamically supplied content and third-party capabilities, without equivalent controls around identity, input handling, or privilege scoping.\n\nIn an unguarded deployment, three risks materialize quickly:\n\n- Credentials and accessible data may be exposed or exfiltrated.\n- The agent’s persistent state or “memory” can be modified, causing it to follow attacker-supplied instructions over time.\n- The host environment can be compromised if the agent is induced to retrieve and execute malicious code.\n\nBecause of these characteristics, OpenClaw should be treated as untrusted code execution with persistent credentials. It is not appropriate to run on a standard personal or enterprise workstation. If an organization determines that OpenClaw must be evaluated, it should be deployed only in a fully isolated environment such as a dedicated virtual machine or separate physical system. The runtime should use dedicated, non-privileged credentials and access only non-sensitive data. Continuous monitoring and a rebuild plan should be part of the operating model.\n\nThis post explains how the two supply chains inherent to self-hosted agents — untrusted code (skills and extensions) and untrusted instructions (external text inputs) — converge into a single execution loop. We examine how this design creates compounding risk in workstation environments, provide a representative compromise chain, and outline deployment, monitoring, and hunting guidance aligned to Microsoft Security controls, including Microsoft Defender XDR. For organizations that still choose to evaluate OpenClaw, we include a minimum safe operating posture.\n\n## Clarifying the landscape: runtime vs platform\n\nTo reason about controls and avoid applying the wrong mitigations in the wrong place, it is important to separate where code executes from where instructions propagate. These two surfaces are often discussed together, but they behave differently under attack and are typically owned by different teams.\n\n**OpenClaw (runtime):** A self-hosted agent runtime that runs on a workstation, VM, or container. It can load skills and interact with local and cloud resources. The key security point: it inherits the trust (and risk) of the machine and the identities it can use. Installing a skill is basically installing privileged code. Skills are often discovered and installed through ClawHub, the public skills registry for OpenClaw. With that said, OpenClaw works within the access users grant on their devices. If it has permission to reach certain apps, files, or accounts, it may be able to retrieve additional information from them. For privacy and security considerations, Microsoft Defender recommends using OpenClaw only in isolated environments that do not have access to any non-dedicated credentials or data which must not be leaked.\n\n**Moltbook (platform):** An agent-focused platform and identity layer where agents post, read, and authenticate through APIs. The key security point is that it can become a high-volume stream of attacker-influenceable content that agents ingest on a schedule. A single malicious post can therefore reach multiple agents.\n\nIn practice, OpenClaw expands the code execution boundary within your environment, while Moltbook expands the instruction influence surface at scale. When these two interact without appropriate guardrails, a single malicious input can result in durable, credentialed execution.\n\n## How agents shift the security boundary\n\nMost security teams already know how to secure automation. Agents change the risk because the entity deciding what to do isn’t always the one taking the action. At runtime, the agent loads third‑party code, reads untrusted input, and acts using durable credentials, making the runtime environment the new security boundary.\n\nThat boundary has three components:\n\n- **Identity:** The tokens the agent uses to do work (SaaS APIs, repos, mail, cloud control planes).\n- **Execution:** The tools it can run that change state (files, shell, infrastructure, messages).\n- **Persistence:** The ways it can keep changes across runs (tasks, config, schedules).\n\nTo summarize, there are two types of security problems called out here:\n\n1. **Indirect prompt injection:** Attackers can hide malicious instructions inside content an agent reads and can either steer tool use or modify its memory to affect its behavior over time unless users put strong boundaries in place.\n2. **Skill malware:** Agents acquire skills from a variety of sources, basically by downloading and running code off the Internet, and can contain malicious code.\n\n### Managed platforms Vs. self-hosted runtimes\n\nWith managed assistants and agent platforms, security controls typically center on identity scopes, connector governance, and data boundaries, because the runtime and updates are centrally managed. With self-hosted runtimes, that responsibility shifts to the organization. The host system, plugin surface, and local state become part of the trust boundary, and the runtime often operates in close proximity to sensitive developer credentials.\n\nWith a self-hosted runtime, you are responsible for the blast radius. The host, plugins, and local state are all within the trust boundary. If the agent is able to browse external content and install extensions, it should be assumed that it will eventually process malicious input. Controls should therefore prioritize containment and recoverability, rather than relying on prevention alone.\n\n### End-to-end attack scenario: The poisoned skill\n\nThis scenario represents a plausible compromise chain in open agent ecosystems. It maps directly to control points defenders can influence: what is installed, what the runtime can access, and how persistence is established. Public reporting has documented malicious skills appearing in public registries. In some cases, registry content has been straightforward malware packaged as a skill, rather than a subtle lookalike.\n\n![](https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2026/02/image-32.webp)*Figure 1: A five-step flow showing how a malicious skill moves from public distribution to durable control, often through configuration or state changes rather than a traditional malware drop.*\n\n### Step 1: Distribution\n\nAn attacker publishes a malicious skill to ClawHub, sometimes disguised as a utility and sometimes openly malicious, and promotes it through community channels. In other cases, the skill is discovered organically through search and installed because the ecosystem evolves quickly and low-friction installation encourages experimentation. This creates a direct code supply chain path into the runtime.\n\n### Step 2: Installation\n\nA developer or an agent initiates installation because the skill appears relevant to a task. In permissive deployments, the runtime may be allowed to execute the installation flow without human approval. In more controlled environments, installation should be treated as an explicit approval event, equivalent to executing third-party code.\n\n### Step 3: State access (tokens and durable instructions)\n\nThe attacker’s objective is access to agent state, including tokens, cached credentials, configuration data, and transcripts, as well as durable instruction channels that influence future runs, such as task files, scheduled actions, or agent configuration. If durable instructions can be modified through normal interactions, a single injection can persist across executions.\n\n### Step 4: Privilege reuse through legitimate APIs\n\nWith valid identity material, the attacker can perform actions through standard APIs and tooling. This activity often resembles legitimate automation unless strong monitoring and logging controls are in place.\n\n### Step 5: Persistence through configuration\n\nPersistence frequently manifests as durable configuration changes, such as new OAuth consents, scheduled executions, modified agent tasks, or tools that remain permanently approved. The objective is less about deploying malware and more about maintaining long-term control over the automation pathway.\n\n## **Variant: indirect prompt injection through shared feeds**\n\nIf agents are configured to poll a shared feed, an attacker can place malicious instructions inside content the agents ingest. This is indirect prompt injection: the payload rides in the instruction supply chain, embedded in external content rather than provided by a trusted operator. In multi-agent settings, a single malicious thread can reach many agents at once. The practical risk is steering tool use or triggering sensitive disclosure in the subset of agents that have high authority and weak gating.\n\n## Microsoft Defender and Microsoft Security controls for self-hosted agents\n\n### Minimum safe operating posture (if you choose to run OpenClaw)\n\nThe safest guidance is to avoid installing and running OpenClaw with primary work or personal accounts and to avoid running it on a device that contains sensitive data. In its current form, assume the runtime can be influenced by untrusted input, its state can be modified, and the host system can be exposed through the agent.\n\nIf there is a legitimate requirement to evaluate OpenClaw, the following guardrails should be treated as a baseline:\n\n**1) Run only in isolation**\n\nUse a dedicated virtual machine or a separate physical device that is not used for daily work. Treat the environment as disposable.\n\n**2) Use dedicated credentials and non-sensitive data**\n\nCreate accounts, tokens, and datasets that exist solely for the agent’s purpose. Assume compromise is possible and plan for regular rotation.\n\n**3) Monitor for state or memory manipulation**\n\nRegularly review the agent’s saved instructions and state for unexpected persistent rules, newly trusted sources, or changes in behavior across runs.\n\n**4) Back up state to enable rapid rebuild**\n\nOpenClaw allows state to be snapshotted and restored:\n\n- Backing up `.openclaw/workspace/`\ncaptures the agent’s working state without including credentials.\n- Backing up the entire `.openclaw/`\ndirectory also captures tokens and credentials. While this simplifies restoration, it increases backup sensitivity and may be inappropriate if credentials are suspected to be compromised.\n\n**5) Treat rebuild as an expected control**\n\nReinstall regularly and rebuild immediately if anomalous behavior is observed. Persistence may appear as subtle configuration changes rather than overt malware deployment.\n\nThe table below maps key security actions to concrete implementation approaches using Microsoft Security solutions and related Microsoft controls. Links to implementation of guidance for the Microsoft controls referenced are provided in the References section.\n\n| **What to do** | **How to do it with Microsoft controls** | | --- | --- | | **Identity** | | Use dedicated identities for agents. Minimize permissions. Prefer short-lived tokens. Use controlled consent for powerful permissions. | **Microsoft Entra ID**: Enforce least privilege, Conditional Access, and Admin consent workflows for sensitive OAuth scopes. **Microsoft Defender for Cloud Apps (App Governance)**: inventory of OAuth apps, monitor consent drift, and alert on risky publishers or privilege levels. | | **Endpoint and host** | | Treat agent hosts privileged. Separate pilots from production. Plan rapid isolation and token revocation. | **Microsoft Defender for Endpoint**: Onboard agent hosts and use device groups for stricter policies. **Microsoft Defender XDR**: correlate endpoint activity with identity and cloud events for fast triage and containment. | | **Supply chain (skills, extensions, plugins)** | | Restrict install sources and publishers where possible. Pin versions for approved capabilities. Review updates. | **Microsoft Defender for Endpoint**: use telemetry and investigation to spot suspicious extension installs and remote access tooling. **Endpoint management and app control**: restrict unapproved install paths and publishers where feasible. | | **Network and egress** | | Restrict outbound access for agent hosts and workloads to known destinations required for business. Block or isolate high-risk external ingestion sources unless justified. | **Defender for Endpoint web content filtering**: restrict categories and access to agent device groups. **Azure network controls and Defender for Cloud**: Apply network controls in Azure and monitor outbound behavior with central logging. | | **Data protection** | | Reduce the chance that sensitive data is ingested into agent prompts. Reduce the chance that sensitive data is exfiltrated by agent tools. | **Microsoft Purview**: Use sensitivity labeling and Endpoint DLP to audit or block movement of labeled data by agent processes and external destinations. | | **Monitoring and response** | | Log agent actions and treat abnormal tool use as an incident signal. Prepare a playbook for agent identity compromises. | **Microsoft Defender XDR**: Use hunting and incident correlation. **Microsoft Sentinel**: Use it when deeper retention, enrichment, and automation are needed. **Operational playbooks**: build playbooks around isolation, credential rotation, consent review, and workspace forensics. |\n\n## **Hunting queries and triage guidance (Microsoft Defender XDR)**\n\nThese hunting queries are designed to quickly surface where agent runtimes are operating across the environment and to help distinguish deployments that function as privileged automation from those reflecting normal, user-driven behavior, enabling faster scoping, prioritization, and response.\n\n**Hunt 1: Discover agent runtimes and related tooling**\n\nUse this to inventory where agent runtimes exist, and which identities and command lines they run under.\n\n```\n\nDeviceProcessEvents | where Timestamp > ago(30d) | where ProcessCommandLine has_any (\"openclaw\",\"moltbot\",\"clawdbot\") or FileName has_any (\"openclaw\",\"moltbot\",\"clawdbot\") | project Timestamp, DeviceName, AccountName=InitiatingProcessAccountName, FileName, FolderPath, ProcessCommandLine | order by Timestamp desc ```\n\nTriage: confirm the device is part of an approved pilot, validate any control interface exposure is restricted, and review recent installs if the runtime is unexpected.\n\n**Hunt 1b: Cloud workloads variant (CloudProcessEvents)**\n\nUse this to extend the same inventory to container and Kubernetes workloads that report process telemetry through Defender for Cloud integration.\n\nUse this when agent runtimes may be running in multicloud container environments onboarded through Defender for Cloud so process telemetry lands in CloudProcessEvents.\n\n```\n\nCloudProcessEvents | where Timestamp > ago(30d) | where ProcessCommandLine has_any (\"openclaw\",\"moltbot\",\"clawdbot\") or ProcessName has_any (\"openclaw\",\"moltbot\",\"clawdbot\") or FileName has_any (\"openclaw\",\"moltbot\",\"clawdbot\") | extend WorkloadId = coalesce(AzureResourceId, AwsResourceName, GcpFullResourceName) | project Timestamp, WorkloadId, KubernetesNamespace, KubernetesPodName, ContainerName, AccountName, ProcessName, Filenames, FolderPath, ProcessCommandLine | order by Timestamp desc ```\n\nTriage: validate the workload and namespace map to an approved pilot, confirm container image provenance, and verify that the process and command line are expected for that service.\n\n**Hunt 1c: ClawHub skill installs and low-prevalence skill slugs**\n\nUse this to identify ClawHub skill installs and surface rare skill slugs across your environment.\n\n```\n\nDeviceProcessEvents | where Timestamp > ago(30d) | where ProcessCommandLine has \"clawhub install\" | extend SkillSlug = extract(@\"\\bclawhub\\s+install\\s+([^\\s]+)\", 1, ProcessCommandLine) | where isnotempty(SkillSlug) | summarize InstallEvents=count(), Devices=dcount(DeviceName), Accounts=dcount(InitiatingProcessAccountName) by SkillSlug | order by Devices asc, InstallEvents desc ```\n\nTriage: validate that the skill is approved for the pilot, then review the installed skill folder content and correlate with follow-on activity such as new shells, download tools, or outbound connections. Compare the slug against an approved list to catch lookalike naming.\n\n**Hunt 2: Extension installs and churn on developer endpoints**\n\nUse this to detect extension churn on developer endpoints that often precedes suspicious execution.\n\n```\n\nDeviceFileEvents | where Timestamp > ago(30d) | where FolderPath has_any (@\"\\.vscode\\extensions\\\", @\"/.vscode/extensions/\") | where ActionType in (\"FileCreated\",\"FileModified\",\"FolderCreated\") | summarize FirstSeen=min(Timestamp), LastSeen=max(Timestamp), FileCount=count() by DeviceName, InitiatingProcessAccountName, FolderPath | order by LastSeen desc ```\n\nTriage: focus on newly created extension folders and unexpected modification bursts. Validate publisher and installation source, then examine what processes the extension spawned.\n\n**Hunt 3: High-privilege OAuth apps and consent drift (App Governance)**\n\nUse this to surface new or changed high-privilege OAuth apps associated with agent integrations (requires App Governance).\n\nPrerequisite: App Governance must be enabled, so OAuthAppInfo is populated.\n\n```\n\nOAuthAppInfo | where Timestamp > ago(30d) | where PrivilegeLevel =~ \"High\" | project Timestamp, AppName, VerifiedPublisher, AppOrigin, IsAdminConsented, ConsentedUsersCount, AppStatus, Permissions | order by Timestamp desc ```\n\nTriage: validate business need for high-privilege apps, confirm publisher identity, and investigate sudden changes in privileges or consent scope.\n\n**Hunt 4: Unexpected listening services created by agent processes**\n\nUse this to detect agent processes opening listening ports, which can indicate exposed control surfaces or unintended services.\n\n```\n\nDeviceNetworkEvents | where Timestamp > ago(30d) | where ActionType == \"ListeningConnectionCreated\" | where InitiatingProcessCommandLine has_any (\"openclaw\",\"moltbot\",\"clawdbot\") or InitiatingProcessFileName has_any (\"openclaw\",\"moltbot\",\"clawdbot\") | summarize FirstSeen=min(Timestamp), LastSeen=max(Timestamp), Ports=make_set(LocalPort) by DeviceName, InitiatingProcessFileName, InitiatingProcessAccountName, LocalIP | order by Timestamp desc ```\n\nTriage: validate whether the listener is required and restricted. If it is reachable beyond the intended boundary, isolate the host and rotate any identities used by the agent.\n\n**Hunt 5: Agent runtimes spawning unexpected shells or download tools**\n\nUse this to flag agent runtimes spawning shells or download tools that are uncommon in expected agent operation.\n\n```\n\nagent operation. DeviceProcessEvents | where Timestamp > ago(30d) | where InitiatingProcessFileName has_any (\"openclaw\",\"moltbot\",\"clawdbot\") or InitiatingProcessCommandLine has_any (\"openclaw\",\"moltbot\",\"clawdbot\") | where FileName in (\"cmd.exe\",\"powershell.exe\",\"pwsh.exe\",\"bash\",\"sh\",\"curl\",\"wget\") | project Timestamp, DeviceName, AccountName=InitiatingProcessAccountName, Parent=InitiatingProcessFileName, FileName, ProcessCommandLine | order by Timestamp desc ```\n\nTriage: Separate expected automation from opportunistic execution. Prioritize cases where the child process touches credential stores, installs new packages, or opens network connections to unusual destinations.\n\n## **Security implications for self-hosted agents**\n\nSelf-hosted agents combine untrusted code and untrusted instructions into a single execution loop that runs with valid credentials. That is the core risk.\n\nRunning OpenClaw is not simply a configuration choice. It is a trust decision about which machine, identities, and data you are prepared to expose when the agent processes untrusted input.\n\nFor most environments, the appropriate decision may be not to deploy it. If a team proceeds, the defensible posture is to assume compromise is possible: isolate the runtime, constrain what it can access, monitor it continuously, and be prepared to rebuild without delay.\n\nThree actions should be taken immediately: inventory where the runtime is deployed, verify the identities it uses and the permissions associated with them, and identify which inputs can influence tool execution. Tighten controls accordingly and monitor activity end to end. Use the hunting queries provided as a starting point, and treat every finding as an opportunity to reduce blast radius before it is exploited.\n\n## References\n\n- Microsoft Defender XDR Advanced Hunting overview (how to run hunts): https://learn.microsoft.com/en-us/defender-xdr/advanced-hunting-overview\n\n- CloudProcessEvents table reference: https://learn.microsoft.com/en-us/defender-xdr/advanced-hunting-cloudprocessevents-table\n\n- OAuthAppInfo table reference and prerequisites: https://learn.microsoft.com/en-us/defender-xdr/advanced-hunting-oauthappinfo-table\n\n- Web content filtering in Defender for Endpoint: https://learn.microsoft.com/en-us/defender-endpoint/web-content-filtering\n\n- Entra admin consent workflow overview: https://learn.microsoft.com/en-us/entra/identity/enterprise-apps/admin-consent-workflow-overview\n\n- Conditional Access overview: https://learn.microsoft.com/en-us/entra/identity/conditional-access/overview\n\n- Defender for Cloud Apps App Governance overview: https://learn.microsoft.com/en-us/defender-cloud-apps/app-governance\n\n- Microsoft Purview Endpoint DLP overview: https://learn.microsoft.com/en-us/purview/endpoint-dlp-learn-about\n\n*This research is provided by Microsoft Defender Security Research with contributions from Idan Hen.*\n\n## **Learn more**\n\nReview our documentation to learn more about our real-time protection capabilities and see how to enable them within your organization.\n\n- [Microsoft 365 Copilot AI security documentation](https://learn.microsoft.com/en-us/copilot/microsoft-365/microsoft-365-copilot-ai-security)\n- [How Microsoft discovers and mitigates evolving attacks against AI guardrails](https://www.microsoft.com/en-us/security/blog/2024/04/11/how-microsoft-discovers-and-mitigates-evolving-attacks-against-ai-guardrails/)\n- Learn more about [securing Copilot Studio agents with Microsoft Defender](https://learn.microsoft.com/en-us/defender-cloud-apps/ai-agent-protection)\n- Learn more about [Protect your agents in real-time during runtime (Preview) – Microsoft Defender for Cloud Apps | Microsoft Learn](https://learn.microsoft.com/en-us/defender-cloud-apps/real-time-agent-protection-during-runtime)\n- Explore [how to build and customize agents with Copilot Studio Agent Builder](https://eurppc-word-edit.officeapps.live.com/we/%E2%80%A2%09https:/learn.microsoft.com/en-us/microsoft-365-copilot/extensibility/copilot-studio-agent-builder)",
  "ProcessedDate": "2026-02-19 17:18:13",
  "FeedLevelAuthor": "Microsoft Security Blog"
}
