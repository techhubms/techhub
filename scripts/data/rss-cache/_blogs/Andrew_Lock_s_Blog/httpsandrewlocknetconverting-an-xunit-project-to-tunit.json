{
  "FeedUrl": "https://andrewlock.net/rss.xml",
  "FeedName": "Andrew Lock's Blog",
  "FeedLevelAuthor": "Andrew Lock | .NET Escapades",
  "Description": "In this post I discuss the new TUnit testing framework, why I ported one of my libraries to use it instead of xUnit and related issues I had to deal with",
  "OutputDir": "_blogs",
  "Tags": [
    ".NET Core",
    "Testing"
  ],
  "Title": "Converting an xUnit test project to TUnit",
  "PubDate": "2025-08-19T10:00:00+00:00",
  "ProcessedDate": "2025-08-19 11:09:57",
  "EnhancedContent": "In this post I discuss the new [TUnit testing framework](https://github.com/thomhurst/TUnit), why I ported one of my libraries to use it instead of xUnit, how I did that, and related issues I had to deal with.\n\n## What is TUnit\n\n[TUnit](https://github.com/thomhurst/TUnit) is a new testing library, similar to [xUnit](https://xunit.net/), [NUnit](https://nunit.org/), or [MSTest](https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-mstest-intro), that you can use to write test suites for your .NET applications. As per [the TUnit project's README](https://github.com/thomhurst/TUnit?tab=readme-ov-file):\n\n>\n> **TUnit** is a next-generation testing framework for C# that outpaces traditional frameworks with **source-generated tests**, **parallel execution by default**, and **Native AOT support**. Built on the modern Microsoft.Testing.Platform, TUnit delivers faster test runs, better developer experience, and unmatched flexibility.\n> >\n\nThe project is still pretty new, with the very first alpha releases first appearing in 2024, and without a v1.0.0 release yet. That said, [according to the current status](https://github.com/thomhurst/TUnit?tab=readme-ov-file#-current-status), \"The API is mostly stable\", and it certainly seems well developed both from a feature point of view, but also in terms of documentation and guides. More on that later!\n\nAnother important aspect is that it uses the newer [*Microsoft.Testing.Platform*](https://learn.microsoft.com/en-us/dotnet/core/testing/microsoft-testing-platform-intro?tabs=dotnetcli) experience (instead of the old [VSTest](https://learn.microsoft.com/en-us/dotnet/core/testing/microsoft-testing-platform-vs-vstest) runner), so it requires using a recent version of the .NET SDK. Even though it's new, Visual Studio, VS Code, and Rider all support the newer lightweight platform, and [hence support TUnit](https://github.com/thomhurst/TUnit?tab=readme-ov-file#%EF%B8%8F-ide-support) (though you may need to enabled the option in your IDE). Consequently, you'll see your TUnit tests show up in your IDE's test explorer, just as you are used to with other frameworks.\n\nOne of the minor selling points of TUnit is that many of the decisions made in the design mean that it can be *fast*. That includes source-generation based test discovery and even NativeAOT support. The [benchmarks on the TUnit](https://github.com/thomhurst/TUnit?tab=readme-ov-file#scenario-a-test-that-takes-50ms-to-execute-repeated-100-times-including-spawning-a-new-process-and-initialising-the-test-framework) README describe various scenarios, but the one that really stands out is:\n\n>\n> A test that takes 50ms to execute, repeated 100 times (including spawning a new process and initialising the test framework)\n> >\n\nThe first set of benchmarks for this scenario run on an Apple M1 macos, and show a very impressive speed up versus other frameworks (which I think is ultimately due to the increased parallelization used by TUnit):\n\n| Method | Mean | Error | StdDev | | --- | --- | --- | --- | | TUnit AOT | 235.8 ms | 12.94 ms | 38.15 ms | | TUnit | 643.5 ms | 21.41 ms | 63.13 ms | | NUnit | 13,517.6 ms | 269.19 ms | 644.96 ms | | xUnit | 13,932.4 ms | 276.32 ms | 505.26 ms | | MSTest | 13,704.8 ms | 269.71 ms | 614.28 ms |\n\nFor me the speed up is a nice benefit, but ultimately it's not the reason I looked at TUnit and wondered if it was worth converting my existing xUnit-based project to use TUnitâ€¦\n\n## Why change test frameworks?\n\nIn general, I wouldn't recommend changing your test framework. Yes, there are differences between the different frameworks, but many of those differences are cosmetic; it is *really* worth the hassle for minor changes? How much are you going to gain?\n\nAnd yet, I considered it ðŸ˜… This was actually first driven by an issue I found at work, working on [the DataDog .NET Tracer](https://github.com/DataDog/dd-trace-dotnet), when we tried to update to using the .NET 10 preview 5 SDK and our xUnit test libraries were failing to discover any tests. Not *failing*, just failing to run any tests ðŸ˜¬. That issue was ultimately an unrelated distraction, but it made us wonder whether we should stick with xUnit. What is the chance that we will hit an issue at some point and be completely stuck?\n\nOn top of that, there's the whole \"xUnit v3\" issueâ€¦\n\nxUnit v2, which uses [the \"xUnit\" NuGet package](https://www.nuget.org/packages/xunit/) supports basically all target frameworks: it supports .NET standard 1.1+ (so all .NET Core) and .NET Framework 4.5.2+. xUnit.v3 on the other hand (which is [a different NuGet package](https://www.nuget.org/packages/xunit.v3)) only supports .NET Framework 4.7.2 and .NET 8+.\n\nIt's obviously entirely up to the maintainers to decide what to support, and they've settled on supporting only the frameworks that Microsoft supports, which is reasonable on the face of it. But it gives us a tricky question at work, given that we need to test on a wide variety of frameworks. Even in my OSS projects I normally favour supporting a larger number of test frameworks for ease of use for consumers, and that range is always larger than xUnit.v3's matrix\n\nAll that means that it's unlikely I'll *ever* adopt xUnit.v3, whether at work, *or* in my personal projects. Which means I'm essentially stuck on v2 of xUnit *forever*. And that makes me nervous, given that xUnit v2 isn't receiving updates any moreâ€¦\n\n>\n> I do have some other minor gripes with xUnit which I won't go into here. I always find it kind of concerning that xUnit.v3 has had 3 major versions in the space of 6 months. I [defer to Aaron Stannard](https://aaronstannard.com/oss-semver/) as to why I consider this a big mistake.\n> >\n\nAll of which made me wonder if TUnit could be a potential alternative, so I decided to try it out on one of my OSS projects.\n\n## How is TUnit different to xUnit?\n\nOne of the nice things about [the TUnit docs](https://tunit.dev/docs) is that they explicitly try to address the differences between TUnit and other test frameworks. For xUnit, [the TUnit docs highlight 5 main points of difficulty](https://tunit.dev/docs/comparison/framework-differences#xunit):\n\n- **Async tests parallel limit**. xUnit allows limiting the *thread* count, but not the number of concurrent tests, because with `async`\ntests, those two things are not the same. With TUnit, you can explicitly choose the number of tests to run in parallel.\n- **Set up and tear downs**. xUnit mostly relies on constructors and `IDisposable`\nto handle test setup and shutdown. If you want *async* setup and teardown, you have to implement `IAsyncLifetime` , and there are some complexities around inheritance. With TUnit you have an additional option, `[BeforeTest]` and `[AfterTest]` attributes.\n- **Assembly level hooks**. xUnit doesn't have an easy way to run something before executing the tests for an assembly, TUnit has `[BeforeAssembly]`\nand `[AfterAssembly]` .\n- **TestContext**. xUnit doesn't track the state of the \"current\" test in things like tear down methods. With TUnit you can inject a context object into tear down methods or use the static `TestContext.Current`\n.\n- **Assertions**. xUnit assertions use a somewhat \"legacy\" `Assert.Equal(x, y)`\nformat, which makes it hard to know if the `x` or `y` is the actual or expected value. TUnit assertions use a fluent style like FluentAssertions or Shouldly.\n\nNow, to be fair to xUnit, many of these complaints are directed towards the *v2* version of xUnit. For example, xUnit v3 [has a `TestContext` type](https://xunit.net/docs/getting-started/v3/whats-new#test-context) similar to TUnit's, [and an `\\[AssemblyFixture\\]` attribute](https://xunit.net/docs/getting-started/v3/whats-new#miscellaneous-changes) for providing assembly-level hooks.\n\nThat said, TUnit brings a bunch of extra features to the table too:\n\n- **Source generation**. Instead of discovering tests at runtime, TUnit [relies on source generators to drive test discovery](https://tunit.dev/docs/comparison/framework-differences/#source-generated--native-aot-support--single-file-support), which makes things much faster at runtime.\n- **Native AOT support**. One benefit to using Native AOT is that you can actually use Native AOT to publish your *test* projects. Though I wonder how useful that *really* is, beyond being cuteðŸ˜…\n- **Test ordering**. TUnit provides [a `\\[DependsOn\\]`\nattribute](https://tunit.dev/docs/comparison/framework-differences/#test-dependencies) that allows providing an implicit ordering to tests, without having to disable parallelization in general or set ordinal `Order` values.\n- **Console capture**. With xUnit v2, nothing you write to `Console`\nis captured in the test output, but [TUnit automatically intercepts these logs](https://tunit.dev/docs/customization-extensibility/logging/) and correlates them with the current test. For the record, xUnit v3 has an option for this too.\n\nOf course, the *really* important difference from my point of view is the supported frameworks. As I mentioned before, xUnit v3 only supports .NET Framework 4.7.2 and .NET 8+. TUnit, on the other hand, supports .NET 8+ but *also* .NET Standard 2.0, which means .NET Framework 4.7.2, but *also* .NET Core 2.0+ which is the really killer feature from my point of view.\n\nSo with that in mind, I set about seeing what it would be like to convert one of my OSS projects to use TUnit instead of xUnit.\n\n## Converting an XUnit project to TUnit\n\nFurther kudos is due to the TUnit project: they have [a step-by-step guide](https://tunit.dev/docs/migration/xunit) describing migrating from xUnit to TUnit. And it worked amazingly well! So this section is mostly a rehash of those steps, with examples applied to my repo, and some caveats.\n\n### 1. Add the TUnit packages\n\nFirst of all, add the TUnit package to your test projects, for example:\n\n```bash dotnet add package TUnit\n\n```\n\nAt this point you'll have both xUnit and TUnit references in your project.\n\n### 2. Remove the automatically added global usings\n\nTUnit adds implicit global `using` statements to your project, however having these as well as xUnit `using` statements may cause some namespaces clashes. It's important that the projects are building successfully for the next step, so disable the using statements in the test projects:\n\n```xml <PropertyGroup> <TUnitImplicitUsings>false</TUnitImplicitUsings> <TUnitAssertionsImplicitUsings>false</TUnitAssertionsImplicitUsings> </PropertyGroup>\n\n```\n\nYou should now be able to build the project, which will also make sure all the TUnit analyzers are running and available.\n\n### 3. Convert the xUnit usages to TUnit\n\nThe next step is the really neat part. TUnit includes [an analyzer](https://github.com/thomhurst/TUnit/blob/main/TUnit.Analyzers/Migrators/XUnitMigrationAnalyzer.cs#L114) that helps convert from xUnit to TUnit. And the best bit is that you can run the analyzer and associated code fixer from the command line, and it will convert the project to TUnit for you:\n\n```bash dotnet format analyzers --severity info --diagnostics TUXU0001\n\n```\n\n[I ran this](https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders/pull/255/commits/0e49268406f485bcab6585974e9ba0da69aa9e3a) on the two test projects in my library and it did all the grunt work of removing the `using xunit;` , changing `[Fact]` to `[Test]` , `[InlineData]` to `[Arguments]` , among various other things:\n\n![A diff of some of the changes](/content/images/2025/tunit.png)\n\nThis wasn't completely successful, in that it left a few xUnit asserts untouched, but I was generally converting to FluentAssertions anyway, so I just went ahead and [completed that conversion first](https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders/pull/252).\n\nAnother thing to note is that the analyzer performed some general reformatting of some lines (you can see removed blank lines in the screenshot above, for example). This wasn't a big deal for me, but it's something worth bearing in mind.\n\n### 4. Reinstate the global usings\n\nNow that all the usages are converted, you need to re-enable the TUnit namespaces, so the easiest thing to do is to revert the `TUnitImplicitUsings` and `TUnitAssertionsImplicitUsings` properties.\n\n### 5. Remove unneeded packages\n\nWe're almost done. Finally, you can remove all the xUnit packages, including the runner packages, and importantly *also* the *Microsoft.NET.Test.Sdk* package. TUnit uses the newer, lightweight *Microsoft.Testing.Platform* package instead, and references the package directly, so the only package you need is TUnit.\n\nAt this point, you should be able to build and test your project, and if all has gone well, you can test your project with `dotnet test` , or however you prefer!\n\n## Related issues\n\nThere were a few minor issues I ran into.\n\nThe first one I've already mentioned, in that I had to fix some `Assert` calls that weren't converted correctly, in particular `Assert.Throws<>` calls. As described previously, I resolved the issue by converting to FluentAssertions instead, before converting to TUnit.\n\nAnother issue I had was with TRX report generation. TUnit and *Microsoft.Testing.Platform* support TRX report generation by way of [an extension package](https://tunit.dev/docs/extensions/#trx-test-reports), *Microsoft.Testing.Extensions.TrxReport*. [Theoretically](https://learn.microsoft.com/en-us/dotnet/core/testing/microsoft-testing-platform-extensions-test-reports#visual-studio-test-reports) you just need to remove the `--logger trx` call used with *Microsoft.NET.Test.Sdk*, and add the `--report-trx` version required by *Microsoft.Testing.Platform*.\n\nHowever, I found that I needed to add `--report-trx` (and the `--results-directory` argument) *after* a `--` argument. And related to this, I had to work around the fact that [Nuke](https://nuke.build/), my preferred build system, doesn't have first-class support for the *Microsoft.Testing.Platform* library. All in all I had to make the following changes to the `Test` stage in my Nuke script:\n\n```diff DotNetTest(s => s .SetProjectFile(Solution) .SetConfiguration(Configuration) .SetProperty(\"Version\", Version) .When(IsServerBuild, x => x\n- .SetLoggers(\"trx\")\n- .SetResultsDirectory(TestResultsDirectory))\n+ .SetProcessArgumentConfigurator(x=>x\n+ .Add(\"--\")\n+ .Add(\"--report-trx\")\n+ .Add(\"--results-directory\")\n+ .Add(TestResultsDirectory)));\n\n```\n\nThe final issue I had was with my use of [Verify](https://github.com/VerifyTests/Verify) for snapshot testing. Verify has plugins for multiple test frameworks, including TUnit. However, unfortunately for me, even the *earliest* version of [Verify.TUnit](https://www.nuget.org/packages/Verify.TUnit/26.5.0#dependencies-body-tab) only supports .NET 8+, no earlier versions of .NET Core, which makes it a deal breaker for me.\n\n>\n> Verify is another library where I'm indefinitely stuck on old versions (both in OSS and at work) due to the dropping of older frameworks. That, plus a somewhat aggressive approach to breaking changes, has meant I was about 12 major versions behind the latest, and unable to upgrade ðŸ˜…\n> >\n\nSo this left me a little stuck. I considered just removing Verify entirely, seeing as I was only using it in a single test. However I *also* wanted to consider moving to TUnit for other projects, and converting *those* projects could end up trickyâ€¦\n\nSo I did something moderately drastic. I forked Verify at the highest version that I could add a .NET Core 2.1 target to (`21.3.0` ) and uploaded [my own version](https://www.nuget.org/packages/NetEscapades.Verify). I don't envisage this going any further, but it may make it simpler to convert some of my other libraries to TUnit without having to also swap to a different snapshot testing library!\n\n## Summary\n\nIn this post I discussed the new [TUnit testing framework](https://github.com/thomhurst/TUnit), looking at some of it's features, and some of its differences from other frameworks. Then I described how the move for xUnit to create xUnit.v3 had prompted me to consider changing the test framework for my open source libraries to TUnit. This isn't something you should take lightly, but the fact that xUnit.v3 on works on .NET 8+ (and .NET Framework) was a blocker for me to use it in my libraries, so I tried a sample conversion for one of my libraries.\n\nFor the remainder of the post I described the process of converting an xUnit project to TUnit. I found this to be incredibly smooth, thanks to the TUnit project providing a migration tool, by way of Roslyn analyzers. This process worked smoothly overall, with only relatively minor changes required on my side after the conversion. Overall TUnit seems very interesting, and I shall be watching it with interest, and potentially converting more of my projects across!\n\n## Tags\n\nAndrew Lock | .Net Escapades\n\n![](/assets/img/icons/apple/apple-touch-icon-180x180.png) Want an email when there's new posts?\n\nStay up to the date with the latest posts!\n\nOops! Check your details and try again.\n\nThanks! Check your email for confirmation.",
  "Link": "https://andrewlock.net/converting-an-xunit-project-to-tunit/",
  "Author": "Andrew Lock"
}
