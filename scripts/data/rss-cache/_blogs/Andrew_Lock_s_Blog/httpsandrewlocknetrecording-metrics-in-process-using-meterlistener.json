{
  "FeedName": "Andrew Lock's Blog",
  "PubDate": "2026-02-24T10:00:00+00:00",
  "OutputDir": "_blogs",
  "Author": "Andrew Lock",
  "Description": "In this post I show how you can use MeterListener to listen to Instrument measurements, how to trigger Observable measurements, and how to aggregate values.",
  "EnhancedContent": "So far in this series I've described how to [create and consume metrics using `dotnet-counters`](/creating-and-consuming-metrics-with-system-diagnostics-metrics-apis/), how to [create each of the different `Instrument` types](/creating-standard-and-observable-instruments/#system-diagnostics-metrics-apis) exposed by the *System.Diagnostics.Metrics* APIs, and how to [use a source generator to produce values](/creating-strongly-typed-metics-with-a-source-generator/). In this post, I look at how to *consume* the stream of values produced by `Instrument` implementations in-process, using the `MeterListener` type.\n\nI start by describing the scenario of an app that wants to record and process a specific subset of metrics exposed via the *System.Diagnostics.Metrics* APIs. We'll create a simple app that generates some load, use `MeterListener` to listen for `Instrument` measurements, and display the results in a table using [Spectre.Console](https://spectreconsole.net/) (because everyone loves [Spectre.Console](https://spectreconsole.net/))!\n\n>\n> Note that I'm *not* suggesting you use `MeterListener`\n> directly in your production apps. In production, you'll likely want to use a solution like OpenTelemetry or Datadog that does all this work for you!\n> >\n\n## Creating the test ASP.NET Core app\n\nAs described above, for the purposes of this post, I created a simple \"hello world\" ASP.NET Core app using `dotnet new web` , and tweaked it so that it will send requests to itself, as long as the app is running:\n\n```csharp using Microsoft.AspNetCore.Hosting.Server; using Microsoft.AspNetCore.Hosting.Server.Features;\n\n// Very basic hello-world app var builder = WebApplication.CreateBuilder(args); var app = builder.Build();\n\napp.MapGet(\"/\", () => \"Hello World!\");\n\nvar task = app.RunAsync();\n\n// Grab the address Kestrel's listening on var address = app.Services.GetRequiredService<IServer>()! .Features.Get<IServerAddressesFeature>()! .Addresses.First();\n\ntry { // Run 4 loops in parallel, sending HTTP requests continuously // until the app gets the shut down notification await Parallel.ForAsync(0, 4, app.Lifetime.ApplicationStopping, async (i, ct) => { var httpClient = new HttpClient() { BaseAddress = new Uri(address), };\n\n// Just keep hammering requests! while (!ct.IsCancellationRequested) { string _ = await httpClient.GetStringAsync(\"/\"); } }); } catch (OperationCanceledException) { // expected on shutdown }\n\n// Wait for the final cleanup await task;\n\n```\n\nThe code above isn't particularly pretty, but it does the following:\n\n- Creates a \"hello world\" minimal API ASP.NET Core app.\n- After the app starts up, it starts 4 parallel jobs\n- Each job has its own `HttpClient`\nand continuously makes HTTP requests to the app\n- ctrl+c in the console stops the requests and shut's down the app.\n\nNow that we have this app, we can start grabbing some metrics out of it. We're aiming for something like the following, which shows the majority of metrics from [my previous post](/creating-standard-and-observable-instruments/#system-diagnostics-metrics-apis/) in a [live-updating Spectre.Console](https://spectreconsole.net/console/how-to/live-rendering-and-dynamic-updates) [table](https://spectreconsole.net/console/how-to/displaying-tabular-data):\n\n```ini ASP.NET Core Metrics â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Metric â”‚ Type â”‚ Value â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ aspnetcore.routing.match_attempts â”‚ Counter â”‚ 250,428 â”‚ â”‚ dotnet.gc.heap.total_allocated â”‚ ObservableCounter â”‚ 849,743,376 â”‚ â”‚ http.server.active_requests â”‚ UpDownCounter â”‚ 4 â”‚ â”‚ dotnet.gc.last_collection.heap.size (gen0) â”‚ ObservableUpDownCounter â”‚ 2,497,080 â”‚ â”‚ dotnet.gc.last_collection.heap.size (gen1) â”‚ ObservableUpDownCounter â”‚ 774,872 â”‚ â”‚ dotnet.gc.last_collection.heap.size (gen2) â”‚ ObservableUpDownCounter â”‚ 1,219,120 â”‚ â”‚ dotnet.gc.last_collection.heap.size (loh) â”‚ ObservableUpDownCounter â”‚ 98,384 â”‚ â”‚ dotnet.gc.last_collection.heap.size (poh) â”‚ ObservableUpDownCounter â”‚ 65,728 â”‚ â”‚ process.cpu.utilization â”‚ ObservableGauge â”‚ 36% â”‚ â”‚ http.server.request.duration â”‚ Histogram â”‚ 0.011ms â”‚ â”‚ http.server.request.duration (count) â”‚ Histogram â”‚ 250,425 â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n```\n\nTo record the values from these metrics, we're going to use the `MeterListener` type.\n\n## Recording metrics with `MeterListener`\n\nIn my previous post I discussed how `Instrument` s have both a consumer and a producer side. To consume the output of `Instrument` s inside your app you must subscribe to them using a `MeterListener` . To manage all this configuration, we'll create a helper type called `MetricManager` .\n\n### Creating a wrapper `MetricManager`\nfor working with metrics\n\nTo encapsulate the collection and aggregation of metrics emitted by the *System.Diagnostics.Metrics* APIs, I'm going to create a type called `MetricManager` . This is entirely optional, it's just helpful for my scenario. The public API for this type is shown below, which we'll be fleshing out shortly.\n\n```csharp public class MetricManager : IDisposable { public void Dispose(); public MetricValues GetMetrics(); }\n\n```\n\nThe `MetricManager` is responsible for interacting with the *System.Diagnostics.Metrics* APIs. And when you call `GetMetrics()` , the manager returns the values for each of the `Instruments` we listed above:\n\n```csharp public readonly record struct MetricValues( long TotalMatchAttempts, long TotalHeapAllocated, long ActiveRequests, long HeapSizeGen0, long HeapSizeGen1, long HeapSizeGen2, long HeapSizeLoh, long HeapSizePoh, double CpuUtilization, double AverageDuration, long TotalRequests);\n\n```\n\nJust to reiterate, this is not *required*. It's just how I've chosen in this post to expose the interactions with the *System.Diagnostics.Metrics* APIs.\n\n>\n> Note also that I'm creating a very well-defined API here. If you want to have more of a \"generalised\" listener, that can listen to *all* metrics, and records all the tags for those metrics, I strongly recommend looking at OpenTelemetry instead!\n> >\n\nSo we have our basic public API, now let's create a `MeterListener` and hook it up.\n\n### Creating a `MeterListener`\nand configuring callbacks\n\nOne of the design tenants of the *System.Diagnostics.Metrics* APIs is that they should be high performance. Commonly for .NET, that mostly means \"you don't need additional allocations\". That shows up in some of the design of the `MeterListener` as you'll see shortly.\n\nThe code below shows how we would extend `MetricManager` to create a `MeterListener` , initialize it, and configure callbacks:\n\n```csharp public class MetricManager : IDisposable { private readonly MeterListener _listener;\n\npublic MetricManager() { // Create a MeterListener, and configure the method to call // when a new instrument is published in the application _listener = new() { InstrumentPublished = OnInstrumentPublished };\n\n// Configure the callbacks to invoke when an Instrument emits a value. // In this case, we know that the .NET runtime instruments we listen to only // produce long or double values, so that's all we listen for here _listener.SetMeasurementEventCallback<long>(OnMeasurementRecordedLong); _listener.SetMeasurementEventCallback<double>(OnMeasurementRecordedDouble);\n\n// Start the listener, which invokes OnInstrumentPublished for already-published Instruments _listener.Start(); }\n\n// Call Dispose on the listener to prevent further callbacks being invoked public void Dispose() => _listener.Dispose();\n\n// Callback invoked whenever an instrument is published private void OnInstrumentPublished(Instrument instrument, MeterListener listener) { // ... }\n\n// Callback invoked whenever a `long` measurement is recorded private static void OnMeasurementRecordedLong(Instrument instrument, long measurement, ReadOnlySpan<KeyValuePair<string, object?>> tags, object? state) { // ... }\n\n// Callback invoked whenever a `double` measurement is recorded private static void OnMeasurementRecordedDouble(Instrument instrument, double measurement, ReadOnlySpan<KeyValuePair<string, object?>> tags, object? state) { // ... } }\n\n```\n\nI've heavily commented the code above, but I'll highlight some interesting points.\n\nFirstly, the `OnInstrument` callback allows the listener to choose which `Meter` s and `Instrument` s it wants to subscribe to. This callback is invoked once for each existing `Instrument` when you call `MeterListener.Start()` , and is then subsequently invoked whenever a new `Meter` or `Instrument` is subsequently registered.\n\nIn addition, we have the `SetMeasurementEventCallback<T>()` method. This is a generic method, because it allows you to register a different callback for each *type* of `Instrument` measurement you might receive. Instruments can be created with `byte` , `short` , `int` , `long` , `float` , `double` , and `decimal` types, so [it's recommended](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/metrics-collection#create-a-custom-collection-tool-using-the-net-meterlistener-api) that you register a callback for each of these types.\n\n>\n> Note that if you use a generic argument that *isn't* one of these types, you'll get an exception at runtime.\n> >\n\nThis kind of API might seem a little unusual; having to register virtually identical callbacks for each different type feels a bit clumsy. But it's written this way for performance reasons. By having a dedicated callback for each supported `T` , you can avoid any allocation or overhead that would come from having a \"generic\" callback that would only work with `object` .\n\nAlso note that the callback you register doesn't *have* to be different methods like I have used above. You *could* also have a single generic method with a signature like this:\n\n```csharp static void OnMeasurementRecorded<T>( Instrument instrument, T measurement, ReadOnlySpan<KeyValuePair<string, object?>> tags, object? state);\n\n```\n\nHowever, you would still need to call `SetMeasurementEventCallback<T>` once for each measurement type you want to handle, for example:\n\n```csharp _listener.SetMeasurementEventCallback<long>(OnMeasurementRecorded); _listener.SetMeasurementEventCallback<double>(OnMeasurementRecorded);\n\n```\n\nWe are yet to implement these measurement callbacks, but before we get to that, we'll take a look at the `OnInstrumentPublished()` callback.\n\n### Selecting which `Instrument`\ns to listen to\n\nThe `MeterListener` is \"connected\" to all of the `Meter` s and `Instrument` s in the application, but it won't automatically receive measurements from all of them unless you enable each one. For this demo, we only care about a subset of `Meter` s and `Instrument` s, so our `OnInstrumentPublished()` callback uses a switch expression to check for specific values of `Instrument.Name` and `Meter.Name` :\n\n```csharp private void OnInstrumentPublished(Instrument instrument, MeterListener listener) { string meterName = instrument.Meter.Name; string instrumentName = instrument.Name;\n\n// Is this a Meter and Instrument we care about? var enable = meterName switch { \"Microsoft.AspNetCore.Routing\" => instrumentName == \"aspnetcore.routing.match_attempts\", \"System.Runtime\" => instrumentName is \"dotnet.gc.heap.total_allocated\" or \"dotnet.gc.last_collection.heap.size\", \"Microsoft.AspNetCore.Hosting\" => instrumentName is \"http.server.active_requests\" or \"http.server.request.duration\", \"Microsoft.Extensions.Diagnostics.ResourceMonitoring\" => instrumentName == \"process.cpu.utilization\", _ => false };\n\nif (enable) { // If yes, enable measurements, and pass the `MetricManager` as \"state\" listener.EnableMeasurementEvents(instrument, state: this); } }\n\n```\n\nTo enable measurements, you call `MeterListener.EnableMeasurementEvents()` , passing in the `Instrument` to listen to. One interesting point here is that we're also passing the `MetricManager` as the `state` variable. This variable is passed in to our `OnMeasurementRecorded` callbacks and is a way of avoiding closures or expensive lookups in the callback events. You'll see how it's used shortly.\n\nNote that if we were creating a generic implementation that listened to *all* `Insturment` s emitted by the app, we could implement this method very simply:\n\n```csharp private void OnInstrumentPublished(Instrument instrument, MeterListener listener) => listener.EnableMeasurementEvents(instrument, state: this);\n\n```\n\nSo at this point we've enabled the instruments, we've called `MeterListener.Start()` , and it's time to start receiving some measurements!\n\n### Triggering `ObservableInstrument`\ns to emit measurements\n\nNow that we've subscribed to the instruments, the `OnMeasurementRecorded` callbacks are invoked whenever an `Instrument` emits a value. For \"standard\" `Instrument` s, that happens immediately, whenever a value is recorded: add a value to a `Counter<long>` , and our `OnMeasurementRecorded` callback is immediately called. But that's not how it works for observable instruments.\n\nIn my [previous post](/creating-standard-and-observable-instruments/#what-is-an-observable-instrument-), I described how observable instruments don't emit any values until the consumer *asks* them to. Well, the consumer here is `MeterListener` , and it needs to ask all the `Instrument` s it is interested in to emit values when `GetMetrics()` is called:\n\n```csharp public MetricValues GetMetrics() { // This triggers the observable metrics to go and read the values and // then invoke the OnMeasurementRecorded callback to send the values to us _listener.RecordObservableInstruments();\n\n// ... }\n\n```\n\nCalling `RecordObservableInstruments()` triggers all the observable instruments that we enabled to emit a measurement (by invoking their associated callbacks, such as [those described in my previous post](/creating-standard-and-observable-instruments/#observablecountert)). These measurements are then reported via the callbacks registered with the `MeterListener` .\n\nOur `MeterListener` is now completely configured, so it's time to flesh out the `OnMeasurementRecorded` callbacks.\n\n### Recording `Instrument`\nmeasurements\n\nWhenever a measurement is recorded by an `Instrument` , the registered callback of the appropriate type is invoked (if you haven't registered an appropriate callback, none will be invoked). Exactly what you should *do* with that metric depends on how you want to aggregate your data.\n\nThe following implementation of the `OnMeasurementRecordedLong` method shows one way to aggregate the data, focusing on displaying long running totals for the duration of the app:\n\n```csharp private static void OnMeasurementRecordedLong(Instrument instrument, long measurement, ReadOnlySpan<KeyValuePair<string, object?>> tags, object? state) { var handler = (MetricManager)state!; switch (instrument.Name) { // Counter case \"aspnetcore.routing.match_attempts\": Interlocked.Add(ref handler._matchAttempts, measurement); break;\n\n// ObservableCounter case \"dotnet.gc.heap.total_allocated\": Interlocked.Exchange(ref handler._totalHeapAllocated, measurement); break;\n\n// UpDownCounter case \"http.server.active_requests\": Interlocked.Add(ref handler._activeRequests, measurement); break;\n\n// ObservableUpDownCounter case \"dotnet.gc.last_collection.heap.size\": foreach (var tag in tags) { if (tag is { Key: \"gc.heap.generation\", Value: string gen }) { switch (gen) { case \"gen0\": Interlocked.Exchange(ref handler._heapSizeGen0, measurement); break; case \"gen1\": Interlocked.Exchange(ref handler._heapSizeGen1, measurement); break; case \"gen2\": Interlocked.Exchange(ref handler._heapSizeGen2, measurement); break; case \"loh\": Interlocked.Exchange(ref handler._heapSizeLoh, measurement); break; case \"poh\": Interlocked.Exchange(ref handler._heapSizePoh, measurement); break; } } }\n\nbreak; } }\n\n```\n\nThe first step is to cast the `state` object back to the `MetricManager` instance that we passed in when calling `EnableMeasurementEvents()` . We then switch based on the instrument name, and handle the measurement value differently depending on the instrument type:\n\n- For `Counter`\nand `UpDownCounter` , the callback is invoked once for every time a new value is recorded, with the `measurement` value as the increment. To create a running total of values, you must *add* the new measurement to the current running total.\n- For `ObservableCounter`\nand `ObservableUpDownCounter` , the callback is only invoked when you call `RecordObservableInstruments()` . The `measurement` value in these cases *aren't* incremental values, but rather they're the \"final\" current value, so you can use the value \"as is\" for the current running total.\n\nYou can see these rules applied in the above method, where the `Counter` and `UpDownCounter` metrics are aggregated using `Interlocked.Add()` , whereas the `ObservableCounter` and `ObservableUpDownCounter` metrics are \"aggregated\" by using `Interlocked.Exchange` .\n\nAnother interesting aspect is the handling of tags. The `\"dotnet.gc.last_collection.heap.size\"` is an `ObservableUpDownCounter` , so the values are emitted only when you call `RecordObservableInstruments()` . In this case, we receive one invocation of the callback *per generation*, with the `gc.heap.generation` tag indicating to which generation the current measurement applies.\n\nIn addition to the `OnMeasurementRecordedLong` callback, we also have the `OnMeasurementRecordedDouble` callback, which we use to record the `ObservableGauge` and `Histogram` metrics:\n\n```csharp private static void OnMeasurementRecordedDouble(Instrument instrument, double measurement, ReadOnlySpan<KeyValuePair<string, object?>> tags, object? state) { var handler = (MetricManager)state!; switch (instrument.Name) { // ObservableGauge case \"process.cpu.utilization\": Interlocked.Exchange(ref handler._cpuUtilization, measurement); break;\n\n// Histogram case \"http.server.request.duration\": Interlocked.Increment(ref handler._totalRequestCount); lock (handler._durationLock) { handler._intervalRequests++; handler._totalDuration += measurement; }\n\nbreak; } }\n\n```\n\nThe structure for this callback is very similar to the previous one:\n\n- We cast the `state`\nvariable to our `MetricManager` instance that we passed in when registering the callback.\n- For the `ObservableGauge`\n(as for all of the observable instruments), we *replace* our recorded value, using `Interlocked.Exchange()`\n- For the `Histogram`, there are many different ways we could aggregate the data, especially considering that these measurements contain a lot of high cardinality tags. I chose to calculate just two values from this data:\n- The total number of requests since app start, stored in `_totalRequestCount`\n.\n- The average request duration in the current time interval. This requires recording the number of requests (`_intervalRequests`\n) during the interval, and the sum of the durations of requests during the interval (`_totalDuration` ). We'll use these values to calculate the average shortly.\n\nSome of these measurements may be recorded concurrently with when while we are reading the values, which is why I've used `Interlocked` where possible, to make updates atomic. Where I couldn't use `Interlocked` , I used a `lock` for simplicity, though you should be careful about this in practice; in high performance applications it might be possible to run into lock contention, if many requests are trying to increment these values.\n\nNow that all of our `Instrument` s are recording values, both standard and observable, it's time to report the results.\n\n### Reporting the results from `GetMetrics`\n\nI have already partially shown the `GetMetrics()` implementation, in so far as it's where we called `RecordObservableInstruments()` . Other than triggering the observable measurements to be taken, all `GetMetrics()` does is read the values recorded in the fields, calculate the average duration, and return a `MetricValues` instance:\n\n```csharp public MetricValues GetMetrics() { // This triggers the observable metrics to go and read the values // and then call the OnMeasurement callbacks to send the values to us _listener.RecordObservableInstruments();\n\n// Read all of the values from the fields and return a MetricValues object return new MetricValues( TotalMatchAttempts: Interlocked.Read(ref _matchAttempts), TotalHeapAllocated: Interlocked.Read(ref _totalHeapAllocated), ActiveRequests: Interlocked.Read(ref _activeRequests), HeapSizeGen0: Interlocked.Read(ref _heapSizeGen0), HeapSizeGen1: Interlocked.Read(ref _heapSizeGen1), HeapSizeGen2: Interlocked.Read(ref _heapSizeGen2), HeapSizeLoh: Interlocked.Read(ref _heapSizeLoh), HeapSizePoh: Interlocked.Read(ref _heapSizePoh), CpuUtilization: Volatile.Read(ref _cpuUtilization), AverageDuration: ComputeAndResetAverageDuration(), TotalRequests: Interlocked.Read(ref _totalRequestCount) );\n\ndouble ComputeAndResetAverageDuration() { long count; double sum; lock (_durationLock) { // Grab the current values count = _intervalRequests; sum = _totalDuration; // Reset the values _intervalRequests = 0; _totalDuration = 0; }\n\n// Do the calculation return count > 0 ? sum / count : 0; } }\n\n```\n\nAnd with that, the implementation of `MetricManager` and its usage of `MeterListener` is complete. All that remains is to plug the listener into our app.\n\n## Creating a service to display the results\n\nTo view the metrics being collected by `MetricManager` and its `MeterListener` , I created a `BackgroundService` that would render a [Spectre.Console](https://spectreconsole.net/) live table to the console, and update it periodically:\n\n```csharp using MyMetrics; using Spectre.Console;\n\ninternal class MetricDisplayService : BackgroundService { protected override async Task ExecuteAsync(CancellationToken stoppingToken) { using var manager = new MetricManager();\n\nvar table = new Table() .Title(\"[bold]ASP.NET Core Metrics[/]\") .Border(TableBorder.Rounded) .AddColumn(\"Metric\") .AddColumn(\"Type\") .AddColumn(new TableColumn(\"Value\").RightAligned());\n\ntable.AddRow(\"aspnetcore.routing.match_attempts\", \"Counter\", \"0\"); table.AddRow(\"dotnet.gc.heap.total_allocated\", \"ObservableCounter\", \"0\"); table.AddRow(\"http.server.active_requests\", \"UpDownCounter\", \"0\"); table.AddRow(\"dotnet.gc.last_collection.heap.size (gen0)\", \"ObservableUpDownCounter\", \"0\"); table.AddRow(\"dotnet.gc.last_collection.heap.size (gen1)\", \"ObservableUpDownCounter\", \"0\"); table.AddRow(\"dotnet.gc.last_collection.heap.size (gen2)\", \"ObservableUpDownCounter\", \"0\"); table.AddRow(\"dotnet.gc.last_collection.heap.size (loh)\", \"ObservableUpDownCounter\", \"0\"); table.AddRow(\"dotnet.gc.last_collection.heap.size (poh)\", \"ObservableUpDownCounter\", \"0\"); table.AddRow(\"process.cpu.utilization\", \"ObservableGauge\", \"0%\"); table.AddRow(\"http.server.request.duration\", \"Histogram\", \"0.000ms\"); table.AddRow(\"http.server.request.duration (count)\", \"Histogram\", \"0\");\n\nawait AnsiConsole.Live(table).StartAsync(async ctx => { // This is the update loop, where we poll the `MetricManager` while (!stoppingToken.IsCancellationRequested) { await Task.Delay(TimeSpan.FromSeconds(1), stoppingToken); RenderMetricValues(table, ctx, manager.GetMetrics()); } }); }\n\nprivate void RenderMetricValues(Table table, LiveDisplayContext ctx, in MetricManager.MetricValues values) { table.UpdateCell(0, 2, values.TotalMatchAttempts.ToString(\"N0\")); table.UpdateCell(1, 2, values.TotalHeapAllocated.ToString(\"N0\")); table.UpdateCell(2, 2, values.ActiveRequests.ToString(\"N0\")); table.UpdateCell(3, 2, values.HeapSizeGen0.ToString(\"N0\")); table.UpdateCell(4, 2, values.HeapSizeGen1.ToString(\"N0\")); table.UpdateCell(5, 2, values.HeapSizeGen2.ToString(\"N0\")); table.UpdateCell(6, 2, values.HeapSizeLoh.ToString(\"N0\")); table.UpdateCell(7, 2, values.HeapSizePoh.ToString(\"N0\")); table.UpdateCell(8, 2, $\"{values.CpuUtilization:F0}%\"); table.UpdateCell(9, 2, $\"{values.AverageDuration * 1000:F3}ms\"); table.UpdateCell(10, 2, values.TotalRequests.ToString(\"N0\")); ctx.Refresh(); } }\n\n```\n\nMost of this code is simply setting up the table, the \"important\" part in terms of the interaction with the `MetricManager` all takes place in the `AnsiConsole.Live` block:\n\n```csharp // As long as the app keeps running... while (!stoppingToken.IsCancellationRequested) { // ...wait 1 second... await Task.Delay(TimeSpan.FromSeconds(1), stoppingToken); // ...and then grab the metrics, and render them RenderMetricValues(table, ctx, manager.GetMetrics()); }\n\n```\n\nAll that remains is to plug our background service into our app:\n\n```csharp using Microsoft.AspNetCore.Hosting.Server; using Microsoft.AspNetCore.Hosting.Server.Features;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Register the MetricDisplayService as an `IHostedService` builder.Services.AddHostedService<MetricDisplayService>();\n\n// Add the ResourceMonitoring package so that we can retrieve \"process.cpu.utilization\" builder.Services.AddResourceMonitoring(); var app = builder.Build();\n\napp.MapGet(\"/\", () => \"Hello World!\");\n\napp.Run();\n\n```\n\nand that's it! If we run the app, and generate some load, we'll see our metrics being reported to the console ğŸ‰\n\n```ini â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Metric â”‚ Type â”‚ Value â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ aspnetcore.routing.match_attempts â”‚ Counter â”‚ 250,428 â”‚ â”‚ dotnet.gc.heap.total_allocated â”‚ ObservableCounter â”‚ 849,743,376 â”‚ â”‚ http.server.active_requests â”‚ UpDownCounter â”‚ 4 â”‚ â”‚ dotnet.gc.last_collection.heap.size (gen0) â”‚ ObservableUpDownCounter â”‚ 2,497,080 â”‚ â”‚ dotnet.gc.last_collection.heap.size (gen1) â”‚ ObservableUpDownCounter â”‚ 774,872 â”‚ â”‚ dotnet.gc.last_collection.heap.size (gen2) â”‚ ObservableUpDownCounter â”‚ 1,219,120 â”‚ â”‚ dotnet.gc.last_collection.heap.size (loh) â”‚ ObservableUpDownCounter â”‚ 98,384 â”‚ â”‚ dotnet.gc.last_collection.heap.size (poh) â”‚ ObservableUpDownCounter â”‚ 65,728 â”‚ â”‚ process.cpu.utilization â”‚ ObservableGauge â”‚ 36% â”‚ â”‚ http.server.request.duration â”‚ Histogram â”‚ 0.011ms â”‚ â”‚ http.server.request.duration (count) â”‚ Histogram â”‚ 250,425 â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\n```\n\nAnd with that we reach the end. Our app is able to report metrics about itself, and report those in any way it sees fit. In this example we just blindly report them to the console, but you could do anything with them. That said, if you're thinking of doing anything *serious* with these metrics, you should likely consider using [the OpenTelemetry libraries](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/observability-with-otel) instead!\n\n## Summary\n\nIn this post I describe the scenario of an app that wants to record and process a specific subset of metrics exposed via the *System.Diagnostics.Metrics* APIs. I then show a simple app that generates some load, use `MeterListener` to listen for `Instrument` measurements, and display the results in a table using [Spectre.Console](https://spectreconsole.net/). Along the way I show the difference between the standard `Instrument` and `ObservableInstrument` measurements, show how to trigger observable measurements to be reported, and discuss performance aspects, such as passing state to the callback functions.\n\n## Tags\n\nAndrew Lock | .Net Escapades\n\n![](/assets/img/icons/apple/apple-touch-icon-180x180.png) Want an email when there's new posts?\n\nStay up to the date with the latest posts!\n\nOops! Check your details and try again.\n\nThanks! Check your email for confirmation.",
  "Link": "https://andrewlock.net/recording-metrics-in-process-using-meterlistener/",
  "FeedUrl": "https://andrewlock.net/rss.xml",
  "Tags": [
    ".NET Core",
    "Observability"
  ],
  "ProcessedDate": "2026-02-24 11:14:39",
  "Title": "Recording metrics in-process using MeterListener: System.Diagnostics.Metrics APIs - Part 4",
  "FeedLevelAuthor": "Andrew Lock | .NET Escapades"
}
