{
  "Author": "Scott Hanselman",
  "OutputDir": "_blogs",
  "ProcessedDate": "2025-11-29 00:09:09",
  "Title": "Automatically Signing a Windows EXE with Azure Trusted Signing, dotnet sign, and GitHub Actions",
  "Description": "[![WindowsEdgeLight on a Surface](https://www.hanselman.com/blog/content/binary/Windows-Live-Writer/Automatically-Signing-a-Windows-EXE-with_D0BE/image_thumb%5B1%5D.png \"WindowsEdgeLight on a Surface\")](https://www.hanselman.com/blog/content/binary/Windows-Live-Writer/Automatically-Signing-a-Windows-EXE-with_D0BE/image_2.png)Mac Tahoe (in Beta as of the time of this writing) has this new feature called Edge Light that basically puts a bright picture of an Edge Light around your screen and basically uses the power of OLED to give you a virtual ring light. So I was like, why can't we also have nice things? I wrote ([vibed, with GitHub Copilot and Claude Sonnet 4.5](https://www.youtube.com/watch?v=WMbHVu4lAGA)) a Windows Edge Light App (source code at [https://github.com/shanselman/WindowsEdgeLight](https://github.com/shanselman/WindowsEdgeLight) and you can get the latest release here [https://github.com/shanselman/WindowsEdgeLight/releases](https://github.com/shanselman/WindowsEdgeLight/releases) or the app will check for new releases and autoupdate with Updatum).\n\nHowever, as is with all suss loose executables on the internet, when you run random stuff you'll often get the Window Defender 'new phone, who dis' warning which is scary. After several downloads and no viruses or complaints, my executable will eventually gain reputation with the Windows Defender Smart Screen service, but having a Code Signing Certificate is said to help with that. However, code signing certs are expensive and a hassle to manage and renew.\n\nSomeone told me that [Azure Trusted Signing](https://azure.microsoft.com/en-us/products/trusted-signing) was somewhat less of a hassle - it's less, but it's still non-trivial. I read [this post from Rick (his blog is gold and has been for years) earlier in the year](https://weblog.west-wind.com/posts/2025/Jul/20/Fighting-through-Setting-up-Microsoft-Trusted-Signing) and some of it was super useful and other stuff has been made simpler over time.\n\nI wrote 80% of this blog post, but since I just spent an hour getting code signing to work and GitHub Copilot was going through and logging everything I did, I did use Claude 4.5 to help organize some of this. I have reviewed it all and re-written parts I didn't like, so any mistakes are mine.\n\nAzure Trusted Signing is Microsoft's cloud-based code signing service that:\n\n- **No hardware tokens** - Everything happens in the cloud\n- **Automatic certificate management** - Certificates are issued and renewed automatically\n- **GitHub Actions integration** - Sign during your CI/CD pipeline. I used GH Actions.\n- **Kinda Affortable** - About $10/month for small projects. I would like it if this were $10 a year. This is cheaper than a yearly cert, but it'll add up after a while so I'm always looking for cheaper/easier options.\n- **Trusted by Windows** - Uses the same certificate authority as Microsoft's own apps, so you should get your EXE trusted faster\n\n## Prerequisites\n\nBefore starting, you'll need:\n\n1. **Azure subscription**\n2. **Azure CLI** - [Install from here](https://aka.ms/installazurecliwindows)\n3. **Identity validation documents** - Driver's license or passport for individual developers. Note that I'm in the US, so your mileage may vary but I basically set up the account, scanned a QR code, took a picture of my license, then did a selfie, then waited.\n4. **Windows PC** - For local signing (optional) but I ended up using the dotnet sign tool. There are\n5. **GitHub repository** - For automated signing (optional)\n\n### Part 1: Setting Up Azure Trusted Signing\n\n#### Step 1: Register the Resource Provider\n\nFirst, I need to enable the Azure Trusted Signing service in my subscription. This can be done in the Portal, or at the CLI.\n\n```\n# Login to Azure\naz login\n\n# Register the Microsoft.CodeSigning resource provider\naz provider register --namespace Microsoft.CodeSigning\n\n# Wait for registration to complete (takes 2-3 minutes)\naz provider show --namespace Microsoft.CodeSigning --query \"registrationState\"\n\n```\n\nWait until the output shows `\"Registered\"` .\n\n### Step 2: Create a Trusted Signing Account\n\nNow create the actual signing account. You can do this via Azure Portal or CLI.\n\n**Option A: Azure Portal (Easier for first-timers)**\n\n1. Go to [Azure Portal](https://portal.azure.com/)\n2. Search for \"Trusted Signing Accounts\"\n3. Click **Create**\n4. Fill in:\n- **Subscription**: Your subscription\n- **Resource Group**: Create new or use existing (e.g., \"MyAppSigning\")\n- **Account Name**: A unique name (e.g., \"myapp-signing\")\n- **Region**: Choose closest to you (e.g., \"West US 2\")\n- **SKU**: Basic (sufficient for most apps)\n5. Click **Review + Create**, then **Create**\n\n**Option B: Azure CLI (Faster if you are a CLI person or like to drive stick shift)**\n\n```\n# Create a resource group\naz group create --name MyAppSigning --location westus2\n\n# Create the Trusted Signing account\naz trustedsigning create \\ --resource-group MyAppSigning \\ --account-name myapp-signing \\ --location westus2 \\ --sku-name Basic\n\n```\n\n**Important**: Note your region endpoint. Common ones are:\n\n- East US: `https://eus.codesigning.azure.net/`\n- West US 2: `https://wus2.codesigning.azure.net/`\n- Your specific region: Check in Azure Portal under your account's Overview page\n\nI totally flaked on this and messed around for 10 min before I realized that this URL matters and is specific to your account. Remember this endpoint.\n\n### Step 3: Complete Identity Validation\n\nThis is the most important step. Microsoft needs to verify you're a real person/organization.\n\n1. In Azure Portal, go to your Trusted Signing Account\n2. Click **Identity validation** in the left menu\n3. Click **Add identity validation**\n4. Choose validation type:\n- **Individual**: For solo developers (uses driver's license/passport)\n- **Organization**: For companies (uses business registration documents)\n5. For **Individual validation**:\n- Upload a clear photo of your government-issued ID\n- Provide your full legal name (must match ID exactly)\n- Provide your email address\n6. Submit and wait for approval\n\n**Approval Time**:\n\n- Individual: Usually 1-3 business days\n- Organization: 3-5 business days\n- Me: This took about 4 hours, so again, YMMV. I used my personal account and my personal Azure (don't trust MSFT folks with unlimited Azure credits, I pay for my own) so they didn't know it was me. I went through the regular line, not the Pre-check line LOL.\n\nYou'll receive an email when approved. **You cannot sign any code until this is approved.**\n\n### Step 4: Create a Certificate Profile\n\nOnce your identity is validated, create a certificate profile. This is what actually issues the signing certificates.\n\n1. In your Trusted Signing Account, click **Certificate profiles**\n2. Click **Add certificate profile**\n3. Fill in:\n- **Profile name**: Descriptive name (e.g., \"MyAppProfile\")\n- **Profile type**: Choose **Public Trust** (required to prevent SmartScreen)\n- **Identity validation**: Select your approved identity\n- **Certificate type**: Code Signing\n4. Click **Add**\n\n**Important**: Only \"Public Trust\" profiles prevent SmartScreen warnings. \"Private Trust\" is for internal apps only. This took me a second to realize also as it's not an intuitive name.\n\n### Step 5: Verify Your Setup\n\n```\n# List your Trusted Signing accounts\naz trustedsigning show \\ --resource-group MyAppSigning \\ --account-name myapp-signing\n\n# Should show status: \"Succeeded\"\n\n```\n\n**Write down these values** - you'll need them later:\n\n- **Account Name**: `myapp-signing`\n- **Certificate Profile Name**: `MyAppProfile`\n- **Endpoint URL**: `https://wus2.codesigning.azure.net/`\n(or your region)\n- **Subscription ID**: Found in Azure Portal\n- **Resource Group**: `MyAppSigning`\n\n## Part 2: Local Code Signing\n\nNow let's sign an executable on your my machine. You don't NEED to do this, but I wanted to try it locally to avoid a bunch of CI/CD runs, and I wanted to right-click the EXE and see the cert in Properties before I took it all to the cloud. The nice part about this was that I didn't need to mess with any certificates.\n\n### Step 1: Assign Yourself the Signing Role\n\nYou need permission to actually use the signing service.\n\n**Option A: Azure Portal**\n\n1. Go to your Trusted Signing Account\n2. Click **Access control (IAM)**\n3. Click **Add** → **Add role assignment**\n4. Search for and select **Trusted Signing Certificate Profile Signer.** This is important. I searched for \"code\" and found nothing. Search for \"Trusted\"\n5. Click **Next**\n6. Click **Select members** and find your user account\n7. Click **Select**, then **Review + assign**\n\n**Option B: Azure CLI**\n\n```\n# Get your user object ID\n$userId = az ad signed-in-user show --query id -o tsv\n\n# Assign the role\naz role assignment create \\ --role \"Trusted Signing Certificate Profile Signer\" \\ --assignee-object-id $userId \\ --scope /subscriptions/YOUR_SUBSCRIPTION_ID/resourceGroups/MyAppSigning/providers/Microsoft.CodeSigning/codeSigningAccounts/myapp-signing\n\n```\n\nReplace `YOUR_SUBSCRIPTION_ID` with your actual subscription ID.\n\n### Step 2: Login with the Correct Scope\n\nThis is crucial - you need to login with the specific codesigning scope.\n\n```\n# Logout first to clear old tokens\naz logout\n\n# Login with codesigning scope\naz login --use-device-code --scope \"https://codesigning.azure.net/.default\"\n\n```\n\nThis will give you a code to enter at [https://microsoft.com/devicelogin](https://microsoft.com/devicelogin). Follow the prompts.\n\n**Why device code flow?** Because Azure CLI's default authentication can conflict with Visual Studio credentials in my experience. Device code flow is more reliable for code signing.\n\n### Step 3: Download the Sign Tool\n\n**Option A: Install Globally (Recommended for regular use)**\n\n```\n# Install as a global tool (available everywhere)\ndotnet tool install --global --prerelease sign\n\n# Verify installation\nsign --version\n\n```\n\n**Option B: Install Locally (Project-specific)**\n\n```\n# Install to current directory\ndotnet tool install --tool-path . --prerelease sign\n\n# Use with .\\sign.exe\n\n```\n\n**Which should I use?**\n\n- **Global**: If you'll sign multiple projects or sign frequently\n- **Local**: If you want to keep the tool with a specific project or don't want it in your PATH\n\n### Step 4: Sign Your Executable\n\nNote again that code signing URL is specific to you. The tscp is your Trusted Signing Certificate Profile name and the tsa is your Trusted Signing Account name. I set \\*.exe to sign all the EXEs in the folder and note that the -b base directory is an absolute path, not a relative one. For me it was d:\\github\\WindowsEdgeLight\\publish, and your mileage will vary.\n\n```\n# Navigate to your project folder\ncd C:\\MyProject\n\n# Sign the executable\n.\\sign.exe code trusted-signing ` -b \"C:\\MyProject\\publish\" ` -tse \"https://wus2.codesigning.azure.net\" ` -tscp \"MyAppProfile\" ` -tsa \"myapp-signing\" ` *.exe ` -v Information\n\n```\n\n**Parameters explained:**\n\n- `-b`\n: Base directory containing files to sign\n- `-tse`\n: Trusted Signing endpoint (your region)\n- `-tscp`\n: Certificate profile name\n- `-tsa`\n: Trusted Signing account name\n- `*.exe`\n: Pattern to match files to sign\n- `-v`\n: Verbosity level (Trace, Information, Warning, Error)\n\n**Expected output:**\n\n``` info: Signing WindowsEdgeLight.exe succeeded. Completed in 2743 ms.\n\n```\n\n### Step 5: Verify the Signature\n\nYou can do this in PowerShell:\n\n```\n# Check the signature\nGet-AuthenticodeSignature \".\\publish\\MyApp.exe\" | Format-List\n\n# Look for:\n# Status: Valid\n# SignerCertificate: CN=Your Name, O=Your Name, ...\n# TimeStamperCertificate: Should be present\n\n```\n\n**Right-click the EXE** → **Properties** → **Digital Signatures** tab:\n\n- You should see your signature\n- \"This digital signature is OK\"\n\n### Common Local Signing Issues\n\nI hit all of these lol\n\n**Issue: \"Please run 'az login' to set up account\"**\n\n- **Cause**: Not logged in with the right scope\n- **Fix**: Run `az logout`\nthen `az login --use-device-code --scope \"https://codesigning.azure.net/.default\"`\n\n**Issue: \"403 Forbidden\"**\n\n- **Cause**: Wrong endpoint, account name, or missing permissions\n- **Fix**:\n- Verify endpoint matches your region (wus2, eus, etc.)\n- Verify account name is exact (case-sensitive)\n- Verify you have \"Trusted Signing Certificate Profile Signer\" role\n\n**Issue: \"User account does not exist in tenant\"**\n\n- **Cause**: Azure CLI trying to use Visual Studio credentials\n- **Fix**: Use device code flow (see Step 2)\n\n## Part 3: Automated Signing with GitHub Actions\n\nThis is where the magic happens. I want to automatically sign every release. I'm using GitVersion so I just need to tag a commit and GitHub Actions will kick off a run. You can go look at a real run in detail at [https://github.com/shanselman/WindowsEdgeLight/actions/runs/19775054123](https://github.com/shanselman/WindowsEdgeLight/actions/runs/19775054123)\n\n### Step 1: Create a Service Principal\n\nGitHub Actions needs its own identity to sign code. We'll create a service principal (like a robot account). This is VERY different than your local signing setup.\n\n**Important**: You need **Owner** or **User Access Administrator** role on your subscription to do this. If you don't have it, ask your Azure admin or a friend.\n\n```\n# Create service principal with signing permissions\naz ad sp create-for-rbac \\ --name \"MyAppGitHubActions\" \\ --role \"Trusted Signing Certificate Profile Signer\" \\ --scopes /subscriptions/YOUR_SUBSCRIPTION_ID/resourceGroups/MyAppSigning/providers/Microsoft.CodeSigning/codeSigningAccounts/myapp-signing \\ --json-auth\n\n```\n\nThis outputs JSON like this:\n\n``` { \"clientId\": \"12345678-1234-1234-1234-123456789abc\", \"clientSecret\": \"super-secret-value-abc123\", \"tenantId\": \"87654321-4321-4321-4321-cba987654321\", \"subscriptionId\": \"abcdef12-3456-7890-abcd-ef1234567890\" }\n\n```\n\n**SAVE THESE VALUES IMMEDIATELY!** You can't retrieve the `clientSecret` again. This is super important.\n\n**Alternative: Azure Portal Method**\n\nIf CLI doesn't work:\n\n1. **Azure Portal** → **App registrations** → **New registration**\n2. Name: \"MyAppGitHubActions\"\n3. Click **Register**\n4. **Copy the Application (client) ID** - this is `AZURE_CLIENT_ID`\n5. **Copy the Directory (tenant) ID** - this is `AZURE_TENANT_ID`\n6. Go to **Certificates & secrets** → **New client secret**\n7. Description: \"GitHub Actions\"\n8. Expiration: 24 months (max)\n9. Click **Add** and **immediately copy the Value** - this is `AZURE_CLIENT_SECRET`\n10. Go to your Trusted Signing Account → **Access control (IAM)**\n11. **Add role assignment** → **Trusted Signing Certificate Profile Signer**\n12. **Select members** → Search for \"MyAppGitHubActions\"\n13. **Review + assign**\n\n### Step 2: Add GitHub Secrets\n\nGo to your GitHub repository:\n\n1. **Settings** → **Secrets and variables** → **Actions**\n2. Click **New repository secret** for each:\n\n- `AZURE_CLIENT_ID `\n- From service principal output or App registration\n- `AZURE_CLIENT_SECRET - `\nFrom service principal output or Certificates & secrets\n- `AZURE_TENANT_ID `\n- From service principal output or App registration\n- `AZURE_SUBSCRIPTION_ID `\n- Azure Portal → Subscriptions\n\n**Security Note**: These secrets are encrypted and never visible in logs. Only your workflow can access them. You'll never see them again.\n\n### Step 3: Update Your GitHub Workflow\n\nThis is a little confusing as it's YAML, which is Satan's markup, but it's what we have sunk to as a society.\n\nNote the dotnet-version below. Yours might be 8 or 9, etc. Also, I am building both x64 and ARM versions and I am using GitVersion so if you want a more complete build.yml, you can go here [https://github.com/shanselman/WindowsEdgeLight/blob/master/.github/workflows/build.yml](https://github.com/shanselman/WindowsEdgeLight/blob/master/.github/workflows/build.yml) I am also zipping mine up and prepping my releases so my loose EXE lives in a ZIP file.\n\nAdd signing steps to your `.github/workflows/build.yml` :\n\n``` name: Build and Sign\n\non: push: tags:\n- 'v*'\nworkflow_dispatch:\n\npermissions: contents: write\n\njobs: build: runs-on: windows-latest\n\nsteps:\n- name: Checkout code\nuses: actions/checkout@v4 with: fetch-depth: 0\n\n- name: Setup .NET\nuses: actions/setup-dotnet@v4 with: dotnet-version: '10.0.x'\n\n- name: Restore dependencies\nrun: dotnet restore MyApp/MyApp.csproj\n\n- name: Build\nrun: | dotnet publish MyApp/MyApp.csproj ` -c Release ` -r win-x64 ` --self-contained\n\n# === SIGNING STEPS START HERE ===\n\n- name: Azure Login\nuses: azure/login@v2 with: creds: '{\"clientId\":\"${{ secrets.AZURE_CLIENT_ID }}\",\"clientSecret\":\"${{ secrets.AZURE_CLIENT_SECRET }}\",\"subscriptionId\":\"${{ secrets.AZURE_SUBSCRIPTION_ID }}\",\"tenantId\":\"${{ secrets.AZURE_TENANT_ID }}\"}'\n\n- name: Sign executables with Trusted Signing\nuses: azure/trusted-signing-action@v0 with: azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }} azure-client-id: ${{ secrets.AZURE_CLIENT_ID }} azure-client-secret: ${{ secrets.AZURE_CLIENT_SECRET }} endpoint: https://wus2.codesigning.azure.net/ trusted-signing-account-name: myapp-signing certificate-profile-name: MyAppProfile files-folder: ${{ github.workspace }}\\MyApp\\bin\\Release\\net10.0-windows\\win-x64\\publish files-folder-filter: exe files-folder-recurse: true file-digest: SHA256 timestamp-rfc3161: http://timestamp.acs.microsoft.com timestamp-digest: SHA256\n\n# === SIGNING STEPS END HERE ===\n\n- name: Create Release\nif: startsWith(github.ref, 'refs/tags/') uses: softprops/action-gh-release@v2 with: files: MyApp/bin/Release/net10.0-windows/win-x64/publish/MyApp.exe env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n```\n\n**Key points:**\n\n- `endpoint`\n: Use YOUR region's endpoint (wus2, eus, etc.)\n- `trusted-signing-account-name`\n: Your account name (exact, case-sensitive)\n- `certificate-profile-name`\n: Your certificate profile name (exact, case-sensitive)\n- `files-folder`\n: Path to your compiled executables\n- `files-folder-filter`\n: File types to sign (exe, dll, etc.)\n- `files-folder-recurse`\n: Sign files in subfolders\n\n### Step 4: Test the Workflow\n\nNow trigger the workflow. You have two options:\n\n**Option A: Manual Trigger (Safest for testing)**\n\nSince the workflow includes `workflow_dispatch:` , you can trigger it manually without creating a tag:\n\n```\n# Trigger manually via GitHub CLI\ngh workflow run build.yml\n\n# Or go to GitHub web UI:\n# Actions tab → \"Build and Sign\" workflow → \"Run workflow\" button\n\n```\n\nThis is ideal for testing because:\n\n- No tag required\n- Won't create a release\n- Can test multiple times\n- Easy to debug issues\n\n**Option B: Create a Tag (For actual releases)**\n\n```\n# Make sure you're on your main branch with no uncommitted changes\ngit status\n\n# Create and push a tag\ngit tag v1.0.0 git push origin v1.0.0\n\n```\n\nUse this when you're ready to create an actual release with signed binaries. This is what I am doing on my side.\n\n### Step 5: Monitor the Build\n\nWatch the progress with GitHub CLI:\n\n```\n# See latest runs\ngh run list --limit 5\n\n# Watch a specific run\ngh run watch\n\n# View detailed status\ngh run view --log\n\n```\n\nOr visit: `https://github.com/YOUR_USERNAME/YOUR_REPO/actions`\n\n**Look for:**\n\n- Azure Login - Should complete in ~5 seconds\n- Sign executables with Trusted Signing - Should complete in ~10-30 seconds\n- Create Release - Your signed executable is now available in /releases in your GitHib project\n\n### Common GitHub Actions Issues\n\nI hit a few of these, natch.\n\n**Issue: \"403 Forbidden\" during signing**\n\n- **Cause**: Service principal doesn't have permissions\n- **Fix**:\n1. Go to Azure Portal → Trusted Signing Account → Access control (IAM)\n2. Verify \"MyAppGitHubActions\" has \"Trusted Signing Certificate Profile Signer\" role\n3. If not, add it manually\n\n**Issue: \"No files matched the pattern\"**\n\n- **Cause**: Wrong `files-folder`\npath or build artifacts in wrong location\n- **Fix**:\n1. Add a debug step before signing: `- run: Get-ChildItem -Recurse`\n2. Find where your EXE is actually located\n3. Update `files-folder`\nto match\n\n**Issue: Secrets not working**\n\n- **Cause**: Typo in secret name or value not saved\n- **Fix**:\n1. Verify secret names EXACTLY match (case-sensitive)\n2. Re-create secrets if unsure\n3. Make sure no extra spaces in values\n\n**Issue: \"DefaultAzureCredential authentication failed\"**\n\n- **Cause**: Usually wrong tenant ID or client ID\n- **Fix**: Verify all 4 secrets are correct from service principal output\n\n## Part 4: Understanding the Certificate\n\n### Certificate Lifecycle\n\nAzure Trusted Signing uses **short-lived certificates** (typically 3 days). This freaked me out but they say this is actually a security feature:\n\n- If a certificate is compromised, it expires quickly\n- You never manage certificate files or passwords\n- Automatic renewal - you don't have to do anything\n\n**But won't my signature break after 3 days?**\n\nNo, it seems that's what **timestamping** is for. When you sign a file:\n\n1. Azure issues a 3-day certificate\n2. The file is signed with that certificate\n3. A timestamp server records \"this file was signed on DATE\"\n4. Even after the certificate expires, the signature remains valid because the timestamp proves it was signed when the certificate was valid\n\nThat's why both local and GitHub Actions signing include:\n\n``` timestamp-rfc3161: http://timestamp.acs.microsoft.com\n\n```\n\n### What the Certificate Contains\n\nYour signed executable has a certificate with:\n\n- **Subject**: Your name (e.g., \"CN=John Doe, O=John Doe, L=Seattle, S=Washington, C=US\")\n- **Issuer**: Microsoft ID Verified CS EOC CA 01\n- **Valid Dates**: 3-day window\n- **Key Size**: 3072-bit RSA (very secure)\n- **Enhanced Key Usage**: Code Signing\n\n### Verify Certificate on Any Machine\n\n```\n# Using PowerShell\nGet-AuthenticodeSignature \"MyApp.exe\" | Select-Object -ExpandProperty SignerCertificate | Format-List\n\n# Using Windows UI\n# Right-click EXE → Properties → Digital Signatures tab → Details → View Certificate\n\n```\n\nThis whole thing took me about an hour to 75 minutes. It was detailed, but not deeply difficult. Misspellings, case-sensitivity, and a few account issues with Role-Based Access Control did slow me down. Hope this helps!\n\n### Used Resources\n\n- [Azure Trusted Signing Documentation](https://learn.microsoft.com/en-us/azure/trusted-signing/)\n- [dotnet/sign Tool](https://github.com/dotnet/sign)\n- [azure/trusted-signing-action](https://github.com/Azure/trusted-signing-action)\n- [Windows Code Signing Best Practices](https://learn.microsoft.com/en-us/windows/win32/seccrypto/cryptography-tools)\n- [SmartScreen Reputation System](https://learn.microsoft.com/en-us/windows/security/threat-protection/microsoft-defender-smartscreen/microsoft-defender-smartscreen-overview)\n\n*Written in November 2025 based on real-world implementation for WindowsEdgeLight. Your setup might vary slightly depending on Azure region and account type. Things change, be stoic.*\n\n© 2025 Scott Hanselman. All rights reserved.",
  "FeedLevelAuthor": "scott@hanselman.com",
  "Link": "https://www.hanselman.com/blog/automatically-signing-a-windows-exe-with-azure-trusted-signing-dotnet-sign-and-github-actions",
  "EnhancedContent": "# [Scott Hanselman](/blog/)\n\nbrowse by [category](category) or [date](archive)\n\n## [Automatically Signing a Windows EXE with Azure Trusted Signing, dotnet sign, and GitHub Actions](https://www.hanselman.com/blog/automatically-signing-a-windows-exe-with-azure-trusted-signing-dotnet-sign-and-github-actions)\n\nNovember 28, 2025 [Comment on this post \\[1\\]](https://www.hanselman.com/blog/automatically-signing-a-windows-exe-with-azure-trusted-signing-dotnet-sign-and-github-actions/comments#comments-start) Posted in [Azure](https://www.hanselman.com/blog/category/azure) | [DotNetCore](https://www.hanselman.com/blog/category/dotnetcore)\n\nSponsored By\n\n[![WindowsEdgeLight on a Surface](https://images.hanselman.com/blog/Windows-Live-Writer/Automatically-Signing-a-Windows-EXE-with_D0BE/image_thumb%5B1%5D.png \"WindowsEdgeLight on a Surface\")](https://images.hanselman.com/blog/Windows-Live-Writer/Automatically-Signing-a-Windows-EXE-with_D0BE/image_2.png)Mac Tahoe (in Beta as of the time of this writing) has this new feature called Edge Light that basically puts a bright picture of an Edge Light around your screen and basically uses the power of OLED to give you a virtual ring light. So I was like, why can't we also have nice things? I wrote ([vibed, with GitHub Copilot and Claude Sonnet 4.5](https://www.youtube.com/watch?v=WMbHVu4lAGA)) a Windows Edge Light App (source code at [https://github.com/shanselman/WindowsEdgeLight](https://github.com/shanselman/WindowsEdgeLight) and you can get the latest release here [https://github.com/shanselman/WindowsEdgeLight/releases](https://github.com/shanselman/WindowsEdgeLight/releases) or the app will check for new releases and autoupdate with Updatum).\n\nHowever, as is with all suss loose executables on the internet, when you run random stuff you'll often get the Window Defender 'new phone, who dis' warning which is scary. After several downloads and no viruses or complaints, my executable will eventually gain reputation with the Windows Defender Smart Screen service, but having a Code Signing Certificate is said to help with that. However, code signing certs are expensive and a hassle to manage and renew.\n\nSomeone told me that [Azure Trusted Signing](https://azure.microsoft.com/en-us/products/trusted-signing) was somewhat less of a hassle - it's less, but it's still non-trivial. I read [this post from Rick (his blog is gold and has been for years) earlier in the year](https://weblog.west-wind.com/posts/2025/Jul/20/Fighting-through-Setting-up-Microsoft-Trusted-Signing) and some of it was super useful and other stuff has been made simpler over time.\n\nI wrote 80% of this blog post, but since I just spent an hour getting code signing to work and GitHub Copilot was going through and logging everything I did, I did use Claude 4.5 to help organize some of this. I have reviewed it all and re-written parts I didn't like, so any mistakes are mine.\n\nAzure Trusted Signing is Microsoft's cloud-based code signing service that:\n\n- **No hardware tokens** - Everything happens in the cloud\n- **Automatic certificate management** - Certificates are issued and renewed automatically\n- **GitHub Actions integration** - Sign during your CI/CD pipeline. I used GH Actions.\n- **Kinda Affortable** - About $10/month for small projects. I would like it if this were $10 a year. This is cheaper than a yearly cert, but it'll add up after a while so I'm always looking for cheaper/easier options.\n- **Trusted by Windows** - Uses the same certificate authority as Microsoft's own apps, so you should get your EXE trusted faster\n\n## Prerequisites\n\nBefore starting, you'll need:\n\n1. **Azure subscription**\n2. **Azure CLI** - [Install from here](https://aka.ms/installazurecliwindows)\n3. **Identity validation documents** - Driver's license or passport for individual developers. Note that I'm in the US, so your mileage may vary but I basically set up the account, scanned a QR code, took a picture of my license, then did a selfie, then waited.\n4. **Windows PC** - For local signing (optional) but I ended up using the dotnet sign tool. There are\n5. **GitHub repository** - For automated signing (optional)\n\n### Part 1: Setting Up Azure Trusted Signing\n\n#### Step 1: Register the Resource Provider\n\nFirst, I need to enable the Azure Trusted Signing service in my subscription. This can be done in the Portal, or at the CLI.\n\n```\n# Login to Azure\naz login\n\n# Register the Microsoft.CodeSigning resource provider\naz provider register --namespace Microsoft.CodeSigning\n\n# Wait for registration to complete (takes 2-3 minutes)\naz provider show --namespace Microsoft.CodeSigning --query \"registrationState\"\n\n```\n\nWait until the output shows `\"Registered\"` .\n\n### Step 2: Create a Trusted Signing Account\n\nNow create the actual signing account. You can do this via Azure Portal or CLI.\n\n**Option A: Azure Portal (Easier for first-timers)**\n\n1. Go to [Azure Portal](https://portal.azure.com/)\n2. Search for \"Trusted Signing Accounts\"\n3. Click **Create**\n4. Fill in:\n- **Subscription**: Your subscription\n- **Resource Group**: Create new or use existing (e.g., \"MyAppSigning\")\n- **Account Name**: A unique name (e.g., \"myapp-signing\")\n- **Region**: Choose closest to you (e.g., \"West US 2\")\n- **SKU**: Basic (sufficient for most apps)\n5. Click **Review + Create**, then **Create**\n\n**Option B: Azure CLI (Faster if you are a CLI person or like to drive stick shift)**\n\n```\n# Create a resource group\naz group create --name MyAppSigning --location westus2\n\n# Create the Trusted Signing account\naz trustedsigning create \\ --resource-group MyAppSigning \\ --account-name myapp-signing \\ --location westus2 \\ --sku-name Basic\n\n```\n\n**Important**: Note your region endpoint. Common ones are:\n\n- East US: `https://eus.codesigning.azure.net/`\n- West US 2: `https://wus2.codesigning.azure.net/`\n- Your specific region: Check in Azure Portal under your account's Overview page\n\nI totally flaked on this and messed around for 10 min before I realized that this URL matters and is specific to your account. Remember this endpoint.\n\n### Step 3: Complete Identity Validation\n\nThis is the most important step. Microsoft needs to verify you're a real person/organization.\n\n1. In Azure Portal, go to your Trusted Signing Account\n2. Click **Identity validation** in the left menu\n3. Click **Add identity validation**\n4. Choose validation type:\n- **Individual**: For solo developers (uses driver's license/passport)\n- **Organization**: For companies (uses business registration documents)\n5. For **Individual validation**:\n- Upload a clear photo of your government-issued ID\n- Provide your full legal name (must match ID exactly)\n- Provide your email address\n6. Submit and wait for approval\n\n**Approval Time**:\n\n- Individual: Usually 1-3 business days\n- Organization: 3-5 business days\n- Me: This took about 4 hours, so again, YMMV. I used my personal account and my personal Azure (don't trust MSFT folks with unlimited Azure credits, I pay for my own) so they didn't know it was me. I went through the regular line, not the Pre-check line LOL.\n\nYou'll receive an email when approved. **You cannot sign any code until this is approved.**\n\n### Step 4: Create a Certificate Profile\n\nOnce your identity is validated, create a certificate profile. This is what actually issues the signing certificates.\n\n1. In your Trusted Signing Account, click **Certificate profiles**\n2. Click **Add certificate profile**\n3. Fill in:\n- **Profile name**: Descriptive name (e.g., \"MyAppProfile\")\n- **Profile type**: Choose **Public Trust** (required to prevent SmartScreen)\n- **Identity validation**: Select your approved identity\n- **Certificate type**: Code Signing\n4. Click **Add**\n\n**Important**: Only \"Public Trust\" profiles prevent SmartScreen warnings. \"Private Trust\" is for internal apps only. This took me a second to realize also as it's not an intuitive name.\n\n### Step 5: Verify Your Setup\n\n```\n# List your Trusted Signing accounts\naz trustedsigning show \\ --resource-group MyAppSigning \\ --account-name myapp-signing\n\n# Should show status: \"Succeeded\"\n\n```\n\n**Write down these values** - you'll need them later:\n\n- **Account Name**: `myapp-signing`\n- **Certificate Profile Name**: `MyAppProfile`\n- **Endpoint URL**: `https://wus2.codesigning.azure.net/`\n(or your region)\n- **Subscription ID**: Found in Azure Portal\n- **Resource Group**: `MyAppSigning`\n\n## Part 2: Local Code Signing\n\nNow let's sign an executable on your my machine. You don't NEED to do this, but I wanted to try it locally to avoid a bunch of CI/CD runs, and I wanted to right-click the EXE and see the cert in Properties before I took it all to the cloud. The nice part about this was that I didn't need to mess with any certificates.\n\n### Step 1: Assign Yourself the Signing Role\n\nYou need permission to actually use the signing service.\n\n**Option A: Azure Portal**\n\n1. Go to your Trusted Signing Account\n2. Click **Access control (IAM)**\n3. Click **Add** → **Add role assignment**\n4. Search for and select **Trusted Signing Certificate Profile Signer.** This is important. I searched for \"code\" and found nothing. Search for \"Trusted\"\n5. Click **Next**\n6. Click **Select members** and find your user account\n7. Click **Select**, then **Review + assign**\n\n**Option B: Azure CLI**\n\n```\n# Get your user object ID\n$userId = az ad signed-in-user show --query id -o tsv\n\n# Assign the role\naz role assignment create \\ --role \"Trusted Signing Certificate Profile Signer\" \\ --assignee-object-id $userId \\ --scope /subscriptions/YOUR_SUBSCRIPTION_ID/resourceGroups/MyAppSigning/providers/Microsoft.CodeSigning/codeSigningAccounts/myapp-signing\n\n```\n\nReplace `YOUR_SUBSCRIPTION_ID` with your actual subscription ID.\n\n### Step 2: Login with the Correct Scope\n\nThis is crucial - you need to login with the specific codesigning scope.\n\n```\n# Logout first to clear old tokens\naz logout\n\n# Login with codesigning scope\naz login --use-device-code --scope \"https://codesigning.azure.net/.default\"\n\n```\n\nThis will give you a code to enter at [https://microsoft.com/devicelogin](https://microsoft.com/devicelogin). Follow the prompts.\n\n**Why device code flow?** Because Azure CLI's default authentication can conflict with Visual Studio credentials in my experience. Device code flow is more reliable for code signing.\n\n### Step 3: Download the Sign Tool\n\n**Option A: Install Globally (Recommended for regular use)**\n\n```\n# Install as a global tool (available everywhere)\ndotnet tool install --global --prerelease sign\n\n# Verify installation\nsign --version\n\n```\n\n**Option B: Install Locally (Project-specific)**\n\n```\n# Install to current directory\ndotnet tool install --tool-path . --prerelease sign\n\n# Use with .\\sign.exe\n\n```\n\n**Which should I use?**\n\n- **Global**: If you'll sign multiple projects or sign frequently\n- **Local**: If you want to keep the tool with a specific project or don't want it in your PATH\n\n### Step 4: Sign Your Executable\n\nNote again that code signing URL is specific to you. The tscp is your Trusted Signing Certificate Profile name and the tsa is your Trusted Signing Account name. I set \\*.exe to sign all the EXEs in the folder and note that the -b base directory is an absolute path, not a relative one. For me it was d:\\github\\WindowsEdgeLight\\publish, and your mileage will vary.\n\n```\n# Navigate to your project folder\ncd C:\\MyProject\n\n# Sign the executable\n.\\sign.exe code trusted-signing ` -b \"C:\\MyProject\\publish\" ` -tse \"https://wus2.codesigning.azure.net\" ` -tscp \"MyAppProfile\" ` -tsa \"myapp-signing\" ` *.exe ` -v Information\n\n```\n\n**Parameters explained:**\n\n- `-b`\n: Base directory containing files to sign\n- `-tse`\n: Trusted Signing endpoint (your region)\n- `-tscp`\n: Certificate profile name\n- `-tsa`\n: Trusted Signing account name\n- `*.exe`\n: Pattern to match files to sign\n- `-v`\n: Verbosity level (Trace, Information, Warning, Error)\n\n**Expected output:**\n\n``` info: Signing WindowsEdgeLight.exe succeeded. Completed in 2743 ms.\n\n```\n\n### Step 5: Verify the Signature\n\nYou can do this in PowerShell:\n\n```\n# Check the signature\nGet-AuthenticodeSignature \".\\publish\\MyApp.exe\" | Format-List\n\n# Look for:\n# Status: Valid\n# SignerCertificate: CN=Your Name, O=Your Name, ...\n# TimeStamperCertificate: Should be present\n\n```\n\n**Right-click the EXE** → **Properties** → **Digital Signatures** tab:\n\n- You should see your signature\n- \"This digital signature is OK\"\n\n### Common Local Signing Issues\n\nI hit all of these lol\n\n**Issue: \"Please run 'az login' to set up account\"**\n\n- **Cause**: Not logged in with the right scope\n- **Fix**: Run `az logout`\nthen `az login --use-device-code --scope \"https://codesigning.azure.net/.default\"`\n\n**Issue: \"403 Forbidden\"**\n\n- **Cause**: Wrong endpoint, account name, or missing permissions\n- **Fix**:\n- Verify endpoint matches your region (wus2, eus, etc.)\n- Verify account name is exact (case-sensitive)\n- Verify you have \"Trusted Signing Certificate Profile Signer\" role\n\n**Issue: \"User account does not exist in tenant\"**\n\n- **Cause**: Azure CLI trying to use Visual Studio credentials\n- **Fix**: Use device code flow (see Step 2)\n\n## Part 3: Automated Signing with GitHub Actions\n\nThis is where the magic happens. I want to automatically sign every release. I'm using GitVersion so I just need to tag a commit and GitHub Actions will kick off a run. You can go look at a real run in detail at [https://github.com/shanselman/WindowsEdgeLight/actions/runs/19775054123](https://github.com/shanselman/WindowsEdgeLight/actions/runs/19775054123)\n\n### Step 1: Create a Service Principal\n\nGitHub Actions needs its own identity to sign code. We'll create a service principal (like a robot account). This is VERY different than your local signing setup.\n\n**Important**: You need **Owner** or **User Access Administrator** role on your subscription to do this. If you don't have it, ask your Azure admin or a friend.\n\n```\n# Create service principal with signing permissions\naz ad sp create-for-rbac \\ --name \"MyAppGitHubActions\" \\ --role \"Trusted Signing Certificate Profile Signer\" \\ --scopes /subscriptions/YOUR_SUBSCRIPTION_ID/resourceGroups/MyAppSigning/providers/Microsoft.CodeSigning/codeSigningAccounts/myapp-signing \\ --json-auth\n\n```\n\nThis outputs JSON like this:\n\n``` { \"clientId\": \"12345678-1234-1234-1234-123456789abc\", \"clientSecret\": \"super-secret-value-abc123\", \"tenantId\": \"87654321-4321-4321-4321-cba987654321\", \"subscriptionId\": \"abcdef12-3456-7890-abcd-ef1234567890\" }\n\n```\n\n**SAVE THESE VALUES IMMEDIATELY!** You can't retrieve the `clientSecret` again. This is super important.\n\n**Alternative: Azure Portal Method**\n\nIf CLI doesn't work:\n\n1. **Azure Portal** → **App registrations** → **New registration**\n2. Name: \"MyAppGitHubActions\"\n3. Click **Register**\n4. **Copy the Application (client) ID** - this is `AZURE_CLIENT_ID`\n5. **Copy the Directory (tenant) ID** - this is `AZURE_TENANT_ID`\n6. Go to **Certificates & secrets** → **New client secret**\n7. Description: \"GitHub Actions\"\n8. Expiration: 24 months (max)\n9. Click **Add** and **immediately copy the Value** - this is `AZURE_CLIENT_SECRET`\n10. Go to your Trusted Signing Account → **Access control (IAM)**\n11. **Add role assignment** → **Trusted Signing Certificate Profile Signer**\n12. **Select members** → Search for \"MyAppGitHubActions\"\n13. **Review + assign**\n\n### Step 2: Add GitHub Secrets\n\nGo to your GitHub repository:\n\n1. **Settings** → **Secrets and variables** → **Actions**\n2. Click **New repository secret** for each:\n\n- `AZURE_CLIENT_ID `\n- From service principal output or App registration\n- `AZURE_CLIENT_SECRET - `\nFrom service principal output or Certificates & secrets\n- `AZURE_TENANT_ID `\n- From service principal output or App registration\n- `AZURE_SUBSCRIPTION_ID `\n- Azure Portal → Subscriptions\n\n**Security Note**: These secrets are encrypted and never visible in logs. Only your workflow can access them. You'll never see them again.\n\n### Step 3: Update Your GitHub Workflow\n\nThis is a little confusing as it's YAML, which is Satan's markup, but it's what we have sunk to as a society.\n\nNote the dotnet-version below. Yours might be 8 or 9, etc. Also, I am building both x64 and ARM versions and I am using GitVersion so if you want a more complete build.yml, you can go here [https://github.com/shanselman/WindowsEdgeLight/blob/master/.github/workflows/build.yml](https://github.com/shanselman/WindowsEdgeLight/blob/master/.github/workflows/build.yml) I am also zipping mine up and prepping my releases so my loose EXE lives in a ZIP file.\n\nAdd signing steps to your `.github/workflows/build.yml` :\n\n``` name: Build and Sign\n\non: push: tags:\n- 'v*'\nworkflow_dispatch:\n\npermissions: contents: write\n\njobs: build: runs-on: windows-latest\n\nsteps:\n- name: Checkout code\nuses: actions/checkout@v4 with: fetch-depth: 0\n\n- name: Setup .NET\nuses: actions/setup-dotnet@v4 with: dotnet-version: '10.0.x'\n\n- name: Restore dependencies\nrun: dotnet restore MyApp/MyApp.csproj\n\n- name: Build\nrun: | dotnet publish MyApp/MyApp.csproj ` -c Release ` -r win-x64 ` --self-contained\n\n# === SIGNING STEPS START HERE ===\n\n- name: Azure Login\nuses: azure/login@v2 with: creds: '{\"clientId\":\"${{ secrets.AZURE_CLIENT_ID }}\",\"clientSecret\":\"${{ secrets.AZURE_CLIENT_SECRET }}\",\"subscriptionId\":\"${{ secrets.AZURE_SUBSCRIPTION_ID }}\",\"tenantId\":\"${{ secrets.AZURE_TENANT_ID }}\"}'\n\n- name: Sign executables with Trusted Signing\nuses: azure/trusted-signing-action@v0 with: azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }} azure-client-id: ${{ secrets.AZURE_CLIENT_ID }} azure-client-secret: ${{ secrets.AZURE_CLIENT_SECRET }} endpoint: https://wus2.codesigning.azure.net/ trusted-signing-account-name: myapp-signing certificate-profile-name: MyAppProfile files-folder: ${{ github.workspace }}\\MyApp\\bin\\Release\\net10.0-windows\\win-x64\\publish files-folder-filter: exe files-folder-recurse: true file-digest: SHA256 timestamp-rfc3161: http://timestamp.acs.microsoft.com timestamp-digest: SHA256\n\n# === SIGNING STEPS END HERE ===\n\n- name: Create Release\nif: startsWith(github.ref, 'refs/tags/') uses: softprops/action-gh-release@v2 with: files: MyApp/bin/Release/net10.0-windows/win-x64/publish/MyApp.exe env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n```\n\n**Key points:**\n\n- `endpoint`\n: Use YOUR region's endpoint (wus2, eus, etc.)\n- `trusted-signing-account-name`\n: Your account name (exact, case-sensitive)\n- `certificate-profile-name`\n: Your certificate profile name (exact, case-sensitive)\n- `files-folder`\n: Path to your compiled executables\n- `files-folder-filter`\n: File types to sign (exe, dll, etc.)\n- `files-folder-recurse`\n: Sign files in subfolders\n\n### Step 4: Test the Workflow\n\nNow trigger the workflow. You have two options:\n\n**Option A: Manual Trigger (Safest for testing)**\n\nSince the workflow includes `workflow_dispatch:` , you can trigger it manually without creating a tag:\n\n```\n# Trigger manually via GitHub CLI\ngh workflow run build.yml\n\n# Or go to GitHub web UI:\n# Actions tab → \"Build and Sign\" workflow → \"Run workflow\" button\n\n```\n\nThis is ideal for testing because:\n\n- No tag required\n- Won't create a release\n- Can test multiple times\n- Easy to debug issues\n\n**Option B: Create a Tag (For actual releases)**\n\n```\n# Make sure you're on your main branch with no uncommitted changes\ngit status\n\n# Create and push a tag\ngit tag v1.0.0 git push origin v1.0.0\n\n```\n\nUse this when you're ready to create an actual release with signed binaries. This is what I am doing on my side.\n\n### Step 5: Monitor the Build\n\nWatch the progress with GitHub CLI:\n\n```\n# See latest runs\ngh run list --limit 5\n\n# Watch a specific run\ngh run watch\n\n# View detailed status\ngh run view --log\n\n```\n\nOr visit: `https://github.com/YOUR_USERNAME/YOUR_REPO/actions`\n\n**Look for:**\n\n- Azure Login - Should complete in ~5 seconds\n- Sign executables with Trusted Signing - Should complete in ~10-30 seconds\n- Create Release - Your signed executable is now available in /releases in your GitHib project\n\n### Common GitHub Actions Issues\n\nI hit a few of these, natch.\n\n**Issue: \"403 Forbidden\" during signing**\n\n- **Cause**: Service principal doesn't have permissions\n- **Fix**:\n1. Go to Azure Portal → Trusted Signing Account → Access control (IAM)\n2. Verify \"MyAppGitHubActions\" has \"Trusted Signing Certificate Profile Signer\" role\n3. If not, add it manually\n\n**Issue: \"No files matched the pattern\"**\n\n- **Cause**: Wrong `files-folder`\npath or build artifacts in wrong location\n- **Fix**:\n1. Add a debug step before signing: `- run: Get-ChildItem -Recurse`\n2. Find where your EXE is actually located\n3. Update `files-folder`\nto match\n\n**Issue: Secrets not working**\n\n- **Cause**: Typo in secret name or value not saved\n- **Fix**:\n1. Verify secret names EXACTLY match (case-sensitive)\n2. Re-create secrets if unsure\n3. Make sure no extra spaces in values\n\n**Issue: \"DefaultAzureCredential authentication failed\"**\n\n- **Cause**: Usually wrong tenant ID or client ID\n- **Fix**: Verify all 4 secrets are correct from service principal output\n\n## Part 4: Understanding the Certificate\n\n### Certificate Lifecycle\n\nAzure Trusted Signing uses **short-lived certificates** (typically 3 days). This freaked me out but they say this is actually a security feature:\n\n- If a certificate is compromised, it expires quickly\n- You never manage certificate files or passwords\n- Automatic renewal - you don't have to do anything\n\n**But won't my signature break after 3 days?**\n\nNo, it seems that's what **timestamping** is for. When you sign a file:\n\n1. Azure issues a 3-day certificate\n2. The file is signed with that certificate\n3. A timestamp server records \"this file was signed on DATE\"\n4. Even after the certificate expires, the signature remains valid because the timestamp proves it was signed when the certificate was valid\n\nThat's why both local and GitHub Actions signing include:\n\n``` timestamp-rfc3161: http://timestamp.acs.microsoft.com\n\n```\n\n### What the Certificate Contains\n\nYour signed executable has a certificate with:\n\n- **Subject**: Your name (e.g., \"CN=John Doe, O=John Doe, L=Seattle, S=Washington, C=US\")\n- **Issuer**: Microsoft ID Verified CS EOC CA 01\n- **Valid Dates**: 3-day window\n- **Key Size**: 3072-bit RSA (very secure)\n- **Enhanced Key Usage**: Code Signing\n\n### Verify Certificate on Any Machine\n\n```\n# Using PowerShell\nGet-AuthenticodeSignature \"MyApp.exe\" | Select-Object -ExpandProperty SignerCertificate | Format-List\n\n# Using Windows UI\n# Right-click EXE → Properties → Digital Signatures tab → Details → View Certificate\n\n```\n\nThis whole thing took me about an hour to 75 minutes. It was detailed, but not deeply difficult. Misspellings, case-sensitivity, and a few account issues with Role-Based Access Control did slow me down. Hope this helps!\n\n### Used Resources\n\n- [Azure Trusted Signing Documentation](https://learn.microsoft.com/en-us/azure/trusted-signing/)\n- [dotnet/sign Tool](https://github.com/dotnet/sign)\n- [azure/trusted-signing-action](https://github.com/Azure/trusted-signing-action)\n- [Windows Code Signing Best Practices](https://learn.microsoft.com/en-us/windows/win32/seccrypto/cryptography-tools)\n- [SmartScreen Reputation System](https://learn.microsoft.com/en-us/windows/security/threat-protection/microsoft-defender-smartscreen/microsoft-defender-smartscreen-overview)\n\n*Written in November 2025 based on real-world implementation for WindowsEdgeLight. Your setup might vary slightly depending on Azure region and account type. Things change, be stoic.*\n\n#### About Scott\n\nScott Hanselman is a former professor, former Chief Architect in finance, now speaker, consultant, father, diabetic, and Microsoft employee. He is a failed stand-up comic, a cornrower, and a book author.\n\n[![facebook](//images.hanselman.com/main/icon-fb.png)](https://facebook.com/shanselman) [![bluesky](//images.hanselman.com/main/icon-bluesky.png)](https://bsky.app/profile/scott.hanselman.com) [![subscribe](//images.hanselman.com/main/icon-rss.png)](http://feeds.hanselman.com/ScottHanselman)\n\n[About](http://hanselman.com/about)   [Newsletter](http://www.hanselman.com/newsletter)\n\n**Hosting By**\n\n[![Hosted on Linux using .NET in an Azure App Service](//images.hanselman.com/main/azure-250x250.png)](https://azure.microsoft.com/free)\n\n[Comment on this post \\[1\\]](https://www.hanselman.com/blog/automatically-signing-a-windows-exe-with-azure-trusted-signing-dotnet-sign-and-github-actions/comments#comments-start)\n\nShare on [BlueSky](https://bsky.app/intent/compose?text=https://www.hanselman.com/blog/automatically-signing-a-windows-exe-with-azure-trusted-signing-dotnet-sign-and-github-actions) or use the [Permalink](automatically-signing-a-windows-exe-with-azure-trusted-signing-dotnet-sign-and-github-actions) and post anywhere!\n\nNovember 29, 2025 3:40\n\nCool stuff. Note, Macs don't have OLED but rather MBPs have MiniLED screens with local dimming that get wicked bright (&gt;1000 nits) that makes this approach so effective.\n\n![](//www.gravatar.com/avatar/538d845ead710ee91dfa89724b90b2e2?rating=PG&size=80&default=identicon)\n\nDamian\n\n| <ul><li></li><br><br></ul> | | --- | | Name | | | Email | (will show your [gravatar](http://www.gravatar.com) icon) | | Home page (optional) | | | 5+1=? | | | | | Comment (Some html is allowed: `a@href@title, b, blockquote@cite, em, i, li, ol, pre, strike, strong, sub, super, u, ul`<br>) where the @ means \"attribute.\" For example, you can use &lt;a href=\"\" title=\"\"&gt; or &lt;blockquote cite=\"Scott\"&gt;. | | | | Live Comment Preview | | | | |\n\nDisclaimer: The opinions expressed herein are my own personal opinions and do not represent my employer's view in any way.",
  "PubDate": "2025-11-28T19:31:25+00:00",
  "Tags": [
    "Azure",
    "DotNetCore"
  ],
  "FeedName": "Scott Hanselman's Blog",
  "FeedUrl": "https://www.hanselman.com/blog/SyndicationService.asmx/GetRss"
}
