{
  "OutputDir": "_blogs",
  "PubDate": "2026-01-12T00:00:00+00:00",
  "Description": "> >\n> **This is Part 2 of a 5-part series on mastering AI-assisted development.** Last week, we explored why vibe coding fails and what spec-driven development offers. This week, weâ€™re getting hands-on with the actual workflow.\n> >\n\n## Series overview\n\n1. [**Part 1**](/from-vibe-coding-to-spec-driven-development): The problem and the solution\n2. **Part 2 (This post)**: Deep dive into the Spec-Kit workflow\n3. **Part 3 (Jan 19)**: Best practices and troubleshooting\n4. **Part 4 (Jan 26)**: Team collaboration and advanced patterns\n5. **Part 5 (Feb 2)**: Case studies and lessons learned\n\n## What weâ€™re building today\n\nTo demonstrate the Spec-Kit workflow, weâ€™ll build a real application: a **Team Task Manager**. Not a hello-world todo list, but something with actual complexity:\n\n- Multi-user authentication\n- Team workspaces\n- Task assignment and tracking\n- Real-time updates\n- Responsive design\n\nBy the end of this post, youâ€™ll have walked through every step of the Spec-Kit workflow with concrete examples you can adapt to your own projects.\n\n## Prerequisites\n\nBefore we start, make sure you have:\n\n```\n# Install Spec-Kit CLI\nuv tool install specify-cli --from git+https://github.com/github/spec-kit.git\n\n# Verify installation\nspecify --version\n\n# Install an AI coding assistant (one of these)\n# - GitHub Copilot\n# - Claude Desktop\n# - Cursor\n# - Windsurf\n\n```\n\n**Note**: The examples in this post use GitHub Copilot, but the workflow is identical for all supported AI agents.\n\n## The complete workflow\n\nHereâ€™s the accountability chain weâ€™ll follow:\n\n``` Constitution â†’ Specification â†’ Plan â†’ Tasks â†’ Implementation\n\n```\n\nEach step builds on the previous one. Each step produces artifacts that guide the next. Letâ€™s dive in.\n\n## Step 1: Initialize your project\n\nFirst, create your project directory:\n\n``` specify init team-task-manager cd team-task-manager\n\n```\n\nThis creates the basic structure with organized folders for agents, prompts, and specification artifacts:\n\n``` team-task-manager/ â”œâ”€â”€ .github/ â”œâ”€â”€ agents/ â”œâ”€â”€ prompts/ â””â”€â”€ .specify/ â”œâ”€â”€ memory/ â”œâ”€â”€ scripts/ â”œâ”€â”€ templates/ â””â”€â”€ .vscode/\n\n```\n\n![Spec-Kit project structure](/images/spec-kit/workflow-01-init.png) *The initialized project structure shown in VS Code*\n\n## Step 2: Create your constitution\n\nThe constitution is your projectâ€™s foundation - the non-negotiable principles that guide all decisions.\n\n**Important**: When you ran `specify init` , it created a **template** at `.specify/constitution.md` with TODOs and placeholder sections. You need to fill this in with your actual project requirements before proceeding.\n\nHereâ€™s what the empty template looks like:\n\n```\n# TODO(PROJECT_NAME) Constitution\n\n## Core Principles\n\n### TODO(PRINCIPLE_1_NAME)\nTODO(PRINCIPLE_1_DESCRIPTION): Define first core principle...\n\n### TODO(PRINCIPLE_2_NAME)\nTODO(PRINCIPLE_2_DESCRIPTION): Define second core principle...\n\n## Governance\n\nTODO(GOVERNANCE_RULES): Define how this constitution is amended...\n\n```\n\n### What goes in a constitution?\n\nReplace the TODOs with real content:\n\n1. **Project purpose**: What problem are you solving?\n2. **Core principles**: What values guide technical decisions?\n3. **Technical constraints**: What technologies, frameworks, or patterns must you use?\n4. **Quality standards**: What does â€œdoneâ€ look like?\n5. **Non-goals**: What are you explicitly not building?\n\n### Real example: Our Team Task Manager constitution\n\n```\n# Team Task Manager Constitution\n\n## Project Purpose\n\nBuild a collaborative task management system for small teams (5-20 people) to organize work, assign tasks, and track progress in real-time.\n\n## Core Principles\n\n### I. Simplicity First\nStart with the minimum viable feature set. Complexity must be justified against simpler alternatives. The constitution's Complexity Tracking mechanism MUST be used to document any deviation from this principle.\n\n**Rationale**: Small teams need tools they can understand and maintain. Over-engineering leads to technical debt and slower iteration.\n\n### II. User Experience Over Features\nA polished core beats a bloated mess. Every feature must demonstrably improve the user experience. Feature requests that compromise UX quality are rejected.\n\n**Rationale**: Users value reliable, intuitive tools over feature-rich but confusing interfaces.\n\n### III. Security By Design\nAuthentication and authorization at every layer. Security is non-negotiable and cannot be retrofitted.\n\n**Rationale**: Task management involves sensitive business information. A single breach destroys trust.\n\n### IV. Performance Matters\nSub-second response times for all interactions. Performance targets are requirements, not aspirations.\n\n**Rationale**: Slow tools disrupt workflow. Performance directly impacts user adoption and satisfaction.\n\n### V. Mobile-Friendly\nResponsive design, not separate mobile apps. The web interface must work seamlessly on all device sizes.\n\n**Rationale**: Team members work from various devices. Maintaining separate mobile apps increases complexity and violates Principle I.\n\n## Technical Constraints\n\n### Must Use\n- **Backend**: .NET 9 with C#\n- **Frontend**: Blazor Server (keep it simple, no separate SPA)\n- **Database**: SQL Server or PostgreSQL\n- **Authentication**: ASP.NET Core Identity\n- **Deployment**: Containerized (Docker)\n\n### Must Avoid\n- No complex microservices (keep it monolithic for now)\n- No separate frontend frameworks (React, Angular, Vue, etc.)\n- No over-engineered authentication flows (stick to ASP.NET Core Identity)\n\n**Rationale**: These constraints enforce Principle I (Simplicity First) by limiting architectural complexity and preventing technology sprawl.\n\n## Quality Standards\n\n### Code Quality\n- C# nullable reference types MUST be enabled project-wide\n- Roslyn analyzers MUST be enabled (minimum: StyleCop.Analyzers)\n- EditorConfig MUST be configured for consistent formatting\n- All public methods MUST be documented with XML comments\n\n### Testing\n- Unit tests for business logic (80%+ coverage REQUIRED)\n- Integration tests for all API endpoints\n- End-to-end tests for critical user flows (defined as: create team, create task, assign task, complete task)\n\n**Enforcement**: Pull requests failing coverage or missing critical path tests will be rejected.\n\n### Performance\n- Page load time - API response time - Database queries MUST be optimized (execution plans reviewed during code review)\n\n**Enforcement**: Features that regress performance targets will be rolled back.\n\n### Security\n- OWASP Top 10 MUST be addressed for all user-facing features\n- Dependencies MUST be scanned weekly (automated via CI/CD)\n- SQL injection prevention: parameterized queries ONLY (raw SQL prohibited)\n- XSS protection: all user input MUST be sanitized\n\n**Enforcement**: Security violations block deployment.\n\n## Non-Goals (What We're NOT Building)\n\nExplicitly out of scope to prevent feature creep:\n\n- âŒ Project management (Gantt charts, resource allocation, burndown charts)\n- âŒ Time tracking or invoicing\n- âŒ Complex workflows or automation (no custom workflow engines)\n- âŒ Native mobile apps (web-first per Principle V)\n- âŒ Real-time video/chat (out of scope for task management)\n\n**Rationale**: These features violate Principle I (Simplicity First) and expand scope beyond small team task management. Feature requests in these categories should be politely declined.\n\n## Success Criteria\n\n### MVP (Version 1.0)\n- Users can create teams\n- Users can create, assign, and complete tasks\n- Users can see team activity in real-time\n- Application is secure (authentication required, OWASP Top 10 addressed)\n- Application is fast (performance targets met)\n\n### Future Enhancements (Post-MVP)\nConsidered only after MVP is stable and validated with users:\n- Task comments and attachments\n- Task dependencies and blocking relationships\n- Email notifications\n- Calendar integration (read-only)\n\n## Governance\n\n### Amendment Process\n1. Amendments proposed via pull request to this file\n2. Proposed changes must include:\n- Rationale for the change\n- Impact assessment on existing features/plans\n- Migration plan if breaking change\n3. Approval requires: project maintainer sign-off\n4. Constitution takes precedence over all other documents\n\n### Versioning Policy\nSemantic versioning (MAJOR.MINOR.PATCH):\n- **MAJOR**: Backward incompatible changes (principle removal, constraint changes that invalidate existing code)\n- **MINOR**: New principle or section added, material expansion of guidance\n- **PATCH**: Clarifications, wording improvements, non-semantic refinements\n\n### Compliance Review\n- All feature specifications MUST reference this constitution\n- All implementation plans MUST include \"Constitution Check\" section\n- Code reviews MUST verify adherence to quality standards and technical constraints\n- Violations MUST be documented in plan.md Complexity Tracking section\n\n### Review Cadence\nConstitution reviewed quarterly or when significant architectural decisions arise.\n\n**Version**: 1.0.0 | **Ratified**: 2026-01-12 | **Last Amended**: 2026-01-12\n\n```\n\n### Why this works\n\nNotice what weâ€™ve done:\n\n1. **Clear purpose**: Everyone knows what weâ€™re building and why\n2. **Explicit constraints**: The AI wonâ€™t suggest GraphQL or microservices\n3. **Measurable standards**: â€œFastâ€ means\n4. **Explicit non-goals**: Weâ€™re not building Jira\n\nThis constitution will be referenced in every subsequent step. When the AI suggests adding time tracking, we can point back to the constitutionâ€™s non-goals.\n\n### Running the constitution command\n\nIn your AI coding assistant, run:\n\n``` /speckit.constitution\n\n```\n\n![Running the constitution command](/images/spec-kit/workflow-02-constitution-command.png) *Typing the /speckit.constitution command in GitHub Copilot Chat*\n\nThe AI will:\n\n1. Read the constitution\n2. Validate itâ€™s complete\n3. Confirm it understands the constraints\n\n![Constitution validated](/images/spec-kit/workflow-03-constitution-response.png) *The AI confirms it has read and understood the constitution*\n\n## Step 3: Write the specification\n\nNow we define **what** weâ€™re building in detail. The spec focuses on user stories, acceptance criteria, and behavior - not implementation.\n\n### The specification structure\n\nA good spec includes:\n\n1. **User stories**: Who does what and why\n2. **Acceptance criteria**: What does â€œdoneâ€ mean?\n3. **User interface mockups**: Visual guides (can be sketches)\n4. **Data requirements**: What information flows through the system?\n5. **Edge cases**: What happens when things go wrong?\n\n### Real example: Team Task Manager spec\n\nCreate `.speckit/spec.md` :\n\n```\n# Team Task Manager Specification\n\n## Overview\n\nA collaborative task management application for small teams to organize work, assign tasks, and track progress.\n\n---\n\n## User Stories\n\n### Authentication\n\n**As a new user**, I want to:\n- Sign up with my email or Google account\n- Receive a confirmation email\n- Log in securely\n- Reset my password if forgotten\n\n**Acceptance Criteria:**\n- Sign-up takes - Email confirmation sent within 1 minute\n- Password reset link expires in 24 hours\n- Failed login attempts rate-limited after 5 attempts\n\n---\n\n### Team Management\n\n**As a team admin**, I want to:\n- Create a new team with a unique name\n- Invite members via email\n- Remove members from the team\n- Transfer ownership to another member\n\n**Acceptance Criteria:**\n- Team names must be unique\n- Email invitations expire in 7 days\n- Removed members lose access immediately\n- Ownership transfer requires confirmation\n\n---\n\n### Task Management\n\n**As a team member**, I want to:\n- Create tasks with title, description, and due date\n- Assign tasks to myself or team members\n- Mark tasks as complete\n- Edit or delete tasks I created\n- Filter tasks by assignee or status\n\n**Acceptance Criteria:**\n- Task creation takes - Tasks appear in real-time for all team members\n- Completed tasks marked with timestamp\n- Only task creator or assignee can edit/delete\n- Filters apply instantly (no page reload)\n\n---\n\n## User Interface Requirements\n\n### Dashboard View\n- Navigation bar with logo, user menu\n- Tab navigation: My Tasks, Team Tasks, Completed\n- Filter dropdown: All, Assigned to me, Created by me\n- Task cards showing: title, description preview, assignee, due date\n- Checkbox to mark tasks complete\n- \"New Task\" button\n\n### Task Detail View\n- Back navigation to dashboard\n- Task title (editable)\n- Creator and creation date\n- Assignee dropdown (team members)\n- Due date picker\n- Status dropdown (Open, In Progress, Completed)\n- Description text area\n- Delete and Save buttons\n\n### Responsive Behavior\n- **Desktop (> 1024px)**: Side-by-side task list and detail\n- **Tablet (768-1024px)**: Stacked layout with full-width cards\n- **Mobile (: Single-column, touch-optimized buttons\n\n---\n\n## Data Requirements\n\n### Users\n- Unique identifier (UUID)\n- Email (unique, validated)\n- Display name\n- Avatar URL (optional)\n- Created timestamp\n- Last login timestamp\n\n### Teams\n- Unique identifier (UUID)\n- Team name (unique)\n- Owner (user reference)\n- Created timestamp\n- Member count\n\n### Team Memberships\n- Team reference\n- User reference\n- Role (admin, member)\n- Joined timestamp\n\n### Tasks\n- Unique identifier (UUID)\n- Title (required, max 200 chars)\n- Description (optional, max 5000 chars)\n- Status (open, in_progress, completed)\n- Created by (user reference)\n- Assigned to (user reference, optional)\n- Team reference\n- Due date (optional)\n- Created timestamp\n- Updated timestamp\n- Completed timestamp (nullable)\n\n---\n\n## Edge Cases & Error Handling\n\n### Authentication\n- **Scenario**: User tries to access app without logging in\n- **Expected**: Redirect to login page, preserve intended destination\n\n- **Scenario**: Session expires while user is working\n- **Expected**: Show modal \"Session expired, please log in again\"\n\n### Task Management\n- **Scenario**: Two users edit the same task simultaneously\n- **Expected**: Last write wins, show conflict notification\n\n- **Scenario**: User tries to delete a task they didn't create\n- **Expected**: Show error \"Only task creator can delete\"\n\n### Real-time updates\n- **Scenario**: Network connection drops\n- **Expected**: Show \"Offline\" indicator, queue updates, sync when reconnected\n\n- **Scenario**: User has 1000+ completed tasks\n- **Expected**: Paginate results, load 50 at a time\n\n### Team Management\n- **Scenario**: Last admin leaves the team\n- **Expected**: Promote oldest member to admin automatically\n\n- **Scenario**: User invited to team they're already in\n- **Expected**: Show message \"You're already a member\"\n\n---\n\n## Performance Requirements\n\n### Page Load\n- Initial load: - Subsequent navigation: ### API Response Times (95th percentile)\n- GET requests: - POST/PUT requests: - Real-time updates: ### Concurrent Users\n- Support 100 concurrent users per team\n- Support 1000 teams total (MVP target)\n\n---\n\n## Security Requirements\n\n### Authentication\n- Passwords hashed with bcrypt (cost factor 12)\n- OAuth tokens stored securely (httpOnly cookies)\n- MFA support (optional for MVP)\n\n### Authorization\n- Role-based access control (RBAC)\n- Users can only access teams they belong to\n- Task operations checked against user permissions\n\n### Data Protection\n- All API requests over HTTPS\n- SQL injection prevention (parameterized queries)\n- XSS prevention (sanitize user input)\n- CSRF tokens on all state-changing requests\n\n### Auditing\n- Log all authentication attempts\n- Log all task CRUD operations\n- Log all team membership changes\n\n---\n\n## Success Metrics\n\n### User Engagement\n- Daily active users per team: > 60%\n- Tasks created per user per week: > 5\n- Task completion rate: > 70%\n\n### System Health\n- Uptime: > 99.5%\n- Error rate: - Response time (p95): ### User Satisfaction\n- NPS score: > 40\n- Support tickets per user:\n```\n\n### Why this spec works\n\nThis specification gives the AI everything it needs:\n\n1. **Detailed user stories**: Exact behavior expected\n2. **Visual mockups**: Clear UI direction (even ASCII art helps!)\n3. **Edge cases**: Real-world scenarios covered\n4. **Measurable criteria**: â€œFastâ€ is defined numerically\n\n### Running the specify command\n\nIn your AI coding assistant:\n\n``` /speckit.specify\n\n```\n\nThe AI will:\n\n1. Read the constitution and spec\n2. Ask clarifying questions\n3. Validate specification completeness and quality\n4. Confirm understanding before proceeding\n\n### Specification Quality Validation\n\nThe `specify` command validates your specification against quality criteria:\n\n```\n# Specification Quality Checklist: Team Task Manager\n\n## Content Quality\nâœ… Written for non-technical stakeholders âœ… Focused on user value and business needs âœ… No implementation details (languages, frameworks, APIs)\n\n## Requirement Completeness\nâœ… No NEEDS CLARIFICATION markers remain âœ… Success criteria are technology-agnostic âœ… All acceptance scenarios are defined âœ… Use cases are identified\n\n## Feature Readiness\nâœ… All functional requirements have clear acceptance criteria âœ… User scenarios cover primary flows âœ… Feature meets measurable outcomes âœ… No implementation details leak into specification\n\n## Edge Cases\nâœ… Nine edge case scenarios documented covering:\n- Concurrent editing conflicts\n- Network issues and offline scenarios\n- Data volume and pagination\n- Team management edge cases\n- Authorization failures\n\n## Validation Summary\nStatus: âœ… PASSED - All quality criteria met\n\nThis specification is ready for /speckit.plan\n\n```\n\n![Specification validated](/images/spec-kit/workflow-04a-specify-validation.png) *The specification quality checklist confirms all criteria are met*\n\n**Why this matters**: The validation catches common spec issues before you invest time in planning:\n\n- Missing acceptance criteria\n- Vague requirements that canâ€™t be tested\n- Implementation details leaking into the spec\n- Edge cases not considered\n\n## Step 4: Generate the technical plan\n\nNow the AI takes our spec and creates a technical plan. This is where we decide **how** to build it.\n\n### Running the plan command\n\n``` /speckit.plan\n\n```\n\n![Running the plan command](/images/spec-kit/workflow-06-plan-command.png) *The AI analyzes the spec and generates the technical plan*\n\nThe AI will generate several artifacts in the `/specs/001-team-task-manager/` directory:\n\n1. `requirements.md`\n- Detailed functional requirements and acceptance criteria\n2. `checklist.md`\n- Quality validation checklist\n3. `plan.md`\n- Overall technical architecture\n4. `data-model.md`\n- Database schema design\n5. `contracts.md`\n- API contracts and endpoint specifications\n\n![Generated plan files](/images/spec-kit/workflow-07-plan-files.png) *All generated planning artifacts shown in the VS Code file explorer*\n\nThe requirements.md contains the complete breakdown of functional requirements with Given-When-Then scenarios, while the checklist validates specification quality. The contracts.md defines all API endpoints, request/response schemas, and integration points before moving forward with implementation.\n\n### Real example: Generated plan.md\n\nThe AI produces something like this:\n\n```\n# Technical Plan: Team Task Manager\n\n## Technology Stack\n\n### Backend\n- **Framework**: .NET 9\n- **Language**: C# 13\n- **Authentication**: ASP.NET Core Identity\n- **Database ORM**: Entity Framework Core 9\n- **Validation**: FluentValidation\n- **Testing**: xUnit + Moq\n\n### Frontend\n- **Framework**: Blazor Server\n- **UI Components**: Bootstrap 5 or MudBlazor\n\n### Database\n- **Primary**: SQL Server 2022 or PostgreSQL 16+\n- **Schema Migrations**: EF Core Migrations\n- **Connection Pooling**: Built-in connection pooling\n\n### Infrastructure\n- **Containerization**: Docker + Docker Compose\n- **Web Server**: Kestrel (built-in)\n- **Environment Config**: appsettings.json + User Secrets\n\n---\n\n## Architecture Overview\n\nThe application follows a traditional three-tier architecture:\n\n**Presentation Layer**\n- Blazor Server (server-side rendering)\n- Standard HTTP requests\n\n**Application Layer**\n- .NET 9 Web Application\n- ASP.NET Core Identity for authentication\n- API Controllers for REST endpoints\n\n**Data Layer**\n- Entity Framework Core 9\n- SQL Server or PostgreSQL database\n\n---\n\n## Database Schema\n\nSee `data-model.md` for complete Entity Framework model.\n\n### Key Entities\n- `User` - User accounts (ASP.NET Identity)\n- `Team` - Team workspaces\n- `TeamMember` - Many-to-many relationship\n- `Task` - Task data\n\n### Indexes\n- `User.Email` (unique)\n- `Team.Name` (unique)\n- `Task.TeamId` (for filtering)\n- `Task.AssignedToId` (for user task views)\n- `Task.Status` (for status filters)\n\n---\n\n## API Design\n\n### RESTful Endpoints\n\n#### Authentication\n- Built-in ASP.NET Core Identity pages\n- `/Account/Register` - Create new user\n- `/Account/Login` - Login existing user\n- `/Account/Logout` - Logout user\n\n#### Teams\n- `GET /api/teams` - List user's teams\n- `POST /api/teams` - Create new team\n- `GET /api/teams/{id}` - Get team details\n- `PUT /api/teams/{id}` - Update team\n- `DELETE /api/teams/{id}` - Delete team\n- `POST /api/teams/{id}/invite` - Invite member\n- `DELETE /api/teams/{id}/members/{userId}` - Remove member\n\n#### Tasks\n- `GET /api/teams/{teamId}/tasks` - List team tasks\n- `POST /api/teams/{teamId}/tasks` - Create task\n- `GET /api/tasks/{id}` - Get task details\n- `PUT /api/tasks/{id}` - Update task\n- `DELETE /api/tasks/{id}` - Delete task\n\n---\n\n## Security Implementation\n\n### Authentication Flow\n1. User submits credentials\n2. ASP.NET Core Identity validates\n3. Authentication cookie created\n4. Authorization policies check on each request\n\n### Authorization Policy\n```csharp // Verify user belongs to team public class TeamMemberRequirement : IAuthorizationRequirement { public string TeamIdClaimType { get; set; } = \"TeamId\"; }\n\npublic class TeamMemberHandler : AuthorizationHandlerTeamMemberRequirement> { private readonly AppDbContext _context;\n\npublic TeamMemberHandler(AppDbContext context) { _context = context; }\n\nprotected override async Task HandleRequirementAsync( AuthorizationHandlerContext context, TeamMemberRequirement requirement) { var userId = context.User.FindFirstValue(ClaimTypes.NameIdentifier); var teamId = context.User.FindFirstValue(requirement.TeamIdClaimType);\n\nif (userId == null || teamId == null) { return; }\n\nvar isMember = await _context.TeamMembers .AnyAsync(tm => tm.UserId == userId && tm.TeamId == teamId);\n\nif (isMember) { context.Succeed(requirement); } } }\n\n```\n\n## Testing Strategy\n\n### Unit Tests\n\n- Business logic functions\n- Utility helpers\n- React hooks\n\n### Integration Tests\n\n- API endpoints\n- Database operations\n- WebSocket events\n\n### E2E Tests\n\n- User registration flow\n- Task creation and completion\n- Team invitation flow\n\n### Test Coverage Targets\n\n- Business logic: 90%+\n- API routes: 80%+\n- UI components: 70%+\n\n## Deployment Plan\n\n### Development\n\n``` docker-compose up\n\n```\n\n### Production Considerations\n\n- Environment variables via secrets\n- Database connection pooling\n- Rate limiting on auth endpoints\n- CORS configured for production domain\n- Logging to stdout (12-factor app)\n\n## Open Questions\n\n1. **Email service**: Use SendGrid, AWS SES, or Mailgun?\n2. **File storage**: Do we need task attachments? (Not in spec)\n3. **Monitoring**: Application Insights, Datadog, or self-hosted?\n\n*These should be resolved before implementation.*\n\n```\n\n### Generated data-model.md\n\n```markdown\n# Data Model: Team Task Manager\n\n## Entity Framework Core Models\n\n```csharp // Models/User.cs public class User : IdentityUser { public string DisplayName { get; set; } = string.Empty; public string? AvatarUrl { get; set; } public DateTime CreatedAt { get; set; } = DateTime.UtcNow; public DateTime? LastLoginAt { get; set; }\n\n// Navigation properties public ICollection TeamMemberships { get; set; } = new List(); public ICollection CreatedTasks { get; set; } = new List(); public ICollection AssignedTasks { get; set; } = new List(); public ICollection OwnedTeams { get; set; } = new List(); }\n\n// Models/Team.cs public class Team { public string Id { get; set; } = Guid.NewGuid().ToString(); public string Name { get; set; } = string.Empty; public string OwnerId { get; set; } = string.Empty; public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n// Navigation properties public User Owner { get; set; } = null!; public ICollection Members { get; set; } = new List(); public ICollection Tasks { get; set; } = new List(); }\n\n// Models/TeamMember.cs public class TeamMember { public string Id { get; set; } = Guid.NewGuid().ToString(); public string TeamId { get; set; } = string.Empty; public string UserId { get; set; } = string.Empty; public Role Role { get; set; } = Role.Member; public DateTime JoinedAt { get; set; } = DateTime.UtcNow;\n\n// Navigation properties public Team Team { get; set; } = null!; public User User { get; set; } = null!; }\n\n// Models/Task.cs public class Task { public string Id { get; set; } = Guid.NewGuid().ToString(); public string Title { get; set; } = string.Empty; public string? Description { get; set; } public TaskStatus Status { get; set; } = TaskStatus.Open; public string TeamId { get; set; } = string.Empty; public string CreatedById { get; set; } = string.Empty; public string? AssignedToId { get; set; } public DateTime? DueDate { get; set; } public DateTime CreatedAt { get; set; } = DateTime.UtcNow; public DateTime UpdatedAt { get; set; } = DateTime.UtcNow; public DateTime? CompletedAt { get; set; }\n\n// Navigation properties public Team Team { get; set; } = null!; public User CreatedBy { get; set; } = null!; public User? AssignedTo { get; set; } }\n\n// Enums public enum Role { Admin, Member }\n\npublic enum TaskStatus { Open, InProgress, Completed }\n\n```\n\n## Relationships\n\n**User to Team** (Many-to-Many via TeamMember)\n\n- A user can belong to multiple teams\n- A team can have multiple users\n\n**Team to Task** (One-to-Many)\n\n- A team has many tasks\n- Each task belongs to one team\n\n**User to Task** (Multiple relationships)\n\n- A user creates many tasks (CreatedBy)\n- A user can be assigned many tasks (AssignedTo)\n- Each task has one creator and optionally one assignee\n\n## Indexes\n\n### Performance-critical\n\n- `tasks.teamId`\n- Filtering tasks by team\n- `tasks.assignedToId`\n- User task views\n- `tasks.status`\n- Status filtering\n\n### Uniqueness constraints\n\n- `users.email`\n- One account per email\n- `teams.name`\n- Unique team names\n- `team_members.[teamId, userId]`\n- No duplicate memberships\n\n## Migration strategy\n\n```\n# Create initial migration\ndotnet ef migrations add InitialCreate\n\n# Apply to database\ndotnet ef database update\n\n# Seed demo data\ndotnet run --seed\n\n```\n\n**Production**: Always backup before applying migrations\n\n```\n\n### Why these generated plans work\n\nThe AI has:\n\n1. **Made concrete technology choices**: React, Express, PostgreSQL (aligned with constitution)\n2. **Designed the data model**: Prisma schema with relationships\n3. **Specified API contracts**: Every endpoint documented\n4. **Included security patterns**: Middleware examples\n5. **Identified open questions**: Decisions that need human input\n\n**This is where you review carefully.** Does the tech stack make sense? Are there better options? Now's the time to adjust.\n\n---\n\n## Step 5: Break down into tasks\n\nNow we convert the plan into implementable tasks.\n\n### Running the tasks command\n\n```\n\n/speckit.tasks\n\n```\n\nThe AI generates `tasks.md` with **137 ordered, actionable tasks** organized by user story.\n\nHere's how the AI structures the implementation:\n\n```markdown\n# Tasks: Team Task Manager\n\n**Organization**: Tasks are grouped by user story to enable independent implementation and testing of each story.\n\n## Format: `- [ ] [ID] [P?] [Story?] Description`\n\n- **[P]**: Can run in parallel (different files, no dependencies)\n- **[Story]**: Which user story this task belongs to (e.g., US1, US2)\n\n---\n\n## Phase 1: Setup (Shared Infrastructure)\n\n**Purpose**: Project initialization and basic structure\n\n- [ ] T001 Create .NET 9 solution with TeamTaskManager project and test project\n- [ ] T002 Configure project settings: enable nullable reference types\n- [ ] T003 [P] Add NuGet packages: EF Core, Npgsql, Identity\n- [ ] T004 [P] Create EditorConfig with StyleCop.Analyzers configuration\n- [ ] T005 [P] Create docker-compose.yml with PostgreSQL service\n- [ ] T006 [P] Create Dockerfile with multi-stage build\n- [ ] T007 Create directory structure: Components, Models, Data, Services, Auth\n- [ ] T008 Create appsettings.json with connection string placeholders\n- [ ] T009 Create .gitignore excluding appsettings.Development.json\n\n---\n\n## Phase 2: Foundational (Blocking Prerequisites)\n\n**Purpose**: Core infrastructure that MUST be complete before ANY user story\n\nâš ï¸ **CRITICAL**: No user story work can begin until this phase is complete\n\n- [ ] T010 Create User entity model with all properties from data-model.md\n- [ ] T011 Create Team entity model with all properties\n- [ ] T012 [P] Create Task entity with Status enum and RowVersion for concurrency\n- [ ] T013 [P] Create TeamMembership entity with Role enum\n- [ ] T014 [P] Create TeamInvitation entity with Status enum\n- [ ] T015 [P] Create AuditLog entity model\n- [ ] T016 Create ApplicationDbContext extending IdentityDbContext\n- [ ] T017 Configure entity relationships using Fluent API per data-model.md\n- [ ] T018 Create indexes: Task(TeamId,Status), TeamMembership(TeamId,UserId)\n- [ ] T019 Create initial EF Core migration: dotnet ef migrations add InitialCreate\n- [ ] T020 Configure ASP.NET Core Identity with password requirements\n- [ ] T021 Configure authentication: AddIdentity, cookie settings (24hr expiration)\n- [ ] T022 Create custom AuthenticationStateProvider for Blazor\n- [ ] T023 [P] Create IRepository interface\n- [ ] T024 [P] Create Repository implementation with async methods\n- [ ] T025 Configure error handling middleware\n- [ ] T026 Configure structured logging using ILogger\n- [ ] T027 Configure rate limiting middleware per API specification\n- [ ] T028 Create MainLayout.razor with navigation and auth state\n- [ ] T029 Create NavMenu.razor with conditional rendering\n- [ ] T030 Configure SignalR hub with connection timeout and group support\n\n**Checkpoint**: Foundation ready - user story implementation can now begin in parallel\n\n---\n\n## Phase 3: User Story 2 - User Authentication (Priority: P1) ğŸ¯ MVP Foundation\n\n**Goal**: Enable secure user sign-up, login, and password recovery\n\n**Independent Test**: Sign up with email, log in, reset password, verify rate limiting\n\n**Why First**: Authentication is foundational - required before collaborative features\n\n### Implementation for User Story 2\n\n- [ ] T031 [P] [US2] Create Register.razor page with email/password form\n- [ ] T032 [P] [US2] Create Login.razor page with email/password form\n- [ ] T033 [P] [US2] Create ForgotPassword.razor page with email input\n- [ ] T034 [P] [US2] Create ResetPassword.razor page with token validation\n- [ ] T035 [US2] Create AuthService with RegisterAsync, LoginAsync, LogoutAsync\n- [ ] T036 [US2] Implement email confirmation using ASP.NET Core Identity tokens\n- [ ] T037 [US2] Implement password reset with 24-hour token expiration\n- [ ] T038 [US2] Implement rate limiting: 5 attempts, 15-minute lockout\n- [ ] T039 [US2] Add session expiration: 24-hour absolute expiration\n- [ ] T040 [US2] Create AuditService with LogAsync method\n- [ ] T041 [US2] Add audit logging for authentication events\n- [ ] T042 [US2] Create IEmailService interface\n- [ ] T043 [US2] Create SendGridEmailService implementation\n- [ ] T044 [US2] Add email templates for confirmation and password reset\n- [ ] T045 [US2] Wire up Register page to AuthService with validation\n- [ ] T046 [US2] Wire up Login page with error handling\n- [ ] T047 [US2] Wire up ForgotPassword and ResetPassword pages\n- [ ] T048 [US2] Add redirect to preserved destination after login\n- [ ] T049 [US2] Create API endpoints: POST /api/auth/register, /login, /logout\n\n**Checkpoint**: Users can sign up, log in, reset passwords securely\n\n---\n\n## Phase 4: User Story 1 - Task Management Core (Priority: P1) ğŸ¯ MVP\n\n**Goal**: Enable task creation, assignment, editing, and completion\n\n**Independent Test**: Create task, edit description, mark complete, verify timestamp\n\n**Why Second**: Core value proposition - delivers immediate task tracking\n\n### Implementation for User Story 1\n\n- [ ] T050 [P] [US1] Create TaskCard.razor component\n- [ ] T051 [P] [US1] Create TaskDetailModal.razor for editing\n- [ ] T052 [P] [US1] Create NewTaskModal.razor for creating tasks\n- [ ] T053 [US1] Create Tasks.razor page with task list view\n- [ ] T054 [US1] Create TaskService with CRUD methods\n- [ ] T055 [US1] Implement CreateTaskAsync with validation\n- [ ] T056 [US1] Implement UpdateTaskAsync with optimistic concurrency using RowVersion\n- [ ] T057 [US1] Implement CompleteTaskAsync setting CompletedAt timestamp\n- [ ] T058 [US1] Implement DeleteTaskAsync with creator-only authorization\n- [ ] T059 [US1] Add authorization: only creator/assignee can edit\n- [ ] T060 [US1] Implement real-time task broadcast using SignalR (\n```\n\nFoundational (Phase 2) â†“ US2: Auth (Phase 3) â† MVP Foundation â†“ US1: Tasks (Phase 4) â† MVP Core + US3: Teams (Phase 5) â† Can parallelize â†“ US4: Filtering (Phase 6) â† Enhances US1 â†“ US5: Responsive (Phase 7) â† Enhances all UIs â†“ Polish (Phase 8)\n\n```\n\n**Recommended Order**: Setup â†’ Foundational â†’ US2 â†’ US3 â†’ US1 â†’ US4 â†’ US5 â†’ Polish\n\n**MVP Milestone**: Phases 1-5 = Basic task management with teams\n\n---\n\n## Parallel opportunities\n\n**Phase 1 (Setup)**: T003-T006 can run in parallel **Phase 2 (Foundational)**: T012-T015 (entity models), T023-T024 (repositories) **Phase 3 (US2)**: T031-T034 (all auth pages) at start **Phase 4 (US1)**: T050-T052 (all task components) at start **Phase 8 (Polish)**: Most tasks (T118-T128) can parallelize\n\n---\n\n## Implementation strategy\n\n### MVP First (2-3 weeks for single developer)\n\n1. **Week 1**: Setup + Foundational â†’ 2-3 days\n2. **Week 1-2**: User Story 2 (Auth) â†’ 3-4 days\n3. **Week 2**: User Story 3 (Teams) â†’ 2-3 days\n4. **Week 2-3**: User Story 1 (Tasks) â†’ 3-4 days\n5. **VALIDATE MVP**: Can users sign up, create teams, manage tasks?\n\n**Deploy at this point** - Core value delivered\n\n### Incremental Delivery\n\n1. **Foundation** â†’ Infrastructure ready\n2. **MVP** (US2, US3, US1) â†’ Users, teams, tasks working â†’ **DEPLOY**\n3. **Enhancement 1** (US4) â†’ Task filtering â†’ **DEPLOY**\n4. **Enhancement 2** (US5) â†’ Responsive UI â†’ **DEPLOY**\n5. **Polish** â†’ Performance, security hardening â†’ **DEPLOY**\n\n```\n\n![Generated tasks](/images/spec-kit/workflow-09-tasks-file.png) *The tasks.md file showing phased implementation with dependencies*\n\n### Why this breakdown works\n\nEach task:\n\n1. **Has clear dependencies**: Wonâ€™t fail due to missing prerequisites\n2. **Is independently testable**: Can verify completion\n3. **Has acceptance criteria**: We know when itâ€™s done\n4. **Is sized appropriately**: Can be completed in 2-4 hours\n\n## Step 6: Implementation\n\nFinally, we implement. This is where the AI writes code.\n\n### Running the implement command\n\n``` /speckit.implement\n\n```\n\n![Running the implement command](/images/spec-kit/workflow-10-implement-start.png) *Starting the implementation phase*\n\nThe AI will:\n\n1. Load constitution, spec, plan, and tasks\n2. Execute tasks in order\n3. Create files, write code, run tests\n4. Report progress after each task\n\n![Implementation in progress](/images/spec-kit/workflow-11-implement-progress.png) *The AI creating files and implementing tasks with progress updates*\n\n### What the AI generates\n\n![Generated code structure](/images/spec-kit/workflow-12-generated-code.png) *The complete project structure after implementation*\n\nHereâ€™s a sample of generated code:\n\n#### Backend: Task creation endpoint\n\n``` using Microsoft.AspNetCore.SignalR; using Microsoft.EntityFrameworkCore; using TeamTaskManager.Data; using TeamTaskManager.Hubs; using TeamTaskManager.Models;\n\nnamespace TeamTaskManager.Services;\n\npublic class TaskService { private readonly ApplicationDbContext _context; private readonly IHubContextTaskHub> _hubContext; private readonly AuditService _auditService; private readonly IHttpContextAccessor _httpContextAccessor;\n\npublic TaskService( ApplicationDbContext context, IHubContextTaskHub> hubContext, AuditService auditService, IHttpContextAccessor httpContextAccessor) { _context = context; _hubContext = hubContext; _auditService = auditService; _httpContextAccessor = httpContextAccessor; }\n\npublic async System.Threading.Tasks.TaskModels.Task> CreateTaskAsync(Models.Task task) { try { _context.Tasks.Add(task); await _context.SaveChangesAsync();\n\n// Load related entities for SignalR broadcast await _context.Entry(task).Reference(t => t.Creator).LoadAsync(); await _context.Entry(task).Reference(t => t.Assignee).LoadAsync();\n\n// Log audit event await _auditService.LogAsync( \"TaskCreated\", task.CreatorId, GetClientIpAddress(), new { TaskId = task.Id, Title = task.Title, TeamId = task.TeamId } );\n\n// Broadcast to team members via SignalR (within 2 seconds per FR-028) if (task.TeamId.HasValue) { await _hubContext.Clients.Group($\"team_{task.TeamId.Value}\") .SendAsync(\"TaskCreated\", task); }\n\nreturn task; } catch (Exception ex) { throw new ApplicationException($\"Failed to create task: {ex.Message}\", ex); } }\n\npublic async System.Threading.Tasks.TaskModels.Task> UpdateTaskAsync(Models.Task task) { try { var existingTask = await _context.Tasks .Include(t => t.Creator) .Include(t => t.Assignee) .FirstOrDefaultAsync(t => t.Id == task.Id);\n\nif (existingTask == null) { throw new InvalidOperationException(\"Task not found\"); }\n\n// Optimistic concurrency check using RowVersion (per FR-043, FR-044) if (existingTask.RowVersion != null && task.RowVersion != null && !existingTask.RowVersion.SequenceEqual(task.RowVersion)) { throw new DbUpdateConcurrencyException(\"Task was modified by another user. Please refresh and try again.\"); }\n\n// Update fields existingTask.Title = task.Title; existingTask.Description = task.Description; existingTask.Status = task.Status; existingTask.DueDate = task.DueDate; existingTask.UpdatedAt = DateTime.UtcNow; existingTask.AssigneeId = task.AssigneeId;\n\nif (task.Status == Models.TaskStatus.Completed && !existingTask.CompletedAt.HasValue) { existingTask.CompletedAt = DateTime.UtcNow; }\n\nawait _context.SaveChangesAsync();\n\n// Log audit event await _auditService.LogAsync( \"TaskUpdated\", task.CreatorId, GetClientIpAddress(), new { TaskId = task.Id, Title = task.Title, Status = task.Status } );\n\n// Broadcast to team members via SignalR if (existingTask.TeamId.HasValue) { await _hubContext.Clients.Group($\"team_{existingTask.TeamId.Value}\") .SendAsync(\"TaskUpdated\", existingTask);\n\nif (existingTask.Status == Models.TaskStatus.Completed) { await _hubContext.Clients.Group($\"team_{existingTask.TeamId.Value}\") .SendAsync(\"TaskCompleted\", existingTask); } }\n\nreturn existingTask; } catch (DbUpdateConcurrencyException) { throw; // Rethrow concurrency exceptions as-is } catch (Exception ex) { throw new ApplicationException($\"Failed to update task: {ex.Message}\", ex); } }\n\npublic async System.Threading.Tasks.Task DeleteTaskAsync(int taskId) { try { var task = await _context.Tasks.FindAsync(taskId);\n\nif (task == null) { throw new InvalidOperationException(\"Task not found\"); }\n\nvar teamId = task.TeamId; var creatorId = task.CreatorId;\n\n_context.Tasks.Remove(task); await _context.SaveChangesAsync();\n\n// Log audit event await _auditService.LogAsync( \"TaskDeleted\", creatorId, GetClientIpAddress(), new { TaskId = taskId, TeamId = teamId } );\n\n// Broadcast to team members via SignalR if (teamId.HasValue) { await _hubContext.Clients.Group($\"team_{teamId.Value}\") .SendAsync(\"TaskDeleted\", taskId); } } catch (Exception ex) { throw new ApplicationException($\"Failed to delete task: {ex.Message}\", ex); } }\n\npublic async System.Threading.Tasks.TaskModels.Task?> GetTaskByIdAsync(int taskId) { return await _context.Tasks .Include(t => t.Creator) .Include(t => t.Assignee) .Include(t => t.Team) .FirstOrDefaultAsync(t => t.Id == taskId); }\n\npublic async System.Threading.Tasks.TaskListModels.Task>> GetUserTasksAsync(string userId) { return await _context.Tasks .Include(t => t.Creator) .Include(t => t.Assignee) .Include(t => t.Team) .Where(t => t.CreatorId == userId || t.AssigneeId == userId) .OrderBy(t => t.Status) .ThenByDescending(t => t.CreatedAt) .ToListAsync(); }\n\npublic async System.Threading.Tasks.TaskListModels.Task>> GetTeamTasksAsync(int teamId) { return await _context.Tasks .Include(t => t.Creator) .Include(t => t.Assignee) .Where(t => t.TeamId == teamId) .OrderBy(t => t.Status) .ThenByDescending(t => t.CreatedAt) .ToListAsync(); }\n\nprivate string? GetClientIpAddress() { var httpContext = _httpContextAccessor.HttpContext;\n\nif (httpContext == null) { return null; }\n\nvar forwardedFor = httpContext.Request.Headers[\"X-Forwarded-For\"].FirstOrDefault(); if (!string.IsNullOrEmpty(forwardedFor)) { return forwardedFor.Split(',')[0].Trim(); }\n\nreturn httpContext.Connection.RemoteIpAddress?.ToString(); } }\n\n```\n\n#### Frontend: Task list component\n\n```cshtml @using TeamTaskManager.Models @using TaskStatus = TeamTaskManager.Models.TaskStatus\n\n@Task.Title\n\n@Task.Status\n\n@if (!string.IsNullOrEmpty(Task.Description)) {\n\n@(Task.Description.Length > 100 ? Task.Description.Substring(0, 100) + \"...\" : Task.Description)\n\n}\n\n@if (Task.DueDate.HasValue) {\n\n}\n\n@if (Task.Assignee != null) {\n\n@Task.Assignee.DisplayName\n\n}\n\n@code { [Parameter] public TeamTaskManager.Models.Task Task { get; set; } = default!;\n\n[Parameter] public Action? OnTaskClick { get; set; }\n\nprivate string GetStatusBadgeClass() { return Task.Status switch { TaskStatus.Open => \"bg-secondary\", TaskStatus.InProgress => \"bg-primary\", TaskStatus.Completed => \"bg-success\", _ => \"bg-secondary\" }; } }\n\n```\n\n### The AIâ€™s process\n\nFor each task in `tasks.md` , the AI:\n\n1. **Reads the requirements** from spec and plan\n2. **Generates code** following the constitutionâ€™s standards\n3. **Runs tests** to verify correctness\n4. **Reports completion** before moving to next task\n\nIf tests fail, the AI debugs and fixes automatically.\n\n![Implementation complete](/images/spec-kit/workflow-13-implementation-complete.png) *All tasks completed and verified*\n\n## Validation and testing\n\nAfter implementation, you must test the application yourself.\n\n### Critical testing checklist\n\n- Run the application locally\n- Open browser developer console\n- Test each user story from the spec\n- Try edge cases (empty inputs, network errors)\n- Check performance (response times)\n- Verify security (canâ€™t access other teamsâ€™ data)\n\n### If you find bugs\n\nDonâ€™t just say â€œitâ€™s broken.â€ Provide rich context:\n\n``` /implement fix bug: When creating a task without an assignee, the API returns 500 error with \"Cannot read property 'id' of null\" in tasks.ts line 47.\n\nExpected: Task should be created with null assignedToId Actual: Server crashes\n\nStack trace: TypeError: Cannot read property 'id' of null at /api/routes/tasks.ts:47:35\n\n```\n\nThe AI will:\n\n1. Fix the bug\n2. Add a test case for it\n3. Update the plan/tasks if needed\n\n## Handling spec changes\n\nWhat if requirements change mid-development?\n\n### The workflow\n\n1. **Update the spec**: Edit `.speckit/spec.md`\nwith new requirements\n2. **Regenerate plan**: Run `/speckit.plan`\nagain\n3. **Regenerate tasks**: Run `/speckit.tasks`\nagain\n4. **Continue implementation**: Run `/speckit.implement`\n(skips completed tasks)\n\n### Example: Adding task comments\n\nOriginal spec didnâ€™t include comments. User asks for them.\n\n#### Step 1: Update spec\n\nAdd to `.speckit/spec.md` :\n\n```\n### Task Comments\n\n**As a team member**, I want to:\n- Add comments to tasks\n- See all comments with timestamps\n- Edit or delete my own comments\n\n**Acceptance Criteria:**\n- Comments appear in real-time\n- Comments support basic Markdown\n- Comments preserved when task completed\n\n```\n\n#### Step 2: Regenerate plan\n\n``` /speckit.plan\n\n```\n\nAI updates `data-model.md` :\n\n```prisma model Comment { id String @id @default(uuid()) taskId String userId String content String createdAt DateTime @default(now()) updatedAt DateTime @updatedAt\n\ntask Task @relation(fields: [taskId], references: [id], onDelete: Cascade) user User @relation(fields: [userId], references: [id])\n\n@@map(\"comments\") }\n\nmodel Task { // ... existing fields comments Comment[] }\n\n```\n\nAnd adds to `plan.md` :\n\n```\n#### Comments\n- `GET /api/tasks/:id/comments` - List task comments\n- `POST /api/tasks/:id/comments` - Add comment\n- `PUT /api/comments/:id` - Edit comment\n- `DELETE /api/comments/:id` - Delete comment\n\n```\n\n#### Step 3: Regenerate tasks\n\n``` /speckit.tasks\n\n```\n\nAI adds new tasks:\n\n```\n## Phase 11: Task Comments\n- [ ] 11.1 Add Comment model to Prisma schema\n- [ ] 11.2 Run migration\n- [ ] 11.3 Create comments API endpoints\n- [ ] 11.4 Add comments UI component\n- [ ] 11.5 Implement real-time comment updates\n\n**Dependencies**: 9.1-9.5 **Acceptance**: Users can add, edit, delete comments\n\n```\n\n#### Step 4: Continue implementation\n\n``` /speckit.implement\n\n```\n\nAI implements only the new tasks (skips already completed ones).\n\n## Best practices recap\n\n### 1. Constitution: Start strict, relax later\n\nItâ€™s easier to remove constraints than add them. Start with:\n\n- **Specific tech stack requirements**\n- **Performance targets with numbers**\n- **Explicit non-goals**\n\n### 2. Spec: Be exhaustively detailed\n\nDonâ€™t assume the AI knows what you want. Include:\n\n- **Every user action**\n- **Every edge case**\n- **Every error message**\n- **Visual mockups** (even sketches help)\n\n### 3. Plan: Review carefully\n\nThis is your last chance before code generation. Check:\n\n- **Is the tech stack appropriate?**\n- **Are there better framework choices?**\n- **Is the database schema normalized?**\n- **Are APIs RESTful and consistent?**\n\n### 4. Tasks: Verify dependencies\n\nMake sure:\n\n- **Tasks are ordered correctly**\n- **Dependencies are accurate**\n- **Each task has acceptance criteria**\n- **Tasks are small enough** (2-4 hours each)\n\n### 5. Implementation: Test ruthlessly\n\nAfter every major phase:\n\n- **Run the application**\n- **Test in the browser**\n- **Check for console errors**\n- **Verify performance**\n\n## Common pitfalls and how to avoid them\n\n### Pitfall #1: Vague specifications\n\nâŒ **Bad**:\n\n``` Build a task manager with teams\n\n```\n\nâœ… **Good**:\n\n```\n## User Story: Team Creation\n\nAs a user, I want to create a new team by:\n1. Clicking \"New Team\" button\n2. Entering team name (3-50 chars, alphanumeric)\n3. Seeing confirmation \"Team created\"\n\n**Acceptance Criteria:**\n- Team name must be unique\n- Creator becomes admin automatically\n- Team appears in sidebar immediately\n- Error shown if name taken: \"Team name already exists\"\n\n```\n\n### Pitfall #2: Over-engineering early\n\nâŒ **Bad constitution**:\n\n``` Must use microservices with event sourcing\n\n```\n\nâœ… **Good constitution**:\n\n``` Start with monolithic architecture Consider microservices only if:\n- Team exceeds 10 developers\n- System exceeds 10k users\n- Performance becomes bottleneck\n\n```\n\n### Pitfall #3: Ignoring AI suggestions\n\nThe AI might suggest better approaches. Donâ€™t dismiss them automatically.\n\n**Example**: AI suggests caching frequently accessed data. Even if not in spec, itâ€™s worth considering.\n\n### Pitfall #4: Not testing increments\n\nDonâ€™t wait until the end to test. Test after each phase:\n\n- **Phase 3 done?** Test authentication\n- **Phase 5 done?** Test task CRUD\n- **Phase 6 done?** Test real-time updates\n\n## Troubleshooting common issues\n\n### Issue: AI generates outdated code\n\n**Symptom**: Uses deprecated APIs or old library versions\n\n**Solution**: In the constitution, specify minimum versions:\n\n```\n## Technical Constraints\n- React >= 18.2 (use new hooks API)\n- Express >= 4.18 (async/await support)\n\n```\n\n### Issue: AI hallucinates functionality\n\n**Symptom**: References functions or libraries that donâ€™t exist\n\n**Solution**: Run `/speckit.analyze` to validate consistency across artifacts\n\n### Issue: Tests fail after implementation\n\n**Symptom**: â€œCannot find moduleâ€ or â€œUnexpected tokenâ€\n\n**Solution**: Check that the AI installed all dependencies. Run:\n\n``` npm install\n# or\nnpm run install:all # if monorepo\n\n```\n\n### Issue: Real-time updates donâ€™t work\n\n**Symptom**: Changes donâ€™t appear for other users\n\n**Solution**: Check WebSocket connection in browser console:\n\n``` // Browser console socket.connected // should be true\n\n```\n\nIf false, verify:\n\n- Server WebSocket port is correct\n- CORS settings allow WebSocket connections\n- Client and server Socket.io versions match\n\n## What weâ€™ve accomplished\n\nBy following the Spec-Kit workflow, we:\n\n1. âœ… Created a comprehensive constitution\n2. âœ… Wrote detailed specifications with user stories\n3. âœ… Generated a complete technical plan\n4. âœ… Broke work into implementable tasks\n5. âœ… Implemented a production-ready application\n\n**Result**: A team task manager with authentication, real-time updates, and tested code - not vibe-coded, but spec-driven.\n\n## Next week: Best practices and troubleshooting\n\nIn Part 3, weâ€™ll dive deeper into:\n\n- **Advanced specification techniques**: How to spec complex workflows\n- **Debugging strategies**: When the AI goes off track\n- **Iteration patterns**: Evolving specs over time\n- **Performance optimization**: Keeping the AI focused and fast\n- **Real-world edge cases**: Lessons from production deployments\n\n### Homework before Part 3\n\nTry the workflow yourself:\n\n1. Pick a small project (simpler than our example)\n2. Write a constitution and spec\n3. Generate a plan\n4. Review it carefully\n5. Note any issues you encounter\n\nWeâ€™ll use your experiences to guide Part 3â€™s content.\n\n## Key takeaways from part 2\n\n1. **Constitution sets boundaries**: Non-negotiable principles guide all decisions\n2. **Specs must be exhaustive**: The more detail, the better the output\n3. **Plans are reviewable**: This is where you catch architectural mistakes\n4. **Tasks create accountability**: Dependencies and acceptance criteria matter\n5. **Implementation requires testing**: AI-generated code needs human validation\n\nNext week in Part 3, weâ€™ll tackle the messy reality of spec-driven development: debugging, iteration, and real-world troubleshooting.\n\n## Resources\n\n- **Spec-Kit GitHub**: [github.com/github/spec-kit](https://github.com/github/spec-kit)\n- **Example Project**: [github.com/hiddedesmet/spec-kit-task-manager](https://github.com/hiddedesmet/spec-kit-task-manager) *(coming soon)*\n- **.NET 9 Documentation**: [learn.microsoft.com/dotnet](https://learn.microsoft.com/dotnet)\n- **Blazor Documentation**: [learn.microsoft.com/aspnet/core/blazor](https://learn.microsoft.com/aspnet/core/blazor)\n- **Entity Framework Core**: [learn.microsoft.com/ef/core](https://learn.microsoft.com/ef/core)\n- **SignalR for Real-Time**: [learn.microsoft.com/aspnet/core/signalr](https://learn.microsoft.com/aspnet/core/signalr)\n\n## Series navigation\n\n- **Previous**: [Part 1 - The problem and the solution](/from-vibe-coding-to-spec-driven-development)\n- **ğŸ“ You are here: Part 2 - The Spec-Kit workflow**\n- **Next**: Part 3 - Best practices and troubleshooting (Coming January 19, 2026)\n- Part 4 - Team collaboration and advanced patterns (Coming January 26, 2026)\n- Part 5 - Case studies and lessons learned (Coming February 2, 2026)\n\n*Have questions about the workflow? Found a bug in the example? Connect with me on [LinkedIn](https://linkedin.com/in/hiddedesmet) or check out more posts at [hiddedesmet.com](https://hiddedesmet.com).*\n\n**Want to get notified when Part 3 drops?** Follow me on [LinkedIn](https://linkedin.com/in/hiddedesmet) for updates.",
  "Title": "From Vibe Coding to Spec-Driven Development: Part 2 - The Spec-Kit Workflow",
  "FeedUrl": "https://hiddedesmet.com/feed.xml",
  "Tags": [
    "AI",
    "ai-assisted-development",
    "claude",
    "copilot",
    "Development",
    "DevOps",
    "github",
    "series",
    "spec-kit",
    "specification-driven-development",
    "vibe-coding"
  ],
  "FeedLevelAuthor": "Hidde de Smet",
  "Author": "Hidde de Smet",
  "EnhancedContent": "Search for Blog\n\n[ai-assisted-development](/tags#ai-assisted-development)\n\n[spec-kit](/tags#spec-kit)\n\n[github](/tags#github)\n\n[claude](/tags#claude)\n\n[copilot](/tags#copilot)\n\n[vibe-coding](/tags#vibe-coding)\n\n[specification-driven-development](/tags#specification-driven-development)\n\n[series](/tags#series)\n\nâ€¢ Jan 12, 2026\n\nâ€¢\n\n53 min read\n\n# From Vibe Coding to Spec-Driven Development: Part 2 - The Spec-Kit Workflow\n\nPart 2 of our series on mastering AI-assisted development. A hands-on walkthrough of the complete Spec-Kit workflow: creating constitutions, writing specs, generating plans, and implementing production-ready code.\n\n- https://twitter.com/intent/tweet?text=From%20Vibe%20Coding%20to%20Spec-Driven%20Development:%20Part%202%20-%20The%20Spec-Kit%20Workflow&url=https://hiddedesmet.com/from-vibe-coding-to-spec-driven-development-part2\n- https://www.facebook.com/sharer/sharer.php?u=https://hiddedesmet.com/from-vibe-coding-to-spec-driven-development-part2\n- http://pinterest.com/pin/create/button/?url=https://hiddedesmet.com/from-vibe-coding-to-spec-driven-development-part2&amp;media=https://hiddedesmet.com/images/spec-kit/image-02.png&amp;description=From%20Vibe%20Coding%20to%20Spec-Driven%20Development:%20Part%202%20-%20The%20Spec-Kit%20Workflow\n- https://www.linkedin.com/shareArticle?mini=true&url=https://hiddedesmet.com/from-vibe-coding-to-spec-driven-development-part2&title=From%20Vibe%20Coding%20to%20Spec-Driven%20Development:%20Part%202%20-%20The%20Spec-Kit%20Workflow&summary=Part%202%20of%20our%20series%20on%20mastering%20AI-assisted%20development.%20A%20hands-on%20walkthrough%20of%20the%20complete%20Spec-Kit%20workflow:%20creating%20constitutions,%20writing%20specs,%20generating%20plans,%20and%20implementing%20production-ready%20code.&source=myblog\n\n![From Vibe Coding to Spec-Driven Development: Part 2 - The Spec-Kit Workflow]()\n\n## Table of Contents\n\n1. Series overview\n2. What weâ€™re building today\n3. Prerequisites\n4. The complete workflow\n5. Step 1: Initialize your project\n6. Step 2: Create your constitution\n1. What goes in a constitution?\n2. Real example: Our Team Task Manager constitution\n3. Why this works\n4. Running the constitution command\n7. Step 3: Write the specification\n1. The specification structure\n2. Real example: Team Task Manager spec\n3. Why this spec works\n4. Running the specify command\n5. Specification Quality Validation\n8. Step 4: Generate the technical plan\n1. Running the plan command\n2. Real example: Generated plan.md\n9. Testing Strategy\n1. Unit Tests\n2. Integration Tests\n3. E2E Tests\n4. Test Coverage Targets\n10. Deployment Plan\n1. Development\n2. Production Considerations\n11. Open Questions\n12. Relationships\n13. Indexes\n1. Performance-critical\n2. Uniqueness constraints\n14. Migration strategy\n1. Why this breakdown works\n15. Step 6: Implementation\n1. Running the implement command\n2. What the AI generates\n1. Backend: Task creation endpoint\n2. Frontend: Task list component\n3. The AIâ€™s process\n16. Validation and testing\n1. Critical testing checklist\n2. If you find bugs\n17. Handling spec changes\n1. The workflow\n2. Example: Adding task comments\n1. Step 1: Update spec\n2. Step 2: Regenerate plan\n3. Step 3: Regenerate tasks\n4. Step 4: Continue implementation\n18. Best practices recap\n1. 1. Constitution: Start strict, relax later\n2. 2. Spec: Be exhaustively detailed\n3. 3. Plan: Review carefully\n4. 4. Tasks: Verify dependencies\n5. 5. Implementation: Test ruthlessly\n19. Common pitfalls and how to avoid them\n1. Pitfall #1: Vague specifications\n2. Pitfall #2: Over-engineering early\n3. Pitfall #3: Ignoring AI suggestions\n4. Pitfall #4: Not testing increments\n20. Troubleshooting common issues\n1. Issue: AI generates outdated code\n2. Issue: AI hallucinates functionality\n3. Issue: Tests fail after implementation\n4. Issue: Real-time updates donâ€™t work\n21. What weâ€™ve accomplished\n22. Next week: Best practices and troubleshooting\n1. Homework before Part 3\n23. Key takeaways from part 2\n24. Resources\n25. Series navigation\n\n> >\n> **This is Part 2 of a 5-part series on mastering AI-assisted development.** Last week, we explored why vibe coding fails and what spec-driven development offers. This week, weâ€™re getting hands-on with the actual workflow.\n> >\n\n## Series overview\n\n1. [**Part 1**](/from-vibe-coding-to-spec-driven-development): The problem and the solution\n2. **Part 2 (This post)**: Deep dive into the Spec-Kit workflow\n3. **Part 3 (Jan 19)**: Best practices and troubleshooting\n4. **Part 4 (Jan 26)**: Team collaboration and advanced patterns\n5. **Part 5 (Feb 2)**: Case studies and lessons learned\n\n## What weâ€™re building today\n\nTo demonstrate the Spec-Kit workflow, weâ€™ll build a real application: a **Team Task Manager**. Not a hello-world todo list, but something with actual complexity:\n\n- Multi-user authentication\n- Team workspaces\n- Task assignment and tracking\n- Real-time updates\n- Responsive design\n\nBy the end of this post, youâ€™ll have walked through every step of the Spec-Kit workflow with concrete examples you can adapt to your own projects.\n\n## Prerequisites\n\nBefore we start, make sure you have:\n\n```\n# Install Spec-Kit CLI\nuv tool install specify-cli --from git+https://github.com/github/spec-kit.git\n\n# Verify installation\nspecify --version\n\n# Install an AI coding assistant (one of these)\n# - GitHub Copilot\n# - Claude Desktop\n# - Cursor\n# - Windsurf\n\n```\n\n**Note**: The examples in this post use GitHub Copilot, but the workflow is identical for all supported AI agents.\n\n## The complete workflow\n\nHereâ€™s the accountability chain weâ€™ll follow:\n\n``` Constitution â†’ Specification â†’ Plan â†’ Tasks â†’ Implementation\n\n```\n\nEach step builds on the previous one. Each step produces artifacts that guide the next. Letâ€™s dive in.\n\n## Step 1: Initialize your project\n\nFirst, create your project directory:\n\n``` specify init team-task-manager cd team-task-manager\n\n```\n\nThis creates the basic structure with organized folders for agents, prompts, and specification artifacts:\n\n``` team-task-manager/ â”œâ”€â”€ .github/ â”œâ”€â”€ agents/ â”œâ”€â”€ prompts/ â””â”€â”€ .specify/ â”œâ”€â”€ memory/ â”œâ”€â”€ scripts/ â”œâ”€â”€ templates/ â””â”€â”€ .vscode/\n\n```\n\n![Spec-Kit project structure](/images/spec-kit/workflow-01-init.png) *The initialized project structure shown in VS Code*\n\n## Step 2: Create your constitution\n\nThe constitution is your projectâ€™s foundation - the non-negotiable principles that guide all decisions.\n\n**Important**: When you ran `specify init` , it created a **template** at `.specify/constitution.md` with TODOs and placeholder sections. You need to fill this in with your actual project requirements before proceeding.\n\nHereâ€™s what the empty template looks like:\n\n```\n# TODO(PROJECT_NAME) Constitution\n\n## Core Principles\n\n### TODO(PRINCIPLE_1_NAME)\nTODO(PRINCIPLE_1_DESCRIPTION): Define first core principle...\n\n### TODO(PRINCIPLE_2_NAME)\nTODO(PRINCIPLE_2_DESCRIPTION): Define second core principle...\n\n## Governance\n\nTODO(GOVERNANCE_RULES): Define how this constitution is amended...\n\n```\n\n### What goes in a constitution?\n\nReplace the TODOs with real content:\n\n1. **Project purpose**: What problem are you solving?\n2. **Core principles**: What values guide technical decisions?\n3. **Technical constraints**: What technologies, frameworks, or patterns must you use?\n4. **Quality standards**: What does â€œdoneâ€ look like?\n5. **Non-goals**: What are you explicitly not building?\n\n### Real example: Our Team Task Manager constitution\n\n```\n# Team Task Manager Constitution\n\n## Project Purpose\n\nBuild a collaborative task management system for small teams (5-20 people) to organize work, assign tasks, and track progress in real-time.\n\n## Core Principles\n\n### I. Simplicity First\nStart with the minimum viable feature set. Complexity must be justified against simpler alternatives. The constitution's Complexity Tracking mechanism MUST be used to document any deviation from this principle.\n\n**Rationale**: Small teams need tools they can understand and maintain. Over-engineering leads to technical debt and slower iteration.\n\n### II. User Experience Over Features\nA polished core beats a bloated mess. Every feature must demonstrably improve the user experience. Feature requests that compromise UX quality are rejected.\n\n**Rationale**: Users value reliable, intuitive tools over feature-rich but confusing interfaces.\n\n### III. Security By Design\nAuthentication and authorization at every layer. Security is non-negotiable and cannot be retrofitted.\n\n**Rationale**: Task management involves sensitive business information. A single breach destroys trust.\n\n### IV. Performance Matters\nSub-second response times for all interactions. Performance targets are requirements, not aspirations.\n\n**Rationale**: Slow tools disrupt workflow. Performance directly impacts user adoption and satisfaction.\n\n### V. Mobile-Friendly\nResponsive design, not separate mobile apps. The web interface must work seamlessly on all device sizes.\n\n**Rationale**: Team members work from various devices. Maintaining separate mobile apps increases complexity and violates Principle I.\n\n## Technical Constraints\n\n### Must Use\n- **Backend**: .NET 9 with C#\n- **Frontend**: Blazor Server (keep it simple, no separate SPA)\n- **Database**: SQL Server or PostgreSQL\n- **Authentication**: ASP.NET Core Identity\n- **Deployment**: Containerized (Docker)\n\n### Must Avoid\n- No complex microservices (keep it monolithic for now)\n- No separate frontend frameworks (React, Angular, Vue, etc.)\n- No over-engineered authentication flows (stick to ASP.NET Core Identity)\n\n**Rationale**: These constraints enforce Principle I (Simplicity First) by limiting architectural complexity and preventing technology sprawl.\n\n## Quality Standards\n\n### Code Quality\n- C# nullable reference types MUST be enabled project-wide\n- Roslyn analyzers MUST be enabled (minimum: StyleCop.Analyzers)\n- EditorConfig MUST be configured for consistent formatting\n- All public methods MUST be documented with XML comments\n\n### Testing\n- Unit tests for business logic (80%+ coverage REQUIRED)\n- Integration tests for all API endpoints\n- End-to-end tests for critical user flows (defined as: create team, create task, assign task, complete task)\n\n**Enforcement**: Pull requests failing coverage or missing critical path tests will be rejected.\n\n### Performance\n- Page load time < 2 seconds (measured at p95)\n- API response time < 500ms (measured at p95)\n- Database queries MUST be optimized (execution plans reviewed during code review)\n\n**Enforcement**: Features that regress performance targets will be rolled back.\n\n### Security\n- OWASP Top 10 MUST be addressed for all user-facing features\n- Dependencies MUST be scanned weekly (automated via CI/CD)\n- SQL injection prevention: parameterized queries ONLY (raw SQL prohibited)\n- XSS protection: all user input MUST be sanitized\n\n**Enforcement**: Security violations block deployment.\n\n## Non-Goals (What We're NOT Building)\n\nExplicitly out of scope to prevent feature creep:\n\n- âŒ Project management (Gantt charts, resource allocation, burndown charts)\n- âŒ Time tracking or invoicing\n- âŒ Complex workflows or automation (no custom workflow engines)\n- âŒ Native mobile apps (web-first per Principle V)\n- âŒ Real-time video/chat (out of scope for task management)\n\n**Rationale**: These features violate Principle I (Simplicity First) and expand scope beyond small team task management. Feature requests in these categories should be politely declined.\n\n## Success Criteria\n\n### MVP (Version 1.0)\n- Users can create teams\n- Users can create, assign, and complete tasks\n- Users can see team activity in real-time\n- Application is secure (authentication required, OWASP Top 10 addressed)\n- Application is fast (performance targets met)\n\n### Future Enhancements (Post-MVP)\nConsidered only after MVP is stable and validated with users:\n- Task comments and attachments\n- Task dependencies and blocking relationships\n- Email notifications\n- Calendar integration (read-only)\n\n## Governance\n\n### Amendment Process\n1. Amendments proposed via pull request to this file\n2. Proposed changes must include:\n- Rationale for the change\n- Impact assessment on existing features/plans\n- Migration plan if breaking change\n3. Approval requires: project maintainer sign-off\n4. Constitution takes precedence over all other documents\n\n### Versioning Policy\nSemantic versioning (MAJOR.MINOR.PATCH):\n- **MAJOR**: Backward incompatible changes (principle removal, constraint changes that invalidate existing code)\n- **MINOR**: New principle or section added, material expansion of guidance\n- **PATCH**: Clarifications, wording improvements, non-semantic refinements\n\n### Compliance Review\n- All feature specifications MUST reference this constitution\n- All implementation plans MUST include \"Constitution Check\" section\n- Code reviews MUST verify adherence to quality standards and technical constraints\n- Violations MUST be documented in plan.md Complexity Tracking section\n\n### Review Cadence\nConstitution reviewed quarterly or when significant architectural decisions arise.\n\n**Version**: 1.0.0 | **Ratified**: 2026-01-12 | **Last Amended**: 2026-01-12\n\n```\n\n### Why this works\n\nNotice what weâ€™ve done:\n\n1. **Clear purpose**: Everyone knows what weâ€™re building and why\n2. **Explicit constraints**: The AI wonâ€™t suggest GraphQL or microservices\n3. **Measurable standards**: â€œFastâ€ means &lt; 500ms, not â€œfeels fastâ€\n4. **Explicit non-goals**: Weâ€™re not building Jira\n\nThis constitution will be referenced in every subsequent step. When the AI suggests adding time tracking, we can point back to the constitutionâ€™s non-goals.\n\n### Running the constitution command\n\nIn your AI coding assistant, run:\n\n``` /speckit.constitution\n\n```\n\n![Running the constitution command](/images/spec-kit/workflow-02-constitution-command.png) *Typing the /speckit.constitution command in GitHub Copilot Chat*\n\nThe AI will:\n\n1. Read the constitution\n2. Validate itâ€™s complete\n3. Confirm it understands the constraints\n\n![Constitution validated](/images/spec-kit/workflow-03-constitution-response.png) *The AI confirms it has read and understood the constitution*\n\n## Step 3: Write the specification\n\nNow we define **what** weâ€™re building in detail. The spec focuses on user stories, acceptance criteria, and behavior - not implementation.\n\n### The specification structure\n\nA good spec includes:\n\n1. **User stories**: Who does what and why\n2. **Acceptance criteria**: What does â€œdoneâ€ mean?\n3. **User interface mockups**: Visual guides (can be sketches)\n4. **Data requirements**: What information flows through the system?\n5. **Edge cases**: What happens when things go wrong?\n\n### Real example: Team Task Manager spec\n\nCreate `.speckit/spec.md` :\n\n```\n# Team Task Manager Specification\n\n## Overview\n\nA collaborative task management application for small teams to organize work, assign tasks, and track progress.\n\n---\n\n## User Stories\n\n### Authentication\n\n**As a new user**, I want to:\n- Sign up with my email or Google account\n- Receive a confirmation email\n- Log in securely\n- Reset my password if forgotten\n\n**Acceptance Criteria:**\n- Sign-up takes < 30 seconds\n- Email confirmation sent within 1 minute\n- Password reset link expires in 24 hours\n- Failed login attempts rate-limited after 5 attempts\n\n---\n\n### Team Management\n\n**As a team admin**, I want to:\n- Create a new team with a unique name\n- Invite members via email\n- Remove members from the team\n- Transfer ownership to another member\n\n**Acceptance Criteria:**\n- Team names must be unique\n- Email invitations expire in 7 days\n- Removed members lose access immediately\n- Ownership transfer requires confirmation\n\n---\n\n### Task Management\n\n**As a team member**, I want to:\n- Create tasks with title, description, and due date\n- Assign tasks to myself or team members\n- Mark tasks as complete\n- Edit or delete tasks I created\n- Filter tasks by assignee or status\n\n**Acceptance Criteria:**\n- Task creation takes < 5 seconds\n- Tasks appear in real-time for all team members\n- Completed tasks marked with timestamp\n- Only task creator or assignee can edit/delete\n- Filters apply instantly (no page reload)\n\n---\n\n## User Interface Requirements\n\n### Dashboard View\n- Navigation bar with logo, user menu\n- Tab navigation: My Tasks, Team Tasks, Completed\n- Filter dropdown: All, Assigned to me, Created by me\n- Task cards showing: title, description preview, assignee, due date\n- Checkbox to mark tasks complete\n- \"New Task\" button\n\n### Task Detail View\n- Back navigation to dashboard\n- Task title (editable)\n- Creator and creation date\n- Assignee dropdown (team members)\n- Due date picker\n- Status dropdown (Open, In Progress, Completed)\n- Description text area\n- Delete and Save buttons\n\n### Responsive Behavior\n- **Desktop (> 1024px)**: Side-by-side task list and detail\n- **Tablet (768-1024px)**: Stacked layout with full-width cards\n- **Mobile (< 768px)**: Single-column, touch-optimized buttons\n\n---\n\n## Data Requirements\n\n### Users\n- Unique identifier (UUID)\n- Email (unique, validated)\n- Display name\n- Avatar URL (optional)\n- Created timestamp\n- Last login timestamp\n\n### Teams\n- Unique identifier (UUID)\n- Team name (unique)\n- Owner (user reference)\n- Created timestamp\n- Member count\n\n### Team Memberships\n- Team reference\n- User reference\n- Role (admin, member)\n- Joined timestamp\n\n### Tasks\n- Unique identifier (UUID)\n- Title (required, max 200 chars)\n- Description (optional, max 5000 chars)\n- Status (open, in_progress, completed)\n- Created by (user reference)\n- Assigned to (user reference, optional)\n- Team reference\n- Due date (optional)\n- Created timestamp\n- Updated timestamp\n- Completed timestamp (nullable)\n\n---\n\n## Edge Cases & Error Handling\n\n### Authentication\n- **Scenario**: User tries to access app without logging in\n- **Expected**: Redirect to login page, preserve intended destination\n\n- **Scenario**: Session expires while user is working\n- **Expected**: Show modal \"Session expired, please log in again\"\n\n### Task Management\n- **Scenario**: Two users edit the same task simultaneously\n- **Expected**: Last write wins, show conflict notification\n\n- **Scenario**: User tries to delete a task they didn't create\n- **Expected**: Show error \"Only task creator can delete\"\n\n### Real-time updates\n- **Scenario**: Network connection drops\n- **Expected**: Show \"Offline\" indicator, queue updates, sync when reconnected\n\n- **Scenario**: User has 1000+ completed tasks\n- **Expected**: Paginate results, load 50 at a time\n\n### Team Management\n- **Scenario**: Last admin leaves the team\n- **Expected**: Promote oldest member to admin automatically\n\n- **Scenario**: User invited to team they're already in\n- **Expected**: Show message \"You're already a member\"\n\n---\n\n## Performance Requirements\n\n### Page Load\n- Initial load: < 2 seconds (3G connection)\n- Subsequent navigation: < 500ms\n\n### API Response Times (95th percentile)\n- GET requests: < 200ms\n- POST/PUT requests: < 500ms\n- Real-time updates: < 2 seconds\n\n### Concurrent Users\n- Support 100 concurrent users per team\n- Support 1000 teams total (MVP target)\n\n---\n\n## Security Requirements\n\n### Authentication\n- Passwords hashed with bcrypt (cost factor 12)\n- OAuth tokens stored securely (httpOnly cookies)\n- MFA support (optional for MVP)\n\n### Authorization\n- Role-based access control (RBAC)\n- Users can only access teams they belong to\n- Task operations checked against user permissions\n\n### Data Protection\n- All API requests over HTTPS\n- SQL injection prevention (parameterized queries)\n- XSS prevention (sanitize user input)\n- CSRF tokens on all state-changing requests\n\n### Auditing\n- Log all authentication attempts\n- Log all task CRUD operations\n- Log all team membership changes\n\n---\n\n## Success Metrics\n\n### User Engagement\n- Daily active users per team: > 60%\n- Tasks created per user per week: > 5\n- Task completion rate: > 70%\n\n### System Health\n- Uptime: > 99.5%\n- Error rate: < 0.1% of requests\n- Response time (p95): < 500ms\n\n### User Satisfaction\n- NPS score: > 40\n- Support tickets per user: < 0.05/month\n\n```\n\n### Why this spec works\n\nThis specification gives the AI everything it needs:\n\n1. **Detailed user stories**: Exact behavior expected\n2. **Visual mockups**: Clear UI direction (even ASCII art helps!)\n3. **Edge cases**: Real-world scenarios covered\n4. **Measurable criteria**: â€œFastâ€ is defined numerically\n\n### Running the specify command\n\nIn your AI coding assistant:\n\n``` /speckit.specify\n\n```\n\nThe AI will:\n\n1. Read the constitution and spec\n2. Ask clarifying questions\n3. Validate specification completeness and quality\n4. Confirm understanding before proceeding\n\n### Specification Quality Validation\n\nThe `specify` command validates your specification against quality criteria:\n\n```\n# Specification Quality Checklist: Team Task Manager\n\n## Content Quality\nâœ… Written for non-technical stakeholders âœ… Focused on user value and business needs âœ… No implementation details (languages, frameworks, APIs)\n\n## Requirement Completeness\nâœ… No NEEDS CLARIFICATION markers remain âœ… Success criteria are technology-agnostic âœ… All acceptance scenarios are defined âœ… Use cases are identified\n\n## Feature Readiness\nâœ… All functional requirements have clear acceptance criteria âœ… User scenarios cover primary flows âœ… Feature meets measurable outcomes âœ… No implementation details leak into specification\n\n## Edge Cases\nâœ… Nine edge case scenarios documented covering:\n- Concurrent editing conflicts\n- Network issues and offline scenarios\n- Data volume and pagination\n- Team management edge cases\n- Authorization failures\n\n## Validation Summary\nStatus: âœ… PASSED - All quality criteria met\n\nThis specification is ready for /speckit.plan\n\n```\n\n![Specification validated](/images/spec-kit/workflow-04a-specify-validation.png) *The specification quality checklist confirms all criteria are met*\n\n**Why this matters**: The validation catches common spec issues before you invest time in planning:\n\n- Missing acceptance criteria\n- Vague requirements that canâ€™t be tested\n- Implementation details leaking into the spec\n- Edge cases not considered\n\n## Step 4: Generate the technical plan\n\nNow the AI takes our spec and creates a technical plan. This is where we decide **how** to build it.\n\n### Running the plan command\n\n``` /speckit.plan\n\n```\n\n![Running the plan command](/images/spec-kit/workflow-06-plan-command.png) *The AI analyzes the spec and generates the technical plan*\n\nThe AI will generate several artifacts in the `/specs/001-team-task-manager/` directory:\n\n1. `requirements.md`\n- Detailed functional requirements and acceptance criteria\n2. `checklist.md`\n- Quality validation checklist\n3. `plan.md`\n- Overall technical architecture\n4. `data-model.md`\n- Database schema design\n5. `contracts.md`\n- API contracts and endpoint specifications\n\n![Generated plan files](/images/spec-kit/workflow-07-plan-files.png) *All generated planning artifacts shown in the VS Code file explorer*\n\nThe requirements.md contains the complete breakdown of functional requirements with Given-When-Then scenarios, while the checklist validates specification quality. The contracts.md defines all API endpoints, request/response schemas, and integration points before moving forward with implementation.\n\n### Real example: Generated plan.md\n\nThe AI produces something like this:\n\n```\n# Technical Plan: Team Task Manager\n\n## Technology Stack\n\n### Backend\n- **Framework**: .NET 9\n- **Language**: C# 13\n- **Authentication**: ASP.NET Core Identity\n- **Database ORM**: Entity Framework Core 9\n- **Validation**: FluentValidation\n- **Testing**: xUnit + Moq\n\n### Frontend\n- **Framework**: Blazor Server\n- **UI Components**: Bootstrap 5 or MudBlazor\n\n### Database\n- **Primary**: SQL Server 2022 or PostgreSQL 16+\n- **Schema Migrations**: EF Core Migrations\n- **Connection Pooling**: Built-in connection pooling\n\n### Infrastructure\n- **Containerization**: Docker + Docker Compose\n- **Web Server**: Kestrel (built-in)\n- **Environment Config**: appsettings.json + User Secrets\n\n---\n\n## Architecture Overview\n\nThe application follows a traditional three-tier architecture:\n\n**Presentation Layer**\n- Blazor Server (server-side rendering)\n- Standard HTTP requests\n\n**Application Layer**\n- .NET 9 Web Application\n- ASP.NET Core Identity for authentication\n- API Controllers for REST endpoints\n\n**Data Layer**\n- Entity Framework Core 9\n- SQL Server or PostgreSQL database\n\n---\n\n## Database Schema\n\nSee `data-model.md` for complete Entity Framework model.\n\n### Key Entities\n- `User` - User accounts (ASP.NET Identity)\n- `Team` - Team workspaces\n- `TeamMember` - Many-to-many relationship\n- `Task` - Task data\n\n### Indexes\n- `User.Email` (unique)\n- `Team.Name` (unique)\n- `Task.TeamId` (for filtering)\n- `Task.AssignedToId` (for user task views)\n- `Task.Status` (for status filters)\n\n---\n\n## API Design\n\n### RESTful Endpoints\n\n#### Authentication\n- Built-in ASP.NET Core Identity pages\n- `/Account/Register` - Create new user\n- `/Account/Login` - Login existing user\n- `/Account/Logout` - Logout user\n\n#### Teams\n- `GET /api/teams` - List user's teams\n- `POST /api/teams` - Create new team\n- `GET /api/teams/{id}` - Get team details\n- `PUT /api/teams/{id}` - Update team\n- `DELETE /api/teams/{id}` - Delete team\n- `POST /api/teams/{id}/invite` - Invite member\n- `DELETE /api/teams/{id}/members/{userId}` - Remove member\n\n#### Tasks\n- `GET /api/teams/{teamId}/tasks` - List team tasks\n- `POST /api/teams/{teamId}/tasks` - Create task\n- `GET /api/tasks/{id}` - Get task details\n- `PUT /api/tasks/{id}` - Update task\n- `DELETE /api/tasks/{id}` - Delete task\n\n---\n\n## Security Implementation\n\n### Authentication Flow\n1. User submits credentials\n2. ASP.NET Core Identity validates\n3. Authentication cookie created\n4. Authorization policies check on each request\n\n### Authorization Policy\n```csharp // Verify user belongs to team public class TeamMemberRequirement : IAuthorizationRequirement { public string TeamIdClaimType { get; set; } = \"TeamId\"; }\n\npublic class TeamMemberHandler : AuthorizationHandler<TeamMemberRequirement> { private readonly AppDbContext _context;\n\npublic TeamMemberHandler(AppDbContext context) { _context = context; }\n\nprotected override async Task HandleRequirementAsync( AuthorizationHandlerContext context, TeamMemberRequirement requirement) { var userId = context.User.FindFirstValue(ClaimTypes.NameIdentifier); var teamId = context.User.FindFirstValue(requirement.TeamIdClaimType);\n\nif (userId == null || teamId == null) { return; }\n\nvar isMember = await _context.TeamMembers .AnyAsync(tm => tm.UserId == userId && tm.TeamId == teamId);\n\nif (isMember) { context.Succeed(requirement); } } }\n\n```\n\n## Testing Strategy\n\n### Unit Tests\n\n- Business logic functions\n- Utility helpers\n- React hooks\n\n### Integration Tests\n\n- API endpoints\n- Database operations\n- WebSocket events\n\n### E2E Tests\n\n- User registration flow\n- Task creation and completion\n- Team invitation flow\n\n### Test Coverage Targets\n\n- Business logic: 90%+\n- API routes: 80%+\n- UI components: 70%+\n\n## Deployment Plan\n\n### Development\n\n``` docker-compose up\n\n```\n\n### Production Considerations\n\n- Environment variables via secrets\n- Database connection pooling\n- Rate limiting on auth endpoints\n- CORS configured for production domain\n- Logging to stdout (12-factor app)\n\n## Open Questions\n\n1. **Email service**: Use SendGrid, AWS SES, or Mailgun?\n2. **File storage**: Do we need task attachments? (Not in spec)\n3. **Monitoring**: Application Insights, Datadog, or self-hosted?\n\n*These should be resolved before implementation.*\n\n```\n\n### Generated data-model.md\n\n```markdown\n# Data Model: Team Task Manager\n\n## Entity Framework Core Models\n\n```csharp // Models/User.cs public class User : IdentityUser { public string DisplayName { get; set; } = string.Empty; public string? AvatarUrl { get; set; } public DateTime CreatedAt { get; set; } = DateTime.UtcNow; public DateTime? LastLoginAt { get; set; }\n\n// Navigation properties public ICollection<TeamMember> TeamMemberships { get; set; } = new List<TeamMember>(); public ICollection<Task> CreatedTasks { get; set; } = new List<Task>(); public ICollection<Task> AssignedTasks { get; set; } = new List<Task>(); public ICollection<Team> OwnedTeams { get; set; } = new List<Team>(); }\n\n// Models/Team.cs public class Team { public string Id { get; set; } = Guid.NewGuid().ToString(); public string Name { get; set; } = string.Empty; public string OwnerId { get; set; } = string.Empty; public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n// Navigation properties public User Owner { get; set; } = null!; public ICollection<TeamMember> Members { get; set; } = new List<TeamMember>(); public ICollection<Task> Tasks { get; set; } = new List<Task>(); }\n\n// Models/TeamMember.cs public class TeamMember { public string Id { get; set; } = Guid.NewGuid().ToString(); public string TeamId { get; set; } = string.Empty; public string UserId { get; set; } = string.Empty; public Role Role { get; set; } = Role.Member; public DateTime JoinedAt { get; set; } = DateTime.UtcNow;\n\n// Navigation properties public Team Team { get; set; } = null!; public User User { get; set; } = null!; }\n\n// Models/Task.cs public class Task { public string Id { get; set; } = Guid.NewGuid().ToString(); public string Title { get; set; } = string.Empty; public string? Description { get; set; } public TaskStatus Status { get; set; } = TaskStatus.Open; public string TeamId { get; set; } = string.Empty; public string CreatedById { get; set; } = string.Empty; public string? AssignedToId { get; set; } public DateTime? DueDate { get; set; } public DateTime CreatedAt { get; set; } = DateTime.UtcNow; public DateTime UpdatedAt { get; set; } = DateTime.UtcNow; public DateTime? CompletedAt { get; set; }\n\n// Navigation properties public Team Team { get; set; } = null!; public User CreatedBy { get; set; } = null!; public User? AssignedTo { get; set; } }\n\n// Enums public enum Role { Admin, Member }\n\npublic enum TaskStatus { Open, InProgress, Completed }\n\n```\n\n## Relationships\n\n**User to Team** (Many-to-Many via TeamMember)\n\n- A user can belong to multiple teams\n- A team can have multiple users\n\n**Team to Task** (One-to-Many)\n\n- A team has many tasks\n- Each task belongs to one team\n\n**User to Task** (Multiple relationships)\n\n- A user creates many tasks (CreatedBy)\n- A user can be assigned many tasks (AssignedTo)\n- Each task has one creator and optionally one assignee\n\n## Indexes\n\n### Performance-critical\n\n- `tasks.teamId`\n- Filtering tasks by team\n- `tasks.assignedToId`\n- User task views\n- `tasks.status`\n- Status filtering\n\n### Uniqueness constraints\n\n- `users.email`\n- One account per email\n- `teams.name`\n- Unique team names\n- `team_members.[teamId, userId]`\n- No duplicate memberships\n\n## Migration strategy\n\n```\n# Create initial migration\ndotnet ef migrations add InitialCreate\n\n# Apply to database\ndotnet ef database update\n\n# Seed demo data\ndotnet run --seed\n\n```\n\n**Production**: Always backup before applying migrations\n\n```\n\n### Why these generated plans work\n\nThe AI has:\n\n1. **Made concrete technology choices**: React, Express, PostgreSQL (aligned with constitution)\n2. **Designed the data model**: Prisma schema with relationships\n3. **Specified API contracts**: Every endpoint documented\n4. **Included security patterns**: Middleware examples\n5. **Identified open questions**: Decisions that need human input\n\n**This is where you review carefully.** Does the tech stack make sense? Are there better options? Now's the time to adjust.\n\n---\n\n## Step 5: Break down into tasks\n\nNow we convert the plan into implementable tasks.\n\n### Running the tasks command\n\n```\n\n/speckit.tasks\n\n```\n\nThe AI generates `tasks.md` with **137 ordered, actionable tasks** organized by user story.\n\nHere's how the AI structures the implementation:\n\n```markdown\n# Tasks: Team Task Manager\n\n**Organization**: Tasks are grouped by user story to enable independent implementation and testing of each story.\n\n## Format: `- [ ] [ID] [P?] [Story?] Description`\n\n- **[P]**: Can run in parallel (different files, no dependencies)\n- **[Story]**: Which user story this task belongs to (e.g., US1, US2)\n\n---\n\n## Phase 1: Setup (Shared Infrastructure)\n\n**Purpose**: Project initialization and basic structure\n\n- [ ] T001 Create .NET 9 solution with TeamTaskManager project and test project\n- [ ] T002 Configure project settings: enable nullable reference types\n- [ ] T003 [P] Add NuGet packages: EF Core, Npgsql, Identity\n- [ ] T004 [P] Create EditorConfig with StyleCop.Analyzers configuration\n- [ ] T005 [P] Create docker-compose.yml with PostgreSQL service\n- [ ] T006 [P] Create Dockerfile with multi-stage build\n- [ ] T007 Create directory structure: Components, Models, Data, Services, Auth\n- [ ] T008 Create appsettings.json with connection string placeholders\n- [ ] T009 Create .gitignore excluding appsettings.Development.json\n\n---\n\n## Phase 2: Foundational (Blocking Prerequisites)\n\n**Purpose**: Core infrastructure that MUST be complete before ANY user story\n\nâš ï¸ **CRITICAL**: No user story work can begin until this phase is complete\n\n- [ ] T010 Create User entity model with all properties from data-model.md\n- [ ] T011 Create Team entity model with all properties\n- [ ] T012 [P] Create Task entity with Status enum and RowVersion for concurrency\n- [ ] T013 [P] Create TeamMembership entity with Role enum\n- [ ] T014 [P] Create TeamInvitation entity with Status enum\n- [ ] T015 [P] Create AuditLog entity model\n- [ ] T016 Create ApplicationDbContext extending IdentityDbContext<User>\n- [ ] T017 Configure entity relationships using Fluent API per data-model.md\n- [ ] T018 Create indexes: Task(TeamId,Status), TeamMembership(TeamId,UserId)\n- [ ] T019 Create initial EF Core migration: dotnet ef migrations add InitialCreate\n- [ ] T020 Configure ASP.NET Core Identity with password requirements\n- [ ] T021 Configure authentication: AddIdentity, cookie settings (24hr expiration)\n- [ ] T022 Create custom AuthenticationStateProvider for Blazor\n- [ ] T023 [P] Create IRepository<T> interface\n- [ ] T024 [P] Create Repository<T> implementation with async methods\n- [ ] T025 Configure error handling middleware\n- [ ] T026 Configure structured logging using ILogger<T>\n- [ ] T027 Configure rate limiting middleware per API specification\n- [ ] T028 Create MainLayout.razor with navigation and auth state\n- [ ] T029 Create NavMenu.razor with conditional rendering\n- [ ] T030 Configure SignalR hub with connection timeout and group support\n\n**Checkpoint**: Foundation ready - user story implementation can now begin in parallel\n\n---\n\n## Phase 3: User Story 2 - User Authentication (Priority: P1) ğŸ¯ MVP Foundation\n\n**Goal**: Enable secure user sign-up, login, and password recovery\n\n**Independent Test**: Sign up with email, log in, reset password, verify rate limiting\n\n**Why First**: Authentication is foundational - required before collaborative features\n\n### Implementation for User Story 2\n\n- [ ] T031 [P] [US2] Create Register.razor page with email/password form\n- [ ] T032 [P] [US2] Create Login.razor page with email/password form\n- [ ] T033 [P] [US2] Create ForgotPassword.razor page with email input\n- [ ] T034 [P] [US2] Create ResetPassword.razor page with token validation\n- [ ] T035 [US2] Create AuthService with RegisterAsync, LoginAsync, LogoutAsync\n- [ ] T036 [US2] Implement email confirmation using ASP.NET Core Identity tokens\n- [ ] T037 [US2] Implement password reset with 24-hour token expiration\n- [ ] T038 [US2] Implement rate limiting: 5 attempts, 15-minute lockout\n- [ ] T039 [US2] Add session expiration: 24-hour absolute expiration\n- [ ] T040 [US2] Create AuditService with LogAsync method\n- [ ] T041 [US2] Add audit logging for authentication events\n- [ ] T042 [US2] Create IEmailService interface\n- [ ] T043 [US2] Create SendGridEmailService implementation\n- [ ] T044 [US2] Add email templates for confirmation and password reset\n- [ ] T045 [US2] Wire up Register page to AuthService with validation\n- [ ] T046 [US2] Wire up Login page with error handling\n- [ ] T047 [US2] Wire up ForgotPassword and ResetPassword pages\n- [ ] T048 [US2] Add redirect to preserved destination after login\n- [ ] T049 [US2] Create API endpoints: POST /api/auth/register, /login, /logout\n\n**Checkpoint**: Users can sign up, log in, reset passwords securely\n\n---\n\n## Phase 4: User Story 1 - Task Management Core (Priority: P1) ğŸ¯ MVP\n\n**Goal**: Enable task creation, assignment, editing, and completion\n\n**Independent Test**: Create task, edit description, mark complete, verify timestamp\n\n**Why Second**: Core value proposition - delivers immediate task tracking\n\n### Implementation for User Story 1\n\n- [ ] T050 [P] [US1] Create TaskCard.razor component\n- [ ] T051 [P] [US1] Create TaskDetailModal.razor for editing\n- [ ] T052 [P] [US1] Create NewTaskModal.razor for creating tasks\n- [ ] T053 [US1] Create Tasks.razor page with task list view\n- [ ] T054 [US1] Create TaskService with CRUD methods\n- [ ] T055 [US1] Implement CreateTaskAsync with validation\n- [ ] T056 [US1] Implement UpdateTaskAsync with optimistic concurrency using RowVersion\n- [ ] T057 [US1] Implement CompleteTaskAsync setting CompletedAt timestamp\n- [ ] T058 [US1] Implement DeleteTaskAsync with creator-only authorization\n- [ ] T059 [US1] Add authorization: only creator/assignee can edit\n- [ ] T060 [US1] Implement real-time task broadcast using SignalR (< 2 seconds)\n- [ ] T061 [US1] Add audit logging for task operations\n- [ ] T062 [US1] Wire up Tasks.razor to TaskService with data loading\n- [ ] T063 [US1] Wire up NewTaskModal with form validation\n- [ ] T064 [US1] Wire up TaskDetailModal with concurrency conflict handling\n- [ ] T065 [US1] Add checkbox for marking complete\n- [ ] T066 [US1] Implement SignalR hub subscription for real-time updates\n- [ ] T067 [US1] Add \"New Task\" button opening NewTaskModal\n- [ ] T068 [US1] Handle concurrent edit conflict: show notification with conflicting user\n- [ ] T069 [US1] Create API endpoints: GET/POST /api/teams/{teamId}/tasks, etc.\n\n**Checkpoint**: Users can create, assign, edit, complete tasks with real-time updates\n\n---\n\n## Phase 5: User Story 3 - Team Collaboration (Priority: P2)\n\n**Goal**: Enable team creation, member invitations, and membership management\n\n**Why Third**: Enables collaboration; builds on tasks and auth\n\n- [ ] T070-T094 [US3] Team management implementation (25 tasks)\n- Create Teams.razor, TeamSettings.razor, invitation flows\n- Implement TeamService and MembershipService\n- Email invitations with 7-day expiration\n- Auto-promote oldest member when last admin leaves\n- Handle edge cases: duplicate invitations, expired tokens\n\n**Checkpoint**: Users can create teams, invite members, manage membership\n\n---\n\n## Phase 6: User Story 4 - Task Filtering (Priority: P2)\n\n**Goal**: Enable filtering by assignee, status, and creator\n\n- [ ] T095-T106 [US4] Filtering implementation (12 tasks)\n- Create TaskFilters.razor component\n- Implement instant filtering without page reload\n- Add pagination for completed tasks (50 per page)\n- Optimize queries using database indexes\n\n**Checkpoint**: Users can filter tasks instantly by multiple criteria\n\n---\n\n## Phase 7: User Story 5 - Responsive Interface (Priority: P3)\n\n**Goal**: Ensure mobile, tablet, and desktop layouts work seamlessly\n\n- [ ] T107-T117 [US5] Responsive UI implementation (11 tasks)\n- Mobile-first CSS with 768px and 1024px breakpoints\n- Touch-optimized buttons (44px minimum)\n- Hamburger menu for mobile navigation\n- Test across device sizes\n\n**Checkpoint**: Application works on all device sizes\n\n---\n\n## Phase 8: Polish & Cross-Cutting Concerns\n\n**Purpose**: Final quality, security hardening, performance optimization\n\n- [ ] T118-T137 Polish tasks (20 tasks)\n- Health check endpoint\n- CORS, HTTPS, anti-forgery tokens\n- Input sanitization for XSS prevention\n- Database query optimization\n- Caching with IMemoryCache\n- Performance testing: < 2s page load, < 500ms API\n- OWASP Top 10 security review\n\n---\n\n## Task count summary\n\n- **Phase 1 (Setup)**: 9 tasks\n- **Phase 2 (Foundational)**: 21 tasks â† Critical path\n- **Phase 3 (US2 - Auth)**: 19 tasks â† P1 (MVP Foundation)\n- **Phase 4 (US1 - Tasks)**: 20 tasks â† P1 (MVP Core)\n- **Phase 5 (US3 - Teams)**: 25 tasks â† P2\n- **Phase 6 (US4 - Filtering)**: 12 tasks â† P2\n- **Phase 7 (US5 - Responsive)**: 11 tasks â† P3\n- **Phase 8 (Polish)**: 20 tasks â† Cross-cutting\n\n**Total**: 137 tasks\n\n**MVP Scope (Phases 1-5)**: 94 tasks (~69% of total)\n\n---\n\n## Dependencies and execution order\n\n```\n\nFoundational (Phase 2) â†“ US2: Auth (Phase 3) â† MVP Foundation â†“ US1: Tasks (Phase 4) â† MVP Core + US3: Teams (Phase 5) â† Can parallelize â†“ US4: Filtering (Phase 6) â† Enhances US1 â†“ US5: Responsive (Phase 7) â† Enhances all UIs â†“ Polish (Phase 8)\n\n```\n\n**Recommended Order**: Setup â†’ Foundational â†’ US2 â†’ US3 â†’ US1 â†’ US4 â†’ US5 â†’ Polish\n\n**MVP Milestone**: Phases 1-5 = Basic task management with teams\n\n---\n\n## Parallel opportunities\n\n**Phase 1 (Setup)**: T003-T006 can run in parallel **Phase 2 (Foundational)**: T012-T015 (entity models), T023-T024 (repositories) **Phase 3 (US2)**: T031-T034 (all auth pages) at start **Phase 4 (US1)**: T050-T052 (all task components) at start **Phase 8 (Polish)**: Most tasks (T118-T128) can parallelize\n\n---\n\n## Implementation strategy\n\n### MVP First (2-3 weeks for single developer)\n\n1. **Week 1**: Setup + Foundational â†’ 2-3 days\n2. **Week 1-2**: User Story 2 (Auth) â†’ 3-4 days\n3. **Week 2**: User Story 3 (Teams) â†’ 2-3 days\n4. **Week 2-3**: User Story 1 (Tasks) â†’ 3-4 days\n5. **VALIDATE MVP**: Can users sign up, create teams, manage tasks?\n\n**Deploy at this point** - Core value delivered\n\n### Incremental Delivery\n\n1. **Foundation** â†’ Infrastructure ready\n2. **MVP** (US2, US3, US1) â†’ Users, teams, tasks working â†’ **DEPLOY**\n3. **Enhancement 1** (US4) â†’ Task filtering â†’ **DEPLOY**\n4. **Enhancement 2** (US5) â†’ Responsive UI â†’ **DEPLOY**\n5. **Polish** â†’ Performance, security hardening â†’ **DEPLOY**\n\n```\n\n![Generated tasks](/images/spec-kit/workflow-09-tasks-file.png) *The tasks.md file showing phased implementation with dependencies*\n\n### Why this breakdown works\n\nEach task:\n\n1. **Has clear dependencies**: Wonâ€™t fail due to missing prerequisites\n2. **Is independently testable**: Can verify completion\n3. **Has acceptance criteria**: We know when itâ€™s done\n4. **Is sized appropriately**: Can be completed in 2-4 hours\n\n## Step 6: Implementation\n\nFinally, we implement. This is where the AI writes code.\n\n### Running the implement command\n\n``` /speckit.implement\n\n```\n\n![Running the implement command](/images/spec-kit/workflow-10-implement-start.png) *Starting the implementation phase*\n\nThe AI will:\n\n1. Load constitution, spec, plan, and tasks\n2. Execute tasks in order\n3. Create files, write code, run tests\n4. Report progress after each task\n\n![Implementation in progress](/images/spec-kit/workflow-11-implement-progress.png) *The AI creating files and implementing tasks with progress updates*\n\n### What the AI generates\n\n![Generated code structure](/images/spec-kit/workflow-12-generated-code.png) *The complete project structure after implementation*\n\nHereâ€™s a sample of generated code:\n\n#### Backend: Task creation endpoint\n\n``` using Microsoft.AspNetCore.SignalR; using Microsoft.EntityFrameworkCore; using TeamTaskManager.Data; using TeamTaskManager.Hubs; using TeamTaskManager.Models;\n\nnamespace TeamTaskManager.Services;\n\npublic class TaskService { private readonly ApplicationDbContext _context; private readonly IHubContext<TaskHub> _hubContext; private readonly AuditService _auditService; private readonly IHttpContextAccessor _httpContextAccessor;\n\npublic TaskService( ApplicationDbContext context, IHubContext<TaskHub> hubContext, AuditService auditService, IHttpContextAccessor httpContextAccessor) { _context = context; _hubContext = hubContext; _auditService = auditService; _httpContextAccessor = httpContextAccessor; }\n\npublic async System.Threading.Tasks.Task<Models.Task> CreateTaskAsync(Models.Task task) { try { _context.Tasks.Add(task); await _context.SaveChangesAsync();\n\n// Load related entities for SignalR broadcast await _context.Entry(task).Reference(t => t.Creator).LoadAsync(); await _context.Entry(task).Reference(t => t.Assignee).LoadAsync();\n\n// Log audit event await _auditService.LogAsync( \"TaskCreated\", task.CreatorId, GetClientIpAddress(), new { TaskId = task.Id, Title = task.Title, TeamId = task.TeamId } );\n\n// Broadcast to team members via SignalR (within 2 seconds per FR-028) if (task.TeamId.HasValue) { await _hubContext.Clients.Group($\"team_{task.TeamId.Value}\") .SendAsync(\"TaskCreated\", task); }\n\nreturn task; } catch (Exception ex) { throw new ApplicationException($\"Failed to create task: {ex.Message}\", ex); } }\n\npublic async System.Threading.Tasks.Task<Models.Task> UpdateTaskAsync(Models.Task task) { try { var existingTask = await _context.Tasks .Include(t => t.Creator) .Include(t => t.Assignee) .FirstOrDefaultAsync(t => t.Id == task.Id);\n\nif (existingTask == null) { throw new InvalidOperationException(\"Task not found\"); }\n\n// Optimistic concurrency check using RowVersion (per FR-043, FR-044) if (existingTask.RowVersion != null && task.RowVersion != null && !existingTask.RowVersion.SequenceEqual(task.RowVersion)) { throw new DbUpdateConcurrencyException(\"Task was modified by another user. Please refresh and try again.\"); }\n\n// Update fields existingTask.Title = task.Title; existingTask.Description = task.Description; existingTask.Status = task.Status; existingTask.DueDate = task.DueDate; existingTask.UpdatedAt = DateTime.UtcNow; existingTask.AssigneeId = task.AssigneeId;\n\nif (task.Status == Models.TaskStatus.Completed && !existingTask.CompletedAt.HasValue) { existingTask.CompletedAt = DateTime.UtcNow; }\n\nawait _context.SaveChangesAsync();\n\n// Log audit event await _auditService.LogAsync( \"TaskUpdated\", task.CreatorId, GetClientIpAddress(), new { TaskId = task.Id, Title = task.Title, Status = task.Status } );\n\n// Broadcast to team members via SignalR if (existingTask.TeamId.HasValue) { await _hubContext.Clients.Group($\"team_{existingTask.TeamId.Value}\") .SendAsync(\"TaskUpdated\", existingTask);\n\nif (existingTask.Status == Models.TaskStatus.Completed) { await _hubContext.Clients.Group($\"team_{existingTask.TeamId.Value}\") .SendAsync(\"TaskCompleted\", existingTask); } }\n\nreturn existingTask; } catch (DbUpdateConcurrencyException) { throw; // Rethrow concurrency exceptions as-is } catch (Exception ex) { throw new ApplicationException($\"Failed to update task: {ex.Message}\", ex); } }\n\npublic async System.Threading.Tasks.Task DeleteTaskAsync(int taskId) { try { var task = await _context.Tasks.FindAsync(taskId);\n\nif (task == null) { throw new InvalidOperationException(\"Task not found\"); }\n\nvar teamId = task.TeamId; var creatorId = task.CreatorId;\n\n_context.Tasks.Remove(task); await _context.SaveChangesAsync();\n\n// Log audit event await _auditService.LogAsync( \"TaskDeleted\", creatorId, GetClientIpAddress(), new { TaskId = taskId, TeamId = teamId } );\n\n// Broadcast to team members via SignalR if (teamId.HasValue) { await _hubContext.Clients.Group($\"team_{teamId.Value}\") .SendAsync(\"TaskDeleted\", taskId); } } catch (Exception ex) { throw new ApplicationException($\"Failed to delete task: {ex.Message}\", ex); } }\n\npublic async System.Threading.Tasks.Task<Models.Task?> GetTaskByIdAsync(int taskId) { return await _context.Tasks .Include(t => t.Creator) .Include(t => t.Assignee) .Include(t => t.Team) .FirstOrDefaultAsync(t => t.Id == taskId); }\n\npublic async System.Threading.Tasks.Task<List<Models.Task>> GetUserTasksAsync(string userId) { return await _context.Tasks .Include(t => t.Creator) .Include(t => t.Assignee) .Include(t => t.Team) .Where(t => t.CreatorId == userId || t.AssigneeId == userId) .OrderBy(t => t.Status) .ThenByDescending(t => t.CreatedAt) .ToListAsync(); }\n\npublic async System.Threading.Tasks.Task<List<Models.Task>> GetTeamTasksAsync(int teamId) { return await _context.Tasks .Include(t => t.Creator) .Include(t => t.Assignee) .Where(t => t.TeamId == teamId) .OrderBy(t => t.Status) .ThenByDescending(t => t.CreatedAt) .ToListAsync(); }\n\nprivate string? GetClientIpAddress() { var httpContext = _httpContextAccessor.HttpContext;\n\nif (httpContext == null) { return null; }\n\nvar forwardedFor = httpContext.Request.Headers[\"X-Forwarded-For\"].FirstOrDefault(); if (!string.IsNullOrEmpty(forwardedFor)) { return forwardedFor.Split(',')[0].Trim(); }\n\nreturn httpContext.Connection.RemoteIpAddress?.ToString(); } }\n\n```\n\n#### Frontend: Task list component\n\n```cshtml @using TeamTaskManager.Models @using TaskStatus = TeamTaskManager.Models.TaskStatus\n\n<div class=\"card mb-3 task-card\" @onclick=\"OnTaskClick\"> <div class=\"card-body\"> <div class=\"d-flex justify-content-between align-items-start\"> <h6 class=\"card-title mb-2\">@Task.Title</h6> <span class=\"badge @GetStatusBadgeClass()\">@Task.Status</span> </div>\n\n@if (!string.IsNullOrEmpty(Task.Description)) { <p class=\"card-text text-muted small mb-2\"> @(Task.Description.Length > 100 ? Task.Description.Substring(0, 100) + \"...\" : Task.Description) </p> }\n\n<div class=\"d-flex justify-content-between align-items-center\"> <small class=\"text-muted\"> @if (Task.DueDate.HasValue) { <i class=\"bi bi-calendar\"></i> <span class=\"@(Task.DueDate.Value < DateTime.UtcNow && Task.Status != TaskStatus.Completed ? \"text-danger\" : \"\")\"> @Task.DueDate.Value.ToString(\"MMM d, yyyy\") </span> } </small>\n\n@if (Task.Assignee != null) { <small class=\"text-muted\"> <i class=\"bi bi-person\"></i> @Task.Assignee.DisplayName </small> } </div> </div> </div>\n\n@code { [Parameter] public TeamTaskManager.Models.Task Task { get; set; } = default!;\n\n[Parameter] public Action? OnTaskClick { get; set; }\n\nprivate string GetStatusBadgeClass() { return Task.Status switch { TaskStatus.Open => \"bg-secondary\", TaskStatus.InProgress => \"bg-primary\", TaskStatus.Completed => \"bg-success\", _ => \"bg-secondary\" }; } }\n\n<style> .task-card { cursor: pointer; transition: box-shadow 0.2s; }\n\n.task-card:hover { box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15); } </style>\n\n```\n\n### The AIâ€™s process\n\nFor each task in `tasks.md` , the AI:\n\n1. **Reads the requirements** from spec and plan\n2. **Generates code** following the constitutionâ€™s standards\n3. **Runs tests** to verify correctness\n4. **Reports completion** before moving to next task\n\nIf tests fail, the AI debugs and fixes automatically.\n\n![Implementation complete](/images/spec-kit/workflow-13-implementation-complete.png) *All tasks completed and verified*\n\n## Validation and testing\n\nAfter implementation, you must test the application yourself.\n\n### Critical testing checklist\n\n- Run the application locally\n- Open browser developer console\n- Test each user story from the spec\n- Try edge cases (empty inputs, network errors)\n- Check performance (response times)\n- Verify security (canâ€™t access other teamsâ€™ data)\n\n### If you find bugs\n\nDonâ€™t just say â€œitâ€™s broken.â€ Provide rich context:\n\n``` /implement fix bug: When creating a task without an assignee, the API returns 500 error with \"Cannot read property 'id' of null\" in tasks.ts line 47.\n\nExpected: Task should be created with null assignedToId Actual: Server crashes\n\nStack trace: TypeError: Cannot read property 'id' of null at /api/routes/tasks.ts:47:35\n\n```\n\nThe AI will:\n\n1. Fix the bug\n2. Add a test case for it\n3. Update the plan/tasks if needed\n\n## Handling spec changes\n\nWhat if requirements change mid-development?\n\n### The workflow\n\n1. **Update the spec**: Edit `.speckit/spec.md`\nwith new requirements\n2. **Regenerate plan**: Run `/speckit.plan`\nagain\n3. **Regenerate tasks**: Run `/speckit.tasks`\nagain\n4. **Continue implementation**: Run `/speckit.implement`\n(skips completed tasks)\n\n### Example: Adding task comments\n\nOriginal spec didnâ€™t include comments. User asks for them.\n\n#### Step 1: Update spec\n\nAdd to `.speckit/spec.md` :\n\n```\n### Task Comments\n\n**As a team member**, I want to:\n- Add comments to tasks\n- See all comments with timestamps\n- Edit or delete my own comments\n\n**Acceptance Criteria:**\n- Comments appear in real-time\n- Comments support basic Markdown\n- Comments preserved when task completed\n\n```\n\n#### Step 2: Regenerate plan\n\n``` /speckit.plan\n\n```\n\nAI updates `data-model.md` :\n\n```prisma model Comment { id String @id @default(uuid()) taskId String userId String content String createdAt DateTime @default(now()) updatedAt DateTime @updatedAt\n\ntask Task @relation(fields: [taskId], references: [id], onDelete: Cascade) user User @relation(fields: [userId], references: [id])\n\n@@map(\"comments\") }\n\nmodel Task { // ... existing fields comments Comment[] }\n\n```\n\nAnd adds to `plan.md` :\n\n```\n#### Comments\n- `GET /api/tasks/:id/comments` - List task comments\n- `POST /api/tasks/:id/comments` - Add comment\n- `PUT /api/comments/:id` - Edit comment\n- `DELETE /api/comments/:id` - Delete comment\n\n```\n\n#### Step 3: Regenerate tasks\n\n``` /speckit.tasks\n\n```\n\nAI adds new tasks:\n\n```\n## Phase 11: Task Comments\n- [ ] 11.1 Add Comment model to Prisma schema\n- [ ] 11.2 Run migration\n- [ ] 11.3 Create comments API endpoints\n- [ ] 11.4 Add comments UI component\n- [ ] 11.5 Implement real-time comment updates\n\n**Dependencies**: 9.1-9.5 **Acceptance**: Users can add, edit, delete comments\n\n```\n\n#### Step 4: Continue implementation\n\n``` /speckit.implement\n\n```\n\nAI implements only the new tasks (skips already completed ones).\n\n## Best practices recap\n\n### 1. Constitution: Start strict, relax later\n\nItâ€™s easier to remove constraints than add them. Start with:\n\n- **Specific tech stack requirements**\n- **Performance targets with numbers**\n- **Explicit non-goals**\n\n### 2. Spec: Be exhaustively detailed\n\nDonâ€™t assume the AI knows what you want. Include:\n\n- **Every user action**\n- **Every edge case**\n- **Every error message**\n- **Visual mockups** (even sketches help)\n\n### 3. Plan: Review carefully\n\nThis is your last chance before code generation. Check:\n\n- **Is the tech stack appropriate?**\n- **Are there better framework choices?**\n- **Is the database schema normalized?**\n- **Are APIs RESTful and consistent?**\n\n### 4. Tasks: Verify dependencies\n\nMake sure:\n\n- **Tasks are ordered correctly**\n- **Dependencies are accurate**\n- **Each task has acceptance criteria**\n- **Tasks are small enough** (2-4 hours each)\n\n### 5. Implementation: Test ruthlessly\n\nAfter every major phase:\n\n- **Run the application**\n- **Test in the browser**\n- **Check for console errors**\n- **Verify performance**\n\n## Common pitfalls and how to avoid them\n\n### Pitfall #1: Vague specifications\n\nâŒ **Bad**:\n\n``` Build a task manager with teams\n\n```\n\nâœ… **Good**:\n\n```\n## User Story: Team Creation\n\nAs a user, I want to create a new team by:\n1. Clicking \"New Team\" button\n2. Entering team name (3-50 chars, alphanumeric)\n3. Seeing confirmation \"Team created\"\n\n**Acceptance Criteria:**\n- Team name must be unique\n- Creator becomes admin automatically\n- Team appears in sidebar immediately\n- Error shown if name taken: \"Team name already exists\"\n\n```\n\n### Pitfall #2: Over-engineering early\n\nâŒ **Bad constitution**:\n\n``` Must use microservices with event sourcing\n\n```\n\nâœ… **Good constitution**:\n\n``` Start with monolithic architecture Consider microservices only if:\n- Team exceeds 10 developers\n- System exceeds 10k users\n- Performance becomes bottleneck\n\n```\n\n### Pitfall #3: Ignoring AI suggestions\n\nThe AI might suggest better approaches. Donâ€™t dismiss them automatically.\n\n**Example**: AI suggests caching frequently accessed data. Even if not in spec, itâ€™s worth considering.\n\n### Pitfall #4: Not testing increments\n\nDonâ€™t wait until the end to test. Test after each phase:\n\n- **Phase 3 done?** Test authentication\n- **Phase 5 done?** Test task CRUD\n- **Phase 6 done?** Test real-time updates\n\n## Troubleshooting common issues\n\n### Issue: AI generates outdated code\n\n**Symptom**: Uses deprecated APIs or old library versions\n\n**Solution**: In the constitution, specify minimum versions:\n\n```\n## Technical Constraints\n- React >= 18.2 (use new hooks API)\n- Express >= 4.18 (async/await support)\n\n```\n\n### Issue: AI hallucinates functionality\n\n**Symptom**: References functions or libraries that donâ€™t exist\n\n**Solution**: Run `/speckit.analyze` to validate consistency across artifacts\n\n### Issue: Tests fail after implementation\n\n**Symptom**: â€œCannot find moduleâ€ or â€œUnexpected tokenâ€\n\n**Solution**: Check that the AI installed all dependencies. Run:\n\n``` npm install\n# or\nnpm run install:all # if monorepo\n\n```\n\n### Issue: Real-time updates donâ€™t work\n\n**Symptom**: Changes donâ€™t appear for other users\n\n**Solution**: Check WebSocket connection in browser console:\n\n``` // Browser console socket.connected // should be true\n\n```\n\nIf false, verify:\n\n- Server WebSocket port is correct\n- CORS settings allow WebSocket connections\n- Client and server Socket.io versions match\n\n## What weâ€™ve accomplished\n\nBy following the Spec-Kit workflow, we:\n\n1. âœ… Created a comprehensive constitution\n2. âœ… Wrote detailed specifications with user stories\n3. âœ… Generated a complete technical plan\n4. âœ… Broke work into implementable tasks\n5. âœ… Implemented a production-ready application\n\n**Result**: A team task manager with authentication, real-time updates, and tested code - not vibe-coded, but spec-driven.\n\n## Next week: Best practices and troubleshooting\n\nIn Part 3, weâ€™ll dive deeper into:\n\n- **Advanced specification techniques**: How to spec complex workflows\n- **Debugging strategies**: When the AI goes off track\n- **Iteration patterns**: Evolving specs over time\n- **Performance optimization**: Keeping the AI focused and fast\n- **Real-world edge cases**: Lessons from production deployments\n\n### Homework before Part 3\n\nTry the workflow yourself:\n\n1. Pick a small project (simpler than our example)\n2. Write a constitution and spec\n3. Generate a plan\n4. Review it carefully\n5. Note any issues you encounter\n\nWeâ€™ll use your experiences to guide Part 3â€™s content.\n\n## Key takeaways from part 2\n\n1. **Constitution sets boundaries**: Non-negotiable principles guide all decisions\n2. **Specs must be exhaustive**: The more detail, the better the output\n3. **Plans are reviewable**: This is where you catch architectural mistakes\n4. **Tasks create accountability**: Dependencies and acceptance criteria matter\n5. **Implementation requires testing**: AI-generated code needs human validation\n\nNext week in Part 3, weâ€™ll tackle the messy reality of spec-driven development: debugging, iteration, and real-world troubleshooting.\n\n## Resources\n\n- **Spec-Kit GitHub**: [github.com/github/spec-kit](https://github.com/github/spec-kit)\n- **Example Project**: [github.com/hiddedesmet/spec-kit-task-manager](https://github.com/hiddedesmet/spec-kit-task-manager) *(coming soon)*\n- **.NET 9 Documentation**: [learn.microsoft.com/dotnet](https://learn.microsoft.com/dotnet)\n- **Blazor Documentation**: [learn.microsoft.com/aspnet/core/blazor](https://learn.microsoft.com/aspnet/core/blazor)\n- **Entity Framework Core**: [learn.microsoft.com/ef/core](https://learn.microsoft.com/ef/core)\n- **SignalR for Real-Time**: [learn.microsoft.com/aspnet/core/signalr](https://learn.microsoft.com/aspnet/core/signalr)\n\n## Series navigation\n\n- **Previous**: [Part 1 - The problem and the solution](/from-vibe-coding-to-spec-driven-development)\n- **ğŸ“ You are here: Part 2 - The Spec-Kit workflow**\n- **Next**: Part 3 - Best practices and troubleshooting (Coming January 19, 2026)\n- Part 4 - Team collaboration and advanced patterns (Coming January 26, 2026)\n- Part 5 - Case studies and lessons learned (Coming February 2, 2026)\n\n*Have questions about the workflow? Found a bug in the example? Connect with me on [LinkedIn](https://linkedin.com/in/hiddedesmet) or check out more posts at [hiddedesmet.com](https://hiddedesmet.com).*\n\n**Want to get notified when Part 3 drops?** Follow me on [LinkedIn](https://linkedin.com/in/hiddedesmet) for updates.\n\n### Start the conversation\n\n## Related\n\n[See all ai-assisted-development](/tags#ai-assisted-development)\n\n[!\\[From Vibe Coding to Spec-Driven Development: Part 1 - The problem and the solution\\]()](/from-vibe-coding-to-spec-driven-development)\n\n[ai-assisted-development](/tags#ai-assisted-development)\n\n[spec-kit](/tags#spec-kit)\n\n[github](/tags#github)\n\n[claude](/tags#claude)\n\n[copilot](/tags#copilot)\n\n[vibe-coding](/tags#vibe-coding)\n\n[specification-driven-development](/tags#specification-driven-development)\n\n[series](/tags#series)\n\nâ€¢Jan 05, 2026\n\n## [From Vibe Coding to Spec-Driven Development: Part 1 - The problem and the solution](/from-vibe-coding-to-spec-driven-development)\n\nPart 1 of our series on mastering AI-assisted development. Discover why 'vibe coding' gets you only 70% there, and why spec-driven development is the answer. This is your roadmap to production-ready AI-generated code.",
  "Link": "https://hiddedesmet.com/from-vibe-coding-to-spec-driven-development-part2",
  "ProcessedDate": "2026-01-12 12:02:35",
  "FeedName": "Hidde de Smet's Blog"
}
