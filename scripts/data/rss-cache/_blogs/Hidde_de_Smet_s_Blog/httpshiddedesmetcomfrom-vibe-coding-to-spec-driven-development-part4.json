{
  "Tags": [
    "AI",
    "ai-assisted-development",
    "ci-cd",
    "copilot",
    "Development",
    "DevOps",
    "github",
    "series",
    "spec-kit",
    "specification-driven-development",
    "team-collaboration",
    "vibe-coding"
  ],
  "FeedLevelAuthor": "Hidde de Smet",
  "EnhancedContent": "Search for Blog\n\n[ai-assisted-development](/tags#ai-assisted-development)\n\n[spec-kit](/tags#spec-kit)\n\n[github](/tags#github)\n\n[copilot](/tags#copilot)\n\n[vibe-coding](/tags#vibe-coding)\n\n[specification-driven-development](/tags#specification-driven-development)\n\n[series](/tags#series)\n\n[team-collaboration](/tags#team-collaboration)\n\n[ci-cd](/tags#ci-cd)\n\n‚Ä¢ Jan 26, 2026\n\n‚Ä¢\n\n25 min read\n\n# From Vibe Coding to Spec-Driven Development: Part 4 - Team collaboration and advanced patterns\n\nPart 4 of our series on mastering AI-assisted development. Learn how teams collaborate with Spec-Kit, integrate with CI/CD pipelines (GitHub Actions & Azure DevOps), and apply advanced architectural patterns.\n\n[!\\[Hidde de Smet\\]()](/hidde)\n\nWritten by [Hidde de Smet](/hidde)\n\n- https://twitter.com/intent/tweet?text=From%20Vibe%20Coding%20to%20Spec-Driven%20Development:%20Part%204%20-%20Team%20collaboration%20and%20advanced%20patterns&url=https://hiddedesmet.com/from-vibe-coding-to-spec-driven-development-part4\n- https://www.facebook.com/sharer/sharer.php?u=https://hiddedesmet.com/from-vibe-coding-to-spec-driven-development-part4\n- http://pinterest.com/pin/create/button/?url=https://hiddedesmet.com/from-vibe-coding-to-spec-driven-development-part4&amp;media=https://hiddedesmet.com/images/spec-kit/image-04.png&amp;description=From%20Vibe%20Coding%20to%20Spec-Driven%20Development:%20Part%204%20-%20Team%20collaboration%20and%20advanced%20patterns\n- https://www.linkedin.com/shareArticle?mini=true&url=https://hiddedesmet.com/from-vibe-coding-to-spec-driven-development-part4&title=From%20Vibe%20Coding%20to%20Spec-Driven%20Development:%20Part%204%20-%20Team%20collaboration%20and%20advanced%20patterns&summary=Part%204%20of%20our%20series%20on%20mastering%20AI-assisted%20development.%20Learn%20how%20teams%20collaborate%20with%20Spec-Kit,%20integrate%20with%20CI/CD%20pipelines%20%28GitHub%20Actions%20&%20Azure%20DevOps%29,%20and%20apply%20advanced%20architectural%20patterns.&source=myblog\n\n![From Vibe Coding to Spec-Driven Development: Part 4 - Team collaboration and advanced patterns]()\n\n## Table of Contents\n\n1. Series overview\n2. From solo to team\n3. Section 1: Team workflows\n1. The spec-driven team structure\n2. Workflow #1: Feature branch per user story\n3. Workflow #2: Trunk-based with feature flags\n4. Workflow #3: Mob programming with AI\n4. Section 2: Code review for spec-driven projects\n1. The spec-driven PR checklist\n2. Review automation\n5. Section 3: CI/CD integration\n1. GitHub Actions pipeline\n2. Azure DevOps pipeline\n3. Key differences: GitHub Actions vs Azure DevOps\n6. Section 4: Advanced architectural patterns\n1. Pattern #1: Modular monolith\n2. Pattern #2: Backend for Frontend (BFF)\n3. Pattern #3: Event-driven architecture\n4. Pattern #4: Microservices (proceed with caution)\n5. Choosing the right pattern\n7. Section 5: Scaling strategies\n1. When your application outgrows the initial architecture\n2. Strategy #1: Horizontal scaling\n3. Strategy #2: Caching layers\n4. Strategy #3: Background processing\n8. Section 6: Team communication patterns\n1. Keeping everyone aligned\n2. Pattern #1: Spec review meetings\n3. Pattern #2: Async spec updates\n4. Pattern #3: Decision records\n9. Key takeaways from Part 4\n10. What‚Äôs next\n11. Resources\n12. Series navigation\n\n> >\n> üéØ **This is Part 4 of a 5-part series on mastering AI-assisted development.**\n> >\n> We‚Äôve covered the individual workflow. Now let‚Äôs scale it to teams and production environments.\n> >\n\n## Series overview\n\n| Part | Topic | Status | | --- | --- | --- | | [Part 1](/from-vibe-coding-to-spec-driven-development) | The problem and the solution | ‚úì | | [Part 2](/from-vibe-coding-to-spec-driven-development-part2) | Deep dive into the Spec-Kit workflow | ‚úì | | [Part 3](/from-vibe-coding-to-spec-driven-development-part3) | Best practices and troubleshooting | ‚úì | | **Part 4** | **Team collaboration and advanced patterns** | üìç | | Part 5 | Case studies and lessons learned | Feb 2 |\n\n## From solo to team\n\nEverything we‚Äôve covered so far assumes a single developer working with AI. But real software is built by teams. How does spec-driven development scale?\n\n**The good news**: Spec-Kit was designed with teams in mind. The artifacts (constitution, spec, plan, tasks) become shared contracts that align everyone‚Äîhumans and AI agents alike.\n\n**The challenge**: Multiple developers, multiple AI sessions, multiple opinions. Without coordination, you get chaos.\n\nThis post covers three areas:\n\n1. **Team workflows** - How multiple developers collaborate\n2. **CI/CD integration** - Automating validation with GitHub Actions and Azure DevOps\n3. **Advanced patterns** - Scaling beyond the monolith\n\n## Section 1: Team workflows\n\n### The spec-driven team structure\n\nIn a spec-driven team, roles shift slightly:\n\n| Traditional Role | Spec-Driven Role | Primary Artifacts | | --- | --- | --- | | Tech Lead | **Constitution Guardian** | `constitution.md` | | Product Owner | **Spec Owner** | `spec.md` | | Architect | **Plan Reviewer** | `plan.md`<br>, `data-model.md` | | Developer | **Task Implementer** | `tasks.md`<br>, code |\n\n**Key insight**: The constitution becomes your architecture decision record. The spec becomes your product requirements document. These aren‚Äôt new artifacts‚Äîthey‚Äôre familiar concepts in a format AI can consume.\n\n### Workflow #1: Feature branch per user story\n\nThe cleanest approach for teams of 3-8 developers. Each **user story** (US) gets its own feature branch.\n\n```mermaid %%{init: { 'theme': 'base', 'themeVariables': { 'primaryColor': '#e8f5e9', 'primaryTextColor': '#1b5e20', 'primaryBorderColor': '#4caf50', 'secondaryColor': '#e3f2fd', 'secondaryTextColor': '#0d47a1', 'secondaryBorderColor': '#2196f3', 'tertiaryColor': '#f3e5f5', 'tertiaryTextColor': '#4a148c', 'tertiaryBorderColor': '#9c27b0', 'lineColor': '#546e7a', 'fontSize': '14px' } }}%% flowchart LR subgraph main[\"üå≥ main\"] direction TB M1[v1.0.0] M2[‚ú® Auth merged] M3[‚ú® Tasks merged] M1 --> M2 --> M3 end\n\nsubgraph us1[\"üîê feature/user-authentication\"] direction TB A1[\"üìù Update spec.md\"] A2[\"üó∫Ô∏è Generate plan\"] A3[\"üìã Break into tasks\"] A4[\"‚öôÔ∏è Implement\"] A5[\"‚úÖ Tests pass\"] A6[\"üîç PR review\"] A1 --> A2 --> A3 --> A4 --> A5 --> A6 end\n\nsubgraph us2[\"üìã feature/task-management\"] direction TB B1[\"üìù Update spec.md\"] B2[\"üó∫Ô∏è Generate plan\"] B3[\"üìã Break into tasks\"] B4[\"‚öôÔ∏è Implement\"] B5[\"‚úÖ Tests pass\"] B6[\"üîç PR review\"] B1 --> B2 --> B3 --> B4 --> B5 --> B6 end\n\nsubgraph us3[\"üë• feature/team-collab\"] direction TB C1[\"üìù Update spec.md\"] C2[\"üó∫Ô∏è ...in progress\"] C1 --> C2 end\n\nM1 -.->|branch| A1 M1 -.->|branch| B1 A6 -->|merge| M2 M2 -.->|branch| C1 B6 -->|merge| M3\n\nstyle main fill:#e8f5e9,stroke:#4caf50,stroke-width:3px style us1 fill:#e3f2fd,stroke:#2196f3,stroke-width:2px style us2 fill:#f3e5f5,stroke:#9c27b0,stroke-width:2px style us3 fill:#fff3e0,stroke:#ff9800,stroke-width:2px\n\n```\n\n**Process:**\n\n1. **Spec Owner** creates feature branch with spec changes\n2. **Plan Reviewer** runs `/speckit.plan`\nand reviews architecture\n3. **Task Implementer** runs `/speckit.tasks`\nand implements\n4. **PR review** validates against constitution\n5. **Merge** to main with squash commit\n\n*Each user story branch follows the same workflow: spec ‚Üí plan ‚Üí tasks ‚Üí implement ‚Üí review ‚Üí merge*\n\n### Workflow #2: Trunk-based with feature flags\n\nFor teams practicing continuous deployment (8+ developers).\n\n``` main (always deployable) ‚îÇ ‚îú‚îÄ‚îÄ commit: Add user-auth spec (flag: OFF) ‚îú‚îÄ‚îÄ commit: Implement auth backend (flag: OFF) ‚îú‚îÄ‚îÄ commit: Implement auth frontend (flag: OFF) ‚îú‚îÄ‚îÄ commit: Enable user-auth flag (flag: ON) ‚îÇ ‚îî‚îÄ‚îÄ (features go live via flag toggles)\n\n```\n\n**Process:**\n\n1. All spec changes go to main immediately\n2. Implementation happens behind feature flags\n3. `/speckit.implement`\ngenerates flag-aware code\n4. QA tests with flag enabled\n5. Flag enabled for all users when ready\n\n**Constitution addition for feature flags:**\n\n```\n## Feature Flag Requirements\n\n### Implementation\n- All new features MUST be behind feature flags\n- Flag naming: `feature_{story_id}_{short_name}`\n- Default state: OFF in production\n\n### Flag Service\n- Use LaunchDarkly / Azure App Configuration / custom implementation\n- Flags evaluated server-side (no client exposure of disabled features)\n\n```\n\n### Workflow #3: Mob programming with AI\n\nSurprisingly effective for complex features.\n\n**Setup:**\n\n- One screen shared (driver)\n- 2-4 developers watching (navigators)\n- AI assistant running\n\n**Process:**\n\n1. **Navigator 1** dictates spec requirements\n2. **Driver** types into AI assistant\n3. **Navigator 2** reviews AI output in real-time\n4. **All** discuss and refine before accepting\n5. **Rotate** driver every 15 minutes\n\n**Why this works**: Multiple humans catch AI hallucinations immediately. Knowledge transfers naturally. Everyone understands the codebase.\n\n## Section 2: Code review for spec-driven projects\n\n### The spec-driven PR checklist\n\nStandard code review isn‚Äôt enough. Add these checks:\n\n```\n## PR Review Checklist\n\n### Constitution Compliance\n- [ ] Code follows technical constraints\n- [ ] Performance targets considered\n- [ ] Security requirements addressed\n- [ ] No prohibited patterns used\n\n### Spec Alignment\n- [ ] Implementation matches user stories\n- [ ] All acceptance criteria testable\n- [ ] Edge cases from spec handled\n- [ ] Error messages match spec exactly\n\n### Plan Consistency\n- [ ] Architecture matches plan.md\n- [ ] Data model matches data-model.md\n- [ ] API contracts match api-spec\n- [ ] No undocumented deviations\n\n### AI-Specific Checks\n- [ ] No hallucinated dependencies\n- [ ] No deprecated patterns\n- [ ] Tests actually run (not just generated)\n- [ ] No hardcoded localhost/dev values\n\n```\n\n### Review automation\n\nAdd a PR template that enforces the checklist:\n\n``` <!-- .github/PULL_REQUEST_TEMPLATE.md -->\n\n## Summary\n<!-- What does this PR do? -->\n\n## Related Spec Section\n<!-- Link to spec.md section this implements -->\n\n## Constitution Compliance\n- [ ] Reviewed against constitution.md\n- [ ] No violations or documented exceptions\n\n## Testing\n- [ ] Unit tests added/updated\n- [ ] Integration tests pass\n- [ ] Manual testing completed\n\n## AI Disclosure\n- [ ] AI-assisted code reviewed by human\n- [ ] All dependencies verified to exist\n- [ ] No TODO/FIXME markers from AI\n\n```\n\n## Section 3: CI/CD integration\n\n### GitHub Actions pipeline\n\nFor teams using GitHub, here‚Äôs a complete pipeline:\n\n```\n# .github/workflows/spec-driven-ci.yml\nname: Spec-Driven CI/CD\n\non: push: branches: [main] pull_request: branches: [main]\n\nenv: DOTNET_VERSION: '9.0.x'\n\njobs: validate-specs: name: Validate Specifications runs-on: ubuntu-latest steps:\n- uses: actions/checkout@v4\n\n- name: Check spec completeness\nrun: |\n# Verify required sections exist\nfor section in \"User Stories\" \"Acceptance Criteria\" \"Edge Cases\"; do if ! grep -q \"## $section\" .speckit/spec.md; then echo \"::error::Missing required section: $section\" exit 1 fi done\n\n- name: Check for TODO markers\nrun: | if grep -r \"TODO\\|FIXME\\|XXX\" .speckit/*.md; then echo \"::error::Unresolved TODO markers in specifications\" exit 1 fi\n\n- name: Validate constitution compliance\nrun: |\n# Check nullable reference types (from constitution)\nif ! grep -q \"<Nullable>enable</Nullable>\" src/*.csproj; then echo \"::error::Nullable reference types not enabled\" exit 1 fi\n\nbuild-and-test: name: Build and Test runs-on: ubuntu-latest needs: validate-specs steps:\n- uses: actions/checkout@v4\n\n- name: Setup .NET\nuses: actions/setup-dotnet@v4 with: dotnet-version: $\n\n- name: Restore dependencies\nrun: dotnet restore\n\n- name: Build\nrun: dotnet build --no-restore --configuration Release\n\n- name: Run tests\nrun: dotnet test --no-build --configuration Release --collect:\"XPlat Code Coverage\"\n\n- name: Check coverage threshold\nrun: |\n# Constitution requires 80% coverage\ncoverage=$(cat TestResults/*/coverage.cobertura.xml | grep -oP 'line-rate=\"\\K[^\"]+') if (( $(echo \"$coverage < 0.80\" | bc -l) )); then echo \"::error::Coverage ${coverage} below 80% threshold\" exit 1 fi\n\nsecurity-scan: name: Security Scan runs-on: ubuntu-latest needs: build-and-test steps:\n- uses: actions/checkout@v4\n\n- name: Run dependency audit\nrun: dotnet list package --vulnerable --include-transitive\n\n- name: OWASP dependency check\nuses: dependency-check/Dependency-Check_Action@main with: project: 'TeamTaskManager' path: '.' format: 'HTML'\n\ndeploy-staging: name: Deploy to Staging runs-on: ubuntu-latest needs: [build-and-test, security-scan] if: github.ref == 'refs/heads/main' environment: staging steps:\n- uses: actions/checkout@v4\n\n- name: Deploy to staging\nrun: |\n# Your deployment script here\necho \"Deploying to staging...\"\n\n```\n\n### Azure DevOps pipeline\n\nMany enterprises in the Netherlands and Europe use Azure DevOps. Here‚Äôs the equivalent pipeline:\n\n```\n# azure-pipelines.yml\ntrigger: branches: include:\n- main\npaths: exclude:\n- README.md\n- docs/*\n\npr: branches: include:\n- main\n\npool: vmImage: 'ubuntu-latest'\n\nvariables: dotnetVersion: '9.0.x' buildConfiguration: 'Release'\n\nstages:\n- stage: Validate\ndisplayName: 'Validate Specifications' jobs:\n- job: ValidateSpecs\ndisplayName: 'Spec Validation' steps:\n- checkout: self\n\n- task: Bash@3\ndisplayName: 'Check spec completeness' inputs: targetType: 'inline' script: | echo \"Checking specification completeness...\"\n\nrequired_sections=(\"User Stories\" \"Acceptance Criteria\" \"Edge Cases\") for section in \"${required_sections[@]}\"; do if ! grep -q \"## $section\" .speckit/spec.md; then echo \"##vso[task.logissue type=error]Missing required section: $section\" exit 1 fi done\n\necho \"All required sections present\"\n\n- task: Bash@3\ndisplayName: 'Check for unresolved TODOs' inputs: targetType: 'inline' script: | if grep -r \"TODO\\|FIXME\" .speckit/*.md; then echo \"##vso[task.logissue type=error]Unresolved TODO markers found\" exit 1 fi\n\n- task: Bash@3\ndisplayName: 'Validate constitution compliance' inputs: targetType: 'inline' script: |\n# Check nullable reference types enabled\nif ! grep -q \"<Nullable>enable</Nullable>\" src/*.csproj; then echo \"##vso[task.logissue type=error]Nullable reference types not enabled (constitution violation)\" exit 1 fi\n\n# Check for raw SQL (prohibited by constitution)\nif grep -r \"ExecuteSqlRaw\\|FromSqlRaw\" src/; then echo \"##vso[task.logissue type=error]Raw SQL detected (constitution violation)\" exit 1 fi\n\n- stage: Build\ndisplayName: 'Build and Test' dependsOn: Validate jobs:\n- job: BuildAndTest\ndisplayName: 'Build & Test' steps:\n- checkout: self\n\n- task: UseDotNet@2\ndisplayName: 'Setup .NET' inputs: version: $(dotnetVersion)\n\n- task: DotNetCoreCLI@2\ndisplayName: 'Restore packages' inputs: command: 'restore' projects: '**/*.csproj'\n\n- task: DotNetCoreCLI@2\ndisplayName: 'Build solution' inputs: command: 'build' projects: '**/*.csproj' arguments: '--configuration $(buildConfiguration) --no-restore'\n\n- task: DotNetCoreCLI@2\ndisplayName: 'Run tests with coverage' inputs: command: 'test' projects: '**/*Tests.csproj' arguments: '--configuration $(buildConfiguration) --no-build --collect:\"XPlat Code Coverage\" --results-directory $(Build.SourcesDirectory)/TestResults'\n\n- task: PublishCodeCoverageResults@2\ndisplayName: 'Publish coverage report' inputs: summaryFileLocation: '$(Build.SourcesDirectory)/TestResults/**/coverage.cobertura.xml'\n\n- task: Bash@3\ndisplayName: 'Enforce coverage threshold' inputs: targetType: 'inline' script: |\n# Constitution requires 80% coverage\ncoverage_file=$(find $(Build.SourcesDirectory)/TestResults -name \"coverage.cobertura.xml\" | head -1) if [ -f \"$coverage_file\" ]; then coverage=$(grep -oP 'line-rate=\"\\K[^\"]+' \"$coverage_file\" | head -1) threshold=0.80 if (( $(echo \"$coverage < $threshold\" | bc -l) )); then echo \"##vso[task.logissue type=error]Coverage $coverage is below $threshold threshold\" exit 1 fi echo \"Coverage: $coverage (threshold: $threshold) ‚úì\" fi\n\n- stage: Security\ndisplayName: 'Security Scanning' dependsOn: Build jobs:\n- job: SecurityScan\ndisplayName: 'Dependency & SAST Scan' steps:\n- checkout: self\n\n- task: UseDotNet@2\ninputs: version: $(dotnetVersion)\n\n- task: DotNetCoreCLI@2\ndisplayName: 'Check vulnerable packages' inputs: command: 'custom' custom: 'list' arguments: 'package --vulnerable --include-transitive'\n\n# If you have Microsoft Defender for DevOps or SonarCloud\n- task: MicrosoftSecurityDevOps@1\ndisplayName: 'Microsoft Security DevOps' continueOnError: true\n\n- stage: DeployStaging\ndisplayName: 'Deploy to Staging' dependsOn: Security condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main')) jobs:\n- deployment: DeployStaging\ndisplayName: 'Deploy to Staging' environment: 'staging' strategy: runOnce: deploy: steps:\n- task: AzureWebApp@1\ndisplayName: 'Deploy to Azure App Service' inputs: azureSubscription: '$(azureServiceConnection)' appType: 'webApp' appName: '$(stagingAppName)' package: '$(Pipeline.Workspace)/**/*.zip'\n\n```\n\n### Key differences: GitHub Actions vs Azure DevOps\n\n| Aspect | GitHub Actions | Azure DevOps | | --- | --- | --- | | **Syntax** | YAML with `jobs` | YAML with `stages`<br> and `jobs` | | **Environments** | `environment:`<br> keyword | Deployment jobs with `environment:` | | **Secrets** | Repository/org secrets | Variable groups, Key Vault | | **Logging** | `echo \"::error::\"` | `##vso[task.logissue]` | | **Artifacts** | `actions/upload-artifact` | `PublishPipelineArtifact`<br> task | | **Approvals** | Environment protection rules | Stage gates and approvals |\n\n**Pro tip**: Many Dutch enterprises use Azure DevOps for the tighter Azure integration, built-in boards, and compliance features. GitHub Actions is simpler for open-source or GitHub-native workflows.\n\n## Section 4: Advanced architectural patterns\n\nAs your application grows, the monolith from Part 2 may need to evolve. Here‚Äôs how spec-driven development adapts to advanced patterns.\n\n### Pattern #1: Modular monolith\n\n**When to use**: Application growing, but not ready for microservices.\n\n**Constitution update:**\n\n```\n## Architecture: Modular Monolith\n\n### Module Boundaries\nEach module is a separate project/assembly with:\n- Own data access (no cross-module database queries)\n- Public API via interfaces only\n- Internal implementation hidden\n\n### Modules\n- `TeamTaskManager.Users` - Authentication, profiles\n- `TeamTaskManager.Teams` - Team management\n- `TeamTaskManager.Tasks` - Task CRUD and workflows\n- `TeamTaskManager.Notifications` - Email, push notifications\n\n### Communication\n- Modules communicate via defined interfaces\n- No direct database access across modules\n- Events for async communication (MediatR)\n\n```\n\n**Spec pattern:**\n\n```\n## Feature: Task Assignment Notification\n\n**Module**: Tasks (primary), Notifications (consumer)\n\n**Given** a task is assigned to a user **When** the assignment is saved **Then** Tasks module publishes `TaskAssignedEvent` **And** Notifications module sends email to assignee\n\n```\n\n### Pattern #2: Backend for Frontend (BFF)\n\n**When to use**: Multiple clients (web, mobile, third-party) need different APIs.\n\n**Constitution update:**\n\n```\n## Architecture: Backend for Frontend\n\n### BFF Services\n- `TeamTaskManager.WebBFF` - Optimized for Blazor web app\n- `TeamTaskManager.MobileBFF` - Optimized for mobile (future)\n- `TeamTaskManager.PublicAPI` - Third-party integrations\n\n### Core Services\n- BFFs call shared core services\n- Core services own business logic\n- BFFs handle client-specific concerns (aggregation, formatting)\n\n```\n\n**Plan pattern:**\n\n```\n## API Architecture\n\n### Web BFF Endpoints\nOptimized for single-page load:\n- `GET /web/dashboard` ‚Üí Returns user, teams, tasks in one call\n- `GET /web/team/{id}` ‚Üí Returns team with members and recent tasks\n\n### Mobile BFF Endpoints (Future)\nOptimized for bandwidth:\n- `GET /mobile/sync` ‚Üí Delta sync since last update\n- Compressed responses, minimal payload\n\n### Public API\nRESTful, versioned, rate-limited:\n- `GET /api/v1/tasks` ‚Üí Standard REST\n- OAuth 2.0 authentication\n\n```\n\n### Pattern #3: Event-driven architecture\n\n**When to use**: Need loose coupling, async processing, audit trails.\n\n**Constitution update:**\n\n```\n## Architecture: Event-Driven\n\n### Event Bus\n- Use Azure Service Bus / RabbitMQ / MassTransit\n- All state changes published as events\n- Events are immutable facts\n\n### Event Patterns\n- **Domain Events**: `TaskCreated`, `TaskCompleted`, `MemberInvited`\n- **Integration Events**: Cross-service communication\n- **Event Sourcing**: Optional, for audit-critical features\n\n### Guarantees\n- At-least-once delivery (consumers must be idempotent)\n- Events include correlation ID for tracing\n\n```\n\n**Spec pattern:**\n\n```\n## Event: TaskCompleted\n\n**Published when**: User marks task as complete\n\n**Payload:** ```json { \"eventId\": \"uuid\", \"eventType\": \"TaskCompleted\", \"timestamp\": \"2026-01-26T10:30:00Z\", \"correlationId\": \"uuid\", \"data\": { \"taskId\": \"uuid\", \"completedBy\": \"userId\", \"teamId\": \"uuid\" } }\n\n```\n\n**Consumers:**\n\n- Notifications: Send completion email to task creator\n- Analytics: Update team productivity metrics\n- Audit: Log completion event\n```\n\n### Pattern #4: Microservices (proceed with caution)\n\n**When to use**: Large team (10+ developers), clear domain boundaries, need independent deployment.\n\n> >\n> ‚ö†Ô∏è **Warning**: Don‚Äôt start with microservices. Extract them from a working monolith when you have clear reasons.\n> >\n\n**Constitution update:**\n\n```\n## Architecture: Microservices\n\n### Services\n- `users-service` - Authentication, profiles (owns users DB)\n- `teams-service` - Team management (owns teams DB)\n- `tasks-service` - Task management (owns tasks DB)\n- `notifications-service` - All notifications (stateless)\n\n### Communication\n- Sync: gRPC for internal, REST for external\n- Async: Azure Service Bus for events\n- No shared databases (each service owns its data)\n\n### Deployment\n- Each service independently deployable\n- Kubernetes for orchestration\n- Service mesh for observability (Istio/Linkerd)\n\n### Data Consistency\n- Eventual consistency between services\n- Saga pattern for distributed transactions\n- Outbox pattern for reliable event publishing\n\n```\n\n### Choosing the right pattern\n\n| Pattern | Team Size | Complexity | When to Choose | | --- | --- | --- | --- | | **Monolith** | 1-5 | Low | Starting out, validating product | | **Modular Monolith** | 3-10 | Medium | Growing, need structure | | **BFF** | 5-15 | Medium | Multiple client types | | **Event-Driven** | 5-20 | High | Async workflows, audit needs | | **Microservices** | 10+ | Very High | Clear domains, independent scaling |\n\n**The spec-driven advantage**: Your constitution documents architectural decisions. When you evolve from monolith to modular to microservices, the spec history shows why.\n\n## Section 5: Scaling strategies\n\n### When your application outgrows the initial architecture\n\nThe Team Task Manager from Part 2 works great for 100 users. What about 10,000? 100,000?\n\n### Strategy #1: Horizontal scaling\n\n**Constitution update:**\n\n```\n## Scaling Requirements\n\n### Stateless Application\n- No in-memory session state\n- Use distributed cache (Redis) for session\n- Any instance can handle any request\n\n### Database Scaling\n- Read replicas for query-heavy operations\n- Connection pooling required\n- Consider read/write splitting at 10k users\n\n```\n\n### Strategy #2: Caching layers\n\n**Spec pattern:**\n\n```\n## Performance: Task List Caching\n\n**Given** a user views their team's task list **When** the list was fetched < 30 seconds ago **Then** return cached result (skip database)\n\n**Cache invalidation:**\n- Task created ‚Üí Invalidate team's task list cache\n- Task updated ‚Üí Invalidate specific task + team list cache\n- Team membership changed ‚Üí Invalidate all team caches\n\n**Cache implementation:**\n- L1: In-memory (IMemoryCache), 10 second TTL\n- L2: Distributed (Redis), 30 second TTL\n\n```\n\n### Strategy #3: Background processing\n\n**Constitution update:**\n\n```\n## Background Jobs\n\n### Job Queue\n- Use Hangfire / Azure Functions / AWS Lambda\n- Long-running operations MUST be async\n\n### Job Types\n- Email sending (< 1 minute)\n- Report generation (< 5 minutes)\n- Data export (< 30 minutes)\n\n### Retry Policy\n- 3 retries with exponential backoff\n- Dead letter queue for failed jobs\n- Alert on repeated failures\n\n```\n\n## Section 6: Team communication patterns\n\n### Keeping everyone aligned\n\nSpec-driven development generates artifacts. Those artifacts need to be communicated.\n\n### Pattern #1: Spec review meetings\n\n**Weekly, 30 minutes:**\n\n1. **Spec changes this week**(5 min)\n- What was added/modified/removed?\n2. **Plan deviations**(10 min)\n- Any architectural decisions that deviated from plan?\n- Update plan.md to reflect reality\n3. **Constitution amendments**(10 min)\n- Any new constraints discovered?\n- Any constraints that need relaxing?\n4. **Next week‚Äôs focus**(5 min)\n- Which user stories are in flight?\n\n### Pattern #2: Async spec updates\n\nFor distributed teams:\n\n``` <!-- In PR description -->\n\n## Spec Changes\n\n### Added\n- User story: Password-less authentication (magic links)\n- Edge case: Handle expired magic links gracefully\n\n### Modified\n- Authentication flow now supports both password and magic link\n\n### Constitution Impact\n- None (existing security requirements cover magic links)\n\n### Reviewers\n- @tech-lead - Constitution compliance\n- @product-owner - Spec accuracy\n- @security-team - Authentication changes\n\n```\n\n### Pattern #3: Decision records\n\nWhen specs change significantly, document why:\n\n``` <!-- docs/decisions/004-magic-link-auth.md -->\n\n# ADR-004: Add Magic Link Authentication\n\n## Status\nAccepted\n\n## Context\nUsers forget passwords. Password reset flow has 40% abandonment rate.\n\n## Decision\nAdd magic link (email-based) authentication as alternative to passwords.\n\n## Consequences\n- Positive: Reduced friction, fewer support tickets\n- Negative: Email deliverability becomes critical path\n- Neutral: Both auth methods coexist\n\n## Spec Reference\n- spec.md: Section \"Authentication\" updated\n- plan.md: Email service now critical infrastructure\n\n```\n\n## Key takeaways from Part 4\n\n| # | Takeaway | | --- | --- | | 1 | **Teams need workflows** - Feature branches or trunk-based, pick one and commit | | 2 | **Automate validation** - CI/CD should enforce constitution and spec compliance | | 3 | **Architecture evolves** - Start simple, extract complexity when needed | | 4 | **Document decisions** - Specs + ADRs = traceable architecture history | | 5 | **Communication matters** - Artifacts are useless if the team doesn‚Äôt read them |\n\n## What‚Äôs next\n\nIn **Part 5** (next week), we‚Äôll wrap up the series with:\n\n- **Real case studies** - Actual projects built with spec-driven development\n- **Metrics and outcomes** - What improved, what didn‚Äôt\n- **Lessons learned** - Mistakes made, wisdom gained\n- **The future** - Where AI-assisted development is heading\n\n## Resources\n\n| Resource | Description | | --- | --- | | [**Spec-Kit GitHub**](https://github.com/github/spec-kit) | Official toolkit | | [**GitHub Actions Docs**](https://docs.github.com/en/actions) | CI/CD for GitHub | | [**Azure Pipelines Docs**](https://learn.microsoft.com/en-us/azure/devops/pipelines/) | CI/CD for Azure DevOps | | [**Modular Monolith**](https://www.milanjovanovic.tech/blog/what-is-a-modular-monolith) | Architecture pattern guide | | [**ADR Templates**](https://adr.github.io/) | Architecture Decision Records |\n\n## Series navigation\n\n- **Previous**: [Part 3 - Best practices and troubleshooting](/from-vibe-coding-to-spec-driven-development-part3)\n- **üìç You are here: Part 4 - Team collaboration and advanced patterns**\n- **Next**: Part 5 - Case studies and lessons learned (Coming February 2, 2026)\n\n> >\n> üí¨ **Using spec-driven development with your team?**\n> >\n> I‚Äôd love to hear your experience. Connect with me on [LinkedIn](https://linkedin.com/in/hiddedesmet).\n> >\n> **Want to get notified when Part 5 drops?** Follow me for the finale!\n> >\n\n[!\\[Hidde de Smet\\]()](/hidde)\n\nWritten by\n\n### [Hidde de Smet](/hidde)\n\nAs a certified Azure Solution Architect, I specialize in designing, implementing, and managing cloud-based solutions using Scrum and DevOps methodologies.\n\n### Start the conversation\n\n## Related\n\n[See all ai-assisted-development](/tags#ai-assisted-development)\n\n[!\\[From Vibe Coding to Spec-Driven Development: Part 3 - Best practices and troubleshooting\\]()](/from-vibe-coding-to-spec-driven-development-part3)\n\n[ai-assisted-development](/tags#ai-assisted-development)\n\n[spec-kit](/tags#spec-kit)\n\n[github](/tags#github)\n\n[copilot](/tags#copilot)\n\n[vibe-coding](/tags#vibe-coding)\n\n[specification-driven-development](/tags#specification-driven-development)\n\n[series](/tags#series)\n\n‚Ä¢Jan 19, 2026\n\n## [From Vibe Coding to Spec-Driven Development: Part 3 - Best practices and troubleshooting](/from-vibe-coding-to-spec-driven-development-part3)\n\nPart 3 of our series on mastering AI-assisted development. Learn advanced specification techniques, debugging strategies, iteration patterns, and real-world troubleshooting for production-ready AI-generated code.\n\n[!\\[Hidde de Smet\\]()](/hidde)\n\nWritten by [Hidde de Smet](/hidde)\n\n[!\\[From Vibe Coding to Spec-Driven Development: Part 2 - The Spec-Kit Workflow\\]()](/from-vibe-coding-to-spec-driven-development-part2)\n\n[ai-assisted-development](/tags#ai-assisted-development)\n\n[spec-kit](/tags#spec-kit)\n\n[github](/tags#github)\n\n[copilot](/tags#copilot)\n\n[vibe-coding](/tags#vibe-coding)\n\n[specification-driven-development](/tags#specification-driven-development)\n\n[series](/tags#series)\n\n‚Ä¢Jan 12, 2026\n\n## [From Vibe Coding to Spec-Driven Development: Part 2 - The Spec-Kit Workflow](/from-vibe-coding-to-spec-driven-development-part2)\n\nPart 2 of our series on mastering AI-assisted development. A hands-on walkthrough of the complete Spec-Kit workflow: creating constitutions, writing specs, generating plans, and implementing production-ready code.\n\n[!\\[Hidde de Smet\\]()](/hidde)\n\nWritten by [Hidde de Smet](/hidde)\n\n[!\\[From Vibe Coding to Spec-Driven Development: Part 1 - The problem and the solution\\]()](/from-vibe-coding-to-spec-driven-development)\n\n[ai-assisted-development](/tags#ai-assisted-development)\n\n[spec-kit](/tags#spec-kit)\n\n[github](/tags#github)\n\n[claude](/tags#claude)\n\n[copilot](/tags#copilot)\n\n[vibe-coding](/tags#vibe-coding)\n\n[specification-driven-development](/tags#specification-driven-development)\n\n[series](/tags#series)\n\n‚Ä¢Jan 05, 2026\n\n## [From Vibe Coding to Spec-Driven Development: Part 1 - The problem and the solution](/from-vibe-coding-to-spec-driven-development)\n\nPart 1 of our series on mastering AI-assisted development. Discover why 'vibe coding' gets you only 70% there, and why spec-driven development is the answer. This is your roadmap to production-ready AI-generated code.\n\n[!\\[Hidde de Smet\\]()](/hidde)\n\nWritten by [Hidde de Smet](/hidde)",
  "OutputDir": "_blogs",
  "FeedName": "Hidde de Smet's Blog",
  "FeedUrl": "https://hiddedesmet.com/feed.xml",
  "Link": "https://hiddedesmet.com/from-vibe-coding-to-spec-driven-development-part4",
  "PubDate": "2026-01-26T00:00:00+00:00",
  "Title": "From Vibe Coding to Spec-Driven Development: Part 4 - Team collaboration and advanced patterns",
  "Description": "> >\n> üéØ **This is Part 4 of a 5-part series on mastering AI-assisted development.**\n> >\n> We‚Äôve covered the individual workflow. Now let‚Äôs scale it to teams and production environments.\n> >\n\n## Series overview\n\n| Part | Topic | Status | | --- | --- | --- | | [Part 1](/from-vibe-coding-to-spec-driven-development) | The problem and the solution | ‚úì | | [Part 2](/from-vibe-coding-to-spec-driven-development-part2) | Deep dive into the Spec-Kit workflow | ‚úì | | [Part 3](/from-vibe-coding-to-spec-driven-development-part3) | Best practices and troubleshooting | ‚úì | | **Part 4** | **Team collaboration and advanced patterns** | üìç | | Part 5 | Case studies and lessons learned | Feb 2 |\n\n## From solo to team\n\nEverything we‚Äôve covered so far assumes a single developer working with AI. But real software is built by teams. How does spec-driven development scale?\n\n**The good news**: Spec-Kit was designed with teams in mind. The artifacts (constitution, spec, plan, tasks) become shared contracts that align everyone‚Äîhumans and AI agents alike.\n\n**The challenge**: Multiple developers, multiple AI sessions, multiple opinions. Without coordination, you get chaos.\n\nThis post covers three areas:\n\n1. **Team workflows** - How multiple developers collaborate\n2. **CI/CD integration** - Automating validation with GitHub Actions and Azure DevOps\n3. **Advanced patterns** - Scaling beyond the monolith\n\n## Section 1: Team workflows\n\n### The spec-driven team structure\n\nIn a spec-driven team, roles shift slightly:\n\n| Traditional Role | Spec-Driven Role | Primary Artifacts | | --- | --- | --- | | Tech Lead | **Constitution Guardian** | `constitution.md` | | Product Owner | **Spec Owner** | `spec.md` | | Architect | **Plan Reviewer** | `plan.md`<br>, `data-model.md` | | Developer | **Task Implementer** | `tasks.md`<br>, code |\n\n**Key insight**: The constitution becomes your architecture decision record. The spec becomes your product requirements document. These aren‚Äôt new artifacts‚Äîthey‚Äôre familiar concepts in a format AI can consume.\n\n### Workflow #1: Feature branch per user story\n\nThe cleanest approach for teams of 3-8 developers. Each **user story** (US) gets its own feature branch.\n\n```mermaid %%{init: { 'theme': 'base', 'themeVariables': { 'primaryColor': '#e8f5e9', 'primaryTextColor': '#1b5e20', 'primaryBorderColor': '#4caf50', 'secondaryColor': '#e3f2fd', 'secondaryTextColor': '#0d47a1', 'secondaryBorderColor': '#2196f3', 'tertiaryColor': '#f3e5f5', 'tertiaryTextColor': '#4a148c', 'tertiaryBorderColor': '#9c27b0', 'lineColor': '#546e7a', 'fontSize': '14px' } }}%% flowchart LR subgraph main[\"üå≥ main\"] direction TB M1[v1.0.0] M2[‚ú® Auth merged] M3[‚ú® Tasks merged] M1 --> M2 --> M3 end\n\nsubgraph us1[\"üîê feature/user-authentication\"] direction TB A1[\"üìù Update spec.md\"] A2[\"üó∫Ô∏è Generate plan\"] A3[\"üìã Break into tasks\"] A4[\"‚öôÔ∏è Implement\"] A5[\"‚úÖ Tests pass\"] A6[\"üîç PR review\"] A1 --> A2 --> A3 --> A4 --> A5 --> A6 end\n\nsubgraph us2[\"üìã feature/task-management\"] direction TB B1[\"üìù Update spec.md\"] B2[\"üó∫Ô∏è Generate plan\"] B3[\"üìã Break into tasks\"] B4[\"‚öôÔ∏è Implement\"] B5[\"‚úÖ Tests pass\"] B6[\"üîç PR review\"] B1 --> B2 --> B3 --> B4 --> B5 --> B6 end\n\nsubgraph us3[\"üë• feature/team-collab\"] direction TB C1[\"üìù Update spec.md\"] C2[\"üó∫Ô∏è ...in progress\"] C1 --> C2 end\n\nM1 -.->|branch| A1 M1 -.->|branch| B1 A6 -->|merge| M2 M2 -.->|branch| C1 B6 -->|merge| M3\n\nstyle main fill:#e8f5e9,stroke:#4caf50,stroke-width:3px style us1 fill:#e3f2fd,stroke:#2196f3,stroke-width:2px style us2 fill:#f3e5f5,stroke:#9c27b0,stroke-width:2px style us3 fill:#fff3e0,stroke:#ff9800,stroke-width:2px\n\n```\n\n**Process:**\n\n1. **Spec Owner** creates feature branch with spec changes\n2. **Plan Reviewer** runs `/speckit.plan`\nand reviews architecture\n3. **Task Implementer** runs `/speckit.tasks`\nand implements\n4. **PR review** validates against constitution\n5. **Merge** to main with squash commit\n\n*Each user story branch follows the same workflow: spec ‚Üí plan ‚Üí tasks ‚Üí implement ‚Üí review ‚Üí merge*\n\n### Workflow #2: Trunk-based with feature flags\n\nFor teams practicing continuous deployment (8+ developers).\n\n``` main (always deployable) ‚îÇ ‚îú‚îÄ‚îÄ commit: Add user-auth spec (flag: OFF) ‚îú‚îÄ‚îÄ commit: Implement auth backend (flag: OFF) ‚îú‚îÄ‚îÄ commit: Implement auth frontend (flag: OFF) ‚îú‚îÄ‚îÄ commit: Enable user-auth flag (flag: ON) ‚îÇ ‚îî‚îÄ‚îÄ (features go live via flag toggles)\n\n```\n\n**Process:**\n\n1. All spec changes go to main immediately\n2. Implementation happens behind feature flags\n3. `/speckit.implement`\ngenerates flag-aware code\n4. QA tests with flag enabled\n5. Flag enabled for all users when ready\n\n**Constitution addition for feature flags:**\n\n```\n## Feature Flag Requirements\n\n### Implementation\n- All new features MUST be behind feature flags\n- Flag naming: `feature_{story_id}_{short_name}`\n- Default state: OFF in production\n\n### Flag Service\n- Use LaunchDarkly / Azure App Configuration / custom implementation\n- Flags evaluated server-side (no client exposure of disabled features)\n\n```\n\n### Workflow #3: Mob programming with AI\n\nSurprisingly effective for complex features.\n\n**Setup:**\n\n- One screen shared (driver)\n- 2-4 developers watching (navigators)\n- AI assistant running\n\n**Process:**\n\n1. **Navigator 1** dictates spec requirements\n2. **Driver** types into AI assistant\n3. **Navigator 2** reviews AI output in real-time\n4. **All** discuss and refine before accepting\n5. **Rotate** driver every 15 minutes\n\n**Why this works**: Multiple humans catch AI hallucinations immediately. Knowledge transfers naturally. Everyone understands the codebase.\n\n## Section 2: Code review for spec-driven projects\n\n### The spec-driven PR checklist\n\nStandard code review isn‚Äôt enough. Add these checks:\n\n```\n## PR Review Checklist\n\n### Constitution Compliance\n- [ ] Code follows technical constraints\n- [ ] Performance targets considered\n- [ ] Security requirements addressed\n- [ ] No prohibited patterns used\n\n### Spec Alignment\n- [ ] Implementation matches user stories\n- [ ] All acceptance criteria testable\n- [ ] Edge cases from spec handled\n- [ ] Error messages match spec exactly\n\n### Plan Consistency\n- [ ] Architecture matches plan.md\n- [ ] Data model matches data-model.md\n- [ ] API contracts match api-spec\n- [ ] No undocumented deviations\n\n### AI-Specific Checks\n- [ ] No hallucinated dependencies\n- [ ] No deprecated patterns\n- [ ] Tests actually run (not just generated)\n- [ ] No hardcoded localhost/dev values\n\n```\n\n### Review automation\n\nAdd a PR template that enforces the checklist:\n\n```\n\n## Summary\n\n## Related Spec Section\n\n## Constitution Compliance\n- [ ] Reviewed against constitution.md\n- [ ] No violations or documented exceptions\n\n## Testing\n- [ ] Unit tests added/updated\n- [ ] Integration tests pass\n- [ ] Manual testing completed\n\n## AI Disclosure\n- [ ] AI-assisted code reviewed by human\n- [ ] All dependencies verified to exist\n- [ ] No TODO/FIXME markers from AI\n\n```\n\n## Section 3: CI/CD integration\n\n### GitHub Actions pipeline\n\nFor teams using GitHub, here‚Äôs a complete pipeline:\n\n```\n# .github/workflows/spec-driven-ci.yml\nname: Spec-Driven CI/CD\n\non: push: branches: [main] pull_request: branches: [main]\n\nenv: DOTNET_VERSION: '9.0.x'\n\njobs: validate-specs: name: Validate Specifications runs-on: ubuntu-latest steps:\n- uses: actions/checkout@v4\n\n- name: Check spec completeness\nrun: |\n# Verify required sections exist\nfor section in \"User Stories\" \"Acceptance Criteria\" \"Edge Cases\"; do if ! grep -q \"## $section\" .speckit/spec.md; then echo \"::error::Missing required section: $section\" exit 1 fi done\n\n- name: Check for TODO markers\nrun: | if grep -r \"TODO\\|FIXME\\|XXX\" .speckit/*.md; then echo \"::error::Unresolved TODO markers in specifications\" exit 1 fi\n\n- name: Validate constitution compliance\nrun: |\n# Check nullable reference types (from constitution)\nif ! grep -q \"enable\" src/*.csproj; then echo \"::error::Nullable reference types not enabled\" exit 1 fi\n\nbuild-and-test: name: Build and Test runs-on: ubuntu-latest needs: validate-specs steps:\n- uses: actions/checkout@v4\n\n- name: Setup .NET\nuses: actions/setup-dotnet@v4 with: dotnet-version: $\n\n- name: Restore dependencies\nrun: dotnet restore\n\n- name: Build\nrun: dotnet build --no-restore --configuration Release\n\n- name: Run tests\nrun: dotnet test --no-build --configuration Release --collect:\"XPlat Code Coverage\"\n\n- name: Check coverage threshold\nrun: |\n# Constitution requires 80% coverage\ncoverage=$(cat TestResults/*/coverage.cobertura.xml | grep -oP 'line-rate=\"\\K[^\"]+') if (( $(echo \"$coverage echo \"::error::Coverage ${coverage} below 80% threshold\" exit 1 fi\n\nsecurity-scan: name: Security Scan runs-on: ubuntu-latest needs: build-and-test steps:\n- uses: actions/checkout@v4\n\n- name: Run dependency audit\nrun: dotnet list package --vulnerable --include-transitive\n\n- name: OWASP dependency check\nuses: dependency-check/Dependency-Check_Action@main with: project: 'TeamTaskManager' path: '.' format: 'HTML'\n\ndeploy-staging: name: Deploy to Staging runs-on: ubuntu-latest needs: [build-and-test, security-scan] if: github.ref == 'refs/heads/main' environment: staging steps:\n- uses: actions/checkout@v4\n\n- name: Deploy to staging\nrun: |\n# Your deployment script here\necho \"Deploying to staging...\"\n\n```\n\n### Azure DevOps pipeline\n\nMany enterprises in the Netherlands and Europe use Azure DevOps. Here‚Äôs the equivalent pipeline:\n\n```\n# azure-pipelines.yml\ntrigger: branches: include:\n- main\npaths: exclude:\n- README.md\n- docs/*\n\npr: branches: include:\n- main\n\npool: vmImage: 'ubuntu-latest'\n\nvariables: dotnetVersion: '9.0.x' buildConfiguration: 'Release'\n\nstages:\n- stage: Validate\ndisplayName: 'Validate Specifications' jobs:\n- job: ValidateSpecs\ndisplayName: 'Spec Validation' steps:\n- checkout: self\n\n- task: Bash@3\ndisplayName: 'Check spec completeness' inputs: targetType: 'inline' script: | echo \"Checking specification completeness...\"\n\nrequired_sections=(\"User Stories\" \"Acceptance Criteria\" \"Edge Cases\") for section in \"${required_sections[@]}\"; do if ! grep -q \"## $section\" .speckit/spec.md; then echo \"##vso[task.logissue type=error]Missing required section: $section\" exit 1 fi done\n\necho \"All required sections present\"\n\n- task: Bash@3\ndisplayName: 'Check for unresolved TODOs' inputs: targetType: 'inline' script: | if grep -r \"TODO\\|FIXME\" .speckit/*.md; then echo \"##vso[task.logissue type=error]Unresolved TODO markers found\" exit 1 fi\n\n- task: Bash@3\ndisplayName: 'Validate constitution compliance' inputs: targetType: 'inline' script: |\n# Check nullable reference types enabled\nif ! grep -q \"enable\" src/*.csproj; then echo \"##vso[task.logissue type=error]Nullable reference types not enabled (constitution violation)\" exit 1 fi\n\n# Check for raw SQL (prohibited by constitution)\nif grep -r \"ExecuteSqlRaw\\|FromSqlRaw\" src/; then echo \"##vso[task.logissue type=error]Raw SQL detected (constitution violation)\" exit 1 fi\n\n- stage: Build\ndisplayName: 'Build and Test' dependsOn: Validate jobs:\n- job: BuildAndTest\ndisplayName: 'Build & Test' steps:\n- checkout: self\n\n- task: UseDotNet@2\ndisplayName: 'Setup .NET' inputs: version: $(dotnetVersion)\n\n- task: DotNetCoreCLI@2\ndisplayName: 'Restore packages' inputs: command: 'restore' projects: '**/*.csproj'\n\n- task: DotNetCoreCLI@2\ndisplayName: 'Build solution' inputs: command: 'build' projects: '**/*.csproj' arguments: '--configuration $(buildConfiguration) --no-restore'\n\n- task: DotNetCoreCLI@2\ndisplayName: 'Run tests with coverage' inputs: command: 'test' projects: '**/*Tests.csproj' arguments: '--configuration $(buildConfiguration) --no-build --collect:\"XPlat Code Coverage\" --results-directory $(Build.SourcesDirectory)/TestResults'\n\n- task: PublishCodeCoverageResults@2\ndisplayName: 'Publish coverage report' inputs: summaryFileLocation: '$(Build.SourcesDirectory)/TestResults/**/coverage.cobertura.xml'\n\n- task: Bash@3\ndisplayName: 'Enforce coverage threshold' inputs: targetType: 'inline' script: |\n# Constitution requires 80% coverage\ncoverage_file=$(find $(Build.SourcesDirectory)/TestResults -name \"coverage.cobertura.xml\" | head -1) if [ -f \"$coverage_file\" ]; then coverage=$(grep -oP 'line-rate=\"\\K[^\"]+' \"$coverage_file\" | head -1) threshold=0.80 if (( $(echo \"$coverage echo \"##vso[task.logissue type=error]Coverage $coverage is below $threshold threshold\" exit 1 fi echo \"Coverage: $coverage (threshold: $threshold) ‚úì\" fi\n\n- stage: Security\ndisplayName: 'Security Scanning' dependsOn: Build jobs:\n- job: SecurityScan\ndisplayName: 'Dependency & SAST Scan' steps:\n- checkout: self\n\n- task: UseDotNet@2\ninputs: version: $(dotnetVersion)\n\n- task: DotNetCoreCLI@2\ndisplayName: 'Check vulnerable packages' inputs: command: 'custom' custom: 'list' arguments: 'package --vulnerable --include-transitive'\n\n# If you have Microsoft Defender for DevOps or SonarCloud\n- task: MicrosoftSecurityDevOps@1\ndisplayName: 'Microsoft Security DevOps' continueOnError: true\n\n- stage: DeployStaging\ndisplayName: 'Deploy to Staging' dependsOn: Security condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main')) jobs:\n- deployment: DeployStaging\ndisplayName: 'Deploy to Staging' environment: 'staging' strategy: runOnce: deploy: steps:\n- task: AzureWebApp@1\ndisplayName: 'Deploy to Azure App Service' inputs: azureSubscription: '$(azureServiceConnection)' appType: 'webApp' appName: '$(stagingAppName)' package: '$(Pipeline.Workspace)/**/*.zip'\n\n```\n\n### Key differences: GitHub Actions vs Azure DevOps\n\n| Aspect | GitHub Actions | Azure DevOps | | --- | --- | --- | | **Syntax** | YAML with `jobs` | YAML with `stages`<br> and `jobs` | | **Environments** | `environment:`<br> keyword | Deployment jobs with `environment:` | | **Secrets** | Repository/org secrets | Variable groups, Key Vault | | **Logging** | `echo \"::error::\"` | `##vso[task.logissue]` | | **Artifacts** | `actions/upload-artifact` | `PublishPipelineArtifact`<br> task | | **Approvals** | Environment protection rules | Stage gates and approvals |\n\n**Pro tip**: Many Dutch enterprises use Azure DevOps for the tighter Azure integration, built-in boards, and compliance features. GitHub Actions is simpler for open-source or GitHub-native workflows.\n\n## Section 4: Advanced architectural patterns\n\nAs your application grows, the monolith from Part 2 may need to evolve. Here‚Äôs how spec-driven development adapts to advanced patterns.\n\n### Pattern #1: Modular monolith\n\n**When to use**: Application growing, but not ready for microservices.\n\n**Constitution update:**\n\n```\n## Architecture: Modular Monolith\n\n### Module Boundaries\nEach module is a separate project/assembly with:\n- Own data access (no cross-module database queries)\n- Public API via interfaces only\n- Internal implementation hidden\n\n### Modules\n- `TeamTaskManager.Users` - Authentication, profiles\n- `TeamTaskManager.Teams` - Team management\n- `TeamTaskManager.Tasks` - Task CRUD and workflows\n- `TeamTaskManager.Notifications` - Email, push notifications\n\n### Communication\n- Modules communicate via defined interfaces\n- No direct database access across modules\n- Events for async communication (MediatR)\n\n```\n\n**Spec pattern:**\n\n```\n## Feature: Task Assignment Notification\n\n**Module**: Tasks (primary), Notifications (consumer)\n\n**Given** a task is assigned to a user **When** the assignment is saved **Then** Tasks module publishes `TaskAssignedEvent` **And** Notifications module sends email to assignee\n\n```\n\n### Pattern #2: Backend for Frontend (BFF)\n\n**When to use**: Multiple clients (web, mobile, third-party) need different APIs.\n\n**Constitution update:**\n\n```\n## Architecture: Backend for Frontend\n\n### BFF Services\n- `TeamTaskManager.WebBFF` - Optimized for Blazor web app\n- `TeamTaskManager.MobileBFF` - Optimized for mobile (future)\n- `TeamTaskManager.PublicAPI` - Third-party integrations\n\n### Core Services\n- BFFs call shared core services\n- Core services own business logic\n- BFFs handle client-specific concerns (aggregation, formatting)\n\n```\n\n**Plan pattern:**\n\n```\n## API Architecture\n\n### Web BFF Endpoints\nOptimized for single-page load:\n- `GET /web/dashboard` ‚Üí Returns user, teams, tasks in one call\n- `GET /web/team/{id}` ‚Üí Returns team with members and recent tasks\n\n### Mobile BFF Endpoints (Future)\nOptimized for bandwidth:\n- `GET /mobile/sync` ‚Üí Delta sync since last update\n- Compressed responses, minimal payload\n\n### Public API\nRESTful, versioned, rate-limited:\n- `GET /api/v1/tasks` ‚Üí Standard REST\n- OAuth 2.0 authentication\n\n```\n\n### Pattern #3: Event-driven architecture\n\n**When to use**: Need loose coupling, async processing, audit trails.\n\n**Constitution update:**\n\n```\n## Architecture: Event-Driven\n\n### Event Bus\n- Use Azure Service Bus / RabbitMQ / MassTransit\n- All state changes published as events\n- Events are immutable facts\n\n### Event Patterns\n- **Domain Events**: `TaskCreated`, `TaskCompleted`, `MemberInvited`\n- **Integration Events**: Cross-service communication\n- **Event Sourcing**: Optional, for audit-critical features\n\n### Guarantees\n- At-least-once delivery (consumers must be idempotent)\n- Events include correlation ID for tracing\n\n```\n\n**Spec pattern:**\n\n```\n## Event: TaskCompleted\n\n**Published when**: User marks task as complete\n\n**Payload:** ```json { \"eventId\": \"uuid\", \"eventType\": \"TaskCompleted\", \"timestamp\": \"2026-01-26T10:30:00Z\", \"correlationId\": \"uuid\", \"data\": { \"taskId\": \"uuid\", \"completedBy\": \"userId\", \"teamId\": \"uuid\" } }\n\n```\n\n**Consumers:**\n\n- Notifications: Send completion email to task creator\n- Analytics: Update team productivity metrics\n- Audit: Log completion event\n```\n\n### Pattern #4: Microservices (proceed with caution)\n\n**When to use**: Large team (10+ developers), clear domain boundaries, need independent deployment.\n\n> >\n> ‚ö†Ô∏è **Warning**: Don‚Äôt start with microservices. Extract them from a working monolith when you have clear reasons.\n> >\n\n**Constitution update:**\n\n```\n## Architecture: Microservices\n\n### Services\n- `users-service` - Authentication, profiles (owns users DB)\n- `teams-service` - Team management (owns teams DB)\n- `tasks-service` - Task management (owns tasks DB)\n- `notifications-service` - All notifications (stateless)\n\n### Communication\n- Sync: gRPC for internal, REST for external\n- Async: Azure Service Bus for events\n- No shared databases (each service owns its data)\n\n### Deployment\n- Each service independently deployable\n- Kubernetes for orchestration\n- Service mesh for observability (Istio/Linkerd)\n\n### Data Consistency\n- Eventual consistency between services\n- Saga pattern for distributed transactions\n- Outbox pattern for reliable event publishing\n\n```\n\n### Choosing the right pattern\n\n| Pattern | Team Size | Complexity | When to Choose | | --- | --- | --- | --- | | **Monolith** | 1-5 | Low | Starting out, validating product | | **Modular Monolith** | 3-10 | Medium | Growing, need structure | | **BFF** | 5-15 | Medium | Multiple client types | | **Event-Driven** | 5-20 | High | Async workflows, audit needs | | **Microservices** | 10+ | Very High | Clear domains, independent scaling |\n\n**The spec-driven advantage**: Your constitution documents architectural decisions. When you evolve from monolith to modular to microservices, the spec history shows why.\n\n## Section 5: Scaling strategies\n\n### When your application outgrows the initial architecture\n\nThe Team Task Manager from Part 2 works great for 100 users. What about 10,000? 100,000?\n\n### Strategy #1: Horizontal scaling\n\n**Constitution update:**\n\n```\n## Scaling Requirements\n\n### Stateless Application\n- No in-memory session state\n- Use distributed cache (Redis) for session\n- Any instance can handle any request\n\n### Database Scaling\n- Read replicas for query-heavy operations\n- Connection pooling required\n- Consider read/write splitting at 10k users\n\n```\n\n### Strategy #2: Caching layers\n\n**Spec pattern:**\n\n```\n## Performance: Task List Caching\n\n**Given** a user views their team's task list **When** the list was fetched **Then** return cached result (skip database)\n\n**Cache invalidation:**\n- Task created ‚Üí Invalidate team's task list cache\n- Task updated ‚Üí Invalidate specific task + team list cache\n- Team membership changed ‚Üí Invalidate all team caches\n\n**Cache implementation:**\n- L1: In-memory (IMemoryCache), 10 second TTL\n- L2: Distributed (Redis), 30 second TTL\n\n```\n\n### Strategy #3: Background processing\n\n**Constitution update:**\n\n```\n## Background Jobs\n\n### Job Queue\n- Use Hangfire / Azure Functions / AWS Lambda\n- Long-running operations MUST be async\n\n### Job Types\n- Email sending (- Report generation (- Data export (### Retry Policy\n- 3 retries with exponential backoff\n- Dead letter queue for failed jobs\n- Alert on repeated failures\n\n```\n\n## Section 6: Team communication patterns\n\n### Keeping everyone aligned\n\nSpec-driven development generates artifacts. Those artifacts need to be communicated.\n\n### Pattern #1: Spec review meetings\n\n**Weekly, 30 minutes:**\n\n1. **Spec changes this week**(5 min)\n- What was added/modified/removed?\n2. **Plan deviations**(10 min)\n- Any architectural decisions that deviated from plan?\n- Update plan.md to reflect reality\n3. **Constitution amendments**(10 min)\n- Any new constraints discovered?\n- Any constraints that need relaxing?\n4. **Next week‚Äôs focus**(5 min)\n- Which user stories are in flight?\n\n### Pattern #2: Async spec updates\n\nFor distributed teams:\n\n```\n\n## Spec Changes\n\n### Added\n- User story: Password-less authentication (magic links)\n- Edge case: Handle expired magic links gracefully\n\n### Modified\n- Authentication flow now supports both password and magic link\n\n### Constitution Impact\n- None (existing security requirements cover magic links)\n\n### Reviewers\n- @tech-lead - Constitution compliance\n- @product-owner - Spec accuracy\n- @security-team - Authentication changes\n\n```\n\n### Pattern #3: Decision records\n\nWhen specs change significantly, document why:\n\n```\n\n# ADR-004: Add Magic Link Authentication\n\n## Status\nAccepted\n\n## Context\nUsers forget passwords. Password reset flow has 40% abandonment rate.\n\n## Decision\nAdd magic link (email-based) authentication as alternative to passwords.\n\n## Consequences\n- Positive: Reduced friction, fewer support tickets\n- Negative: Email deliverability becomes critical path\n- Neutral: Both auth methods coexist\n\n## Spec Reference\n- spec.md: Section \"Authentication\" updated\n- plan.md: Email service now critical infrastructure\n\n```\n\n## Key takeaways from Part 4\n\n| # | Takeaway | | --- | --- | | 1 | **Teams need workflows** - Feature branches or trunk-based, pick one and commit | | 2 | **Automate validation** - CI/CD should enforce constitution and spec compliance | | 3 | **Architecture evolves** - Start simple, extract complexity when needed | | 4 | **Document decisions** - Specs + ADRs = traceable architecture history | | 5 | **Communication matters** - Artifacts are useless if the team doesn‚Äôt read them |\n\n## What‚Äôs next\n\nIn **Part 5** (next week), we‚Äôll wrap up the series with:\n\n- **Real case studies** - Actual projects built with spec-driven development\n- **Metrics and outcomes** - What improved, what didn‚Äôt\n- **Lessons learned** - Mistakes made, wisdom gained\n- **The future** - Where AI-assisted development is heading\n\n## Resources\n\n| Resource | Description | | --- | --- | | [**Spec-Kit GitHub**](https://github.com/github/spec-kit) | Official toolkit | | [**GitHub Actions Docs**](https://docs.github.com/en/actions) | CI/CD for GitHub | | [**Azure Pipelines Docs**](https://learn.microsoft.com/en-us/azure/devops/pipelines/) | CI/CD for Azure DevOps | | [**Modular Monolith**](https://www.milanjovanovic.tech/blog/what-is-a-modular-monolith) | Architecture pattern guide | | [**ADR Templates**](https://adr.github.io/) | Architecture Decision Records |\n\n## Series navigation\n\n- **Previous**: [Part 3 - Best practices and troubleshooting](/from-vibe-coding-to-spec-driven-development-part3)\n- **üìç You are here: Part 4 - Team collaboration and advanced patterns**\n- **Next**: Part 5 - Case studies and lessons learned (Coming February 2, 2026)\n\n> >\n> üí¨ **Using spec-driven development with your team?**\n> >\n> I‚Äôd love to hear your experience. Connect with me on [LinkedIn](https://linkedin.com/in/hiddedesmet).\n> >\n> **Want to get notified when Part 5 drops?** Follow me for the finale!\n> >",
  "Author": "Hidde de Smet",
  "ProcessedDate": "2026-01-26 09:06:50"
}
