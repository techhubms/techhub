{
  "PubDate": "2026-01-05T00:00:00+00:00",
  "EnhancedContent": "Search for Blog\n\n[ai-assisted-development](/tags#ai-assisted-development)\n\n[spec-kit](/tags#spec-kit)\n\n[github](/tags#github)\n\n[claude](/tags#claude)\n\n[copilot](/tags#copilot)\n\n[vibe-coding](/tags#vibe-coding)\n\n[specification-driven-development](/tags#specification-driven-development)\n\n[series](/tags#series)\n\n‚Ä¢ Jan 05, 2026\n\n‚Ä¢\n\n16 min read\n\n# From Vibe Coding to Spec-Driven Development: Part 1 - The problem and the solution\n\nPart 1 of our series on mastering AI-assisted development. Discover why 'vibe coding' gets you only 70% there, and why spec-driven development is the answer. This is your roadmap to production-ready AI-generated code.\n\n- https://twitter.com/intent/tweet?text=From%20Vibe%20Coding%20to%20Spec-Driven%20Development:%20Part%201%20-%20The%20problem%20and%20the%20solution&url=https://hiddedesmet.com/from-vibe-coding-to-spec-driven-development\n- https://www.facebook.com/sharer/sharer.php?u=https://hiddedesmet.com/from-vibe-coding-to-spec-driven-development\n- http://pinterest.com/pin/create/button/?url=https://hiddedesmet.com/from-vibe-coding-to-spec-driven-development&amp;media=https://hiddedesmet.com/images/spec-kit/image-01.png&amp;description=From%20Vibe%20Coding%20to%20Spec-Driven%20Development:%20Part%201%20-%20The%20problem%20and%20the%20solution\n- https://www.linkedin.com/shareArticle?mini=true&url=https://hiddedesmet.com/from-vibe-coding-to-spec-driven-development&title=From%20Vibe%20Coding%20to%20Spec-Driven%20Development:%20Part%201%20-%20The%20problem%20and%20the%20solution&summary=Part%201%20of%20our%20series%20on%20mastering%20AI-assisted%20development.%20Discover%20why%20\n\n![From Vibe Coding to Spec-Driven Development: Part 1 - The problem and the solution]()\n\n## Table of Contents\n\n1. Series overview\n2. The AI shift in software development\n3. What is ‚ÄúVibe Coding‚Äù?\n4. The 70% Problem\n1. Four main issues:\n5. The spectrum of AI-assisted development\n6. What is AI-assisted engineering?\n1. Three pillars:\n7. The paradigm shift\n8. The evolution: three levels of spec-driven development\n1. Level 1: Spec-first (throwaway scaffolding)\n2. Level 2: Spec-anchored (documentation trail)\n3. Level 3: Spec-as-source (single source of truth)\n4. Why this matters\n9. Enter Spec-Kit\n1. Key stats:\n2. Quick start:\n10. Core principles\n11. The accountability chain\n12. Constitution vs custom instructions\n1. The real difference: workflow integration\n2. The analogy\n13. Step 1: Create your constitution\n1. Include things like:\n14. Step 2: Write the specification\n1. ‚ùå Don‚Äôt:\n2. ‚úÖ Do:\n15. Step 3: Create the technical plan\n1. The AI generates:\n16. Step 4: Break down into tasks\n1. Each task includes:\n17. Step 5: Implement\n1. The execution flow:\n18. Handling changes after implementation\n1. Before implementation:\n2. Runtime bugs:\n3. Spec changes:\n19. Why this approach works\n20. Best practice #1: Context is everything\n1. ‚ùå Poor context:\n2. ‚úÖ Rich context:\n21. Best practice #2: Plan first, code later\n1. The magic words:\n22. Best practice #3: Test ruthlessly\n1. The rule:\n2. When debugging, be specific:\n23. When to use what\n1. Vibe coding is fine for:\n2. Spec-driven is essential for:\n24. What‚Äôs next in this series\n1. Coming next week (Part 2): The Spec-Kit workflow\n2. Get ready\n25. Key takeaways from part 1\n26. Resources\n27. Series navigation\n\n> >\n> **This is Part 1 of a 5-part series on mastering AI-assisted development.** Each week, we‚Äôll dive deeper into practical techniques for building production-ready applications with AI coding assistants.\n> >\n\n## Series overview\n\n1. **Part 1 (This post)**: The problem and the solution - Why vibe coding fails and what spec-driven development offers\n2. **Part 2 (Jan 12)**: Deep dive into the Spec-Kit workflow - Constitution, specs, plans, and tasks\n3. **Part 3 (Jan 19)**: Best practices and troubleshooting - Real-world debugging and iteration patterns\n4. **Part 4 (Jan 26)**: Team collaboration and advanced patterns - Using Spec-Kit in production environments\n5. **Part 5 (Feb 2)**: Case studies and lessons learned - Real projects, real results, real lessons\n\nA few weeks ago, I presented at a Xebia .NET synergy event on moving from ad-hoc ‚Äúvibe coding‚Äù to structured, spec-driven development. The questions and discussions afterward showed that developers are wrestling with these same issues, so I decided to expand the content into this blog series.\n\nThis blog series is the result of that presentation, expanded and refined based on the feedback and discussions with fellow developers. Whether you attended the event or are discovering this topic for the first time, my goal is to give you practical, actionable guidance for building production-ready AI-assisted applications.\n\nAI coding assistants have changed how we write software. The code they generate often works well enough to ship, but falls apart when you need to maintain or extend it. This guide shows you how to get from code that works to code that‚Äôs production-ready using specification-driven development.\n\nBased on [GitHub‚Äôs Spec-Kit](https://github.com/github/spec-kit) and [Addy Osmani‚Äôs ‚ÄúBeyond Vibe Coding‚Äù](https://addyosmani.com/blog/vibe-coding/) guide, this series walks you through a structured approach to AI-assisted development that actually works for real-world applications.\n\nIn this first post, we‚Äôll explore the fundamental problem with unstructured AI coding and introduce you to the spec-driven approach. Next week, we‚Äôll get hands-on with the actual workflow.\n\n## The AI shift in software development\n\nSoftware development has changed significantly in the past few years:\n\n- **Yesterday**: Simple autocomplete finishing variable names and common patterns\n- **Today**: AI agents that write entire features, debug complex issues, and refactor codebases\n- **Tomorrow**: Autonomous systems handling full development cycles\n\nThe question is how to use AI effectively while maintaining code quality.\n\n## What is ‚ÄúVibe Coding‚Äù?\n\n![What is vibe coding?](/images/spec-kit/slide-03.png)\n\nThe term ‚Äúvibe coding‚Äù comes from Andrej Karpathy (former head of AI at Tesla). It describes an approach where you:\n\n> >\n> Accept AI suggestions without critical review, trusting the output completely\n> >\n\nFor prototypes and experiments? Maybe fine. For production code? We need something more structured.\n\nKey insight: Vibe coding isn‚Äôt inherently bad code‚Äîit‚Äôs a specific approach where you trust the AI completely and don‚Äôt review what it produces.\n\n## The 70% Problem\n\n![The 70% problem](/images/spec-kit/slide-04.png)\n\nHere‚Äôs the core problem with vibe coding: AI can get you 70% of the way incredibly fast. But that last 30%? That‚Äôs where things get difficult.\n\n### Four main issues:\n\n1. **Two steps back pattern**: Fixing bugs creates new bugs\n2. **Hidden technical debt**: Code works but isn‚Äôt maintainable\n3. **Diminishing returns**: AI helps experts more than beginners\n4. **Security vulnerabilities**: Database credentials leak into client-side code\n\n> >\n> ‚ÄúWe‚Äôve seen apps leak database credentials because the AI ‚Äòhelpfully‚Äô included them in client-side code.‚Äù\n> >\n\nThat‚Äôs not hypothetical‚Äîit happens.\n\n## The spectrum of AI-assisted development\n\n![The spectrum](/images/spec-kit/slide-05.png)\n\nAI-assisted development exists on a spectrum:\n\n| Approach | Risk | Reward | Control | | --- | --- | --- | --- | | **Autocomplete** | Low | Low | High | | **Chatbot assistance** | Medium | Medium | Medium | | **Agentic coding** | High | High | Lower | | **Spec-driven development** | Managed | High | High |\n\nThe key insight: As AI gets more capable, we need more structure, not less.\n\n## What is AI-assisted engineering?\n\n![AI-Assisted Engineering](/images/spec-kit/slide-06.png)\n\nAI-assisted engineering is not about letting AI do whatever it wants. It‚Äôs about maintaining human oversight while leveraging AI capabilities.\n\n### Three pillars:\n\n1. **Human-in-the-loop**: You stay in control of decisions\n2. **Structured methodology**: Clear processes and checkpoints\n3. **Quality guardrails**: Automated checks and balances\n\nThink of it like being the architect while AI is the contractor. You design, they build, but you review everything.\n\n## The paradigm shift\n\n![The paradigm shift](/images/spec-kit/slide-07.png)\n\nThis is where the paradigm shift happens:\n\n| OLD WAY | NEW WAY | | --- | --- | | Write code first | Write specifications first | | Document later (maybe) | Code follows from specs | | Specs are scaffolding | Specs are source of truth |\n\nFor decades, we treated specifications as scaffolding‚Äîuseful during construction but discarded afterward. Now, specifications become the **source of truth** that generates the implementation.\n\n## The evolution: three levels of spec-driven development\n\nAs Martin Fowler explores in his article on [exploring generative AI](https://martinfowler.com/articles/exploring-gen-ai.html), spec-driven development exists on a maturity spectrum. Understanding these levels helps clarify where Spec-Kit fits.\n\n```mermaid %%{init: {'theme':'base', 'themeVariables': { 'fontSize':'18px'}}}%% graph TB subgraph Level1[\"<b>Level 1: Spec-First (Throwaway)</b>\"] direction TB A1[\"üìÑ Write spec.md<br/>for feature\"] B1[\"‚öôÔ∏è Generate<br/>code\"] C1[\"üóëÔ∏è Delete<br/>spec.md\"] D1[\" \"] E1[\"üìÑ Write new<br/>spec.md\"] F1[\"‚öôÔ∏è Update<br/>code\"]\n\nA1 --> B1 B1 --> C1 C1 -.->|New feature needed| D1 D1 -.-> E1 E1 --> F1 end\n\nsubgraph Level2[\"<b>Level 2: Spec-Anchored (Multiple Files)</b>\"] direction TB A2[\"üìÑ Original<br/>spec.md\"] B2[\"‚öôÔ∏è Generate<br/>code\"] D2[\" \"] E2[\"üìù Write<br/>change-spec.md\"] F2[\"‚öôÔ∏è Update<br/>code\"] G2[\"üìÑ spec.md stays<br/>but outdated\"]\n\nA2 --> B2 B2 -.->|Change needed| D2 D2 -.-> E2 E2 --> F2 F2 --> G2 end\n\nsubgraph Level3[\"<b>Level 3: Spec-as-Source (Single Truth)</b>\"] direction TB A3[\"üìÑ spec.md<br/>is truth\"] B3[\"‚öôÔ∏è Generate<br/>code\"] D3[\" \"] E3[\"‚úèÔ∏è Edit<br/>spec.md\"] F3[\"‚ôªÔ∏è Regenerate<br/>code\"]\n\nA3 --> B3 B3 -.->|Change needed| D3 D3 -.-> E3 E3 --> F3 F3 -.-> A3 end\n\nstyle C1 fill:#ffdddd,stroke:#cc0000,stroke-width:3px style E2 fill:#fff4cc,stroke:#cc9900,stroke-width:3px style E3 fill:#ddffdd,stroke:#00cc00,stroke-width:3px style F3 fill:#ddffdd,stroke:#00cc00,stroke-width:3px style A3 fill:#ddffdd,stroke:#00cc00,stroke-width:3px\n\nstyle Level1 fill:#f9f9f9,stroke:#666,stroke-width:2px style Level2 fill:#f9f9f9,stroke:#666,stroke-width:2px style Level3 fill:#f9f9f9,stroke:#666,stroke-width:2px\n\n```\n\n### Level 1: Spec-first (throwaway scaffolding)\n\nYou write a spec to help the AI understand what to build, then delete it once the code is generated. The spec was just scaffolding‚Äîuseful temporarily, then discarded.\n\n**Problem**: When you need to change the feature, you start from scratch with a new spec. No continuity, no history.\n\n### Level 2: Spec-anchored (documentation trail)\n\nThe original spec persists, but changes are documented in separate files. You‚Äôre building a paper trail of evolution, but the original spec becomes outdated.\n\n**Problem**: You end up with `spec.md` , `new-feature-spec.md` , `bug-fix-spec.md` , etc. Which one is the source of truth? You have to read them all in order.\n\n### Level 3: Spec-as-source (single source of truth)\n\nThe spec is the source of truth. When you need changes, you edit the spec and regenerate the code. The spec stays current because it‚Äôs the authoritative definition of what the system should do.\n\n**This is where Spec-Kit lives.** The specification isn‚Äôt documentation of the code‚Äîthe code is an implementation of the specification.\n\n### Why this matters\n\nIn traditional development, we wrote code and maybe documented it later. The code was the truth.\n\nIn spec-as-source development, we write specifications and generate code from them. The spec is the truth.\n\nThis isn‚Äôt just a philosophical shift‚Äîit‚Äôs practical. When bugs appear or requirements change, you update the spec and regenerate. The spec never drifts out of sync with reality.\n\n## Enter Spec-Kit\n\n![Introducing Spec-Kit](/images/spec-kit/slide-10.png)\n\n[Spec-Kit](https://github.com/github/spec-kit) is GitHub‚Äôs open-source framework for spec-driven development.\n\n### Key stats:\n\n- **54k+ GitHub stars** ‚Äî Battle-tested, not experimental\n- **18+ AI agents supported** ‚Äî Claude, Copilot, Cursor, Windsurf, Gemini, and more\n- **MIT licensed** ‚Äî Free to use\n\n### Quick start:\n\n``` uv tool install specify-cli --from git+https://github.com/github/spec-kit.git specify init my-project\n\n```\n\n## Core principles\n\n![Core principles](/images/spec-kit/slide-11.png)\n\nFour core principles guide Spec-Kit:\n\n1. **Intent-driven**: Focus on what and why, not how\n2. **Rich specifications**: Detailed context beats vague prompts\n3. **Multi-step refinement**: Review and iterate at each phase\n4. **AI-native design**: Built specifically for how LLMs think\n\nThese aren‚Äôt arbitrary‚Äîthey‚Äôre based on what actually works in practice.\n\n## The accountability chain\n\n![The accountability chain](/images/spec-kit/slide-12.png)\n\nHere‚Äôs the complete Spec-Kit workflow:\n\n``` Constitution ‚Üí Specification ‚Üí Plan ‚Üí Tasks ‚Üí Implementation\n\n```\n\nEach step has a slash command. Each step produces artifacts for the next step. This chain creates **accountability**‚Äîyou can trace any decision back to its source.\n\n| Step | Command | Output | | --- | --- | --- | | Constitution | `/speckit.constitution` | `constitution.md` | | Specify | `/speckit.specify` | `spec.md` | | Plan | `/speckit.plan` | `plan.md`<br>, `data-model.md`<br>, `api-spec.json` | | Tasks | `/speckit.tasks` | `tasks.md` | | Implement | `/speckit.implement` | Working code |\n\n## Constitution vs custom instructions\n\n![Constitution vs custom instructions](/images/spec-kit/slide-15.png)\n\nYou might be thinking: *‚ÄúWait, I already have custom instructions for Copilot or Claude Code. Isn‚Äôt this the same thing?‚Äù*\n\nGreat question‚Äîand this is the heart of the confusion.\n\nBoth files are just Markdown. An LLM can read both the same way. So why does one work better?\n\n### The real difference: workflow integration\n\n**Spec-Kit‚Äôs constitution** is part of a multi-step enforced workflow:\n\n1. Reads `constitution.md`\nfirst\n2. Injects it into every step: spec, plan, tasks, implementation\n3. Each artifact is validated against the constitution\n4. Creates an accountability chain\n\n**Custom instructions** (like Copilot‚Äôs `copilot-instructions.md` ):\n\n1. Added to prompt context\n2. Respected during that interaction\n3. But no formal spec ‚Üí plan ‚Üí tasks chain\n4. No artifact accountability\n\n### The analogy\n\n| Spec-Kit | Custom instructions | | --- | --- | | Architect‚Äôs blueprint + construction plan + building permits checked at every phase | Style guide for a contractor + final inspection |\n\nBoth are valuable! You can even use both together‚ÄîCopilot‚Äôs instructions for coding style, Spec-Kit‚Äôs workflow for complex features.\n\n## Step 1: Create your constitution\n\n![Create constitution](/images/spec-kit/slide-14.png)\n\nThink of this as your project‚Äôs ‚Äúbill of rights‚Äù‚Äîthe principles that guide all decisions.\n\n### Include things like:\n\n- Code quality standards\n- Testing requirements\n- Performance targets\n- Security guidelines\n- Technology constraints\n\n``` /speckit.constitution\n\n```\n\nThe AI references this during all phases. It‚Äôs your guardrail against scope creep and over-engineering.\n\n## Step 2: Write the specification\n\n![Write specification](/images/spec-kit/slide-16.png)\n\nFocus on what and why‚Äînot how.\n\n### ‚ùå Don‚Äôt:\n\n``` Build me a todo app\n\n```\n\n### ‚úÖ Do:\n\n```\n## User Stories\n\nAs a busy professional, I want to:\n- Quickly capture tasks with minimal friction\n- See my tasks organized by priority\n- Mark tasks complete with a single tap\n\n## Acceptance Criteria\n- Task creation takes < 2 seconds\n- Tasks persist across browser sessions\n- Works offline with sync when online\n\n```\n\nThe more context you provide here, the better your results throughout the entire process.\n\n## Step 3: Create the technical plan\n\n![Technical plan](/images/spec-kit/slide-18.png)\n\nNow you specify the tech stack. Not before.\n\nWhy wait? Because understanding what you‚Äôre building should drive how you build it.\n\n### The AI generates:\n\n- `plan.md`\n: Overall architecture\n- `data-model.md`\n: Your data structures\n- `api-spec.json`\n: API contracts\n- `research.md`\n: Framework recommendations\n\n**Pro tip**: Ask the AI to research rapidly-changing frameworks. Its training data might be outdated on specific library versions.\n\n## Step 4: Break down into tasks\n\n![Generate tasks](/images/spec-kit/slide-19.png)\n\nThis takes your plan and breaks it into actionable, implementable chunks.\n\n### Each task includes:\n\n- Clear description\n- Dependencies on other tasks\n- Acceptance criteria\n- Estimated complexity\n\nThe key is **ordered execution**‚Äîdependencies are respected automatically.\n\n**Review these tasks!** This is your last chance to adjust scope before implementation begins.\n\n## Step 5: Implement\n\n![Implementation](/images/spec-kit/slide-20.png)\n\nThe `/speckit.implement` command:\n\n1. Validates all prerequisites exist\n2. Parses the task breakdown\n3. Executes in correct order\n4. Handles errors gracefully\n\n### The execution flow:\n\n``` Load Constitution ‚Üí Validate Spec ‚Üí Review Plan ‚Üí Execute Tasks ‚Üí Run Tests\n\n```\n\nCritical: Test the application after completion. Feed runtime errors back to the AI.\n\n## Handling changes after implementation\n\n![Validation and debugging](/images/spec-kit/slide-21.png)\n\nWhat happens when specs change or bugs appear? This is frontier territory, but here‚Äôs the workflow:\n\n### Before implementation:\n\n- `/speckit.analyze`\n‚Äî Cross-artifact consistency check\n- Audit the plan\n- `/speckit.checklist`\n‚Äî Verify readiness\n\n### Runtime bugs:\n\n``` /implement fix bug: [description with full context]\n\n```\n\n### Spec changes:\n\n1. Update `spec.md`\n2. Re-run `/speckit.plan`\n3. Re-run `/speckit.tasks`\n4. Continue `/implement`\n\nKey principle: ‚ÄúSpecification is durable, plan/tasks are flexible‚Äù\n\nAfter any fix, ask AI to: ‚ÄúUpdate plan, tasks, data-model to reflect this change‚Äù\n\n## Why this approach works\n\n![Why it works](/images/spec-kit/slide-23.png)\n\nFour reasons:\n\n1. **Context is king** ‚Äî AI output quality is proportional to context quality\n2. **Audit trail** ‚Äî Every decision is documented and traceable\n3. **Iterative refinement** ‚Äî Catch mistakes early, not in production\n4. **Safety rails** ‚Äî The constitution prevents over-engineering\n\nResult: You get the full 100%, not just the easy 70%.\n\n## Best practice #1: Context is everything\n\n![Context best practice](/images/spec-kit/slide-24.png)\n\n### ‚ùå Poor context:\n\n``` Why is my code not working?\n\n```\n\n### ‚úÖ Rich context:\n\n``` The handleSubmit function in UserForm.tsx throws \"Cannot read property 'email' of undefined\" on line 47 when the form is submitted with empty fields.\n\nStack trace: [full trace here]\n\nExpected: Form validation should prevent submission Actual: Error thrown before validation runs\n\n```\n\nThe quality of AI output is directly proportional to the context you provide.\n\n## Best practice #2: Plan first, code later\n\n![Plan first](/images/spec-kit/slide-25.png)\n\nThis is exactly what happens when you say ‚Äúbuild me a todo app‚Äù without planning:\n\nYou ask for a bicycle. The AI proudly presents‚Ä¶ a massive over-engineered robot spaceship.\n\n### The magic words:\n\n> >\n> ‚ÄúGive me options, starting with the simplest. Don‚Äôt code yet.‚Äù\n> >\n\nAsk for architecture OPTIONS first. Start with the simplest viable solution.\n\n## Best practice #3: Test ruthlessly\n\n![Test ruthlessly](/images/spec-kit/slide-26.png)\n\n### The rule:\n\nAfter every AI update:\n\n1. Test in localhost immediately\n2. Open browser console\n3. Check for errors\n\n### When debugging, be specific:\n\n‚ùå *‚ÄúIt‚Äôs broken‚Äù*\n\n‚úÖ *‚ÄúThe submit button should save the form data, but instead it shows ‚ÄòTypeError: Cannot read property map of undefined‚Äô in the console‚Äù*\n\nSmall, incremental testing prevents nightmare debugging sessions.\n\n## When to use what\n\n![When to use what](/images/spec-kit/slide-28.png)\n\n### Vibe coding is fine for:\n\n- Quick prototypes and experiments\n- Learning new technologies\n- One-off scripts you‚Äôll throw away\n\n### Spec-driven is essential for:\n\n- Production applications\n- Team projects\n- Anything with users\n- Code that needs to be maintained\n\n**The key question**: Will someone (including future you) need to understand this code later?\n\n## What‚Äôs next in this series\n\n![Getting started](/images/spec-kit/slide-31.png)\n\nNow that you understand the *why* behind spec-driven development, you‚Äôre ready for the *how*.\n\n### Coming next week (Part 2): The Spec-Kit workflow\n\nWe‚Äôll do a hands-on walkthrough of the complete workflow:\n\n- **Creating your constitution** - What to include and what to skip\n- **Writing effective specifications** - Real examples from production projects\n- **Generating plans and tasks** - How AI breaks down your spec into implementable chunks\n- **The implementation phase** - What happens when you hit `/speckit.implement`\n- **Dealing with AI hallucinations** - Practical recovery strategies\n\nEach step will include real code examples, common mistakes, and troubleshooting tips.\n\n### Get ready\n\nBefore next week‚Äôs post, you can:\n\n```\n# Install Spec-Kit CLI\nuv tool install specify-cli --from git+https://github.com/github/spec-kit.git\n\n# Verify installation\nspecify --version\n\n```\n\nWe‚Äôll use this in Part 2 to build a real application together.\n\n## Key takeaways from part 1\n\n![Key takeaways](/images/spec-kit/slide-32.png)\n\n1. **Vibe coding gets you 70%**: The last 30% is where real engineering happens\n2. **Specifications are the new source code**: Write them first, code follows\n3. **Structure enables speed**: More guardrails means less debugging\n4. **Three levels of spec-driven development**: Spec-Kit operates at Level 3 (spec-as-source)\n5. **You‚Äôre the architect**: AI is a tool, but you make the decisions\n\nNext week in Part 2, we‚Äôll put these concepts into practice with a complete walkthrough of the Spec-Kit workflow.\n\n## Resources\n\n- **Spec-Kit**: [github.com/github/spec-kit](https://github.com/github/spec-kit)\n- **Beyond Vibe Coding**: [addyosmani.com/blog/vibe-coding](https://addyosmani.com/blog/vibe-coding/)\n- **GitHub Copilot Custom Instructions**: [docs.github.com](https://docs.github.com/en/copilot/how-tos/configure-custom-instructions/add-repository-instructions)\n\n## Series navigation\n\n**üìç You are here: Part 1 - The problem and the solution**\n\n- **Next**: Part 2 - Deep dive into the Spec-Kit workflow (Coming January 12, 2026)\n- Part 3 - Best practices and troubleshooting (Coming January 19, 2026)\n- Part 4 - Team collaboration and advanced patterns (Coming January 26, 2026)\n- Part 5 - Case studies and lessons learned (Coming February 2, 2026)\n\n*This series is based on a presentation I gave about moving from ad-hoc AI-assisted coding to structured, specification-driven development. The full presentation slides are available for download.*\n\n**Questions or feedback?** Connect with me on [LinkedIn](https://linkedin.com/in/hiddedesmet) or check out more posts at [hiddedesmet.com](https://hiddedesmet.com).\n\n**Want to get notified when Part 2 drops?** Follow me on [LinkedIn](https://linkedin.com/in/hiddedesmet) for updates.\n\n### Start the conversation\n\n## Related\n\n[See all ai-assisted-development](/tags#ai-assisted-development)",
  "ProcessedDate": "2026-01-05 08:02:14",
  "FeedUrl": "https://hiddedesmet.com/feed.xml",
  "FeedLevelAuthor": "Hidde de Smet",
  "OutputDir": "_blogs",
  "Author": "Hidde de Smet",
  "Tags": [
    "AI",
    "ai-assisted-development",
    "claude",
    "copilot",
    "Development",
    "DevOps",
    "github",
    "series",
    "spec-kit",
    "specification-driven-development",
    "vibe-coding"
  ],
  "Description": "> >\n> **This is Part 1 of a 5-part series on mastering AI-assisted development.** Each week, we‚Äôll dive deeper into practical techniques for building production-ready applications with AI coding assistants.\n> >\n\n## Series overview\n\n1. **Part 1 (This post)**: The problem and the solution - Why vibe coding fails and what spec-driven development offers\n2. **Part 2 (Jan 12)**: Deep dive into the Spec-Kit workflow - Constitution, specs, plans, and tasks\n3. **Part 3 (Jan 19)**: Best practices and troubleshooting - Real-world debugging and iteration patterns\n4. **Part 4 (Jan 26)**: Team collaboration and advanced patterns - Using Spec-Kit in production environments\n5. **Part 5 (Feb 2)**: Case studies and lessons learned - Real projects, real results, real lessons\n\nA few weeks ago, I presented at a Xebia .NET synergy event on moving from ad-hoc ‚Äúvibe coding‚Äù to structured, spec-driven development. The questions and discussions afterward showed that developers are wrestling with these same issues, so I decided to expand the content into this blog series.\n\nThis blog series is the result of that presentation, expanded and refined based on the feedback and discussions with fellow developers. Whether you attended the event or are discovering this topic for the first time, my goal is to give you practical, actionable guidance for building production-ready AI-assisted applications.\n\nAI coding assistants have changed how we write software. The code they generate often works well enough to ship, but falls apart when you need to maintain or extend it. This guide shows you how to get from code that works to code that‚Äôs production-ready using specification-driven development.\n\nBased on [GitHub‚Äôs Spec-Kit](https://github.com/github/spec-kit) and [Addy Osmani‚Äôs ‚ÄúBeyond Vibe Coding‚Äù](https://addyosmani.com/blog/vibe-coding/) guide, this series walks you through a structured approach to AI-assisted development that actually works for real-world applications.\n\nIn this first post, we‚Äôll explore the fundamental problem with unstructured AI coding and introduce you to the spec-driven approach. Next week, we‚Äôll get hands-on with the actual workflow.\n\n## The AI shift in software development\n\nSoftware development has changed significantly in the past few years:\n\n- **Yesterday**: Simple autocomplete finishing variable names and common patterns\n- **Today**: AI agents that write entire features, debug complex issues, and refactor codebases\n- **Tomorrow**: Autonomous systems handling full development cycles\n\nThe question is how to use AI effectively while maintaining code quality.\n\n## What is ‚ÄúVibe Coding‚Äù?\n\n![What is vibe coding?](/images/spec-kit/slide-03.png)\n\nThe term ‚Äúvibe coding‚Äù comes from Andrej Karpathy (former head of AI at Tesla). It describes an approach where you:\n\n> >\n> Accept AI suggestions without critical review, trusting the output completely\n> >\n\nFor prototypes and experiments? Maybe fine. For production code? We need something more structured.\n\nKey insight: Vibe coding isn‚Äôt inherently bad code‚Äîit‚Äôs a specific approach where you trust the AI completely and don‚Äôt review what it produces.\n\n## The 70% Problem\n\n![The 70% problem](/images/spec-kit/slide-04.png)\n\nHere‚Äôs the core problem with vibe coding: AI can get you 70% of the way incredibly fast. But that last 30%? That‚Äôs where things get difficult.\n\n### Four main issues:\n\n1. **Two steps back pattern**: Fixing bugs creates new bugs\n2. **Hidden technical debt**: Code works but isn‚Äôt maintainable\n3. **Diminishing returns**: AI helps experts more than beginners\n4. **Security vulnerabilities**: Database credentials leak into client-side code\n\n> >\n> ‚ÄúWe‚Äôve seen apps leak database credentials because the AI ‚Äòhelpfully‚Äô included them in client-side code.‚Äù\n> >\n\nThat‚Äôs not hypothetical‚Äîit happens.\n\n## The spectrum of AI-assisted development\n\n![The spectrum](/images/spec-kit/slide-05.png)\n\nAI-assisted development exists on a spectrum:\n\n| Approach | Risk | Reward | Control | | --- | --- | --- | --- | | **Autocomplete** | Low | Low | High | | **Chatbot assistance** | Medium | Medium | Medium | | **Agentic coding** | High | High | Lower | | **Spec-driven development** | Managed | High | High |\n\nThe key insight: As AI gets more capable, we need more structure, not less.\n\n## What is AI-assisted engineering?\n\n![AI-Assisted Engineering](/images/spec-kit/slide-06.png)\n\nAI-assisted engineering is not about letting AI do whatever it wants. It‚Äôs about maintaining human oversight while leveraging AI capabilities.\n\n### Three pillars:\n\n1. **Human-in-the-loop**: You stay in control of decisions\n2. **Structured methodology**: Clear processes and checkpoints\n3. **Quality guardrails**: Automated checks and balances\n\nThink of it like being the architect while AI is the contractor. You design, they build, but you review everything.\n\n## The paradigm shift\n\n![The paradigm shift](/images/spec-kit/slide-07.png)\n\nThis is where the paradigm shift happens:\n\n| OLD WAY | NEW WAY | | --- | --- | | Write code first | Write specifications first | | Document later (maybe) | Code follows from specs | | Specs are scaffolding | Specs are source of truth |\n\nFor decades, we treated specifications as scaffolding‚Äîuseful during construction but discarded afterward. Now, specifications become the **source of truth** that generates the implementation.\n\n## The evolution: three levels of spec-driven development\n\nAs Martin Fowler explores in his article on [exploring generative AI](https://martinfowler.com/articles/exploring-gen-ai.html), spec-driven development exists on a maturity spectrum. Understanding these levels helps clarify where Spec-Kit fits.\n\n```mermaid %%{init: {'theme':'base', 'themeVariables': { 'fontSize':'18px'}}}%% graph TB subgraph Level1[\"Level 1: Spec-First (Throwaway)\"] direction TB A1[\"üìÑ Write spec.mdfor feature\"] B1[\"‚öôÔ∏è Generatecode\"] C1[\"üóëÔ∏è Deletespec.md\"] D1[\" \"] E1[\"üìÑ Write newspec.md\"] F1[\"‚öôÔ∏è Updatecode\"]\n\nA1 --> B1 B1 --> C1 C1 -.->|New feature needed| D1 D1 -.-> E1 E1 --> F1 end\n\nsubgraph Level2[\"Level 2: Spec-Anchored (Multiple Files)\"] direction TB A2[\"üìÑ Originalspec.md\"] B2[\"‚öôÔ∏è Generatecode\"] D2[\" \"] E2[\"üìù Writechange-spec.md\"] F2[\"‚öôÔ∏è Updatecode\"] G2[\"üìÑ spec.md staysbut outdated\"]\n\nA2 --> B2 B2 -.->|Change needed| D2 D2 -.-> E2 E2 --> F2 F2 --> G2 end\n\nsubgraph Level3[\"Level 3: Spec-as-Source (Single Truth)\"] direction TB A3[\"üìÑ spec.mdis truth\"] B3[\"‚öôÔ∏è Generatecode\"] D3[\" \"] E3[\"‚úèÔ∏è Editspec.md\"] F3[\"‚ôªÔ∏è Regeneratecode\"]\n\nA3 --> B3 B3 -.->|Change needed| D3 D3 -.-> E3 E3 --> F3 F3 -.-> A3 end\n\nstyle C1 fill:#ffdddd,stroke:#cc0000,stroke-width:3px style E2 fill:#fff4cc,stroke:#cc9900,stroke-width:3px style E3 fill:#ddffdd,stroke:#00cc00,stroke-width:3px style F3 fill:#ddffdd,stroke:#00cc00,stroke-width:3px style A3 fill:#ddffdd,stroke:#00cc00,stroke-width:3px\n\nstyle Level1 fill:#f9f9f9,stroke:#666,stroke-width:2px style Level2 fill:#f9f9f9,stroke:#666,stroke-width:2px style Level3 fill:#f9f9f9,stroke:#666,stroke-width:2px\n\n```\n\n### Level 1: Spec-first (throwaway scaffolding)\n\nYou write a spec to help the AI understand what to build, then delete it once the code is generated. The spec was just scaffolding‚Äîuseful temporarily, then discarded.\n\n**Problem**: When you need to change the feature, you start from scratch with a new spec. No continuity, no history.\n\n### Level 2: Spec-anchored (documentation trail)\n\nThe original spec persists, but changes are documented in separate files. You‚Äôre building a paper trail of evolution, but the original spec becomes outdated.\n\n**Problem**: You end up with `spec.md` , `new-feature-spec.md` , `bug-fix-spec.md` , etc. Which one is the source of truth? You have to read them all in order.\n\n### Level 3: Spec-as-source (single source of truth)\n\nThe spec is the source of truth. When you need changes, you edit the spec and regenerate the code. The spec stays current because it‚Äôs the authoritative definition of what the system should do.\n\n**This is where Spec-Kit lives.** The specification isn‚Äôt documentation of the code‚Äîthe code is an implementation of the specification.\n\n### Why this matters\n\nIn traditional development, we wrote code and maybe documented it later. The code was the truth.\n\nIn spec-as-source development, we write specifications and generate code from them. The spec is the truth.\n\nThis isn‚Äôt just a philosophical shift‚Äîit‚Äôs practical. When bugs appear or requirements change, you update the spec and regenerate. The spec never drifts out of sync with reality.\n\n## Enter Spec-Kit\n\n![Introducing Spec-Kit](/images/spec-kit/slide-10.png)\n\n[Spec-Kit](https://github.com/github/spec-kit) is GitHub‚Äôs open-source framework for spec-driven development.\n\n### Key stats:\n\n- **54k+ GitHub stars** ‚Äî Battle-tested, not experimental\n- **18+ AI agents supported** ‚Äî Claude, Copilot, Cursor, Windsurf, Gemini, and more\n- **MIT licensed** ‚Äî Free to use\n\n### Quick start:\n\n``` uv tool install specify-cli --from git+https://github.com/github/spec-kit.git specify init my-project\n\n```\n\n## Core principles\n\n![Core principles](/images/spec-kit/slide-11.png)\n\nFour core principles guide Spec-Kit:\n\n1. **Intent-driven**: Focus on what and why, not how\n2. **Rich specifications**: Detailed context beats vague prompts\n3. **Multi-step refinement**: Review and iterate at each phase\n4. **AI-native design**: Built specifically for how LLMs think\n\nThese aren‚Äôt arbitrary‚Äîthey‚Äôre based on what actually works in practice.\n\n## The accountability chain\n\n![The accountability chain](/images/spec-kit/slide-12.png)\n\nHere‚Äôs the complete Spec-Kit workflow:\n\n``` Constitution ‚Üí Specification ‚Üí Plan ‚Üí Tasks ‚Üí Implementation\n\n```\n\nEach step has a slash command. Each step produces artifacts for the next step. This chain creates **accountability**‚Äîyou can trace any decision back to its source.\n\n| Step | Command | Output | | --- | --- | --- | | Constitution | `/speckit.constitution` | `constitution.md` | | Specify | `/speckit.specify` | `spec.md` | | Plan | `/speckit.plan` | `plan.md`<br>, `data-model.md`<br>, `api-spec.json` | | Tasks | `/speckit.tasks` | `tasks.md` | | Implement | `/speckit.implement` | Working code |\n\n## Constitution vs custom instructions\n\n![Constitution vs custom instructions](/images/spec-kit/slide-15.png)\n\nYou might be thinking: *‚ÄúWait, I already have custom instructions for Copilot or Claude Code. Isn‚Äôt this the same thing?‚Äù*\n\nGreat question‚Äîand this is the heart of the confusion.\n\nBoth files are just Markdown. An LLM can read both the same way. So why does one work better?\n\n### The real difference: workflow integration\n\n**Spec-Kit‚Äôs constitution** is part of a multi-step enforced workflow:\n\n1. Reads `constitution.md`\nfirst\n2. Injects it into every step: spec, plan, tasks, implementation\n3. Each artifact is validated against the constitution\n4. Creates an accountability chain\n\n**Custom instructions** (like Copilot‚Äôs `copilot-instructions.md` ):\n\n1. Added to prompt context\n2. Respected during that interaction\n3. But no formal spec ‚Üí plan ‚Üí tasks chain\n4. No artifact accountability\n\n### The analogy\n\n| Spec-Kit | Custom instructions | | --- | --- | | Architect‚Äôs blueprint + construction plan + building permits checked at every phase | Style guide for a contractor + final inspection |\n\nBoth are valuable! You can even use both together‚ÄîCopilot‚Äôs instructions for coding style, Spec-Kit‚Äôs workflow for complex features.\n\n## Step 1: Create your constitution\n\n![Create constitution](/images/spec-kit/slide-14.png)\n\nThink of this as your project‚Äôs ‚Äúbill of rights‚Äù‚Äîthe principles that guide all decisions.\n\n### Include things like:\n\n- Code quality standards\n- Testing requirements\n- Performance targets\n- Security guidelines\n- Technology constraints\n\n``` /speckit.constitution\n\n```\n\nThe AI references this during all phases. It‚Äôs your guardrail against scope creep and over-engineering.\n\n## Step 2: Write the specification\n\n![Write specification](/images/spec-kit/slide-16.png)\n\nFocus on what and why‚Äînot how.\n\n### ‚ùå Don‚Äôt:\n\n``` Build me a todo app\n\n```\n\n### ‚úÖ Do:\n\n```\n## User Stories\n\nAs a busy professional, I want to:\n- Quickly capture tasks with minimal friction\n- See my tasks organized by priority\n- Mark tasks complete with a single tap\n\n## Acceptance Criteria\n- Task creation takes - Tasks persist across browser sessions\n- Works offline with sync when online\n\n```\n\nThe more context you provide here, the better your results throughout the entire process.\n\n## Step 3: Create the technical plan\n\n![Technical plan](/images/spec-kit/slide-18.png)\n\nNow you specify the tech stack. Not before.\n\nWhy wait? Because understanding what you‚Äôre building should drive how you build it.\n\n### The AI generates:\n\n- `plan.md`\n: Overall architecture\n- `data-model.md`\n: Your data structures\n- `api-spec.json`\n: API contracts\n- `research.md`\n: Framework recommendations\n\n**Pro tip**: Ask the AI to research rapidly-changing frameworks. Its training data might be outdated on specific library versions.\n\n## Step 4: Break down into tasks\n\n![Generate tasks](/images/spec-kit/slide-19.png)\n\nThis takes your plan and breaks it into actionable, implementable chunks.\n\n### Each task includes:\n\n- Clear description\n- Dependencies on other tasks\n- Acceptance criteria\n- Estimated complexity\n\nThe key is **ordered execution**‚Äîdependencies are respected automatically.\n\n**Review these tasks!** This is your last chance to adjust scope before implementation begins.\n\n## Step 5: Implement\n\n![Implementation](/images/spec-kit/slide-20.png)\n\nThe `/speckit.implement` command:\n\n1. Validates all prerequisites exist\n2. Parses the task breakdown\n3. Executes in correct order\n4. Handles errors gracefully\n\n### The execution flow:\n\n``` Load Constitution ‚Üí Validate Spec ‚Üí Review Plan ‚Üí Execute Tasks ‚Üí Run Tests\n\n```\n\nCritical: Test the application after completion. Feed runtime errors back to the AI.\n\n## Handling changes after implementation\n\n![Validation and debugging](/images/spec-kit/slide-21.png)\n\nWhat happens when specs change or bugs appear? This is frontier territory, but here‚Äôs the workflow:\n\n### Before implementation:\n\n- `/speckit.analyze`\n‚Äî Cross-artifact consistency check\n- Audit the plan\n- `/speckit.checklist`\n‚Äî Verify readiness\n\n### Runtime bugs:\n\n``` /implement fix bug: [description with full context]\n\n```\n\n### Spec changes:\n\n1. Update `spec.md`\n2. Re-run `/speckit.plan`\n3. Re-run `/speckit.tasks`\n4. Continue `/implement`\n\nKey principle: ‚ÄúSpecification is durable, plan/tasks are flexible‚Äù\n\nAfter any fix, ask AI to: ‚ÄúUpdate plan, tasks, data-model to reflect this change‚Äù\n\n## Why this approach works\n\n![Why it works](/images/spec-kit/slide-23.png)\n\nFour reasons:\n\n1. **Context is king** ‚Äî AI output quality is proportional to context quality\n2. **Audit trail** ‚Äî Every decision is documented and traceable\n3. **Iterative refinement** ‚Äî Catch mistakes early, not in production\n4. **Safety rails** ‚Äî The constitution prevents over-engineering\n\nResult: You get the full 100%, not just the easy 70%.\n\n## Best practice #1: Context is everything\n\n![Context best practice](/images/spec-kit/slide-24.png)\n\n### ‚ùå Poor context:\n\n``` Why is my code not working?\n\n```\n\n### ‚úÖ Rich context:\n\n``` The handleSubmit function in UserForm.tsx throws \"Cannot read property 'email' of undefined\" on line 47 when the form is submitted with empty fields.\n\nStack trace: [full trace here]\n\nExpected: Form validation should prevent submission Actual: Error thrown before validation runs\n\n```\n\nThe quality of AI output is directly proportional to the context you provide.\n\n## Best practice #2: Plan first, code later\n\n![Plan first](/images/spec-kit/slide-25.png)\n\nThis is exactly what happens when you say ‚Äúbuild me a todo app‚Äù without planning:\n\nYou ask for a bicycle. The AI proudly presents‚Ä¶ a massive over-engineered robot spaceship.\n\n### The magic words:\n\n> >\n> ‚ÄúGive me options, starting with the simplest. Don‚Äôt code yet.‚Äù\n> >\n\nAsk for architecture OPTIONS first. Start with the simplest viable solution.\n\n## Best practice #3: Test ruthlessly\n\n![Test ruthlessly](/images/spec-kit/slide-26.png)\n\n### The rule:\n\nAfter every AI update:\n\n1. Test in localhost immediately\n2. Open browser console\n3. Check for errors\n\n### When debugging, be specific:\n\n‚ùå *‚ÄúIt‚Äôs broken‚Äù*\n\n‚úÖ *‚ÄúThe submit button should save the form data, but instead it shows ‚ÄòTypeError: Cannot read property map of undefined‚Äô in the console‚Äù*\n\nSmall, incremental testing prevents nightmare debugging sessions.\n\n## When to use what\n\n![When to use what](/images/spec-kit/slide-28.png)\n\n### Vibe coding is fine for:\n\n- Quick prototypes and experiments\n- Learning new technologies\n- One-off scripts you‚Äôll throw away\n\n### Spec-driven is essential for:\n\n- Production applications\n- Team projects\n- Anything with users\n- Code that needs to be maintained\n\n**The key question**: Will someone (including future you) need to understand this code later?\n\n## What‚Äôs next in this series\n\n![Getting started](/images/spec-kit/slide-31.png)\n\nNow that you understand the *why* behind spec-driven development, you‚Äôre ready for the *how*.\n\n### Coming next week (Part 2): The Spec-Kit workflow\n\nWe‚Äôll do a hands-on walkthrough of the complete workflow:\n\n- **Creating your constitution** - What to include and what to skip\n- **Writing effective specifications** - Real examples from production projects\n- **Generating plans and tasks** - How AI breaks down your spec into implementable chunks\n- **The implementation phase** - What happens when you hit `/speckit.implement`\n- **Dealing with AI hallucinations** - Practical recovery strategies\n\nEach step will include real code examples, common mistakes, and troubleshooting tips.\n\n### Get ready\n\nBefore next week‚Äôs post, you can:\n\n```\n# Install Spec-Kit CLI\nuv tool install specify-cli --from git+https://github.com/github/spec-kit.git\n\n# Verify installation\nspecify --version\n\n```\n\nWe‚Äôll use this in Part 2 to build a real application together.\n\n## Key takeaways from part 1\n\n![Key takeaways](/images/spec-kit/slide-32.png)\n\n1. **Vibe coding gets you 70%**: The last 30% is where real engineering happens\n2. **Specifications are the new source code**: Write them first, code follows\n3. **Structure enables speed**: More guardrails means less debugging\n4. **Three levels of spec-driven development**: Spec-Kit operates at Level 3 (spec-as-source)\n5. **You‚Äôre the architect**: AI is a tool, but you make the decisions\n\nNext week in Part 2, we‚Äôll put these concepts into practice with a complete walkthrough of the Spec-Kit workflow.\n\n## Resources\n\n- **Spec-Kit**: [github.com/github/spec-kit](https://github.com/github/spec-kit)\n- **Beyond Vibe Coding**: [addyosmani.com/blog/vibe-coding](https://addyosmani.com/blog/vibe-coding/)\n- **GitHub Copilot Custom Instructions**: [docs.github.com](https://docs.github.com/en/copilot/how-tos/configure-custom-instructions/add-repository-instructions)\n\n## Series navigation\n\n**üìç You are here: Part 1 - The problem and the solution**\n\n- **Next**: Part 2 - Deep dive into the Spec-Kit workflow (Coming January 12, 2026)\n- Part 3 - Best practices and troubleshooting (Coming January 19, 2026)\n- Part 4 - Team collaboration and advanced patterns (Coming January 26, 2026)\n- Part 5 - Case studies and lessons learned (Coming February 2, 2026)\n\n*This series is based on a presentation I gave about moving from ad-hoc AI-assisted coding to structured, specification-driven development. The full presentation slides are available for download.*\n\n**Questions or feedback?** Connect with me on [LinkedIn](https://linkedin.com/in/hiddedesmet) or check out more posts at [hiddedesmet.com](https://hiddedesmet.com).\n\n**Want to get notified when Part 2 drops?** Follow me on [LinkedIn](https://linkedin.com/in/hiddedesmet) for updates.",
  "Link": "https://hiddedesmet.com/from-vibe-coding-to-spec-driven-development",
  "FeedName": "Hidde de Smet's Blog",
  "Title": "From Vibe Coding to Spec-Driven Development: Part 1 - The problem and the solution"
}
