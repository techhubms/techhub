# Inspired by Canvas, Built With Code: How I Created My Own Art Tool

* By Olena Borzenko

## Introduction

It’s not the first time I’ve leaned toward art and creativity in my articles and conference sessions—but this time, I took it a step further.
For a very long time, I couldn’t decide what I liked more: tech, science, or art. I’d read books like *A Brief History of Time* by Stephen Hawking, *The God Equation* by Michio Kaku, and others because complicated science was always on the edge of fantasy for me. At the same time, I’d write code and do techy things for work and never miss a chance to dive into something creative and artistic. Every now and then, I’d pick up my watercolors, promising myself to draw regularly, only to put them away again because of lack of time and the endless list of other things to do. (Very typical story, isn’t it?)
Still, I realized this pattern is just part of my creative rhythm. I always come back to art with new inspiration, then shift gears when life gets busy. And last summer was no exception.

## What Set Things in Motion

My surroundings in Ukraine have always included creative and artistic people. When I went home to visit my family and friends, I found myself in a very supportive and inspiring environment. It gave me the motivation I didn’t know I needed. For a while, I’d been carrying around the idea of visualizing math equations or physical processes. I didn’t know exactly what I wanted to create, but I spent a good amount of time researching different equations, reading articles about the intersection of math and art, and watching tons of videos about physics visualizations like particle spins, magnetic fields, and so on. One day, I came across an illustration of the Radium atom by Niels Bohr from his 1922 presentation, and I fell in love with its symmetry. The way the orbits formed a shape that looked like a flower or a star was fascinating.

<table>
  <tr>
    <td><img src="./images/radium.jpg" width="600"/></td>
  </tr>
  <tr>
    <td align="center"><em>Pic. 1. Radium atom by Niels Bohr</em></td>
  </tr>
</table>

I later found similar visuals on a site where the author had played with the parametric equations of a curve.

<table>
  <tr>
    <td><img src="./images/parametric.png" width="600"/></td>
  </tr>
  <tr>
    <td align="center"><em>Pic. 2. Life Through A Mathematician's Eyes blog. Parametric Equations article</em></td>
  </tr>
</table>

I have to admit, I’m oddly drawn to these kinds of visualizations. So I knew, deep down, that I’d eventually start looking for this kind of geometry in my own artwork.

## First Art works

Speaking of which, the summer of 2024 was when I created my first artwork on canvas. Everything about it felt new and unfamiliar. For the first time, I was working with modeling software, machine tools, real canvas, and acrylic paints. I’m really grateful to my partner for all the patience and support he gave me while teaching me how to use the tools and work with the CNC machine to bring my ideas to life. For context, a CNC (Computer Numerical Control) machine works by following digital instructions to move tools or pens across a surface, making it possible to cut, carve, or draw with precision.

My first few pieces were all about learning and exploring different styles, techniques, and colors. I was trying to find what felt right for me but I’m not gonna lie, I struggled quite a bit at the beginning. Creating sketches with modeling tools was especially tough, so I mostly stuck with primitive shapes.

To print a sketch with the CNC machine, you need to provide a file in a specific format called G-code. It’s basically a list of instructions and coordinates that tells the machine how to move a pen across the canvas. To get to that point, I first had to create my design using software like 3ds Max, Inkscape, SketchUp, or others I haven’t even explored yet. Then I had to convert the design into a 2D vector representation. Using tools like Aspire or Inkscape, I could build the drawing path and generate the G-code file.
That G-code can then be used with the CNC machine but instead of using a rotary tool for engraving or carving, we used pens. So in a way, it became a kind of DIY plotter. The main difference is that while a traditional plotter is designed only for drawing, a CNC machine is much more powerful and flexible. It’s typically used for cutting, milling, or engraving, but it can be adapted for more creative purposes. At our Xebia office in Hilversum, Netherlands, for example, we have a similar CNC machine that’s used to water plants.

On the pictures below, you can see how some of my ideas started to take shape. I was combining 3D wireframe forms with loose acrylic brush strokes. The first piece I made was surprisingly large.

<table>
  <tr>
    <td><img src="./images/first.jpg" width="500"/></td>
  </tr>
  <tr>
    <td align="center"><em>Pic. 3. First artwork. Acrylic on canvas, 120x120 cm</em></td>
  </tr>
</table>

Here’s another example. This time, I chose a smaller canvas, but worked in the form of a diptych. With this piece, I discovered a really interesting effect, how paint strokes can add a sense of volume to the wireframe mesh. The intersections where textured brushstrokes meet the white lines are still my favorite parts. [see picture 4]

<table>
  <tr>
    <td><img src="./images/second.jpg" width="800"/></td>
  </tr>
  <tr>
    <td align="center"><em>Pic. 4. Diptych. Acrylic on canvas, 80x55 cm</em></td>
  </tr>
</table>

## Finding the Right Shape

By this point, I had realized that I really enjoyed combining acrylic brushstrokes with wireframe mesh, so I knew I’d continue working in that style. But every sketch I’d made so far had been time-consuming and frustrating, mostly because I lacked the skills to work efficiently in 3ds Max. And still, none of the shapes felt quite right.

So I took a step back. Instead of tweaking segments and adding all kinds of scattered details manually, I went back to basics and explored some primitive forms, trying to avoid any heavy editing. That’s when I stumbled upon the torus knot object. The torus knot is a general mathematical concept, a type of 3D curve that loops around a torus in a specific pattern, but many 3D editing tools, like 3ds Max, also include it as a ready-to-use object or modifier. It can be adjusted and transformed using different built-in modifiers and effects, and the results were unexpectedly awesome.

A closed shape, flowing curves, endless variations and each one brought a different kind of visual association to mind. That was it! Exactly what I’d been looking for. From that point on, I could finally shift my focus to painting, playing with patterns and textures, and actually enjoy the process — hands in paint, not just eyes on a screen.

At one of the conferences, I was really excited to show my work to a friend, and he described the paintings as “visually pleasing.” I couldn’t agree more and that comment stuck with me. I kept creating, and now I’m proud and happy to share some of that work with you here in this article. All pieces are acrylic on canvas, size 60x60 cm.

<table>
  <tr>
    <td><img src="./images/golem.jpg" width="400"/></td>
    <td><img src="./images/stardust.jpg" width="400"/></td>
    <td><img src="./images/salamander.jpg" width="400"/></td>
  </tr>
  <tr>
    <td align="center"><em>Pic. 5. "Golem"</em></td>
    <td align="center"><em>Pic. 6. "Stardust"</em></td>
    <td align="center"><em>Pic. 7. "Salamander"</em></td>
  </tr>
</table>

<table>
  <tr>
    <td><img src="./images/moss.jpg" width="400"/></td>
    <td><img src="./images/flux.jpg" width="400"/></td>
    <td><img src="./images/arachne.jpg" width="400"/></td>
  </tr>
  <tr>
    <td align="center"><em>Pic. 8. "Moss"</em></td>
    <td align="center"><em>Pic. 9. "Flux"</em></td>
    <td align="center"><em>Pic. 10. "Arachne"</em></td>
  </tr>
</table>

What got me thinking was that, at some point, I started to feel limited by the shapes I was creating. I realized I had found a comfortable spot where I was only making small tweaks to the same base forms in each new sketch. It didn’t seem like a big issue at first, but whenever I tried to create something more interesting, the results turned out messy and frustrating.

Since I wasn’t eager to spend more time learning 3ds Max in depth, I knew it was time to take a different route: I was going to write some code to do all of this for me.

Another thing that bothered me was that sometimes I’d land on a cool shape but had no easy way to save or organize it. I wanted something like a catalog or gallery of all the interesting forms I’d discovered, so I could easily pick one for a next piece. Also too many manual steps, I thought. I knew I could automate many steps and build a place to store my sketches, and even create a browser-based playground instead of relying on heavy modeling tools.

## Building a 3D Torus Knot in p5.js

I wouldn’t be writing this article if I hadn’t actually brought the idea to life.

While researching algorithmic art, I kept coming across parametric equations for different shapes including torus knot. I had already shown one of the examples I found online earlier [see pic. 2], and it got me thinking: if there’s a formula for a shape, then I should be able to visualize it. If I could create a torus knot with lines, why not build it with a tube and then take it a step further by applying visual effects to introduce deformations like twists, lumps, and more?

Just for context, this is the parametric equation for a torus knot and it was my starting point. The entire visualization logic is built around it:

$$
\begin{aligned}
x(t) &= (R + r \cdot \cos(qt)) \cdot \cos(pt) \\
y(t) &= (R + r \cdot \cos(qt)) \cdot \sin(pt) \\
z(t) &= r \cdot \sin(qt)
\end{aligned}
$$

I decided to use the skills I’d built over the years to create a tool that would simplify the whole art creation process for me. I didn’t want to automate everything—just enough to turn my hobby into a topic for technical articles and conference talks, so I could do both things I love at the same time (joking, not joking).

Since working with 3ds Max involved a lot of manual tweaking, I figured I could not only generate shapes programmatically but also eventually extract vector paths for printing. (Spoiler alert: that part turned out to be way harder than I thought. I'm still working on it, but I did manage to build a working torus knot gallery.)

I jumped straight into p5.js and spent a few days experimenting, trying to recreate the behavior I’d seen in 3ds Max. On the first day, I somehow managed to generate a perfect torus knot with a structured wireframe tube. Honestly, I didn’t think I could pull it off, the math was tricky, and even with Copilot and ChatGPT it took a lot of effort to get the result I wanted.

And that was the easy part.

Over the next few days, I started adding visual effects one by one. There were moments when I thought the project was too complicated, and that I didn’t know enough math or JavaScript to finish it. But after a lot of trial and error, and a few “crying and trying” sessions it finally worked the way I imagined.

I’m not going to share the entire implementation here, you can check it out on my GitHub, but this is the final version of the configuration object I use in my p5.js component to generate the visuals:

```js
const defaultConfig = {
  p: 3,                        // Number of times the knot wraps around (major direction)
  q: 8,                        // Number of twists (minor direction)
  ringDetail: 20,              // Number of segments around the tube's cross-section
  pathDetail: 400,             // Number of segments along the knot's path
  tubeRadius: 0.15,            // Radius of the tube (thickness of the wireframe)
  knotRadius: 0.85,            // Overall size of the knot
  waveAmplitude: 0.45,         // Amplitude for adding waves along the shape
  eccentricity: 0.6,           // Controls how stretched or "oval" the cross-section becomes
  twistTurns: 20,              // Local twisting along the tube
  globalTwistTurns: 16.5,      // Overall twisting along the entire knot
  twistDirection: -1,          // Direction of the twist (1 or -1)
  lumps: 10,                   // Number of lumps (localized bulges) added
  lumpHeight: 0.9,             // Intensity/height of the lumps
  lumpOffset: 0.0,             // Offset to shift where lumps appear
  enableElectricity: false,    // Whether to add "electricity" effect (chaotic perturbation)
  electricityStrength: 0.15,   // Strength of the electricity effect
  electricityFreq: 2,          // Frequency (how often) the electricity effect happens
  bgColor: "rgb(15, 25, 45)",
  fillColor: "rgba(223, 103, 48, 0.75)", 
  wireColor: "rgb(255, 255, 255)"
};

```

Each of these properties plays a role in calculating the final shape, and each one adds a unique visual effect. And if I were to simplify the whole implementation down to just a few lines, here’s what it would look like:

```js
 const sketch = (s: p5) => {
  const { bgColor } = config;

  let knotPoints: p5.Vector[] = [];
  let ringPoints: p5.Vector[][] = [];

  s.setup = () => {
    s.createCanvas(width, height, s.WEBGL);
    s.ortho(-width / 2, width / 2, -height / 2, height / 2, -1000, 1000);
    s.background(bgColor);
    s.noLoop()

    computeKnotPath();
    computeRingsWithParallelTransport()

    s.rotateX(s.HALF_PI * 2);
    s.scale(scale)

    drawDepthFill();
    drawWireframe();
  }

  // ...and then a few hundred more lines of actual implementation
};
```

## Building the Brains Around the Canvas

I wasn’t even thinking about the rest of the application until I finished the torus knot implementation. Because honestly, if that part didn’t work the way I wanted, there wouldn’t have been much point in continuing.
But once I finished playing around in the p5.js editor and realized I now had fully working visualization logic, it became a real project for me.

I didn’t just want a tool that added randomization to shapes. I wanted something smarter—something that could also experiment with colors and help me discover interesting combinations. And right now, there’s no better fit for such tasks than AI.

Let me explain how I imagined the tool working. I wanted to generate sketches automatically based on user input. Since I had been experimenting pretty randomly anyway, I didn’t mind letting automation handle that part.
I also wanted a gallery where I could see all the generated results and if I could search for similar sketches based on user input, that would be even better. Maybe in the future, I’ll add functionality to adjust the generated visualizations directly in the UI, but that’s a plan for later.

From the technology side, my plan was to use LLMs for the creative part to generate torus knot configuration objects and art descriptions based on user input. For storing the data and handling similarity searches, Azure Cosmos DB was a perfect fit, thanks to its support for vector embeddings and vector search. The previews of my sketches would be saved as images and stored in Azure Blob Storage. On demand, I could also generate 3D object files that could be opened in 3ds Max for further processing.

And because a picture is worth a thousand words, here’s a diagram of how it all comes together:

<table>
  <tr>
    <td><img src="./images/diagram.png" width="800"/></td>
  </tr>
  <tr>
    <td align="center"><em>Pic. 11. High-level diagram of the application</em></td>
  </tr>
</table>

## Implementation details

I hope you now have a better idea of what I wanted to build and before I show you how it turned out, I’ll walk you through a few key parts of the system, so you can get a sense of how everything works under the hood.

The first step happens in the UI: you type in some input. It can be anything, here are a couple of examples:

```
Example 1: Shape that looks like a start in the blue color scheme

Example 2: Torus knot with the smooth curves and lots of twists
```

You get the idea.

Once you click the **Generate** button, an API endpoint is called, and a few things happen. First, we generate embeddings using the *text-3-large model*. These embeddings are then stored in Azure Cosmos DB.
The embeddings are important because they allow us to perform similarity searches across all stored records. My goal was to be able to find documents where the user input was similar, so I could easily compare the results.

```csharp
  var embeddings = await _semanticKernelService.GetEmbeddingsAsync(userInput);
```

After that, the system generates both the art description and the torus knot configuration. Here’s the *GenerateDesignConfigurationAsync* method, which runs right after the embeddings step.

```csharp
  public async Task<(string, TorusConfig)> GenerateDesignConfigurationAsync(string userInput)
  {
    var descriptionFunction = kernel.CreateFunctionFromPrompt(Prompts.DesignDescriptionPromptTemplate);
    var descriptionResult = await kernel.InvokeAsync(descriptionFunction, new KernelArguments { ["prompt"] userInput });

    var description = descriptionResult.ToString();
    var configFunction = kernel.CreateFunctionFromPrompt(Prompts.DesignConfigurationPromptTemplate);
    var configResult = await kernel.InvokeAsync(configFunction, new KernelArguments { ["$description"] = description });

    var artConfig = Prompts.DefaultConfig;
        
    var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
    var output = JsonSerializer.Deserialize<TorusConfig>(configResult.ToString(), options);
    artConfig = output ?? artConfig;
        
    return (description, artConfig);
  }
```

I’m showing you this part of the code to make it clear that the art description is generated from the user input, and then the torus knot configuration is created based on that description, using more context to guide the config generation. Since user input can often be too short or too long, I wanted to first shape it with a specific prompt, so the description would provide a better foundation for generating the configuration object.

Here’s what the first prompt looks like:

```csharp
  public const string DesignDescriptionPromptTemplate = @"
    You're an assistant that transforms creative art prompts into vivid, artistic visual descriptions for generati  artwork based on torus knot geometry.
    The user provides a short input or concept, such as a mood, shape, emotion or other.
    You elaborate it into a short (1–3 sentence) artistic vision.
    The output should mention visual form (e.g., structure, flow), style influences (if relevant), and color/emotion.
    Focus on describing the overall look and feel, not technical parameters. Input: {{$prompt}}";
```

The second prompt is much larger, so to save space, I’m just showing a part of it here.

```csharp
  public const string DesignConfigurationPromptTemplate = @"You are an assistant that transforms  artistic visual descriptions into valid torus knot configurations for generative art.
    The configuration will be used to render a 2D wireframe visualization of a 3D torus knot usithe p5.js library. 
    Your job is to generate a balanced, visually pleasing configuration in strict JSON formafollowing the schema and constraints below.
    Ensure all values are valid, visually harmonious, and within the allowed ranges.

    ---

    Color Guidance:
    Act as a color theory expert. Generate thoughtful and creative combinations.
    - fillColor should reflect the **dominant tone** from the input description.
    - bgColor must **contrast with the fillColor** to make the shape stand out.
    - wireColor must have **strong contrast with fillColor** for wireframe visibility.
    - Use rgb() or rgba() format as specified.

    ---

    // Here will be more additional rules...

    // And then output schema..."
```

The final step is saving all the information to Azure Cosmos DB.

```csharp
  var design = new Design(userInput, embeddings, description, serialisedConfig);
        
  await _cosmosDbService.InsertDesignAsync(design);
```

While all this data is being generated, I’m also sending another request to the API using the same user input. I generate embeddings again, and this time I run a similarity search to find related records. Here’s how that query looks:

```csharp
  const string queryText = $"""
    SELECT Top 5 
      c.id, c.userInput, c.generatedDescription, c.torusConfig, VectorDistance(c.vectors, @vectors) as similarityScore
    FROM c  
    WHERE 
      VectorDistance(c.vectors, @vectors) > @similarityScore 
    ORDER BY 
        VectorDistance(c.vectors, @vectors)
    """;

    var queryDef = new QueryDefinition(query: queryText)
        .WithParameter("@vectors", vectors)
        .WithParameter("@similarityScore", similarityScore);

    using FeedIterator<Design> resultSet = _designContainer.GetItemQueryIterator<Design>(queryDef);
```

After the configuration is generated, I create the visualization and once the canvas is rendered, it’s saved to Azure Blob Storage for future previews. Another cool thing about the visualization is that, since I’m building the torus knot in WebGL as a 3D shape, I can also generate files that can be opened in 3ds Max for further processing or refinement.

## Final result

Once again, I’ve only included some key parts of the implementation here, but if you’re interested in the details, you can check out the full source code on my GitHub (see QR code in the end of this article).
In the pictures below, you can see what the generated results look like:

<table>
  <tr>
    <td><img src="./images/homepage.png" width="900"/></td>
  </tr>
  <tr>
    <td align="center"><em>Pic. 12. Home page: text input for user prompt and the visualized result</em></td>
  </tr>
</table>

I kept the UI as simple as possible, but in the future, I’d like to add some customization options so I can make minor adjustments directly in the interface. And here’s another page view:

<table>
  <tr>
    <td><img src="./images/gallery.png" width="900"/></td>
  </tr>
  <tr>
    <td align="center"><em>Pic. 13. Gallery view showing previews of the generated results.</em></td>
  </tr>
</table>

There’s still a lot I want to do and plenty of features I’d like to add, but even at this stage, I already find the tool useful for its intended purpose. I’m now getting ready to create more artworks, and this time, instead of manually sketching, I’ll choose from one of the generated designs.
I’ll keep working on the tool, and hopefully next time, I’ll write another article to share how it’s evolved over time.

<table>
  <tr>
    <td><img src="./images/qrcode.png" width="400"/></td>
  </tr>
</table>