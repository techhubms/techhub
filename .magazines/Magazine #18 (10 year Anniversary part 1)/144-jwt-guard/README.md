# Are you sure your JWT access tokens are really secure?

When you’re building a Web API, there's a high possibility that you’re relying on JWT access tokens when client applications or services interact with your API in order to perform authentication and authorization. The two most common types of access tokens are opaque (or reference) tokens and JSON Web Tokens (aka JWTs).

These two types of tokens both have their pros and cons:

| Opaque token                                      | JWT                                   |
|---------------------------------------------------|---------------------------------------|
| + Better privacy                                  | - JWT can contain sensitive data      |
| + Easier to revoke                                | - Lifetime of a JWT is encoded within |
| + Very small in size, since it’s just a reference | +/- Can be kept small, but can also easily grow large when including lots of claims |
| - Additional server requests are needed to check the token’s validity and to retrieve user data | + Self-contained |
| - There’s no real defining standard               | + Standardized |

In this article, I'll focus on JWT tokens, since this type of token is used more frequently.

## What's inside a JWT, or JSON Web Token?

A JSON Web Token consists of three parts, each part separated by a dot:

```
eyJhbGciOi...VCJ9 . eyJzdW....MDgxMTMzMX0 . GvHaTrJuFo...s15Ss
      header      .         payload       .     signature
```

The first two parts are Base64URL-encoded JSON objects, representing the token’s header information (called a JOSE header) and the data or payload of the token. The third section contains a Base64URL-encoded array of bytes, representing the signature of the header and payload combined. 

> Note that the signature part is not required! Of course, it is highly recommended to sign tokens when constructing a JWT for security purposes. Next to signed JWTs using the JWS (JSON Web Signature standard), you can also create encrypted tokens using the JWE (JSON Web Encryption) standard. JWE tokens, however, will not be further discussed in this article.

### 1. The JOSE Header

The header of a JWT typically includes the following three properties when creating signed tokens:

* `typ`: the media type of the token. Sometimes omitted, this value is typically set to **_JWT_** to indicate that this is a JSON Web Token. For access tokens, you can also see the value **_at+jwt_** to further specify that the JSON Web Token is an access token.

* `alg`: the cryptographic algorithm used to sign the token. Examples are **_HS256_** for tokens signed using a symmetric HMAC SHA-256 algorithm, **_RS256_** for tokens signed with an assymetric algorithm using a private/public RSA key pair and SHA-256, etc.
You can find a complete list in [RFC 7518](1).

* `kid`: the key ID of the cryptographic key used to sign the JWT. When validating a JWT signature, the `kid` value is used to look up the correct public key information, in case multiple JSON Web Keys (JWKs) are available to sign or validate JSON Web Tokens. For example, you can see the current list of available JWKs for demo.duendesoftware.com by going to [https://demo.duendesoftware.com/.well-known/openid-configuration/jwks](2).

    A JWT generated by demo.duendesoftware.com would have `1CE1DCBAC07A41376725E3B725E75EC4` for its `kid` value.

```json
{
    "keys": [
        {
            "kty": "RSA",
            "use": "sig",
            "kid": "1CE1DCBAC07A41376725E3B725E75EC4",
            "e": "AQAB",
            "n": "uIeg9avR-Pxg4rVR2qC2p7gpiQHD3ktWRT7k4_ZxRZpd964WMYAccAibf5Y3AcdHv6PWUUegtkwv1hAHomhPE-KOCE8uS0wsA9z8xPwO2TSm7AIIUz22Jym6Lj6l-o5Tdf3jpr2j7F4Ad40hQPAcaS28NJm0ipA4blROMSe62KosNA5EdSLCGjX6YqPlEislKZc3nWzf2VisvMvvFa9hEcul6FVAYGlnHm9N47-DphV-g7loK93WLpfNilhZDg6CF5pwamRVyXpH9TVqi_ZIMBsFCFnKujX54hPv-dqNCkAPwNNlFQ5Tr47X4l2GdgIrbVbyJ701x0FcuBFxQwnlsw",
            "alg": "RS256"
        }
    ]
}
```

If you want to read more about the header of a JWT, the best resource available is [RFC 7515, section 4](3).

### 2. The payload of a JSON Web Token

The payload of a JWT is a JSON object containing claims. Some claim types are registered and frequently used, or even mandatory, but you can include as many custom claims as you wish. Just remember that every claim adds data to your token and increases the token's size. Tokens can become too large to be delivered to client applications depending on the delivery mechanism!

Additionally, claims can contain sensitive data. Access tokens typically don't include too much user-specific information to prevent leaking details about the application's users.

The most commonly used claim types are:

* `iss`: the issuer of the JWT. This claim typically points to the service that issues your tokens. In OAuth 2.0 flows, you can tpyically use this claim's value to find the discovery document at the URI `/.well-known/openid-configuration`.

* `sub`: the subject of the JWT. The value indicates the user or application who can access your API resource server.

* `aud`: the audience, or intended recipients for the JWT. The audience value points to your API, to indicate that the JWT was meant to be used to gain access to your API.

* `exp`: the expiration time. When this timestamp passes, the JWT is no longer valid for use.

* `nbf`: the not-before time. The JWT only becomes valid for use after this timestamp.

* `iat`: the issued-at time. This is the timestamp when the JWT was originally created, and can be used to determine the age of the JWT.

* `jti`: a unique identifier for the JWT, which can be used to prevent replay attacks.

## Validating JSON Web Tokens

It would be pretty bad if your API would just accept any access token when that token contains the correct audience claim values, so we ensure that our API will only accept tokens which satisfy a few rules:

1. The `aud` claim contains (only) values that we expect for our API.

2. The current date/time falls between the `nbf` and `exp` values. Some leeway can be granted using a clock skew, to accommodate for time drifting between different servers.

3. The `iss`, or issuer of the token, is a known service which our API trusts.

4. The `alg`, or signature algorithm, is on our allowed list of cryptographic algorithms.

5. The signature can be successfully validated using the `kid` and the corresponding public key material of the issuer.

Luckily, there are plenty of open-source libraries out there for a variety of frameworks and programming languages, which you can use to validate JSON Web Tokens. You can find a list of JWT libraries at [https://jwt.io/libraries](4).

But… 

What if this open-source library contains a vulnerability? Or when an update breaks one of the critical validation paths? Or if some of the library’s methods work every-so-slightly different when validating tokens, causing some invalid tokens to suddenly become valid?

## Trust, but verify: test your JWT validation!

The easiest method to add some trust into your API, is by writing tests to validate that various JSON Web Tokens, both valid and invalid, are being properly validated and respectively accepted or rejected by your API. Every time you then update the JWT validation library, you can automatically rerun your tests to verify that the validation rules still work as expected.

Wondering what could go wrong with access tokens? Well, let’s give some examples of tokens that may try to fool the validation logic.

### Algorithm? What algorithm?

The `alg` property in the token’s header, again, indicates which cryptographic algorithm is used to sign the token. But this property can also be set to `none`, to indicate that the JWT is not signed at all.

Which means that the following token is a valid JWT:
```json
eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0IiwibmFtZSI6Ildlc2xleSIsImlhdCI6MTczMDgxMTMzMX0.

// The JWT above equals the following:
{
  "alg": "none",
  "typ": "JWT"
}
.
{
  "sub": "1234",
  "name": "Wesley",
  "iat": 1730811331
}
.
// no signature

```

This poses a problem, exactly because this JWT is completely valid, as far as [RFC 7519, section 6](5) is concerned. Luckily, most validation libraries will allow you to specify which signature algorithms your API allows, and most will prevent `"alg": "none"` from being used by default.

There are some people out there, however, who don’t play nice and think outside the box. These people may try to authenticate against your API using a JWT where the `alg` property is set to `nONe`, or `some-random-value-here`. This could be enough to fool a poorly written JWT validation library, and yes, some libraries have accepted `"alg": "nONe"` as a valid token for a long time…

Writing an integration test to catch these invalid or unsupported signature algorithms can be very easy:

```csharp
public class SignatureAlgorithmTests(TargetApiWebApplicationFactory factory) : JwtGuardTestBase(factory)
{
    [Theory(DisplayName = "When a token uses an unsupported signature algorithm, the API should return a 401 Unauthorized response.")]
    [InlineData("none")]
    [InlineData("nOnE")]
    internal async Task Accessing_AuthorizedUrl_Is_Unauthorized_For_Unsupported_Signature_Algorithms(string signatureAlgorithm)
    {
        // Arrange
        var jwt = await GetJwtAsync(signatureAlgorithm);
        Client!.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", jwt);

        // Act
        var response = await Client.GetAsync(TestSettings.CurrentTestSettings.TargetUrl);

        // Assert
        Assert.Equal(HttpStatusCode.Unauthorized, response.StatusCode);
    }

    private Task<string> GetJwtAsync(string signatureAlgorithm)
    {
        // Use a JwtBuilder instance to build an access token
        return Factory.CreateJwtBuilder()
            .WithSignatureAlgorithm(signatureAlgorithm)
            .BuildAsync();
    }
}

public class JwtBuilder
{
    // Most other properties and methods are omitted for brevity...

    public Microsoft.IdentityModel.Tokens.SigningCredentials? SigningCredentials { get; private set; }
    public string? SignatureAlgorithm { get; private set; }

    public JwtBuilder WithSignatureAlgorithm(string signatureAlgorithm)
    {
        SignatureAlgorithm = signatureAlgorithm;
        SigningCredentials = null;

        return this;
    }

    public async Task<string> BuildAsync()
    {
        if (!string.IsNullOrEmpty(SignatureAlgorithm) &&
            (string.Equals(SecurityAlgorithms.None, SignatureAlgorithm, StringComparison.OrdinalIgnoreCase) ||
            !TestSettings.KnownSecurityAlgorithms.Contains(SignatureAlgorithm)))
        {
            // Either using "none" (case-insensitive) or an unknown algorithm. TestSettings.KnownSecurityAlgorithms
            // contains a list of known security algorithms.

            // Return an unsigned token.
            return BuildJwtHeader().Base64UrlEncode() + "." + BuildJwtPayload().Base64UrlEncode() + ".";
        }

        // default logic which signs and returns the token goes here...
    }
}
```

With a bit of modification, the same test logic can also be used to test that validly signed tokens are rejected if they’re signed using an algorithm which your API doesn’t want to use, like HS256 for example.

### But wait, there’s even more shenanigans…

When creating a JWT header, you have the option to use some additional "special" properties next to the `alg`, `kid` and `typ` properties we already discussed earlier. These special properties allow you to specify where the JWT validation logic should retrieve public key information from when validating the token's signature. For someone with malicious intent, this is absolutely wonderful, because this allows a potential attacker to create self-signed JWTs!

These are the special properties:

* `jku`: a URL pointing to a set of JSON Web Keys. While this URL could in theory point to the authority or the issuer of the token, it’s not a requirement! Which means that everyone can create a JWT token, host public JWK material and add a reference URL to the token header.

* `jwk`: using this property, a token includes the public JSON Web Key in its header, to allow for full self-validation of the signature. This is very dangerous! Because this means that an attacker can craft a self-signed JSON Web Token and simply include the public JWK in the token’s header!

* `x5u`: a URL pointing to a X.509 certificate or certificate chain, which can be used to validate the signature by hosting the public certificate (chain) online. Just like the `jku` property, the URL could in theory live on the same server as the authority or issuer, but this doesn’t need to be the case.

* `x5c`: an X.509 certificate or certificate chain, which can be used to self-validate the signature, just like the `jwk` property. Again, very dangerous!

Testing these very specific methods to bypass our API’s security is a bit more challenging, since we need to generate valid signature key material and find a way to host it (for the `jku` and `x5u` test scenarios) externally. But in pseudocode, this is how you would write the tests:

```csharp
public class ExternalSignatureTests : IntegrationTestBase
{
    [Fact]
    public async Task RejectExternallySignedToken()
    {
        // Arrange
        var jwt = GetJwt("jwk");
        Client!.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", jwt);

        // Act
        var response = await Client.GetAsync("/secure-api-endpoint");

        // Assert
        Assert.Equal(HttpStatusCode.Unauthorized, response.StatusCode);
    }

    private string GetJwt(string testCase)
    {
        var signatureAlgorithm = "ES256"
        var jwtBuilder = Factory.CreateJwtBuilder()
            .WithSignatureAlgorithm(signatureAlgorithm);

        var header = jwtBuilder.BuildJwtHeader();
        var payload = jwtBuilder.BuildJwtPayload();

        var encodedPayload = payload.Base64UrlEncode();

        var headerAndPayload = "";
        var signature = "";

        switch (testCase)
        {
            case "jwk":
                signature = InjectJsonWebKey(signatureAlgorithm, header, encodedPayload, out headerAndPayload);
                break;

            // other test cases go here...

            default:
                return jwtBuilder.BuildAsync().GetAwaiter().GetResult();
        }

        return headerAndPayload + "." + signature;
    }

    private string InjectJsonWebKey(string signatureAlgorithm, JwtHeader header, string encodedPayload, out string headerAndPayload)
    {
        var securityKey = SecurityKeyBuilder.CreateSecurityKey(signatureAlgorithm);
        var jsonWebKey = JsonWebKeyConverter.ConvertFromSecurityKey(securityKey);
        jsonWebKey.Alg = signatureAlgorithm;
        jsonWebKey.Use = "sig";

        header["jwk"] = jsonWebKey.ToDictionary();
        header["kid"] = jsonWebKey.KeyId;

        return SignAndReturnJwt(header, encodedPayload, signatureAlgorithm, securityKey, out headerAndPayload);
    }

    private string SignAndReturnJwt(JwtHeader header, string encodedPayload, string signatureAlgorithm, SecurityKey securityKey, out string headerAndPayload)
    {
        headerAndPayload = header.Base64UrlEncode() + "." + encodedPayload;

        var asciiBytes = Encoding.ASCII.GetBytes(headerAndPayload);
        var signatureProvider = CryptoProviderFactory.Default.CreateForSigning(securityKey, signatureAlgorithm);
        try
        {
            var signatureBytes = signatureProvider.Sign(asciiBytes);
            return Base64UrlEncoder.Encode(signatureBytes);
        }
        finally
        {
            CryptoProviderFactory.Default.ReleaseSignatureProvider(signatureProvider);
        }
    }
}
```

Writing these test cases can be very tedious and pose some challenges by themselves. But what if I told you that there’s a solution for that?

## JWT Guard to the rescue!

After attending an API security workshop, I got the idea to write some of these test cases for my own API’s, but quickly found that I was repeating myself. And I don't like repeating myself. And I don't like repeating myself. So I started working on extracting the test cases in a separate project, and made these tests configurable to easily apply them to the several API projects.

The end result? JWT Guard: a test project template for .NET, allowing you to easily add a JWT test project to your existing API project by running these two simple commands:

```bash
# You only need to do this once per computer
dotnet new install JWTGuard.Template

# This command runs the JWT Guard template and creates a new JWT test project:
dotnet new jwt-guard --apiProject <relative-path-to-web-api-project>
```

After adding the new test project, all you need to do is configuring the `TestSettings` class in the new test project. The easiest way to configure these settings, is by overriding the defaults, for example:

```csharp
public readonly struct TestSettings
{
    /// <summary>
    /// Static constructor for the <see cref="TestSettings"/> struct.
    /// </summary>
    static TestSettings()
    {
        // Override the default test settings here
        CurrentTestSettings = DefaultTestSettings with
        {
            DefaultAudience = "my-secured-api",
            TargetUrl = "/your-secure-api-endpoint"
        };
    }

    // ... the rest remains as-is.
}
```

Right now, JWT Guard adds the following integration tests to your API project:

* Audience tests (`aud` claim): verifies that tokens only contain allowed audiences and are being rejected when a disallowed audience is present in the token.
* Issuer tests (`iss` claim): verifies that tokens only contain allowed issuers and are being rejected when a disallowed issuer is present in the token.
* JWT type tests (`typ` claim): verifies that tokens only use allowed values for the `typ` claim and are being rejected when a disallowed type is being used in the token's header.
* Signature algorithm tests (`alg` claim): verifies that tokens using disallowed signature algorithms are being rejected.
* External signature tests (`jwk`, `jku`, `x5c` and `x5u` claims): verifies that self-signed tokens or tokens signed with external key material are being rejected.

Want to know more? Then visit [https://jwtguard.net](6) for the full documentation. Happy testing!

[1]: https://datatracker.ietf.org/doc/html/rfc7518
[2]: https://demo.duendesoftware.com/.well-known/openid-configuration/jwks
[3]: https://datatracker.ietf.org/doc/html/rfc7515#section-4
[4]: https://jwt.io/libraries
[5]: https://datatracker.ietf.org/doc/html/rfc7519#section-6
[6]: https://jwtguard.net

