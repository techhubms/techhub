{
  "FeedUrl": "https://www.reddit.com/r/dotnet/.rss",
  "Link": "https://www.reddit.com/r/dotnet/comments/1mkqa37/stop_allocating_strings_i_built_a_spanpowered/",
  "Tags": [
    "dotnet"
  ],
  "OutputDir": "_community",
  "FeedName": "Reddit DotNet",
  "ProcessedDate": "2025-08-08 16:23:54",
  "Title": "Stop allocating strings: I built a Span-powered zero-alloc string helper",
  "FeedLevelAuthor": ".NET",
  "EnhancedContent": "Hey!\n\nIâ€™ve shipped my first .NET library: **ZaString.** It's a tiny helper focused on **zero-allocation** string building using `Span<char>` / `ReadOnlySpan<char>` and `ISpanFormattable` .\n\nNuGet: [https://www.nuget.org/packages/ZaString/0.1.1](https://www.nuget.org/packages/ZaString/0.1.1)\n\n**What it is**\n\n- A small, fluent API for composing text into a caller-provided buffer (array or `stackalloc`\n), avoiding intermediate string allocations.\n- Append overloads for spans, primitives, and any `ISpanFormattable`\n(e.g., numbers with format specifiers).\n- Designed for hot paths, logging, serialization, and tight loops where GC pressure matters.\n\n**DX focus**\n\n- Fluent `Append(...)`\nchain, minimal ceremony.\n- Works with `stackalloc`\nor pooled buffers you already manage.\n- You decide when/if to materialize a `string`\n(or consume the resulting span).\n\n**Tiny example**\n\n``` csharpCopySpan<char> buf = stackalloc char[256];\n\nvar z = ZaSpanString.CreateString(buf) .Append(\"order=\") .Append(orderId) .Append(\"; total=\") .Append(total, \"F2\") .Append(\"; ok=\") .Append(true);\n\n// consume z as span or materialize only at the boundary // var s = z.ToString(); // if/when you need a string ```\n\n**Looking for feedback**\n\n- API surface: naming, ergonomics, missing overloads?\n- Safety: best practices for bounds/formatting/culture?\n- Interop: `String.Create`\n, `Rune` /UTF-8 pipelines, `ArrayPool<char>` patterns.\n- Benchmarks: methodology + scenarios youâ€™d like to see.\n\nItâ€™s early days (0.1.x) and Iâ€™m very open to suggestions, reviews, and critiques. If youâ€™ve built similar Span-heavy utilities (or use **ZString** a lot), Iâ€™d love to hear what would make this helpful in your codebases.\n\nThanks!\n\nHow much performance you actually get by using span instead of string/StringBuilder?\n\nI think it's about avoiding GC with stackalloc, performance shouldn't be much better unless you are using StringBuilder or string concatenation all the time.\n\nEdit: there is performance section in readme [https://github.com/CorentinGS/ZaString?tab=readme-ov-file#-performance](https://github.com/CorentinGS/ZaString?tab=readme-ov-file#-performance)\n\nWhat seperate this from [ZString](https://github.com/Cysharp/ZString)\n\nThe 'a'\n\nGreat, but stackalloc is limited it seems to me, right? What would happen if my channel ended up being 4 MB?\n\nLooking at [OP's struct](https://github.com/CorentinGS/ZaString/blob/main/src/ZaString/Core/ZaSpanString.cs), it just take a `Span<char>` , so that depends on what that span is based on.\n\nIf it's created via `stackalloc` , you'd likely get a `StackOverflowException` , as the stack size is usually (though not always) 1 MB.\n\nThis is essentially just a `Span<char>` and an `int` to indicate how much of the span is actively being used, correct?\n\nI guess yes... But I wrote a lot of boilerplate so you don't have to ðŸ˜Š.\n\nWhy not use StringBuilder?\n\nIf you had looked at the repo for 5 seconds, you would've seen the [ðŸ“Š Performance](https://github.com/CorentinGS/ZaString?tab=readme-ov-file#-performance) section, which highlights the time and memory benefits over StringBuilder.",
  "Author": "typicalyume",
  "PubDate": "2025-08-08T09:05:50+00:00",
  "Description": "Hey!\n\nIâ€™ve shipped my first .NET library: **ZaString.** It's a tiny helper focused on **zero-allocation** string building using `Span` / `ReadOnlySpan` and `ISpanFormattable` .\n\nNuGet: [[https://www.nuget.org/packages/ZaString/0.1.1\\]()](https://www.nuget.org/packages/ZaString/0.1.1%5D%28%29)\n\n**What it is**\n\n- A small, fluent API for composing text into a caller-provided buffer (array or `stackalloc`\n), avoiding intermediate string allocations.\n- Append overloads for spans, primitives, and any `ISpanFormattable`\n(e.g., numbers with format specifiers).\n- Designed for hot paths, logging, serialization, and tight loops where GC pressure matters.\n\n**DX focus**\n\n- Fluent `Append(...)`\nchain, minimal ceremony.\n- Works with `stackalloc`\nor pooled buffers you already manage.\n- You decide when/if to materialize a `string`\n(or consume the resulting span).\n\n**Tiny example**\n\n``` csharpCopySpan buf = stackalloc char[256]; var z = ZaSpanString.CreateString(buf) .Append(\"order=\") .Append(orderId) .Append(\"; total=\") .Append(total, \"F2\") .Append(\"; ok=\") .Append(true); // consume z as span or materialize only at the boundary // var s = z.ToString(); // if/when you need a string ```\n\n**Looking for feedback**\n\n- API surface: naming, ergonomics, missing overloads?\n- Safety: best practices for bounds/formatting/culture?\n- Interop: `String.Create`\n, `Rune` /UTF-8 pipelines, `ArrayPool` patterns.\n- Benchmarks: methodology + scenarios youâ€™d like to see.\n\nItâ€™s early days (0.1.x) and Iâ€™m very open to suggestions, reviews, and critiques. If youâ€™ve built similar Span-heavy utilities (or use **ZString** a lot), Iâ€™d love to hear what would make this helpful in your codebases.\n\nThanks!"
}
