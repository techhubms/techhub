{
  "FeedUrl": "https://www.reddit.com/r/dotnet/.rss",
  "Link": "https://www.reddit.com/r/dotnet/comments/1mku4p2/unexpected_performance_differences_of_jitaot/",
  "Tags": [
    "dotnet"
  ],
  "OutputDir": "_community",
  "FeedName": "Reddit DotNet",
  "ProcessedDate": "2025-08-08 16:23:54",
  "Title": "Unexpected performance differences of JIT/AOT ASP.NET; why?",
  "FeedLevelAuthor": ".NET",
  "EnhancedContent": "I was looking at the TechEmpower web benchmark results, particularly the C# section: [TechEmpower](https://www.techempower.com/benchmarks/#section=data-r23&amp;l=zik0zh-pa7)\n\nI then noticed something I do not understand.\n\nLook at the top results, which are both ASP.NET, but the exact ranking is not what I expected:\n\n- Rank 1: ASPNET-Core, JIT; 741k responses / second\n- Rank 2: ASPNET-Core, AOT; 692k responses / second\n\nI was thinking AOT should be faster since it is able to compile to a form which is pretty close to machine code, which should mean it is generally faster, but apparently it is not the case.\n\nFor example, sometimes we can guide/hint the JIT compiler to optimize away the array bounds check. If the JIT compiler can do this, then I suppose the AOT compiler should also be able to do this? Then, AOT should still be faster than JIT.\n\nDoes anyone know why AOT is slower than JIT in this case?\n\nNot entirely sure, but I believe the JIT compiler is able to tweak and improve methods at runtime based on runtime metrics, whereas an AoT-compiled application can't take advantage of that as it's already been turned into static machine code.\n\nAs far as I understand, one of AoT-compilation's biggest advantages is faster *startup* speeds, but JIT-compilation can win out over time if the application runs for long enough time.\n\nI believe the term for this kind of JIT-tweaking is \"*Dynamic PGO*\".\n\nyeah, I was really sad when I learned that all that work done by JIT gets lost once the app is closed\n\nThis most likely is due to dynamic PGO. Which collects metrics on code usage and does compiler optimisations based on how the application is being used.\n\nRelevant blogposts:\n\n- [https://devblogs.microsoft.com/dotnet/bing-on-dotnet-8-the-impact-of-dynamic-pgo/](https://devblogs.microsoft.com/dotnet/bing-on-dotnet-8-the-impact-of-dynamic-pgo/)\n- [https://devblogs.microsoft.com/dotnet/conversation-about-pgo/](https://devblogs.microsoft.com/dotnet/conversation-about-pgo/)\n\nAOT only gets one chance to compile the code, with JIT it is initial compiled as best as it can cold, but with sort of monitoring code included, as the app runs the jitter learns about how functions are used and recompiles them to be more efficient based that usage.\n\nIt's basically always worse to use AOT than JIT. It's same compiler, but JIT has chance to optimize based on actual environment and usage, while AOT doesn't.\n\nOnly benefit of AOT is warmup, in everything else it will lose.\n\nAnd R2R allows to get the best of two worlds.\n\nAlas, the result of JIT and PGO is not persistend between executions.\n\nThe JIT compiler in CLR is an absolute beast. It's very hard to compete with it when it comes to runtime performance. It's able to perform some crazy optimizations due to runtime data, and it's waaay more mature.\n\nAnyway, in my understanding the JIT compiler is the best option for applications that:\n\n- Are long-running\n- Run in a stable, dedicated environment\n- Have plenty of memory available\n\nUsing AOT compilation is a good approach when you need:\n\n- Lower memory usage\n- Faster cold startup time\n- A single binary for distribution\n\nAOT compilation will certainly improve as it gets more mature, but there are pros and cons for each approach. There's no silver bullet in engineering.\n\nThinking AOT is inherently faster than JIT is one of the most common misconceptions in the programming community. It simply isn't true.\n\nThe performance difference varies depending on the code.\n\nIt is possible for the jit to make optimisations based on runtime data that the aot compiler can't. So it can be faster.\n\nAot gives quicker cold boots and generally smaller binary and memory sizes but there is no guarantee of better performance.\n\nAOT isn’t about higher performance, it’s about smaller footprint and faster startup.\n\nJIT is able to achieve superior performance but with cost of loading IL and assembly metadata into the memory and analysing hot paths.\n\nReplace it with AOT and boom all these stuff is gone but you lose extra optimisations you get from JIT compiler.",
  "Author": "Vectorial1024",
  "PubDate": "2025-08-08T12:41:21+00:00",
  "Description": "I was looking at the TechEmpower web benchmark results, particularly the C# section: [TechEmpower](https://www.techempower.com/benchmarks/#section=data-r23&l=zik0zh-pa7)\n\nI then noticed something I do not understand.\n\nLook at the top results, which are both ASP.NET, but the exact ranking is not what I expected:\n\n- Rank 1: ASPNET-Core, JIT; 741k responses / second\n- Rank 2: ASPNET-Core, AOT; 692k responses / second\n\nI was thinking AOT should be faster since it is able to compile to a form which is pretty close to machine code, which should mean it is generally faster, but apparently it is not the case.\n\nFor example, sometimes we can guide/hint the JIT compiler to optimize away the array bounds check. If the JIT compiler can do this, then I suppose the AOT compiler should also be able to do this? Then, AOT should still be faster than JIT.\n\nDoes anyone know why AOT is slower than JIT in this case?"
}
