{
  "OutputDir": "_community",
  "Description": "**Disclaimer:** The views in this article are my own and do not represent Microsoft or Databricks.\n\n> >\n> *This article is part of a series focused on deploying a secure Medallion Architecture. The series follows a top-down approach ,  beginning with a high-level architectural perspective and gradually drilling down into implementation details using repeatable, code.*\n> >\n\nWithin a Lakehouse, strong security and access controls are essential to govern and protect data processing. This article introduces a deployment pattern for Azure Databricks that uses Lakeflow Jobs and the Medallion Architecture to enforce robust isolation across pipelines. Each pipeline stage runs as its own job per layer, executed by a dedicated Microsoft Entra ID service principal with tightly scoped, least-privilege access.\n\nIn short, we apply least privilege consistently across Bronze, Silver, and Gold using Azure components such as ADLS Gen2, Managed Identities (service principals), Azure Key Vault, Lakeflow Jobs, and Unity Catalog to build a secure, auditable platform. We also advocate separation of duties by segregating clusters and using separate storage accounts per layer.\n\n##### **Medallion Architecture in brief**\n\nThe ‘Medallion Architecture’ provides a data archetype for managing data across its entire lifecycle ( from inception to enrichment, integration, and consumption) organised into sequential, compartmentalised data layers. Data disposition is typically handled by an additional tier, which not shown in the diagram below.\n\n![]()\n\n- *Bronze (Raw):* Ingests and stores unprocessed data from source systems. Data is typically kept in immutable, append-only Delta tables, optionally enriched with technical fields, and pruned by time-based policies.\n- *Silver (Refined):* Cleans, filters, and transforms Bronze data into a consistent business context (e.g., 3NF or Data Vault) while applying appropriate temporal patterns.\n- *Gold (Curated):* Final, analytics-ready datasets (often dimensional models) supporting dashboards, reports, or APIs. A semantic layer may sit on top to handle metadata, presentation, and performance needs.\n\n*The multi-hop design increases business value at each step, simplifies troubleshooting, and enables progressive data quality checks. To fully realise these benefits, pipelines must embed strong security so that each layer is protected and only authorised processes can access it.*\n\n##### **Security challenges in Lakehouse pipelines**\n\nRunning an end-to-end Lakeflow under a single identity with broad permissions creates security risks and governance challenges, such as:\n\n- *No least privilege:* One user or service principal can read and write across all layers. If compromised or misused, it could access or alter even the more sensitive curated data.\n- *Human account dependency:* Using individual user accounts for production jobs is fragile (people leave or change roles). Interactive users often hold broad permissions that violate least privilege and raise the risk of unauthorised access or accidental exposure.\n- *Cross-contamination:* A defect in an upstream stage could overwrite downstream datasets (e.g., Silver accidentally writing into Gold).\n\n> >\n> *This article proposed an archetype that decouple pipeline execution from any single human identity and securely compartmentalizing access across the Medallion Architecture.*\n> >\n\nManaged identities are special service principal objects in Microsoft Entra ID that simplify and secure authentication between Azure resources and services. By utilising managed identities for automation, we gain several key benefits:\n\n- *Decoupled from people:* Pipelines run independently of personal accounts, ensuring continuity through personnel changes.\n- *Granular permissions:* Grant only what each pipeline needs (least privilege).\n- *Auditability:* Actions are logged under distinct non-human identities, improving traceability and compliance.\n- *Consistency:* Standardised, repeatable deployments reduce credential drift and configuration errors.\n\nThe Azure Databricks Access Connector integrates a system-assigned managed identity (SAMI) with a Databricks workspace, enabling secure, least-privilege access to Unity Catalog governed data in line with identity and access-management best practices.\n\n##### **Secure Lakeflow Design - Isolate Each Medallion Layer**\n\nEnforce least privilege by splitting the end-to-end pipeline into three(3) Databricks Lakeflow jobs one per Medallion layer plus and overarching Lakeflow that acts as the orchestrator of the three(3) underline Lakeflow jobs.\n\n- Each Lakeflow runs under its own service principal.\n- Each connects to its own managed identity for accessing Azure Storage.\n- Each identity is granted only the permissions required for that layer.\n\nThis creates clear separation of duties. No single principal, cluster, or job has full access across all layers. If Bronze code is compromised, it cannot read or corrupt Silver and Gold because the Bronze identity lacks access to those locations. The same design prevents accidental overwrites (e.g., a Silver bug attempting to write into Gold will be blocked by permissions). As shown in the table below.\n\n![]()\n\n*Provisioning Steps:*\n\n1. Create three(3) storage accounts (Bronze, Silver and Gold).\n2. Create three(3) managed identities/service principals, one(1) per layer, and assign only the required credentials/roles to the corresponding storage.\n3. In Databricks Unity Catalog, configure the storage credentials as external locations for each of the three(3) layers.\n\n###### **Compute Configuration**\n\nApply the same isolation to compute: provision **** three(3) dedicated clusters, one(1) per layer, instead of sharing a single cluster.\n\n- *Bronze cluster*: raw ingestion.\n- *Silver cluster*: cleansing, transformation, and integration into consistent business models.\n- *Gold cluster*: curated analytics, optimised for BI/reporting (dimensional/semantic layers).\n\nThe key benefits of a this multi-cluster approach are:\n\n- *Cost control & optimisation*: Right-size per workload. Use autoscaling and auto-termination and enforce spend control with cluster policies.\n- *Security isolation*: Restrict user groups to layer-specific clusters; align with Unity Catalog’s fine-grained permissions.\n- *Tailored tuning*:\n- Gold: general-purpose nodes compute optimised nodes with Photon optional, but most of the time disabled depending on workload.\n- Silver: general-purpose nodes compute optimised with Photon acceleration enabled.\n- Bronze: general-purpose node compute optimised with Photon optional, but most of the time disabled depending on workload.\n- Choose the most suitable Databricks Runtime variant per layer.\n- *Performance & independent scaling*: Avoid resource contention. Each stage scales to its own SLA.\n- *Operational simplicity*: Easier monitoring, debugging, tagging, and policy enforcement by layer and environment.\n\n###### **Managed Identities & Service Principals configuration**\n\nService principals can be Databricks or Microsoft Entra ID managed.\n\n- Databricks managed service principals can authenticate to Databricks using Databricks OAuth (client-credentials / machine-to-machine) or personal access tokens (PATs).\n- Microsoft Entra ID managed service principals can authenticate using Databricks OAuth (client-credentials) or Microsoft Entra ID access tokens (OIDC).\n\nIn this pattern we authenticate via Microsoft Entra ID tokens, using Entra-managed service principals.\n\n*Provisioning steps:*\n\n1. Create three service principals (Bronze, Silver, Gold).\n2. Add them to the Databricks Account as *Microsoft Entra ID managed*.\n3. In the Account Console, grant each principal User permission on the target workspaces.\n\n###### **Lakeflow configuration**\n\nConnect the components and complete configuration:\n\n1. In the Databricks workspace, create External Locations (Unity Catalog) for Bronze, Silver, and Gold, each backed by the appropriate storage credentials.\n2. Grant the layer service principal access to its External Location.\n3. Grant *Browse* and *Read File* on source storage and *Browse*, *Read File* and *Write File* on target storage as appropriate for the layer’s job.\n4. If managing identities across multiple workspaces, ensure access is scoped only to the workspace that runs the Lakeflow (do not grant “all workspaces” global access if it’s not needed).\n5. Create three(3) cluster policies, **** one(1) per layer, with configurations aligned to the operations performed in that layer (as previously discussed).\n6. Create three(3) Lakeflow jobs, one for each layer.\n7. Create an orchestrator Lakeflow to execute the underline three(3) Lakeflow jobs.\n8. Create three(3) clusters and attach the appropriate cluster policy to each.\n9. For notebooks in the Lakeflow, grant the relevant service principals *Can Run*.\n10. For each Lakeflow, grant the layer’s service principal *Can Manage* as needed.\n\nPlease find below an high-level view on the cluster policies characteristics.\n\n![]()\n\n###### **Choose your table type (managed vs external)**\n\nUnder Unity Catalog, follow the *catalog.schema.table* convention. To preserve isolation, create separate catalogs for Bronze, Silver, and Gold. This also supports defining sub-layers, enabling smaller, incremental movements and transformations. In terms of table types we have the following choice:\n\n- Managed tables: Unity Catalog manages both metadata and data. Dropping a table also deletes the underlying data. Managed tables can enable Predictive Optimization, Automatic liquid clustering (*CLUSTER BY AUTO, DBR 15.4 LTS+*), and Automatic statistics. Maintenance runs automatically in the background; no extra cluster setup is required.\n- *External tables*: Unity Catalog registers the schema while files live in your storage path (you own permissions, lifecycle, and clean-up). You trade off some automatic optimisations and lineage for direct file ownership.\n\n> >\n> **Note:** For managed tables, Unity Catalog writes data to Azure Storage using GUID-based paths for catalogs, schemas, and tables. This obfuscates the physical layout, making it harder to infer table names from storage alone.\n> >\n\nExample folder structure you might see in ADLS Gen2:\n\n![]()\n\n*Therefore Azure Databricks Managed Tables will be our choice in the design.*\n\n###### **Secrets and credentials**\n\nKeep secrets out of code, repos, and job parameters. Store them in Azure Key Vault (AKV) and read them at runtime from notebooks via AKV-backed secret scopes.\n\n*Provisioning steps( for each environment):*\n\n1. Create an Azure Key Vault (e.g., kv-dev, kv-prod) and add the secrets required (e.g., API keys, DB passwords, webhooks).\n2. Create a Databricks secret scope backed by that Key Vault (e.g., kv-dev, kv-prod).\n3. Grant your layer service principals access to the Key Vault (least privilege).\n\nRead secrets only at runtime using *dbutils.secrets.get(...)*. Keep them in memory and, when you must pass them on, prefer process environment variables over string literals. Implement rotation policies in Azure Key Vault (AKV) so secrets rotate without code changes. Never hard-code secrets or commit them to Git. Do not print or log secret values, avoid display(api\\_token) and any f-strings that echo them, and don’t pass secrets as plain job parameters, as these appear in run history. Operate with one secret scope per environment and use consistent key names (e.g., api-token, db-password).\n\nEnable AKV diagnostic logs for audit and review access regularly. Always validate secret access in a non-production workspace before promoting.\n\n###### **Observability & cost governance**\n\nBuild visibility in from day one. Enable system tables and use the Jobs monitoring UI so you can track failures, durations, and spend per Medallion layer.\n\nWhat to enable\n\n- *System tables*: grant access to the system catalog and query the Jobs system tables in system.lakeflow/\\* (for runs, tasks, and timelines) alongside billing tables in system.billing/\\*. Note that lakeflow was previously named workflow.\n- *Jobs monitoring UI*: use Jobs & Pipelines to view run history, drill into task details, and add notifications, useful for day-to-day triage\n\n##### **Final Words & next steps**\n\nPairing Medallion layering with per-layer identities, storage, and compute enforces least privilege end to end, reduces blast radius, and makes operations auditable and predictable. Unity Catalog provides the governance backbone with External Locations, storage credentials, managed tables and system-table observability so you can track reliability and cost by layer. While Lakeflow Jobs provide orchestration, retries, alerts, of data pipelines.\n\n![]()\n\nIn **Part II**, we’ll publish CI/CD code to deploy this pattern and address a few known challenges, like cluster reusability Lakeflow jobs and environment promotion.",
  "ProcessedDate": "2025-10-07 07:04:16",
  "EnhancedContent": "**Disclaimer:** The views in this article are my own and do not represent Microsoft or Databricks.\n\n> >\n> *This article is part of a series focused on deploying a secure Medallion Architecture. The series follows a top-down approach ,  beginning with a high-level architectural perspective and gradually drilling down into implementation details using repeatable, code.*\n> >\n\nWithin a Lakehouse, strong security and access controls are essential to govern and protect data processing. This article introduces a deployment pattern for Azure Databricks that uses Lakeflow Jobs and the Medallion Architecture to enforce robust isolation across pipelines. Each pipeline stage runs as its own job per layer, executed by a dedicated Microsoft Entra ID service principal with tightly scoped, least-privilege access.\n\nIn short, we apply least privilege consistently across Bronze, Silver, and Gold using Azure components such as ADLS Gen2, Managed Identities (service principals), Azure Key Vault, Lakeflow Jobs, and Unity Catalog to build a secure, auditable platform. We also advocate separation of duties by segregating clusters and using separate storage accounts per layer.\n\n##### **Medallion Architecture in brief**\n\nThe ‘Medallion Architecture’ provides a data archetype for managing data across its entire lifecycle ( from inception to enrichment, integration, and consumption) organised into sequential, compartmentalised data layers. Data disposition is typically handled by an additional tier, which not shown in the diagram below.\n\n- *Bronze (Raw):* Ingests and stores unprocessed data from source systems. Data is typically kept in immutable, append-only Delta tables, optionally enriched with technical fields, and pruned by time-based policies.\n- *Silver (Refined):* Cleans, filters, and transforms Bronze data into a consistent business context (e.g., 3NF or Data Vault) while applying appropriate temporal patterns.\n- *Gold (Curated):* Final, analytics-ready datasets (often dimensional models) supporting dashboards, reports, or APIs. A semantic layer may sit on top to handle metadata, presentation, and performance needs.\n\n*The multi-hop design increases business value at each step, simplifies troubleshooting, and enables progressive data quality checks. To fully realise these benefits, pipelines must embed strong security so that each layer is protected and only authorised processes can access it.*\n\n##### **Security challenges in Lakehouse pipelines**\n\nRunning an end-to-end Lakeflow under a single identity with broad permissions creates security risks and governance challenges, such as:\n\n- *No least privilege:* One user or service principal can read and write across all layers. If compromised or misused, it could access or alter even the more sensitive curated data.\n- *Human account dependency:* Using individual user accounts for production jobs is fragile (people leave or change roles). Interactive users often hold broad permissions that violate least privilege and raise the risk of unauthorised access or accidental exposure.\n- *Cross-contamination:* A defect in an upstream stage could overwrite downstream datasets (e.g., Silver accidentally writing into Gold).\n\n> >\n> *This article proposed an archetype that decouple pipeline execution from any single human identity and securely compartmentalizing access across the Medallion Architecture.*\n> >\n\nManaged identities are special service principal objects in Microsoft Entra ID that simplify and secure authentication between Azure resources and services. By utilising managed identities for automation, we gain several key benefits:\n\n- *Decoupled from people:* Pipelines run independently of personal accounts, ensuring continuity through personnel changes.\n- *Granular permissions:* Grant only what each pipeline needs (least privilege).\n- *Auditability:* Actions are logged under distinct non-human identities, improving traceability and compliance.\n- *Consistency:* Standardised, repeatable deployments reduce credential drift and configuration errors.\n\nThe Azure Databricks Access Connector integrates a system-assigned managed identity (SAMI) with a Databricks workspace, enabling secure, least-privilege access to Unity Catalog governed data in line with identity and access-management best practices.\n\n##### **Secure Lakeflow Design - Isolate Each Medallion Layer**\n\nEnforce least privilege by splitting the end-to-end pipeline into three(3) Databricks Lakeflow jobs one per Medallion layer plus and overarching Lakeflow that acts as the orchestrator of the three(3) underline Lakeflow jobs.\n\n- Each Lakeflow runs under its own service principal.\n- Each connects to its own managed identity for accessing Azure Storage.\n- Each identity is granted only the permissions required for that layer.\n\nThis creates clear separation of duties. No single principal, cluster, or job has full access across all layers. If Bronze code is compromised, it cannot read or corrupt Silver and Gold because the Bronze identity lacks access to those locations. The same design prevents accidental overwrites (e.g., a Silver bug attempting to write into Gold will be blocked by permissions). As shown in the table below.\n\n*Provisioning Steps:*\n\n1. Create three(3) storage accounts (Bronze, Silver and Gold).\n2. Create three(3) managed identities/service principals, one(1) per layer, and assign only the required credentials/roles to the corresponding storage.\n3. In Databricks Unity Catalog, configure the storage credentials as external locations for each of the three(3) layers.\n\n###### **Compute Configuration**\n\nApply the same isolation to compute: provision **** three(3) dedicated clusters, one(1) per layer, instead of sharing a single cluster.\n\n- *Bronze cluster*: raw ingestion.\n- *Silver cluster*: cleansing, transformation, and integration into consistent business models.\n- *Gold cluster*: curated analytics, optimised for BI/reporting (dimensional/semantic layers).\n\nThe key benefits of a this multi-cluster approach are:\n\n- *Cost control & optimisation*: Right-size per workload. Use autoscaling and auto-termination and enforce spend control with cluster policies.\n- *Security isolation*: Restrict user groups to layer-specific clusters; align with Unity Catalog’s fine-grained permissions.\n- *Tailored tuning*:\n- Gold: general-purpose nodes compute optimised nodes with Photon optional, but most of the time disabled depending on workload.\n- Silver: general-purpose nodes compute optimised with Photon acceleration enabled.\n- Bronze: general-purpose node compute optimised with Photon optional, but most of the time disabled depending on workload.\n- Choose the most suitable Databricks Runtime variant per layer.\n- *Performance & independent scaling*: Avoid resource contention. Each stage scales to its own SLA.\n- *Operational simplicity*: Easier monitoring, debugging, tagging, and policy enforcement by layer and environment.\n\n###### **Managed Identities & Service Principals configuration**\n\nService principals can be Databricks or Microsoft Entra ID managed.\n\n- Databricks managed service principals can authenticate to Databricks using Databricks OAuth (client-credentials / machine-to-machine) or personal access tokens (PATs).\n- Microsoft Entra ID managed service principals can authenticate using Databricks OAuth (client-credentials) or Microsoft Entra ID access tokens (OIDC).\n\nIn this pattern we authenticate via Microsoft Entra ID tokens, using Entra-managed service principals.\n\n*Provisioning steps:*\n\n1. Create three service principals (Bronze, Silver, Gold).\n2. Add them to the Databricks Account as *Microsoft Entra ID managed*.\n3. In the Account Console, grant each principal User permission on the target workspaces.\n\n###### **Lakeflow configuration**\n\nConnect the components and complete configuration:\n\n1. In the Databricks workspace, create External Locations (Unity Catalog) for Bronze, Silver, and Gold, each backed by the appropriate storage credentials.\n2. Grant the layer service principal access to its External Location.\n3. Grant *Browse* and *Read File* on source storage and *Browse*, *Read File* and *Write File* on target storage as appropriate for the layer’s job.\n4. If managing identities across multiple workspaces, ensure access is scoped only to the workspace that runs the Lakeflow (do not grant “all workspaces” global access if it’s not needed).\n5. Create three(3) cluster policies, **** one(1) per layer, with configurations aligned to the operations performed in that layer (as previously discussed).\n6. Create three(3) Lakeflow jobs, one for each layer.\n7. Create an orchestrator Lakeflow to execute the underline three(3) Lakeflow jobs.\n8. Create three(3) clusters and attach the appropriate cluster policy to each.\n9. For notebooks in the Lakeflow, grant the relevant service principals *Can Run*.\n10. For each Lakeflow, grant the layer’s service principal *Can Manage* as needed.\n\nPlease find below an high-level view on the cluster policies characteristics.\n\n###### **Choose your table type (managed vs external)**\n\nUnder Unity Catalog, follow the *catalog.schema.table* convention. To preserve isolation, create separate catalogs for Bronze, Silver, and Gold. This also supports defining sub-layers, enabling smaller, incremental movements and transformations. In terms of table types we have the following choice:\n\n- Managed tables: Unity Catalog manages both metadata and data. Dropping a table also deletes the underlying data. Managed tables can enable Predictive Optimization, Automatic liquid clustering (*CLUSTER BY AUTO, DBR 15.4 LTS+*), and Automatic statistics. Maintenance runs automatically in the background; no extra cluster setup is required.\n- *External tables*: Unity Catalog registers the schema while files live in your storage path (you own permissions, lifecycle, and clean-up). You trade off some automatic optimisations and lineage for direct file ownership.\n\n> >\n> **Note:** For managed tables, Unity Catalog writes data to Azure Storage using GUID-based paths for catalogs, schemas, and tables. This obfuscates the physical layout, making it harder to infer table names from storage alone.\n> >\n\nExample folder structure you might see in ADLS Gen2:\n\n*Therefore Azure Databricks Managed Tables will be our choice in the design.*\n\n###### **Secrets and credentials**\n\nKeep secrets out of code, repos, and job parameters. Store them in Azure Key Vault (AKV) and read them at runtime from notebooks via AKV-backed secret scopes.\n\n*Provisioning steps( for each environment):*\n\n1. Create an Azure Key Vault (e.g., kv-dev, kv-prod) and add the secrets required (e.g., API keys, DB passwords, webhooks).\n2. Create a Databricks secret scope backed by that Key Vault (e.g., kv-dev, kv-prod).\n3. Grant your layer service principals access to the Key Vault (least privilege).\n\nRead secrets only at runtime using *dbutils.secrets.get(...)*. Keep them in memory and, when you must pass them on, prefer process environment variables over string literals. Implement rotation policies in Azure Key Vault (AKV) so secrets rotate without code changes. Never hard-code secrets or commit them to Git. Do not print or log secret values, avoid display(api\\_token) and any f-strings that echo them, and don’t pass secrets as plain job parameters, as these appear in run history. Operate with one secret scope per environment and use consistent key names (e.g., api-token, db-password).\n\nEnable AKV diagnostic logs for audit and review access regularly. Always validate secret access in a non-production workspace before promoting.\n\n###### **Observability & cost governance**\n\nBuild visibility in from day one. Enable system tables and use the Jobs monitoring UI so you can track failures, durations, and spend per Medallion layer.\n\nWhat to enable\n\n- *System tables*: grant access to the system catalog and query the Jobs system tables in system.lakeflow/\\* (for runs, tasks, and timelines) alongside billing tables in system.billing/\\*. Note that lakeflow was previously named workflow.\n- *Jobs monitoring UI*: use Jobs & Pipelines to view run history, drill into task details, and add notifications, useful for day-to-day triage\n\n##### **Final Words & next steps**\n\nPairing Medallion layering with per-layer identities, storage, and compute enforces least privilege end to end, reduces blast radius, and makes operations auditable and predictable. Unity Catalog provides the governance backbone with External Locations, storage credentials, managed tables and system-table observability so you can track reliability and cost by layer. While Lakeflow Jobs provide orchestration, retries, alerts, of data pipelines.\n\nIn **Part II**, we’ll publish CI/CD code to deploy this pattern and address a few known challenges, like cluster reusability Lakeflow jobs and environment promotion.\n\nUpdated Oct 07, 2025\n\nVersion 1.0\n\n[analytics](/tag/analytics?nodeId=board%3AAnalyticsonAzure)\n\n[azure](/tag/azure?nodeId=board%3AAnalyticsonAzure)\n\n[azure databricks](/tag/azure%20databricks?nodeId=board%3AAnalyticsonAzure)\n\n[delta lake](/tag/delta%20lake?nodeId=board%3AAnalyticsonAzure)\n\n[spark](/tag/spark?nodeId=board%3AAnalyticsonAzure)\n\n[!\\[mscagliola&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/m_assets/avatars/default/avatar-11.svg?image-dimensions=50x50)](/users/mscagliola/2555962) [mscagliola](/users/mscagliola/2555962) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined July 03, 2024\n\n[View Profile](/users/mscagliola/2555962)\n\n/category/azure/blog/analyticsonazure [Analytics on Azure Blog](/category/azure/blog/analyticsonazure) Follow this blog board to get notified when there's new activity",
  "Author": "mscagliola",
  "Title": "Secure Medallion Architecture Pattern on Azure Databricks (Part I)",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "FeedName": "Microsoft Tech Community",
  "Tags": [],
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "PubDate": "2025-10-07T06:25:50+00:00",
  "Link": "https://techcommunity.microsoft.com/t5/analytics-on-azure-blog/secure-medallion-architecture-pattern-on-azure-databricks-part-i/ba-p/4459268"
}
