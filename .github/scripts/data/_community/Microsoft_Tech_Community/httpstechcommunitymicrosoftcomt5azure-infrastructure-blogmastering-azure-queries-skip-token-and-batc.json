{
  "OutputDir": "_community",
  "Link": "https://techcommunity.microsoft.com/t5/azure-infrastructure-blog/mastering-azure-queries-skip-token-and-batching-for-scale/ba-p/4463387",
  "EnhancedContent": "Let's be honest. As a cloud engineer or DevOps professional managing a large Azure environment, running even a simple resource inventory query can feel like drinking from a firehose. You hit API limits, face slow performance, and struggle to get the complete picture of your estate‚Äîall because the data volume is overwhelming.\n\nBut it doesn't have to be this way!\n\nThis blog is your practical, hands-on guide to mastering two essential techniques for handling massive data volumes in Azure: using **PowerShell** and **Azure Resource Graph (ARG)**: **Skip Token** (for full data retrieval) and **Batching** (for blazing-fast performance).\n\n## Table of Contents\n\n1. Introduction\n2. Understanding Data Pagination in Cloud Queries\n3. What Is a Skip Token?\n3.1 Concept of Skip Token 3.2 PowerShell Example Using Skip Token\n4. What Is Batching?\n4.1 Concept of Batching 4.2 PowerShell Example Using Batching\n5. Is Skip Token a Generic Concept or Azure-Specific?\n5.1 Skip Token in Generic API Design 5.2 Skip Token Usage in Azure Resource Graph (ARG)\n6. Introduction to Azure Resource Graph (ARG)\n6.1 What Is Azure Resource Graph 6.2 Why ARG Uses Skip Token and Batching 6.3 Practical PowerShell Example Using ARG with Skip Token and Batching\n7. Summary and References\n\n## Introduction: Why Standard Queries Don't Work at Scale\n\nWhen you query a service designed for big environments, like Azure Resource Graph, you face two limits:\n\n1. **Result Limits (Pagination):** APIs won't send you millions of records at once. They cap the result size (often 1,000 items) and stop.\n2. **Efficiency Limits (Throttling):** Sending a huge number of individual requests is slow and can cause the API to temporarily block you (throttling).\n\n**Skip Token** helps you solve the first limit by making sure you retrieve **all results**.\n\n**Batching** solves the second by grouping your requests to **improve performance**.\n\n## Understanding Skip Token: The Continuation Pointer\n\n### What is a Skip Token?\n\nA **Skip Token** (or continuation token) is a unique string value returned by an Azure API when a query result exceeds the maximum limit for a single response.\n\nThink of the Skip Token as a ‚Äú**bookmark**‚Äù that tells Azure where your last page ended ‚Äî so you can pick up exactly where you left off in the next API call. Instead of getting cut off after 1,000 records, the API gives you the first 1,000 results plus the Skip Token. You use this token in the next request to get the next page of data. This process is called¬†**pagination**.\n\n### Skip Token in Practice with PowerShell\n\nTo get the complete dataset, you must use a loop that repeatedly calls the API, providing the token each time until the token is no longer returned.\n\n**PowerShell Example: Using Skip Token to Loop Pages**\n\n```\n# Define the query\n$Query = \"Resources | project name, type, location\" $PageSize = 1000\n\n$AllResults = @() $SkipToken = $null # Initialize the token\n\nWrite-Host \"Starting ARG query...\"\n\ndo { Write-Host \"Fetching next page. (Token check: $($SkipToken -ne $null))\"\n\n# 1. Execute the query, using the -SkipToken parameter\n$ResultPage = Search-AzGraph -Query $Query -First $PageSize -SkipToken $SkipToken\n\n# 2. Add the current page results to the main array\n$AllResults += $ResultPage.Data\n\n# 3. Get the token for the next page, if it exists\n$SkipToken = $ResultPage.SkipToken\n\nWrite-Host \" -> Items in this page: $($ResultPage.Data.Count). Total retrieved: $($AllResults.Count)\"\n\n} while ($SkipToken -ne $null) # Loop as long as a Skip Token is returned\n\nWrite-Host \"Query finished. Total resources found: $($AllResults.Count)\" ```\n\n> >\n> This¬†**do-while loop** is the reliable way to ensure you retrieve every item in a large result set.\n> >\n\n## Understanding Batching: Grouping Requests\n\n### What is Batching?\n\n**Batching** means taking several independent requests and combining them into a **single API call**. Instead of making ***N*** separate network requests for ***N*** pieces of data, you make one request containing all ***N***¬†sub-requests.\n\nBatching is primarily used for **performance**. It improves efficiency by:\n\n1. **Reducing Overhead:** Fewer separate network connections are needed.\n2. **Lowering Throttling Risk:** Fewer overall API calls are made, which helps you stay under rate limits.\n\n| **Feature** | **Batching** | **Pagination (Skip Token)** | | --- | --- | --- | | **Goal** | Improve efficiency/speed. | Retrieve all data completely. | | **Input** | Multiple different queries. | Single query, continuing from a marker. | | **Result** | One response with results for all grouped queries. | Partial results with a token for the next step. |\n\n### Batching in Practice with PowerShell\n\nIn ARG, batching lets you run up to ten distinct Kusto queries, possibly targeting different scopes (like subscriptions), in one command.\n\n#### PowerShell Example: Running Multiple Queries in One Call\n\n```\n# Define multiple queries to run together\n$BatchQueries = @( @{ Query = \"Resources | where type =~ 'Microsoft.Compute/virtualMachines'\" Subscriptions = \"Subscription-A-ID\" # Query 1 Scope }, @{ Query = \"Resources | where type =~ 'Microsoft.Network/publicIPAddresses'\" Subscriptions = \"Subscription-B-ID\", \"Subscription-C-ID\" # Query 2 Scope } )\n\nWrite-Host \"Executing batch of $($BatchQueries.Count) queries...\"\n\n# Use the -Batch parameter with Search-AzGraph\n$BatchResults = Search-AzGraph -Batch $BatchQueries\n\nWrite-Host \"Batch complete. Reviewing results...\"\n\n# The results are returned in the same order as the input array\n$VMCount = $BatchResults[0].Data.Count $IPCount = $BatchResults[1].Data.Count\n\nWrite-Host \"Query 1 (VMs) returned: $VMCount results.\" Write-Host \"Query 2 (IPs) returned: $IPCount results.\" ```\n\n## Azure Resource Graph (ARG) and Scale\n\n**Azure Resource Graph (ARG)** is a service built for querying resource properties quickly across a large number of Azure subscriptions using the Kusto Query Language (KQL).\n\nBecause ARG is designed for large scale, it fully supports Skip Token and Batching:\n\n- **Skip Token:** ARG automatically generates and returns the token when a query exceeds its result limit (e.g., 1,000 records).\n- **Batching:** ARG provides a batch API endpoint that allows you to send an array of up to ten distinct queries **** in a single request for optimization.\n\n## Combined Example: Batching and Skip Token Together\n\nThis script shows how to use **Batching** to start a query across multiple subscriptions and then use **Skip Token** within the loop to ensure every subscription's data is fully retrieved.\n\n```\n# Subscriptions to query\n$SubscriptionIDs = @(\"Sub-Alpha-ID\", \"Sub-Beta-ID\") $KQLQuery = \"Resources | project id, name, type, subscriptionId\"\n\n$AllResults = @()\n\nWrite-Host \"Starting batched query across $($SubscriptionIDs.Count) subscriptions...\"\n\n# Create the initial batch request\n$CurrentBatch = $SubscriptionIDs | ForEach-Object { [PSCustomObject]@{ Query = $KQLQuery Subscriptions = $_ # Scope is one subscription ID } }\n\n$Cycle = 0 do { Write-Host \"`n--- Running Batch Cycle: $($Cycle++) ---\"\n\n# 1. Run the batch of queries (each query might return a page of results)\n$BatchResponse = Search-AzGraph -Batch $CurrentBatch -First 1000\n\n# 2. Prepare the batch for the next loop\n$NextBatch = @() $NewResultsInCycle = 0\n\n# 3. Process the results for each sub-query\nforeach ($Result in $BatchResponse) { $SubId = $Result.Subscriptions\n\n# Accumulate results\n$AllResults += $Result.Data $NewResultsInCycle += $Result.Data.Count\n\n# Check if a Skip Token was returned\nif ($Result.SkipToken) { Write-Host \" ‚úÖ Skip Token found for Subscription ID: $SubId. Preparing next page request.\"\n# Add this query to the next batch with the new Skip Token\n$NextBatch += [PSCustomObject]@{ Query = $KQLQuery Subscriptions = $SubId SkipToken = $Result.SkipToken # The key to the next page } } else { Write-Host \" üõë Query complete for Subscription ID: $SubId.\" } }\n\nWrite-Host \"Total new resources retrieved this cycle: $NewResultsInCycle\"\n\n# Set the batch for the next iteration (only queries with remaining pages)\n$CurrentBatch = $NextBatch\n\n} while ($CurrentBatch.Count -gt 0) # Loop until all pages for all subscriptions are retrieved\n\nWrite-Host \"`n--- Script Finished ---\" Write-Host \"Final total resource count: $($AllResults.Count)\" ```\n\n| **Technique** | **Use When...** | **Common Mistake** | **Actionable Advice** | | --- | --- | --- | --- | | **Skip Token** | You must retrieve **all** data items, expecting more than 1,000 results. | Forgetting to check for the token; you only get partial data. | **Always** use a do-while loop to guarantee you get the complete set. | | **Batching** | You need to run several separate queries (max 10 in ARG) efficiently. | Putting too many queries in the batch, causing the request to fail. | Group up to 10 logical queries or subscriptions into one fast request. |\n\nBy combining¬†**Skip Token** for data completeness and **Batching** for efficiency, you can confidently query massive Azure estates without hitting limits or missing data.\n\nThese two techniques ‚Äî when used together ‚Äî turn Azure Resource Graph from a ‚Äúgood tool‚Äù into a **scalable discovery engine** for your entire cloud footprint.\n\n# Summary: Skip Token and Batching in Azure Resource Graph\n\n**Goal:** Efficiently query massive Azure environments using PowerShell and Azure Resource Graph (ARG).\n\n### 1. Skip Token (The Data Completeness Tool)\n\n| **Concept** | **What it Does** | **Why it Matters** | **PowerShell Use** | | --- | --- | --- | --- | | **Skip Token** | A marker returned by Azure APIs when results hit the 1,000-item limit. It points to the next page of data. | Ensures you retrieve **all** records, avoiding incomplete data (pagination). | Use a do-while loop with the -SkipToken parameter in Search-AzGraph until the token is no longer returned. |\n\n### 2. Batching (The Performance Booster)\n\n| **Concept** | **What it Does** | **Why it Matters** | **PowerShell Use** | | --- | --- | --- | --- | | **Batching** | Groups multiple independent queries (up to 10 in ARG) into a single API request. | Drastically improves **query speed** by reducing network overhead and helps avoid API throttling. | Use the Search-AzGraph -Batch parameter with an array of query objects. |\n\n### 3. Best Practice: Combine Them\n\nFor maximum efficiency, **combine Batching and Skip Token**. Use batching to run queries across multiple subscriptions simultaneously, and use the Skip Token logic within the loop to ensure every single subscription's data is fully paginated and retrieved.\n\n**Result:** Fast, complete, and reliable data collection across your large Azure estate.\n\n### References:\n\n- [Azure Resource Graph documentation](https://learn.microsoft.com/en-us/azure/governance/resource-graph/overview)\n- [Search-AzGraph PowerShell reference](https://learn.microsoft.com/en-us/powershell/module/az.resourcegraph/search-azgraph?view=azps-14.5.0)\n\nUpdated Oct 22, 2025\n\nVersion 1.0\n\n[cloud security best practices](/tag/cloud%20security%20best%20practices?nodeId=board%3AAzureInfrastructureBlog)\n\n[updates](/tag/updates?nodeId=board%3AAzureInfrastructureBlog)\n\n[!\\[ankitankit&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0yNDY0NTUwLTU4MTI0OGkyNUIxMkFCNkEwMEU1RTMx?image-dimensions=50x50)](/users/ankitankit/2464550) [ankitankit](/users/ankitankit/2464550) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined May 09, 2024\n\n[View Profile](/users/ankitankit/2464550)\n\n/category/azure/blog/azureinfrastructureblog [Azure Infrastructure Blog](/category/azure/blog/azureinfrastructureblog) Follow this blog board to get notified when there's new activity",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Tags": [],
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Description": "Let's be honest. As a cloud engineer or DevOps professional managing a large Azure environment, running even a simple resource inventory query can feel like drinking from a firehose. You hit API limits, face slow performance, and struggle to get the complete picture of your estate‚Äîall because the data volume is overwhelming.\n\nBut it doesn't have to be this way!\n\nThis blog is your practical, hands-on guide to mastering two essential techniques for handling massive data volumes in Azure: using **PowerShell** and **Azure Resource Graph (ARG)**: **Skip Token** (for full data retrieval) and **Batching** (for blazing-fast performance).\n\n## Table of Contents\n\n1. Introduction\n2. Understanding Data Pagination in Cloud Queries\n3. What Is a Skip Token?\n3.1 Concept of Skip Token 3.2 PowerShell Example Using Skip Token\n4. What Is Batching?\n4.1 Concept of Batching 4.2 PowerShell Example Using Batching\n5. Is Skip Token a Generic Concept or Azure-Specific?\n5.1 Skip Token in Generic API Design 5.2 Skip Token Usage in Azure Resource Graph (ARG)\n6. Introduction to Azure Resource Graph (ARG)\n6.1 What Is Azure Resource Graph 6.2 Why ARG Uses Skip Token and Batching 6.3 Practical PowerShell Example Using ARG with Skip Token and Batching\n7. Summary and References\n\n## Introduction: Why Standard Queries Don't Work at Scale\n\nWhen you query a service designed for big environments, like Azure Resource Graph, you face two limits:\n\n1. **Result Limits (Pagination):** APIs won't send you millions of records at once. They cap the result size (often 1,000 items) and stop.\n2. **Efficiency Limits (Throttling):** Sending a huge number of individual requests is slow and can cause the API to temporarily block you (throttling).\n\n**Skip Token** helps you solve the first limit by making sure you retrieve **all results**.\n\n**Batching** solves the second by grouping your requests to **improve performance**.\n\n## Understanding Skip Token: The Continuation Pointer\n\n### What is a Skip Token?\n\nA **Skip Token** (or continuation token) is a unique string value returned by an Azure API when a query result exceeds the maximum limit for a single response.\n\nThink of the Skip Token as a ‚Äú**bookmark**‚Äù that tells Azure where your last page ended ‚Äî so you can pick up exactly where you left off in the next API call. Instead of getting cut off after 1,000 records, the API gives you the first 1,000 results plus the Skip Token. You use this token in the next request to get the next page of data. This process is called **pagination**.\n\n### Skip Token in Practice with PowerShell\n\nTo get the complete dataset, you must use a loop that repeatedly calls the API, providing the token each time until the token is no longer returned.\n\n**PowerShell Example: Using Skip Token to Loop Pages**\n\n- # Define the query\n$Query = \"Resources | project name, type, location\" $PageSize = 1000\n\n$AllResults = @() $SkipToken = $null # Initialize the token\n\nWrite-Host \"Starting ARG query...\"\n\ndo { Write-Host \"Fetching next page. (Token check: $($SkipToken -ne $null))\"\n\n# 1. Execute the query, using the -SkipToken parameter\n$ResultPage = Search-AzGraph -Query $Query -First $PageSize -SkipToken $SkipToken\n\n# 2. Add the current page results to the main array\n$AllResults += $ResultPage.Data\n\n# 3. Get the token for the next page, if it exists\n$SkipToken = $ResultPage.SkipToken\n\nWrite-Host \" -> Items in this page: $($ResultPage.Data.Count). Total retrieved: $($AllResults.Count)\"\n\n} while ($SkipToken -ne $null) # Loop as long as a Skip Token is returned\n\nWrite-Host \"Query finished. Total resources found: $($AllResults.Count)\"\n\n> >\n> This **do-while loop** is the reliable way to ensure you retrieve every item in a large result set.\n> >\n\n## Understanding Batching: Grouping Requests\n\n### What is Batching?\n\n**Batching** means taking several independent requests and combining them into a **single API call**. Instead of making ***N*** separate network requests for ***N*** pieces of data, you make one request containing all ***N*** sub-requests.\n\nBatching is primarily used for **performance**. It improves efficiency by:\n\n1. **Reducing Overhead:** Fewer separate network connections are needed.\n2. **Lowering Throttling Risk:** Fewer overall API calls are made, which helps you stay under rate limits.\n\n| **Feature** | **Batching** | **Pagination (Skip Token)** | | --- | --- | --- | | **Goal** | Improve efficiency/speed. | Retrieve all data completely. | | **Input** | Multiple different queries. | Single query, continuing from a marker. | | **Result** | One response with results for all grouped queries. | Partial results with a token for the next step. |\n\n### Batching in Practice with PowerShell\n\nIn ARG, batching lets you run up to ten distinct Kusto queries, possibly targeting different scopes (like subscriptions), in one command.\n\n#### PowerShell Example: Running Multiple Queries in One Call\n- # Define multiple queries to run together\n$BatchQueries = @( @{ Query = \"Resources | where type =~ 'Microsoft.Compute/virtualMachines'\" Subscriptions = \"Subscription-A-ID\" # Query 1 Scope }, @{ Query = \"Resources | where type =~ 'Microsoft.Network/publicIPAddresses'\" Subscriptions = \"Subscription-B-ID\", \"Subscription-C-ID\" # Query 2 Scope } )\n\nWrite-Host \"Executing batch of $($BatchQueries.Count) queries...\"\n\n# Use the -Batch parameter with Search-AzGraph\n$BatchResults = Search-AzGraph -Batch $BatchQueries\n\nWrite-Host \"Batch complete. Reviewing results...\"\n\n# The results are returned in the same order as the input array\n$VMCount = $BatchResults[0].Data.Count $IPCount = $BatchResults[1].Data.Count\n\nWrite-Host \"Query 1 (VMs) returned: $VMCount results.\" Write-Host \"Query 2 (IPs) returned: $IPCount results.\"\n\n## Azure Resource Graph (ARG) and Scale\n\n**Azure Resource Graph (ARG)** is a service built for querying resource properties quickly across a large number of Azure subscriptions using the Kusto Query Language (KQL).\n\nBecause ARG is designed for large scale, it fully supports Skip Token and Batching:\n\n- **Skip Token:** ARG automatically generates and returns the token when a query exceeds its result limit (e.g., 1,000 records).\n- **Batching:** ARG provides a batch API endpoint that allows you to send an array of up to ten distinct queries **** in a single request for optimization.\n\n## Combined Example: Batching and Skip Token Together\n\nThis script shows how to use **Batching** to start a query across multiple subscriptions and then use **Skip Token** within the loop to ensure every subscription's data is fully retrieved.\n- # Subscriptions to query\n$SubscriptionIDs = @(\"Sub-Alpha-ID\", \"Sub-Beta-ID\") $KQLQuery = \"Resources | project id, name, type, subscriptionId\"\n\n$AllResults = @()\n\nWrite-Host \"Starting batched query across $($SubscriptionIDs.Count) subscriptions...\"\n\n# Create the initial batch request\n$CurrentBatch = $SubscriptionIDs | ForEach-Object { [PSCustomObject]@{ Query = $KQLQuery Subscriptions = $\\_ # Scope is one subscription ID } }\n\n$Cycle = 0 do { Write-Host \"`n--- Running Batch Cycle: $($Cycle++) ---\"\n\n# 1. Run the batch of queries (each query might return a page of results)\n$BatchResponse = Search-AzGraph -Batch $CurrentBatch -First 1000\n\n# 2. Prepare the batch for the next loop\n$NextBatch = @() $NewResultsInCycle = 0\n\n# 3. Process the results for each sub-query\nforeach ($Result in $BatchResponse) { $SubId = $Result.Subscriptions\n\n# Accumulate results\n$AllResults += $Result.Data $NewResultsInCycle += $Result.Data.Count\n\n# Check if a Skip Token was returned\nif ($Result.SkipToken) { Write-Host \" ‚úÖ Skip Token found for Subscription ID: $SubId. Preparing next page request.\"\n# Add this query to the next batch with the new Skip Token\n$NextBatch += [PSCustomObject]@{ Query = $KQLQuery Subscriptions = $SubId SkipToken = $Result.SkipToken # The key to the next page } } else { Write-Host \" üõë Query complete for Subscription ID: $SubId.\" } }\n\nWrite-Host \"Total new resources retrieved this cycle: $NewResultsInCycle\"\n\n# Set the batch for the next iteration (only queries with remaining pages)\n$CurrentBatch = $NextBatch\n\n} while ($CurrentBatch.Count -gt 0) # Loop until all pages for all subscriptions are retrieved\n\nWrite-Host \"`n--- Script Finished ---\" Write-Host \"Final total resource count: $($AllResults.Count)\"\n\n| **Technique** | **Use When...** | **Common Mistake** | **Actionable Advice** | | --- | --- | --- | --- | | **Skip Token** | You must retrieve **all** data items, expecting more than 1,000 results. | Forgetting to check for the token; you only get partial data. | **Always** use a do-while loop to guarantee you get the complete set. | | **Batching** | You need to run several separate queries (max 10 in ARG) efficiently. | Putting too many queries in the batch, causing the request to fail. | Group up to 10 logical queries or subscriptions into one fast request. |\n\nBy combining **Skip Token** for data completeness and **Batching** for efficiency, you can confidently query massive Azure estates without hitting limits or missing data.\n\nThese two techniques ‚Äî when used together ‚Äî turn Azure Resource Graph from a ‚Äúgood tool‚Äù into a **scalable discovery engine** for your entire cloud footprint.\n\n# Summary: Skip Token and Batching in Azure Resource Graph\n\n**Goal:** Efficiently query massive Azure environments using PowerShell and Azure Resource Graph (ARG).\n\n### 1. Skip Token (The Data Completeness Tool)\n\n| **Concept** | **What it Does** | **Why it Matters** | **PowerShell Use** | | --- | --- | --- | --- | | **Skip Token** | A marker returned by Azure APIs when results hit the 1,000-item limit. It points to the next page of data. | Ensures you retrieve **all** records, avoiding incomplete data (pagination). | Use a do-while loop with the -SkipToken parameter in Search-AzGraph until the token is no longer returned. |\n\n### 2. Batching (The Performance Booster)\n\n| **Concept** | **What it Does** | **Why it Matters** | **PowerShell Use** | | --- | --- | --- | --- | | **Batching** | Groups multiple independent queries (up to 10 in ARG) into a single API request. | Drastically improves **query speed** by reducing network overhead and helps avoid API throttling. | Use the Search-AzGraph -Batch parameter with an array of query objects. |\n\n### 3. Best Practice: Combine Them\n\nFor maximum efficiency, **combine Batching and Skip Token**. Use batching to run queries across multiple subscriptions simultaneously, and use the Skip Token logic within the loop to ensure every single subscription's data is fully paginated and retrieved.\n\n**Result:** Fast, complete, and reliable data collection across your large Azure estate.\n\n### References:\n\n- [Azure Resource Graph documentation](https://learn.microsoft.com/en-us/azure/governance/resource-graph/overview)\n- [Search-AzGraph PowerShell reference](https://learn.microsoft.com/en-us/powershell/module/az.resourcegraph/search-azgraph?view=azps-14.5.0)",
  "PubDate": "2025-10-22T08:53:15+00:00",
  "FeedName": "Microsoft Tech Community",
  "Author": "ankitankit",
  "ProcessedDate": "2025-10-22 09:04:57",
  "Title": "Mastering Azure Queries: Skip Token and Batching for Scale"
}
