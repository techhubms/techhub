{
  "OutputDir": "_community",
  "Author": "PradyH",
  "FeedName": "Microsoft Tech Community",
  "Link": "https://techcommunity.microsoft.com/t5/azure-architecture-blog/building-ai-agents-workflow-first-vs-code-first-vs-hybrid/ba-p/4466788",
  "PubDate": "2025-11-11T18:36:18+00:00",
  "ProcessedDate": "2025-11-11 19:04:15",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Description": "AI Agents are no longer just a developer’s playground. They’re becoming essential for enterprise automation, decision-making, and customer engagement. But how do you build them? Do you go **workflow-first** with drag-and-drop designers, **code-first** with SDKs, or adopt a **hybrid approach** that blends both worlds? In this article, I’ll walk you through the landscape of AI Agent design. We’ll look at **workflow-first** approaches with drag-and-drop designers, **code-first** approaches using SDKs, and **hybrid models** that combine both. The goal is to help you understand the options and choose the right path for your organization.\n\n# Why AI Agents Need Orchestration\n\nBefore diving into tools and approaches, let’s talk about why orchestration matters. AI Agents are not just single-purpose bots anymore. They often need to perform **multi-step reasoning**, interact with multiple systems, and adapt to dynamic workflows. Without orchestration, these agents can become siloed and fail to deliver real business value.\n\nHere’s what I’ve observed as the key drivers for orchestration:\n\n- **Complexity of Enterprise Workflows**\nModern business processes involve multiple applications, data sources, and decision points. AI Agents need a way to coordinate these steps seamlessly.\n- **Governance and Compliance**\nEnterprises require control over how AI interacts with sensitive data and systems. Orchestration frameworks provide guardrails for security and compliance.\n- **Scalability and Maintainability**\nA single agent might work fine for a proof of concept, but scaling to hundreds of workflows requires structured orchestration to avoid chaos.\n- **Integration with Existing Systems**\nAI Agents rarely operate in isolation. They need to plug into ERP systems, CRMs, and custom apps. Orchestration ensures these integrations are reliable and repeatable.\n\nIn short, orchestration is the backbone that turns AI Agents from clever prototypes into enterprise-ready solutions.\n\n# *Behind the Scenes*\n\n*I’ve always been a pro-code guy. I started my career on open-source coding in Unix and hardly touched the mouse. Then I discovered Visual Studio, and it completely changed my perspective. It showed me the power of a hybrid approach, the best of both worlds. That said, I won’t let my experience bias your ideas of what you’d like to build. This blog is about giving you the full picture so you can make the choice that works best for you.*\n\n# Workflow-First Approach\n\nWorkflow-first platforms are more than visual designers and not just about drag-and-drop simplicity. They represent a design paradigm where orchestration logic is abstracted into declarative models rather than imperative code. These tools allow you to define agent behaviors, event triggers, and integration points visually, while the underlying engine handles state management, retries, and scaling. For architects, this means faster prototyping and governance baked into the platform. For developers, it offers extensibility through connectors and custom actions without sacrificing enterprise-grade reliability.\n\n## Copilot Studio\n\nBuilding conversational agents becomes intuitive with a visual designer that maps prompts, actions, and connectors into structured flows. Copilot Studio makes this possible by integrating enterprise data and enabling agents to automate tasks and respond intelligently without deep coding.\n\n**Building AI Agents using Copilot Studio**\n\n- Design conversation flows with adaptive prompts\n- Integrate Microsoft Graph for contextual responses\n- Add AI-driven actions using Copilot extensions\n- Support multi-turn reasoning for complex queries\n- Enable secure access to enterprise data sources\n- Extend functionality through custom connectors\n\n![]()\n\n## Logic Apps\n\nAdaptive workflows and complex integrations are handled through a robust orchestration engine. Logic Apps introduces **Agent Loop**, allowing agents to reason iteratively, adapt workflows, and interact with multiple systems in real time.\n\n**Building AI Agents using Logic Apps**\n\n- Implement Agent Loop for iterative reasoning\n- Integrate Azure OpenAI for goal-driven decisions\n- Access 1,400+ connectors for enterprise actions\n- Support human-in-the-loop for critical approvals\n- Enable multi-agent orchestration for complex tasks\n- Provide observability and security for agent workflows\n\n![]()\n\n## Power Automate\n\nMulti-step workflows can be orchestrated across business applications using AI Builder models or external AI APIs. Power Automate enables agents to make decisions, process data, and trigger actions dynamically, all within a low-code environment.\n\n**Building AI Agents using Power Automate**\n\n- Automate repetitive tasks with minimal effort\n- Apply AI Builder for predictions and classification\n- Call Azure OpenAI for natural language processing\n- Integrate with hundreds of enterprise connectors\n- Trigger workflows based on real-time events\n- Combine flows with human approvals for compliance\n\n![]()\n\n## Azure AI Foundry\n\nVisual orchestration meets pro-code flexibility through **Prompt Flow** and **Connected Agents**, enabling multi-step reasoning flows while allowing developers to extend capabilities through SDKs. Azure AI Foundry is ideal for scenarios requiring both agility and deep customization.\n\n**Building AI Agents using Azure AI Foundry**\n\n- Design reasoning flows visually with Prompt Flow\n- Orchestrate multi-agent systems using Connected Agents\n- Integrate with VS Code for advanced development\n- Apply governance and deployment pipelines for production\n- Use Azure OpenAI models for adaptive decision-making\n- Monitor workflows with built-in observability tools\n\n![]()\n\n## Microsoft Agent Framework (Preview)\n\nI’ve been exploring Microsoft Agent Framework (MAF), an open-source foundation for building AI agents that can run anywhere. It integrates with Azure AI Foundry and Azure services, enabling multi-agent workflows, advanced memory services, and visual orchestration. With public preview live and GA coming soon, MAF is shaping how we deliver scalable, flexible agentic solutions.\n\nEnterprise-scale orchestration is achieved through graph-based workflows, human-in-the-loop approvals, and observability features. The Microsoft Agent Framework lays the foundation for multi-agent systems that are durable and compliant.\n\n**Building AI Agents using Microsoft Agent Framework**\n\n- Coordinate multiple specialized agents in a graph\n- Implement durable workflows with pause and resume\n- Support human-in-the-loop for controlled autonomy\n- Integrate with Azure AI Foundry for hosting and governance\n- Enable observability through OpenTelemetry integration\n- Provide SDK flexibility for custom orchestration patterns\n\n****\n\n![]()\n\nVisual-first platforms make building AI Agents feel less like coding marathons and more like creative design sessions. They’re perfect for those scenarios when you’d rather design than debug and still want the option to dive deeper when complexity calls.\n\n# Pro-Code Approach\n\nRemember I told you how I started as a pro-code developer early in my career and later embraced a hybrid approach? I’ll try to stay neutral here as we explore the pro-code world. Pro-code frameworks offer integration with diverse ecosystems, multi-agent coordination, and fine-grained control over logic. While workflow-first and pro-code approaches both provide these capabilities, the difference lies in how they balance factors such as ease of development, ease of maintenance, time to deliver, monitoring capabilities, and other non-functional requirements. Choosing the right path often depends on which of these trade-offs matter most for your scenario.\n\n## LangChain\n\nWhen I first explored LangChain, it felt like stepping into a developer’s playground for AI orchestration. I could stitch together prompts, tools, and APIs like building blocks, and I enjoyed the flexibility. It reminded me why pro-code approaches appeal to those who want full control over logic and integration with diverse ecosystems.\n\n**Building AI Agents using LangChain**\n\n- Define custom chains for multi-step reasoning [it *is* called Lang“Chain”]\n- Integrate external APIs and tools for dynamic actions\n- Implement memory for context-aware conversations\n- Support multi-agent collaboration through orchestration patterns\n- Extend functionality with custom Python modules\n- Deploy agents across cloud environments for scalability\n\n****\n\n![]()\n\n## Semantic Kernel\n\nI’ve worked with Semantic Kernel when I needed more control over orchestration logic, and what stood out was its flexibility. It provides both .NET and Python SDKs, which makes it easy to combine natural language prompts with traditional programming logic. I found the planners and skills especially useful for breaking down goals into smaller steps, and connectors helped integrate external systems without reinventing the wheel.\n\n**Building AI Agents using Semantic Kernel**\n\n- Create semantic functions for prompt-driven tasks\n- Use planners for dynamic goal decomposition\n- Integrate plugins for external system access\n- Implement memory for persistent context across sessions\n- Combine AI reasoning with deterministic code logic\n- Enable observability and telemetry for enterprise monitoring\n\n****\n\n![]()\n\n## Microsoft Agent Framework (Preview)\n\nAlthough I introduced MAF in the earlier section, its SDK-first design makes it relevant here as well for advanced orchestration and the pro-code nature… and so I’ll probably write this again in the Hybrid section. The Agent Framework is designed for developers who need full control over multi-agent orchestration. It provides a pro-code approach for defining agent behaviors, implementing advanced coordination patterns, and integrating enterprise-grade observability.\n\n**Building AI Agents using Microsoft Agent Framework**\n\n- Define custom orchestration logic using SDK APIs\n- Implement graph-based workflows for multi-agent coordination\n- Extend agent capabilities with custom code modules\n- Apply durable execution patterns with pause and resume\n- Integrate OpenTelemetry for detailed monitoring and debugging\n- Securely host and manage agents through Azure AI Foundry integration\n\n![]()\n\n## Hybrid Approach and decision framework\n\nI’ve always been a fan of both worlds, the flexibility of pro-code and the simplicity of workflow drag-and-drop style IDEs and GUIs. A hybrid approach is not about picking one over the other; it’s about balancing them. In practice, this to me means combining the speed and governance of workflow-first platforms with the extensibility and control of pro-code frameworks.\n\nHybrid design shines when you need agility without sacrificing depth. For example, I can start with **Copilot Studio** to build a conversational agent using its visual designer. But if the scenario demands advanced logic or integration, I can call an **Azure Function** for custom processing, trigger a **Logic Apps** workflow for complex orchestration, or even invoke the **Microsoft Agent Framework** for multi-agent coordination. This flexibility delivers the best of both worlds, low-code for rapid development (remember RAD?) and pro-code for enterprise-grade customization with complex logic or integrations.\n\n**Why go Hybrid**\n\nØ Balance speed and control: Rapid prototyping with workflow-first tools, deep customization with code.\n\nØ Extend functionality: Call APIs, Azure Functions, or SDK-based frameworks from visual workflows.\n\nØ Optimize for non-functional requirements: Address maintainability, monitoring, and scalability without compromising ease of development.\n\nØ Enable interoperability: Combine connectors, plugins, and open standards for diverse ecosystems.\n\nØ Support multi-agent orchestration: Integrate workflow-driven agents with pro-code agents for complex scenarios.\n\nThe hybrid approach for building AI Agents is not just a technical choice but a design philosophy.\n\n![]()\n\nWhen I need rapid prototyping or business automation, workflow-first is my choice. For multi-agent orchestration and deep customization, I go with code-first. Hybrid makes sense for regulated industries and large-scale deployments where flexibility and compliance are critical.\n\n![]()\n\nThe choice isn’t binary, it’s strategic. I’ve worked with both workflow-first tools like **Copilot Studio**, **Power Automate**, and **Logic Apps**, and pro-code frameworks such as **LangChain**, **Semantic Kernel**, and the **Microsoft Agent Framework**. Each approach has its strengths, and the decision often comes down to what matters most for your scenario.\n\nIf rapid prototyping and business automation are priorities, workflow-first platforms make sense. When multi-agent orchestration, deep customization, and integration with diverse ecosystems are critical, pro-code frameworks give you the flexibility and control you need. Hybrid approaches bring both worlds together for regulated industries and large-scale deployments where governance, observability, and interoperability cannot be compromised.\n\nUnderstanding these trade-offs will help you create AI Agents that work so well, you’ll wonder if they’re secretly applying for your job!\n\n## About the author\n\nPradyumna (Prad) Harish is a Technology leader in the WW GSI Partner Organization at Microsoft. He has 26 years of experience in Product Engineering, Partner Development, Presales, and Delivery. Responsible for revenue growth through Cloud, AI, Cognitive Services, ML, Data & Analytics, Integration, DevOps, Open-Source Software, Enterprise Architecture, IoT, Digital strategies and other innovative areas for business generation and transformation; achieving revenue targets via extensive experience in managing global functions, global accounts, products, and solution architects across over 26 countries.",
  "EnhancedContent": "## Exploring Visual Designers, Developer Frameworks, and Hybrid Orchestration Approaches\n\nAI Agents are no longer just a developer’s playground. They’re becoming essential for enterprise automation, decision-making, and customer engagement. But how do you build them? Do you go **workflow-first** with drag-and-drop designers, **code-first** with SDKs, or adopt a **hybrid approach** that blends both worlds? In this article, I’ll walk you through the landscape of AI Agent design. We’ll look at **workflow-first** approaches with drag-and-drop designers, **code-first** approaches using SDKs, and **hybrid models** that combine both. The goal is to help you understand the options and choose the right path for your organization.\n\n# Why AI Agents Need Orchestration\n\nBefore diving into tools and approaches, let’s talk about why orchestration matters. AI Agents are not just single-purpose bots anymore. They often need to perform **multi-step reasoning**, interact with multiple systems, and adapt to dynamic workflows. Without orchestration, these agents can become siloed and fail to deliver real business value.\n\nHere’s what I’ve observed as the key drivers for orchestration:\n\n- **Complexity of Enterprise Workflows**\nModern business processes involve multiple applications, data sources, and decision points. AI Agents need a way to coordinate these steps seamlessly.\n- **Governance and Compliance**\nEnterprises require control over how AI interacts with sensitive data and systems. Orchestration frameworks provide guardrails for security and compliance.\n- **Scalability and Maintainability**\nA single agent might work fine for a proof of concept, but scaling to hundreds of workflows requires structured orchestration to avoid chaos.\n- **Integration with Existing Systems**\nAI Agents rarely operate in isolation. They need to plug into ERP systems, CRMs, and custom apps. Orchestration ensures these integrations are reliable and repeatable.\n\nIn short, orchestration is the backbone that turns AI Agents from clever prototypes into enterprise-ready solutions.\n\n# *Behind the Scenes*\n\n*I’ve always been a pro-code guy. I started my career on open-source coding in Unix and hardly touched the mouse. Then I discovered Visual Studio, and it completely changed my perspective. It showed me the power of a hybrid approach, the best of both worlds. That said, I won’t let my experience bias your ideas of what you’d like to build. This blog is about giving you the full picture so you can make the choice that works best for you.*\n\n# Workflow-First Approach\n\nWorkflow-first platforms are more than visual designers and not just about drag-and-drop simplicity. They represent a design paradigm where orchestration logic is abstracted into declarative models rather than imperative code. These tools allow you to define agent behaviors, event triggers, and integration points visually, while the underlying engine handles state management, retries, and scaling. For architects, this means faster prototyping and governance baked into the platform. For developers, it offers extensibility through connectors and custom actions without sacrificing enterprise-grade reliability.\n\n## Copilot Studio\n\nBuilding conversational agents becomes intuitive with a visual designer that maps prompts, actions, and connectors into structured flows. Copilot Studio makes this possible by integrating enterprise data and enabling agents to automate tasks and respond intelligently without deep coding.\n\n**Building AI Agents using Copilot Studio**\n\n- Design conversation flows with adaptive prompts\n- Integrate Microsoft Graph for contextual responses\n- Add AI-driven actions using Copilot extensions\n- Support multi-turn reasoning for complex queries\n- Enable secure access to enterprise data sources\n- Extend functionality through custom connectors\n\n## Logic Apps\n\nAdaptive workflows and complex integrations are handled through a robust orchestration engine. Logic Apps introduces **Agent Loop**, allowing agents to reason iteratively, adapt workflows, and interact with multiple systems in real time.\n\n**Building AI Agents using Logic Apps**\n\n- Implement Agent Loop for iterative reasoning\n- Integrate Azure OpenAI for goal-driven decisions\n- Access 1,400+ connectors for enterprise actions\n- Support human-in-the-loop for critical approvals\n- Enable multi-agent orchestration for complex tasks\n- Provide observability and security for agent workflows\n\n## Power Automate\n\nMulti-step workflows can be orchestrated across business applications using AI Builder models or external AI APIs. Power Automate enables agents to make decisions, process data, and trigger actions dynamically, all within a low-code environment.\n\n**Building AI Agents using Power Automate**\n\n- Automate repetitive tasks with minimal effort\n- Apply AI Builder for predictions and classification\n- Call Azure OpenAI for natural language processing\n- Integrate with hundreds of enterprise connectors\n- Trigger workflows based on real-time events\n- Combine flows with human approvals for compliance\n\n## Azure AI Foundry\n\nVisual orchestration meets pro-code flexibility through **Prompt Flow** and **Connected Agents**, enabling multi-step reasoning flows while allowing developers to extend capabilities through SDKs. Azure AI Foundry is ideal for scenarios requiring both agility and deep customization.\n\n**Building AI Agents using Azure AI Foundry**\n\n- Design reasoning flows visually with Prompt Flow\n- Orchestrate multi-agent systems using Connected Agents\n- Integrate with VS Code for advanced development\n- Apply governance and deployment pipelines for production\n- Use Azure OpenAI models for adaptive decision-making\n- Monitor workflows with built-in observability tools\n\n## Microsoft Agent Framework (Preview)\n\nI’ve been exploring Microsoft Agent Framework (MAF), an open-source foundation for building AI agents that can run anywhere. It integrates with Azure AI Foundry and Azure services, enabling multi-agent workflows, advanced memory services, and visual orchestration. With public preview live and GA coming soon, MAF is shaping how we deliver scalable, flexible agentic solutions.\n\nEnterprise-scale orchestration is achieved through graph-based workflows, human-in-the-loop approvals, and observability features. The Microsoft Agent Framework lays the foundation for multi-agent systems that are durable and compliant.\n\n**Building AI Agents using Microsoft Agent Framework**\n\n- Coordinate multiple specialized agents in a graph\n- Implement durable workflows with pause and resume\n- Support human-in-the-loop for controlled autonomy\n- Integrate with Azure AI Foundry for hosting and governance\n- Enable observability through OpenTelemetry integration\n- Provide SDK flexibility for custom orchestration patterns\n\n****\n\nVisual-first platforms make building AI Agents feel less like coding marathons and more like creative design sessions. They’re perfect for those scenarios when you’d rather design than debug and still want the option to dive deeper when complexity calls.\n\n# Pro-Code Approach\n\nRemember I told you how I started as a pro-code developer early in my career and later embraced a hybrid approach? I’ll try to stay neutral here as we explore the pro-code world. Pro-code frameworks offer integration with diverse ecosystems, multi-agent coordination, and fine-grained control over logic. While workflow-first and pro-code approaches both provide these capabilities, the difference lies in how they balance factors such as ease of development, ease of maintenance, time to deliver, monitoring capabilities, and other non-functional requirements. Choosing the right path often depends on which of these trade-offs matter most for your scenario.\n\n## LangChain\n\nWhen I first explored LangChain, it felt like stepping into a developer’s playground for AI orchestration. I could stitch together prompts, tools, and APIs like building blocks, and I enjoyed the flexibility. It reminded me why pro-code approaches appeal to those who want full control over logic and integration with diverse ecosystems.\n\n**Building AI Agents using LangChain**\n\n- Define custom chains for multi-step reasoning [it *is* called Lang“Chain”]\n- Integrate external APIs and tools for dynamic actions\n- Implement memory for context-aware conversations\n- Support multi-agent collaboration through orchestration patterns\n- Extend functionality with custom Python modules\n- Deploy agents across cloud environments for scalability\n\n****\n\n## Semantic Kernel\n\nI’ve worked with Semantic Kernel when I needed more control over orchestration logic, and what stood out was its flexibility. It provides both .NET and Python SDKs, which makes it easy to combine natural language prompts with traditional programming logic. I found the planners and skills especially useful for breaking down goals into smaller steps, and connectors helped integrate external systems without reinventing the wheel.\n\n**Building AI Agents using Semantic Kernel**\n\n- Create semantic functions for prompt-driven tasks\n- Use planners for dynamic goal decomposition\n- Integrate plugins for external system access\n- Implement memory for persistent context across sessions\n- Combine AI reasoning with deterministic code logic\n- Enable observability and telemetry for enterprise monitoring\n\n****\n\n## Microsoft Agent Framework (Preview)\n\nAlthough I introduced MAF in the earlier section, its SDK-first design makes it relevant here as well for advanced orchestration and the pro-code nature… and so I’ll probably write this again in the Hybrid section. The Agent Framework is designed for developers who need full control over multi-agent orchestration. It provides a pro-code approach for defining agent behaviors, implementing advanced coordination patterns, and integrating enterprise-grade observability.\n\n**Building AI Agents using Microsoft Agent Framework**\n\n- Define custom orchestration logic using SDK APIs\n- Implement graph-based workflows for multi-agent coordination\n- Extend agent capabilities with custom code modules\n- Apply durable execution patterns with pause and resume\n- Integrate OpenTelemetry for detailed monitoring and debugging\n- Securely host and manage agents through Azure AI Foundry integration\n\n## Hybrid Approach and decision framework\n\nI’ve always been a fan of both worlds, the flexibility of pro-code and the simplicity of workflow drag-and-drop style IDEs and GUIs. A hybrid approach is not about picking one over the other; it’s about balancing them. In practice, this to me means combining the speed and governance of workflow-first platforms with the extensibility and control of pro-code frameworks.\n\nHybrid design shines when you need agility without sacrificing depth. For example, I can start with **Copilot Studio** to build a conversational agent using its visual designer. But if the scenario demands advanced logic or integration, I can call an **Azure Function** for custom processing, trigger a **Logic Apps** workflow for complex orchestration, or even invoke the **Microsoft Agent Framework** for multi-agent coordination. This flexibility delivers the best of both worlds, low-code for rapid development (remember RAD?) and pro-code for enterprise-grade customization with complex logic or integrations.\n\n**Why go Hybrid**\n\nØ  Balance speed and control: Rapid prototyping with workflow-first tools, deep customization with code.\n\nØ  Extend functionality: Call APIs, Azure Functions, or SDK-based frameworks from visual workflows.\n\nØ  Optimize for non-functional requirements: Address maintainability, monitoring, and scalability without compromising ease of development.\n\nØ  Enable interoperability: Combine connectors, plugins, and open standards for diverse ecosystems.\n\nØ  Support multi-agent orchestration: Integrate workflow-driven agents with pro-code agents for complex scenarios.\n\nThe hybrid approach for building AI Agents is not just a technical choice but a design philosophy.\n\nWhen I need rapid prototyping or business automation, workflow-first is my choice. For multi-agent orchestration and deep customization, I go with code-first. Hybrid makes sense for regulated industries and large-scale deployments where flexibility and compliance are critical.\n\nThe choice isn’t binary, it’s strategic. I’ve worked with both workflow-first tools like **Copilot Studio**, **Power Automate**, and **Logic Apps**, and pro-code frameworks such as **LangChain**, **Semantic Kernel**, and the **Microsoft Agent Framework**. Each approach has its strengths, and the decision often comes down to what matters most for your scenario.\n\nIf rapid prototyping and business automation are priorities, workflow-first platforms make sense. When multi-agent orchestration, deep customization, and integration with diverse ecosystems are critical, pro-code frameworks give you the flexibility and control you need. Hybrid approaches bring both worlds together for regulated industries and large-scale deployments where governance, observability, and interoperability cannot be compromised.\n\nUnderstanding these trade-offs will help you create AI Agents that work so well, you’ll wonder if they’re secretly applying for your job!\n\n## About the author\n\nPradyumna (Prad) Harish is a Technology leader in the WW GSI Partner Organization at Microsoft. He has 26 years of experience in Product Engineering, Partner Development, Presales, and Delivery. Responsible for revenue growth through Cloud, AI, Cognitive Services, ML, Data & Analytics, Integration, DevOps, Open-Source Software, Enterprise Architecture, IoT, Digital strategies and other innovative areas for business generation and transformation; achieving revenue targets via extensive experience in managing global functions, global accounts, products, and solution architects across over 26 countries.\n\nPublished Nov 11, 2025\n\nVersion 1.0\n\n[advance analytics](/tag/advance%20analytics?nodeId=board%3AAzureArchitectureBlog)\n\n[application](/tag/application?nodeId=board%3AAzureArchitectureBlog)\n\n[apps & devops](/tag/apps%20%26%20devops?nodeId=board%3AAzureArchitectureBlog)\n\n[artificial intelligence](/tag/artificial%20intelligence?nodeId=board%3AAzureArchitectureBlog)\n\n[data platform](/tag/data%20platform?nodeId=board%3AAzureArchitectureBlog)\n\n[integration](/tag/integration?nodeId=board%3AAzureArchitectureBlog)\n\n[msignite](/tag/msignite?nodeId=board%3AAzureArchitectureBlog)\n\n[well architected](/tag/well%20architected?nodeId=board%3AAzureArchitectureBlog)\n\n[!\\[PradyH&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS02ODM3NTktNTY3NzIxaTkzNzIxQkVDQkM4MEI5QzU?image-dimensions=50x50)](/users/pradyh/683759) [PradyH](/users/pradyh/683759) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined May 29, 2020\n\n[View Profile](/users/pradyh/683759)\n\n/category/azure/blog/azurearchitectureblog [Azure Architecture Blog](/category/azure/blog/azurearchitectureblog) Follow this blog board to get notified when there's new activity",
  "Title": "Building AI Agents: Workflow-First vs. Code-First vs. Hybrid",
  "Tags": []
}
