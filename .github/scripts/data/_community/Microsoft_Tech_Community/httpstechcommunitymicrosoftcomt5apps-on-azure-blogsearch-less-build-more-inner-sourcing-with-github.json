{
  "Title": "Search Less, Build More: Inner Sourcing with GitHub CoPilot and ADO MCP Server",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "OutputDir": "_community",
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/search-less-build-more-inner-sourcing-with-github-copilot-and/ba-p/4454560",
  "Tags": [],
  "ProcessedDate": "2025-09-16 17:11:38",
  "PubDate": "2025-09-16T16:39:16+00:00",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Author": "owaino",
  "Description": "Developers burn cycles context‑switching: opening five repos to find a logging example, searching a wiki for a data masking rule, scrolling chat history for the latest pipeline pattern. Organisations that I speak to are often on the path of transformational platform engineering projects but always have the fear or doubt of \"what if my engineers don't use these resources\". While projects like Backstage still play a pivotal role in inner sourcing and discoverability I also empathise with developers who would argue \"How would I even know in the first place, which modules have or haven't been created for reuse\". In this blog we explore how we can ensure organisational standards and developer satisfaction without any heavy lifting on either side, no custom model training, no rewriting or relocating of repositories and no stagnant local data.\n\nUsing **GitHub CoPilot + Azure DevOps MCP server (with the free `code_search` extension)** we turn the IDE into an **organizational knowledge interface**. Instead of guessing or re‑implementing, engineers can start scaffolding projects or solving issues as they would normally (hopefully using CoPilot) and without extra prompting. GitHub CoPilot can lean into organisational standards and ensure recommendations are made with code snippets directly generated from existing examples.\n\n- Naturally, as with all AI RAG style solutions the success of this approach hinges on the data available to the LLM/Agent. If your repo's do not have ReadME's, Wiki's and/or well commented code then this exercise may be one step ahead of your current agentic development maturity. Fortunately there are plenty of articles online already discussing how LLM's can be leveraged to help improve your code quality and documentation!\n\n## What Is the Azure DevOps MCP Server + code\\_search Extension?\n\n**MCP (Model Context Protocol)** is an open standard that lets agents (like GitHub Copilot) pull in structured, *on-demand* context from external systems. MCP servers contain natural language explanations of the tools that the agent can utilise allowing dynamic decision making of when to implement certain toolsets over others.\n\nThe **Azure DevOps MCP Server** is the ADO Product Team's implementation of that standard. It exposes your ADO environment in a way CoPilot can consume. Out of the box it gives you access to:\n\n- **Projects** – list and navigate across projects in your organization.\n- **Repositories** – browse repos, branches, and files.\n- **Work items** – surface user stories, bugs, or acceptance criteria.\n- **Wiki's** – pull policies, standards, and documentation.\n\nThis means CoPilot can ground its answers in *live* ADO content, instead of hallucinating or relying only on what’s in the current editor window. The ADO server runs locally from your own machine to ensure that all sensitive project information remains within your secure network boundary. This also means that existing permissions on ADO objects such as Projects or Repositories are respected.\n\nWiki search tooling available out of the box with ADO MCP server is very useful however if I am honest I have seen these wiki's go unused with documentation being stored elsewhere either inside the repository or in a project management tool. This means any tool that needs to implement code requires the ability to accurately search the code stored in the repositories themself. That is where the code\\_search extension enablement in ADO is so important. Most organisations have this enabled already however it is worth noting that this pre-requisite is the real unlock of cross-repo search. This allows for CoPilot to:\n\n- Query for symbols, snippets, or keywords across all repos.\n- Retrieve usage examples from code, not just docs.\n- Locate standards (like logging wrappers or retry policies) wherever they live.\n- Back every recommendation with *specific source lines*.\n\nIn short: MCP connects CoPilot to Azure DevOps. code\\_search makes that connection powerful by turning it into a discovery engine.\n\n## What is the relevance of CoPilot Instructions?\n\nOne of the less obvious but most powerful features of GitHub CoPilot is its ability to follow **instructions files**. CoPilot automatically looks for these files and uses them as a “playbook” for how it should behave.\n\nThere are different types of instructions you can provide:\n\n- **Organisational instructions** – apply across your entire workspace, regardless of which repo you’re in.\n- **Repo-specific instructions** – scoped to a particular repository, useful when one project has unique standards or patterns.\n- **Personal instructions** – smaller overrides layered on top of global rules when a local exception applies. (Stored in .github/copilot-instructions.md)\n\nIn this solution, I’m using a single **personal instructions file**. It tells CoPilot:\n\n- **When to search** (e.g., always query repos and wikis before answering a standards question).\n- **Where to look** (Azure DevOps repos, wikis, and with code\\_search, the code itself).\n- **How to answer** (responses must cite the repo/file/line or wiki page; if no source is found, say so).\n- **How to resolve conflicts** (prefer dated wiki entries over older README fragments).\n\nAs a small example, a section of a CoPilot instruction file could look like this:\n- # GitHub Copilot Instructions for Azure DevOps MCP Integration This project uses Azure DevOps with MCP server integration to provide organizational context awareness. Always check to see if the Azure DevOps MCP server has a tool relevant to the user's request. ## Core Principles ### 1. Azure DevOps Integration - \\*\\*Always prioritize Azure DevOps MCP tools\\*\\* when users ask about: - Work items, stories, bugs, tasks - Pull requests and code reviews - Build pipelines and deployments - Repository operations and branch management - Wiki pages and documentation - Test plans and test cases - Project and team information ### 2. Organizational Context Awareness - Before suggesting solutions, \\*\\*check existing organizational patterns\\*\\* by: - Searching code across repositories for similar implementations - Referencing established coding standards and frameworks - Looking for existing shared libraries and utilities - Checking architectural decision records (ADRs) in wikis ### 3. Cross-Repository Intelligence - When providing code suggestions: - \\*\\*Search for existing patterns\\*\\* in other repositories first - \\*\\*Reference shared libraries\\*\\* and common utilities - \\*\\*Maintain consistency\\*\\* with organizational standards - \\*\\*Suggest reusable components\\*\\* when appropriate ## Tool Usage Guidelines ### Work Items and Project Management When users mention bugs, features, tasks, or project planning: ``` ✅ Use: wit\\_my\\_work\\_items, wit\\_create\\_work\\_item, wit\\_update\\_work\\_item ✅ Use: wit\\_list\\_backlogs, wit\\_get\\_work\\_items\\_for\\_iteration ✅ Use: work\\_list\\_team\\_iterations, core\\_list\\_projects\n\n## The result...\n\nTo test this I created 3 ADO Projects each with between 1-2 repositories. The repositories were light with only ReadMe's inside containing descriptions of the \"repo\" and some code snippets examples for usage.\n\nI have then created a brand-new workspace with no context apart from a CoPilot instructions document (which could be part of a repo scaffold or organisation wide) which tells CoPilot to search code and the wikis across all ADO projects in my demo environment. It returns guidance and standards from all available repo's and starts to use it to formulate its response.\n\n![]()\n\nIn the screenshot I have highlighted some key parts with red boxes. The first being a section of the readme that CoPilot has identified in its response, that part also highlighted within CoPilot chat response. I have highlighted the rather generic prompt I used to get this response at the bottom of that window too. Above I have highlighted CoPilot using the MCP server tooling searching through projects, repo's and code. Finally the largest box highlights the instructions given to CoPilot on how to search and how easily these could be optimised or changed depending on the requirements and organisational coding standards.\n\n## How did I implement this?\n\nImplementation is actually incredibly simple. As mentioned I created multiple projects and repositories within my ADO Organisation in order to test cross-project & cross-repo discovery. I then did the following:\n\n1. **Enable code\\_search -** in your Azure DevOps organization (Marketplace → install extension).\n2. **Login to Azure -** Use the AZ CLI to authenticate to Azure with \"az login\".\n3. **Create vscode/mcp.json file -** Snippet is provided below, the organisation name should be changed to your organisations name.\n4. **Start and enable your MCP server -** In the mcp.json file you should see a \"Start\" button. Using the snippet below you will be prompted to add your organisation name. Ensure your CoPilot agent has access to the server under \"tools\" too. View this setup guide for full setup instructions ([azure-devops-mcp/docs/GETTINGSTARTED.md at main · microsoft/azure-devops-mcp](https://github.com/microsoft/azure-devops-mcp/blob/main/docs/GETTINGSTARTED.md))\n5. **Create a CoPilot Instructions file -** with a search-first directive. I have inserted the full version used in this demo at the bottom of the article.\n6. **Experiment with Prompts –** Start generic (“How do we secure APIs?”). Review the output and tools used and then tailor your instructions.\n\n## Considerations\n\nWhile this is a great approach I do still have some considerations when going to production.\n\n1. **Latency -** Using MCP tooling on every request will add some latency to developer requests. We can look at optimizing usage through copilot instructions to better identify when CoPilot should or shouldn't use the ADO MCP server.\n2. **Complex Projects and Repositories -** While I have demonstrated cross project and cross repository retrieval my demo environment does not truly simulate an enterprise ADO environment. Performance should be tested and closely monitored as organisational complexity increases.\n3. **Public Preview -** The ADO MCP server is moving quickly but is currently still public preview.\n\n### We have demonstrated in this article how quickly we can make our Azure DevOps content discoverable. While their are considerations moving forward this showcases a direction towards agentic inner sourcing. Feel free to comment below how you think this approach could be extended or augmented for other use cases!\n\n## Resources\n\n#### MCP Server Config (/.vscode/mcp.json)\n- { \"inputs\": [ { \"id\": \"ado\\_org\", \"type\": \"promptString\", \"description\": \"Azure DevOps organization name (e.g. 'contoso')\" } ], \"servers\": { \"ado\": { \"type\": \"stdio\", \"command\": \"npx\", \"args\": [\"-y\", \"@azure-devops/mcp\", \"${input:ado\\_org}\"] } } }\n\n#### CoPilot Instructions (/.github/copilot-instructions.md)\n- # GitHub Copilot Instructions for Azure DevOps MCP Integration This project uses Azure DevOps with MCP server integration to provide organizational context awareness. Always check to see if the Azure DevOps MCP server has a tool relevant to the user's request. ## Core Principles ### 1. Azure DevOps Integration - \\*\\*Always prioritize Azure DevOps MCP tools\\*\\* when users ask about: - Work items, stories, bugs, tasks - Pull requests and code reviews - Build pipelines and deployments - Repository operations and branch management - Wiki pages and documentation - Test plans and test cases - Project and team information ### 2. Organizational Context Awareness - Before suggesting solutions, \\*\\*check existing organizational patterns\\*\\* by: - Searching code across repositories for similar implementations - Referencing established coding standards and frameworks - Looking for existing shared libraries and utilities - Checking architectural decision records (ADRs) in wikis ### 3. Cross-Repository Intelligence - When providing code suggestions: - \\*\\*Search for existing patterns\\*\\* in other repositories first - \\*\\*Reference shared libraries\\*\\* and common utilities - \\*\\*Maintain consistency\\*\\* with organizational standards - \\*\\*Suggest reusable components\\*\\* when appropriate ## Tool Usage Guidelines ### Work Items and Project Management When users mention bugs, features, tasks, or project planning: ``` ✅ Use: wit_my_work_items, wit_create_work_item, wit_update_work_item ✅ Use: wit_list_backlogs, wit_get_work_items_for_iteration ✅ Use: work_list_team_iterations, core_list_projects ``` ### Code and Repository Operations When users ask about code, branches, or pull requests: ``` ✅ Use: repo_list_repos_by_project, repo_list_pull_requests_by_repo ✅ Use: repo_list_branches_by_repo, repo_search_commits ✅ Use: search_code for finding patterns across repositories ``` ### Documentation and Knowledge Sharing When users need documentation or want to create/update docs: ``` ✅ Use: wiki_list_wikis, wiki_get_page_content, wiki_create_or_update_page ✅ Use: search_wiki for finding existing documentation ``` ### Build and Deployment When users ask about builds, deployments, or CI/CD: ``` ✅ Use: pipelines_get_builds, pipelines_get_build_definitions ✅ Use: pipelines_run_pipeline, pipelines_get_build_status ``` ## Response Patterns ### 1. Discovery First Before providing solutions, always discover organizational context: ``` \"Let me first check what patterns exist in your organization...\" → Search code, check repositories, review existing work items ``` ### 2. Reference Organizational Standards When suggesting code or approaches: ``` \"Based on patterns I found in your [RepositoryName] repository...\" \"Following your organization's standard approach seen in...\" \"This aligns with the pattern established in [TeamName]'s implementation...\" ``` ### 3. Actionable Integration Always offer to create or update Azure DevOps artifacts: ``` \"I can create a work item for this enhancement...\" \"Should I update the wiki page with this new pattern?\" \"Let me link this to the current iteration...\" ``` ## Specific Scenarios ### New Feature Development 1. \\*\\*Search existing repositories\\*\\* for similar features 2. \\*\\*Check architectural patterns\\*\\* and shared libraries 3. \\*\\*Review related work items\\*\\* and planning documents 4. \\*\\*Suggest implementation\\*\\* based on organizational standards 5. \\*\\*Offer to create work items\\*\\* and documentation ### Bug Investigation 1. \\*\\*Search for similar issues\\*\\* across repositories and work items 2. \\*\\*Check related builds\\*\\* and recent changes 3. \\*\\*Review test results\\*\\* and failure patterns 4. \\*\\*Provide solution\\*\\* based on organizational practices 5. \\*\\*Offer to create/update\\*\\* bug work items and documentation ### Code Review and Standards 1. \\*\\*Compare against organizational patterns\\*\\* found in other repositories 2. \\*\\*Reference coding standards\\*\\* from wiki documentation 3. \\*\\*Suggest improvements\\*\\* based on established practices 4. \\*\\*Check for reusable components\\*\\* that could be leveraged ### Documentation Requests 1. \\*\\*Search existing wikis\\*\\* for related content 2. \\*\\*Check for ADRs\\*\\* and technical documentation 3. \\*\\*Reference patterns\\*\\* from similar projects 4. \\*\\*Offer to create/update\\*\\* wiki pages with findings ## Error Handling If Azure DevOps MCP tools are not available or fail: 1. \\*\\*Inform the user\\*\\* about the limitation 2. \\*\\*Provide alternative approaches\\*\\* using available information 3. \\*\\*Suggest manual steps\\*\\* for Azure DevOps integration 4. \\*\\*Offer to help\\*\\* with configuration if needed ## Best Practices ### Always Do: - ✅ Search organizational context before suggesting solutions - ✅ Reference existing patterns and standards - ✅ Offer to create/update Azure DevOps artifacts - ✅ Maintain consistency with organizational practices - ✅ Provide actionable next steps ### Never Do: - ❌ Suggest solutions without checking organizational context - ❌ Ignore existing patterns and implementations - ❌ Provide generic advice when specific organizational context is available - ❌ Forget to offer Azure DevOps integration opportunities --- \\*\\*Remember: The goal is to provide intelligent, context-aware assistance that leverages the full organizational knowledge base available through Azure DevOps while maintaining development efficiency and consistency.\\*\\*",
  "EnhancedContent": "## Developers spend far too much time hunting through repositories, wikis, and scattered documentation to find the right standards, frameworks, or examples they need. It becomes so labour intensive that any productivity gains are lost. Similarly organisations need to be able to enforce certain standards and encourage utilisation of reusable modules. What if your IDE could do that heavy lifting for you? By combining GitHub CoPilot with the Azure MCP server (and its powerful code\\_search extension), you can transform CoPilot into more than just a coding assistant—it becomes a discovery engine for your organizational knowledge.\n\nDevelopers burn cycles context‑switching: opening five repos to find a logging example, searching a wiki for a data masking rule, scrolling chat history for the latest pipeline pattern. Organisations that I speak to are often on the path of transformational platform engineering projects but always have the fear or doubt of \"what if my engineers don't use these resources\". While projects like Backstage still play a pivotal role in inner sourcing and discoverability I also empathise with developers who would argue \"How would I even know in the first place, which modules have or haven't been created for reuse\". In this blog we explore how we can ensure organisational standards and developer satisfaction without any heavy lifting on either side, no custom model training, no rewriting or relocating of repositories and no stagnant local data.\n\nUsing **GitHub CoPilot + Azure DevOps MCP server (with the free `code_search` extension)** we turn the IDE into an **organizational knowledge interface**. Instead of guessing or re‑implementing, engineers can start scaffolding projects or solving issues as they would normally (hopefully using CoPilot) and without extra prompting. GitHub CoPilot can lean into organisational standards and ensure recommendations are made with code snippets directly generated from existing examples.\n\nData related caveat Naturally, as with all AI RAG style solutions the success of this approach hinges on the data available to the LLM/Agent. If your repo's do not have ReadME's, Wiki's and/or well commented code then this exercise may be one step ahead of your current agentic development maturity. Fortunately there are plenty of articles online already discussing how LLM's can be leveraged to help improve your code quality and documentation!\n\n## What Is the Azure DevOps MCP Server + code\\_search Extension?\n\n**MCP (Model Context Protocol)** is an open standard that lets agents (like GitHub Copilot) pull in structured, *on-demand* context from external systems. MCP servers contain natural language explanations of the tools that the agent can utilise allowing dynamic decision making of when to implement certain toolsets over others.\n\nThe **Azure DevOps MCP Server** is the ADO Product Team's implementation of that standard. It exposes your ADO environment in a way CoPilot can consume. Out of the box it gives you access to:\n\n- **Projects** – list and navigate across projects in your organization.\n- **Repositories** – browse repos, branches, and files.\n- **Work items** – surface user stories, bugs, or acceptance criteria.\n- **Wiki's** – pull policies, standards, and documentation.\n\nThis means CoPilot can ground its answers in *live* ADO content, instead of hallucinating or relying only on what’s in the current editor window. The ADO server runs locally from your own machine to ensure that all sensitive project information remains within your secure network boundary. This also means that existing permissions on ADO objects such as Projects or Repositories are respected.\n\nWiki search tooling available out of the box with ADO MCP server is very useful however if I am honest I have seen these wiki's go unused with documentation being stored elsewhere either inside the repository or in a project management tool. This means any tool that needs to implement code requires the ability to accurately search the code stored in the repositories themself. That is where the code\\_search extension enablement in ADO is so important. Most organisations have this enabled already however it is worth noting that this pre-requisite is the real unlock of cross-repo search. This allows for CoPilot to:\n\n- Query for symbols, snippets, or keywords across all repos.\n- Retrieve usage examples from code, not just docs.\n- Locate standards (like logging wrappers or retry policies) wherever they live.\n- Back every recommendation with *specific source lines*.\n\nIn short: MCP connects CoPilot to Azure DevOps. code\\_search makes that connection powerful by turning it into a discovery engine.\n\n## What is the relevance of CoPilot Instructions?\n\nOne of the less obvious but most powerful features of GitHub CoPilot is its ability to follow **instructions files**. CoPilot automatically looks for these files and uses them as a “playbook” for how it should behave.\n\nThere are different types of instructions you can provide:\n\n- **Organisational instructions** – apply across your entire workspace, regardless of which repo you’re in.\n- **Repo-specific instructions** – scoped to a particular repository, useful when one project has unique standards or patterns.\n- **Personal instructions** – smaller overrides layered on top of global rules when a local exception applies. (Stored in .github/copilot-instructions.md)\n\nIn this solution, I’m using a single **personal instructions file**. It tells CoPilot:\n\n- **When to search** (e.g., always query repos and wikis before answering a standards question).\n- **Where to look** (Azure DevOps repos, wikis, and with code\\_search, the code itself).\n- **How to answer** (responses must cite the repo/file/line or wiki page; if no source is found, say so).\n- **How to resolve conflicts** (prefer dated wiki entries over older README fragments).\n\nAs a small example, a section of a CoPilot instruction file could look like this:\n\n```\n# GitHub Copilot Instructions for Azure DevOps MCP Integration This project uses Azure DevOps with MCP server integration to provide organizational context awareness. Always check to see if the Azure DevOps MCP server has a tool relevant to the user's request. ## Core Principles ### 1. Azure DevOps Integration - **Always prioritize Azure DevOps MCP tools** when users ask about: - Work items, stories, bugs, tasks - Pull requests and code reviews - Build pipelines and deployments - Repository operations and branch management - Wiki pages and documentation - Test plans and test cases - Project and team information ### 2. Organizational Context Awareness - Before suggesting solutions, **check existing organizational patterns** by: - Searching code across repositories for similar implementations - Referencing established coding standards and frameworks - Looking for existing shared libraries and utilities - Checking architectural decision records (ADRs) in wikis ### 3. Cross-Repository Intelligence - When providing code suggestions: - **Search for existing patterns** in other repositories first - **Reference shared libraries** and common utilities - **Maintain consistency** with organizational standards - **Suggest reusable components** when appropriate ## Tool Usage Guidelines ### Work Items and Project Management When users mention bugs, features, tasks, or project planning: ``` ✅ Use: wit_my_work_items, wit_create_work_item, wit_update_work_item ✅ Use: wit_list_backlogs, wit_get_work_items_for_iteration ✅ Use: work_list_team_iterations, core_list_projects\n```\n\n## The result...\n\nTo test this I created 3 ADO Projects each with between 1-2 repositories. The repositories were light with only ReadMe's inside containing descriptions of the \"repo\" and some code snippets examples for usage.\n\nI have then created a brand-new workspace with no context apart from a CoPilot instructions document (which could be part of a repo scaffold or organisation wide) which tells CoPilot to search code and the wikis across all ADO projects in my demo environment. It returns guidance and standards from all available repo's and starts to use it to formulate its response.\n\nIn the screenshot I have highlighted some key parts with red boxes. The first being a section of the readme that CoPilot has identified in its response, that part also highlighted within CoPilot chat response. I have highlighted the rather generic prompt I used to get this response at the bottom of that window too. Above I have highlighted CoPilot using the MCP server tooling searching through projects, repo's and code. Finally the largest box highlights the instructions given to CoPilot on how to search and how easily these could be optimised or changed depending on the requirements and organisational coding standards.\n\n## How did I implement this?\n\nImplementation is actually incredibly simple. As mentioned I created multiple projects and repositories within my ADO Organisation in order to test cross-project & cross-repo discovery. I then did the following:\n\n1. **Enable code\\_search -** in your Azure DevOps organization (Marketplace → install extension).\n2. **Login to Azure -**Use the AZ CLI to authenticate to Azure with \"az login\".\n3. **Create vscode/mcp.json file -** Snippet is provided below, the organisation name should be changed to your organisations name.\n4. **Start and enable your MCP server -**In the mcp.json file you should see a \"Start\" button. Using the snippet below you will be prompted to add your organisation name. Ensure your CoPilot agent has access to the server under \"tools\" too. View this setup guide for full setup instructions ([azure-devops-mcp/docs/GETTINGSTARTED.md at main · microsoft/azure-devops-mcp](https://github.com/microsoft/azure-devops-mcp/blob/main/docs/GETTINGSTARTED.md))\n5. **Create a CoPilot Instructions file -** with a search-first directive. I have inserted the full version used in this demo at the bottom of the article.\n6. **Experiment with Prompts –** Start generic (“How do we secure APIs?”). Review the output and tools used and then tailor your instructions.\n\n## Considerations\n\nWhile this is a great approach I do still have some considerations when going to production.\n\n1. **Latency -** Using MCP tooling on every request will add some latency to developer requests. We can look at optimizing usage through copilot instructions to better identify when CoPilot should or shouldn't use the ADO MCP server.\n2. **Complex Projects and Repositories -** While I have demonstrated cross project and cross repository retrieval my demo environment does not truly simulate an enterprise ADO environment.  Performance should be tested and closely monitored as organisational complexity increases.\n3. **Public Preview -**The ADO MCP server is moving quickly but is currently still public preview.\n\n### We have demonstrated in this article how quickly we can make our Azure DevOps content discoverable. While their are considerations moving forward this showcases a direction towards agentic inner sourcing. Feel free to comment below how you think this approach could be extended or augmented for other use cases!\n\n## Resources\n\n#### MCP Server Config (/.vscode/mcp.json)\n\n``` { \"inputs\": [ { \"id\": \"ado_org\", \"type\": \"promptString\", \"description\": \"Azure DevOps organization name (e.g. 'contoso')\" } ], \"servers\": { \"ado\": { \"type\": \"stdio\", \"command\": \"npx\", \"args\": [\"-y\", \"@azure-devops/mcp\", \"${input:ado_org}\"] } } } ```\n\n#### CoPilot Instructions (/.github/copilot-instructions.md)\n\n```\n# GitHub Copilot Instructions for Azure DevOps MCP Integration This project uses Azure DevOps with MCP server integration to provide organizational context awareness. Always check to see if the Azure DevOps MCP server has a tool relevant to the user's request. ## Core Principles ### 1. Azure DevOps Integration - **Always prioritize Azure DevOps MCP tools** when users ask about: - Work items, stories, bugs, tasks - Pull requests and code reviews - Build pipelines and deployments - Repository operations and branch management - Wiki pages and documentation - Test plans and test cases - Project and team information ### 2. Organizational Context Awareness - Before suggesting solutions, **check existing organizational patterns** by: - Searching code across repositories for similar implementations - Referencing established coding standards and frameworks - Looking for existing shared libraries and utilities - Checking architectural decision records (ADRs) in wikis ### 3. Cross-Repository Intelligence - When providing code suggestions: - **Search for existing patterns** in other repositories first - **Reference shared libraries** and common utilities - **Maintain consistency** with organizational standards - **Suggest reusable components** when appropriate ## Tool Usage Guidelines ### Work Items and Project Management When users mention bugs, features, tasks, or project planning: ``` ✅ Use: wit_my_work_items, wit_create_work_item, wit_update_work_item ✅ Use: wit_list_backlogs, wit_get_work_items_for_iteration ✅ Use: work_list_team_iterations, core_list_projects ``` ### Code and Repository Operations When users ask about code, branches, or pull requests: ``` ✅ Use: repo_list_repos_by_project, repo_list_pull_requests_by_repo ✅ Use: repo_list_branches_by_repo, repo_search_commits ✅ Use: search_code for finding patterns across repositories ``` ### Documentation and Knowledge Sharing When users need documentation or want to create/update docs: ``` ✅ Use: wiki_list_wikis, wiki_get_page_content, wiki_create_or_update_page ✅ Use: search_wiki for finding existing documentation ``` ### Build and Deployment When users ask about builds, deployments, or CI/CD: ``` ✅ Use: pipelines_get_builds, pipelines_get_build_definitions ✅ Use: pipelines_run_pipeline, pipelines_get_build_status ``` ## Response Patterns ### 1. Discovery First Before providing solutions, always discover organizational context: ``` \"Let me first check what patterns exist in your organization...\" → Search code, check repositories, review existing work items ``` ### 2. Reference Organizational Standards When suggesting code or approaches: ``` \"Based on patterns I found in your [RepositoryName] repository...\" \"Following your organization's standard approach seen in...\" \"This aligns with the pattern established in [TeamName]'s implementation...\" ``` ### 3. Actionable Integration Always offer to create or update Azure DevOps artifacts: ``` \"I can create a work item for this enhancement...\" \"Should I update the wiki page with this new pattern?\" \"Let me link this to the current iteration...\" ``` ## Specific Scenarios ### New Feature Development 1. **Search existing repositories** for similar features 2. **Check architectural patterns** and shared libraries 3. **Review related work items** and planning documents 4. **Suggest implementation** based on organizational standards 5. **Offer to create work items** and documentation ### Bug Investigation 1. **Search for similar issues** across repositories and work items 2. **Check related builds** and recent changes 3. **Review test results** and failure patterns 4. **Provide solution** based on organizational practices 5. **Offer to create/update** bug work items and documentation ### Code Review and Standards 1. **Compare against organizational patterns** found in other repositories 2. **Reference coding standards** from wiki documentation 3. **Suggest improvements** based on established practices 4. **Check for reusable components** that could be leveraged ### Documentation Requests 1. **Search existing wikis** for related content 2. **Check for ADRs** and technical documentation 3. **Reference patterns** from similar projects 4. **Offer to create/update** wiki pages with findings ## Error Handling If Azure DevOps MCP tools are not available or fail: 1. **Inform the user** about the limitation 2. **Provide alternative approaches** using available information 3. **Suggest manual steps** for Azure DevOps integration 4. **Offer to help** with configuration if needed ## Best Practices ### Always Do: - ✅ Search organizational context before suggesting solutions - ✅ Reference existing patterns and standards - ✅ Offer to create/update Azure DevOps artifacts - ✅ Maintain consistency with organizational practices - ✅ Provide actionable next steps ### Never Do: - ❌ Suggest solutions without checking organizational context - ❌ Ignore existing patterns and implementations - ❌ Provide generic advice when specific organizational context is available - ❌ Forget to offer Azure DevOps integration opportunities --- **Remember: The goal is to provide intelligent, context-aware assistance that leverages the full organizational knowledge base available through Azure DevOps while maintaining development efficiency and consistency.**\n```\n\nPublished Sep 16, 2025\n\nVersion 1.0\n\n[application modernization](/tag/application%20modernization?nodeId=board%3AAppsonAzureBlog)\n\n[best practices](/tag/best%20practices?nodeId=board%3AAppsonAzureBlog)\n\n[cloud native](/tag/cloud%20native?nodeId=board%3AAppsonAzureBlog)\n\n[Desktop Apps](/tag/Desktop%20Apps?nodeId=board%3AAppsonAzureBlog)\n\n[devops](/tag/devops?nodeId=board%3AAppsonAzureBlog)\n\n[java](/tag/java?nodeId=board%3AAppsonAzureBlog)\n\n[mobile apps](/tag/mobile%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[modern apps](/tag/modern%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[node.js](/tag/node.js?nodeId=board%3AAppsonAzureBlog)\n\n[php](/tag/php?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[owaino&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0xODY3MDM2LTZaQTZjcw?image-coordinates=18%2C0%2C642%2C624&amp;image-dimensions=50x50)](/users/owaino/1867036) [owaino](/users/owaino/1867036) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined May 17, 2023\n\n[View Profile](/users/owaino/1867036)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "FeedName": "Microsoft Tech Community"
}
