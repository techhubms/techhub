{
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Link": "https://techcommunity.microsoft.com/t5/linux-and-open-source-blog/event-driven-to-change-driven-low-cost-dependency-inversion/ba-p/4478948",
  "Author": "CollinBrian",
  "PubDate": "2025-12-17T22:22:37+00:00",
  "EnhancedContent": "## Author: Daniel Gerlag, Principal Software Engineer\n\nEvent-driven architectures tout scalability, loose coupling, and eventual consistency. The architectural patterns are sound, the theory is compelling, and the blog posts make it look straightforward.\n\nThen you implement it.\n\nSuddenly you're maintaining separate event stores, implementing transactional outboxes, debugging projection rebuilds, versioning events across a dozen micro-services, and writing mountains of boilerplate to handle what should be simple queries.\n\nYour domain events that were supposed to capture rich business meaning have devolved into glorified database change notifications. Downstream services diff field values to extract intent from \"*OrderUpdated*\" events because developers just don't get what constitutes a proper domain event.\n\nThe complexity tax is real, don't get me wrong, it's very elegant but for many systems it's unjustified.\n\nDrasi offers an alternative: *change-driven architecture* that delivers reactive, real-time capabilities across multiple data sources without requiring you to rewrite your application or over complicate your architecture.\n\n### What do we mean by ‚ÄúEvent-driven‚Äù architecture\n\nAs [Martin Fowler notes](https://www.youtube.com/watch?v=STKCRSUsyP0), event-driven architecture isn't a single pattern, it's at least four distinct patterns that are often confused, each with its own benefits and traps.\n\n**Event Notification** is the simplest form. Here, events act as signals that something has happened, but carry minimal data, often just an identifier. The recipient must query the source system for more details if needed. For example, a service emits an *OrderPlaced* event with just the order ID. Downstream consumers must query the order service to retrieve full order details.\n\n**Event Carried State Transfer** broadcasts full state changes through events. When an order ships, you publish an *OrderShipped* event containing all the order details. Downstream services maintain their own materialized views or projections by consuming these events.\n\n**Event Sourcing** goes further, events become your source of truth. Instead of storing current state, you store the sequence of events that led to that state. Your order isn't a row in a database; it's the sum of *OrderPlaced*, *ItemAdded*, *PaymentProcessed*, and *OrderShipped* events.\n\n**CQRS (Command Query Responsibility Segregation)** separates write operations (commands) from read operations (queries). While not inherently event-driven, CQRS is often paired with event sourcing or event-carried state transfer to optimize for scalability and maintainability. Originally derived from Bertrand Meyer's Command-Query Separation principle and popularized by Greg Young, CQRS addresses a specific architectural challenge: the tension between optimizing for writes versus optimizing for reads.\n\nThe pattern promises several benefits:\n\n**Optimized data models**: Your write model can focus on transactional consistency while read models optimize for query performance\n\n**Scalability**: Read and write sides can scale independently\n\n**Temporal queries**: With event sourcing, you get time travel for free‚Äîreconstruct state at any point in history\n\n**Audit trail**: Every change is captured as an immutable event\n\nWhile CQRS isn't inherently tied to Domain-Driven Design (DDD), the pattern complements DDD well. In DDD contexts, CQRS enables different bounded contexts to maintain their own read models tailored to their specific ubiquitous language, while the write model protects domain invariants. This is why you'll often see them discussed together, though each can be applied independently.\n\n***The core motivation for these patterns is often to invert the dependency between systems, so that your downstream services do not need to know about your upstream services.***\n\n### The Developer's Struggle: When Domain Events Become Database Events\n\nChris Kiehl puts it bluntly in his article \"[Don't Let the Internet Dupe You, Event Sourcing is Hard](https://chriskiehl.com/article/event-sourcing-is-hard)\": *\"The sheer volume of plumbing code involved is staggering‚Äîinstead of a friendly N-tier setup, you now have classes for commands, command handlers, command validators, events, aggregates, and then projections, model classes, access classes, custom materialization code, and so on.\"*\n\nBut the real tragedy isn't the boilerplate, it's what happens to those carefully crafted domain events. As developers are disconnected from the real-world business, they struggle to understand the nuances of domain events, a dangerous pattern emerges. Instead of modeling meaningful business processes, teams default to what they know: CRUD.\n\nYour event stream starts looking like this:\n\n***OrderCreated***\n\n***OrderUpdated***\n\n***OrderUpdated*** (again)\n\n***OrderUpdated*** (wait, what changed?)\n\n***OrderDeleted***\n\nAs one developer [noted on LinkedIn](https://www.linkedin.com/pulse/anti-patterns-event-driven-architecture-arpit-jain), these \"CRUD events\" are really just *\"leaky events that lack clarity and should not be used to replicate databases as this leaks implementation details and couples services to a shared data model.\"*\n\nDennis Doomen, reflecting on [real-world production issues](https://www.dennisdoomen.com/2017/11/the-ugly-of-event-sourcingreal-world.html), observes: *\"It's only once you have a living, breathing machine, users which depend on you, consumers which you can't break, and all the other real-world complexities that plague software projects that the hard problems in event sourcing will rear their heads.\"*\n\nThe result? Your elegant event-driven architecture devolves into an expensive, brittle form of self-maintained Change Data Capture (CDC). You're not modeling business processes; you're just broadcasting database mutations with extra steps.\n\n### The Anti-Corruption Layer: Your Defense Against the Outside World\n\nIn DDD, an Anti-Corruption Layer (ACL) protects your bounded context from external models that would corrupt your domain. Think of it as a translator that speaks both languages, the messy external model and your clean internal model.\n\nThe ACL ensures that changes to the external system don't ripple through your domain. If the legacy system changes its schema, you update the translator, not your entire domain model.\n\n### When Event Taxonomies Become Your ACL (And Why They Fail)\n\nIn most event-driven architectures, your event taxonomy is supposed to serve as the shared contract between services. Each service publishes events using its own ubiquitous language, and consumers translate these into their own models, this translation is the ACL.\n\nThe theory looks beautiful:\n\nBut reality? Most teams end up with this:\n\nInstead of ***OrderPaid*** events that carry business meaning, we get ***OrderUpdated*** events that force every consumer to reconstruct intent by diffing fields. When you change your database schema, say splitting the orders table or switching from SQL to NoSQL, every downstream service breaks because they're all coupled to your internal data model.\n\nYou haven't built an anti-corruption layer. You've built a corruption pipeline that efficiently distributes your internal implementation details across the entire system, forcing you to deploy all services in lock step and eroding the decoupling benefits you were supposed to get.\n\n## Enter Drasi: Continuous Queries\n\nThis is where Drasi changes the game. Instead of publishing events and hoping downstream services can make sense of them, Drasi tails the changelog of the data source itself and derives meaning through continuous queries.\n\nA continuous query in Drasi isn't just a query that runs repeatedly, it's a living, breathing projection that reacts to changes in real-time. Here's the key insight: instead of imperative code that processes events (\"when this happens, do that\"), you write declarative queries that describe the state you care about (\"I want to know about orders that are ready and have drivers waiting\").\n\nLet's break down what makes this powerful:\n\n### Declarative vs. Imperative\n\nTraditional event processing:\n\nDrasi continuous query:\n\n### Semantic Mapping from Low-Level Changes\n\nDrasi excels at transforming database-level changes into business-meaningful events. You're not reacting to \"row updated in orders table\", you're reacting to \"order ready for curbside pickup.\"\n\n***This enables the same core benefits of dependency inversion we get from event-driven architectures but at a fraction of the effort.***\n\n### Advanced Temporal Features\n\nRemember those developers struggling with \"*OrderUpdated*\" events, trying to figure out if something just happened or has been true for a while? Drasi handles this elegantly:\n\nThis query only fires when a driver has been waiting for more than 10 minutes, no timestamp tracking, no state machines, no complex event correlation logic, imagine trying to manually implement this in a downstream event consumer. üò±\n\n### Cross-Source Aggregation Without Code\n\nWith Drasi, you can have live projections across PostgreSQL, MySQL, SQL Server, and Cosmos DB as if they were a single graph:\n\nNo custom aggregation service. No event stitching logic. No custom downstream datastore to track the sum or keep a materialized projection. Just a query.\n\n### Continuous Queries as Your Shared Contract\n\nDrasi's continuous queries, combined with pre-processing middleware, can form the shared contract that your anti-corruption layer can depend on.\n\nThe continuous query becomes your contract. Downstream systems don't know or care whether orders come from PostgreSQL, MongoDB, or a CSV file. They don't know if you normalized your database, denormalized it, or moved to event sourcing. They just consume the query results. Clean, semantic, and stable.\n\n### Reactions as your Declarative Consumers\n\nDrasi does not simply output a stream of raw change diffs, instead it has a library of interchangeable [Reactions](https://drasi.io/concepts/reactions/), that can act on the output of continuous queries. These are declared using YAML and can do anything from host a web-socket endpoint that provides a live projection to your UI, to calling an Http endpoint or publishing a message on a queue.\n\n## Example: The Curbside Pickup System\n\nLet's see how this works in Drasi's [curbside pickup tutorial](https://drasi.io/tutorials/curbside-pickup/). This example has two independent databases and serves as a great illustration of a real-time projection built from multiple upstream services.\n\n### The Business Problem\n\nA retail system needs to:\n\n1. Match ready orders with drivers who've arrived at pickup zones\n2. Alert staff when drivers wait more than 10 minutes without their order being ready\n3. Coordinate data from two different systems (retail ops in PostgreSQL, physical ops in MySQL)\n\n### Traditional Event-Driven Approach\n\nIn this architecture, you'd need something like:\n\nThat's just the happy path. We haven't handled:\n\n- Event ordering issues\n- Partial failures\n- Cache invalidation\n- Service restarts and replay\n- Duplicate events\n- Transactional outboxing\n\n### The Drasi Approach\n\nWith Drasi, the entire aggregation service above becomes two queries:\n\n**Delivery Dashboard Query:**\n\n**Wait Detection Query:**\n\nThat's it. No event handlers. No caching. No timers. No state management. Drasi handles:\n\n- Change detection across both databases\n- Correlation between orders and vehicles\n- Temporal logic for wait detection\n- Pushing updates to dashboards via SignalR\n\nThe queries define your business logic declaratively. When data changes in either database, Drasi automatically re-evaluates the queries and triggers reactions for any changes in the result set.\n\n## Drasi: The Non-Invasive Alternative to Legacy System Rewrites\n\nHere's perhaps the most compelling argument for Drasi: it doesn't require you to rewrite anything.\n\nTraditional event sourcing means:\n\n- Redesigning your application around events\n- Rewriting your persistence layer\n- Implementing transactional outboxes\n- Managing snapshots and replays\n- Training your team on new patterns, steep learning curve\n- Migrating existing data to event streams\n- Building projection infrastructure\n- Updating all consumers to handle events\n\nAs one developer noted about their [event sourcing journey](https://www.infoq.com/news/2019/09/cqrs-event-sourcing-production/): *\"Event Sourcing is a beautiful solution for high-performance or complex business systems, but you need to be aware that this also introduces challenges most people don't tell you about.\"*\n\nDrasi's approach:\n\n- Keep your existing databases\n- Keep your existing services\n- Keep your existing deployment model\n- Add continuous queries where you need reactive behavior\n- Get the benefits of dependency inversion\n- Gradually migrate complexity from code to queries\n\nYou can start with a single query on a single table and expand from there. No big bang. No feature freeze. No three-month architecture sprint or large multi-year investments, full of risk.\n\n### Migration Example: From Polling to Reactive\n\nLet's say you have a legacy order system where a scheduled job polls for ready orders every 30 seconds:\n\nWith Drasi, you:\n\n1. Point Drasi at your existing database\n2. Write the continuous query\n3. Update your dashboard to receive pushes instead of polls\n4. Turn off the polling job\n\nYour database hasn't changed. Your order service hasn't changed. You've just added a reactive layer on top that eliminates polling overhead and reduces notification latency from 30 seconds to milliseconds.\n\nThe intellectually satisfying complexity of event sourcing often obscures a simple truth: most systems don't need it. They need to know when interesting things change in their data and react accordingly. They need to combine data from multiple sources without writing bespoke aggregation services. They need to transform low-level changes into business-meaningful events.\n\nDrasi delivers these capabilities without the ceremony.\n\n## Where Do We Go from Here?\n\nIf you're building a new system and your team has deep event sourcing experience embrace the pattern. Event sourcing shines for certain domains.\n\nBut if you're like many teams, trying to add reactive capabilities to existing systems, struggling with data synchronization across services, or finding that your \"events\" are just CRUD operations in disguise, consider the change-driven approach.\n\nStart small:\n\n1. Identify one painful polling loop or batch job\n2. Set up Drasi to monitor those same data sources\n3. Write a continuous query that captures the business condition\n4. Replace the polling with push-based reactions\n5. Measure the reduction in latency, overhead, and code complexity\n\nThe best architecture isn't the most sophisticated one, it's the one your team can understand, maintain, and evolve. Sometimes that means acknowledging that we've been mid-curving it with overly complex event-driven architectures.\n\nDrasi and change-driven architecture offer the power of reactive systems without the complexity tax. Your data changes. Your queries notice. Your systems react.\n\nIt makes it a non-event.\n\n*Want to explore Drasi further? Check out the* [*official documentation*](https://drasi.io/) *and try the* [*curbside pickup tutorial*](https://drasi.io/tutorials/curbside-pickup/) *to see change-driven architecture in action.*\n\nPublished Dec 17, 2025\n\nVersion 1.0\n\n[monitoring](/tag/monitoring?nodeId=board%3ALinuxandOpenSourceBlog)\n\n[!\\[CollinBrian&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/m_assets/avatars/default/avatar-5.svg?image-dimensions=50x50)](/users/collinbrian/1113044) [CollinBrian](/users/collinbrian/1113044) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined July 26, 2021\n\n[View Profile](/users/collinbrian/1113044)\n\n/category/azure/blog/linuxandopensourceblog [Linux and Open Source Blog](/category/azure/blog/linuxandopensourceblog) Follow this blog board to get notified when there's new activity",
  "OutputDir": "_community",
  "ProcessedDate": "2025-12-17 23:05:18",
  "Description": "Event-driven architectures tout scalability, loose coupling, and eventual consistency. The architectural patterns are sound, the theory is compelling, and the blog posts make it look straightforward.\n\nThen you implement it.\n\nSuddenly you're maintaining separate event stores, implementing transactional outboxes, debugging projection rebuilds, versioning events across a dozen micro-services, and writing mountains of boilerplate to handle what should be simple queries.\n\nYour domain events that were supposed to capture rich business meaning have devolved into glorified database change notifications. Downstream services diff field values to extract intent from \"*OrderUpdated*\" events because developers just don't get what constitutes a proper domain event.\n\nThe complexity tax is real, don't get me wrong, it's very elegant but for many systems it's unjustified.\n\nDrasi offers an alternative: *change-driven architecture* that delivers reactive, real-time capabilities across multiple data sources without requiring you to rewrite your application or over complicate your architecture.\n\n### What do we mean by ‚ÄúEvent-driven‚Äù architecture\n\nAs [Martin Fowler notes](https://www.youtube.com/watch?v=STKCRSUsyP0), event-driven architecture isn't a single pattern, it's at least four distinct patterns that are often confused, each with its own benefits and traps.\n\n**Event Notification** is the simplest form. Here, events act as signals that something has happened, but carry minimal data, often just an identifier. The recipient must query the source system for more details if needed. For example, a service emits an *OrderPlaced* event with just the order ID. Downstream consumers must query the order service to retrieve full order details.\n\n**Event Carried State Transfer** broadcasts full state changes through events. When an order ships, you publish an *OrderShipped* event containing all the order details. Downstream services maintain their own materialized views or projections by consuming these events.\n\n**Event Sourcing** goes further, events become your source of truth. Instead of storing current state, you store the sequence of events that led to that state. Your order isn't a row in a database; it's the sum of *OrderPlaced*, *ItemAdded*, *PaymentProcessed*, and *OrderShipped* events.\n\n**CQRS (Command Query Responsibility Segregation)** separates write operations (commands) from read operations (queries). While not inherently event-driven, CQRS is often paired with event sourcing or event-carried state transfer to optimize for scalability and maintainability. Originally derived from Bertrand Meyer's Command-Query Separation principle and popularized by Greg Young, CQRS addresses a specific architectural challenge: the tension between optimizing for writes versus optimizing for reads.\n\nThe pattern promises several benefits:\n\n**Optimized data models**: Your write model can focus on transactional consistency while read models optimize for query performance\n\n**Scalability**: Read and write sides can scale independently\n\n**Temporal queries**: With event sourcing, you get time travel for free‚Äîreconstruct state at any point in history\n\n**Audit trail**: Every change is captured as an immutable event\n\nWhile CQRS isn't inherently tied to Domain-Driven Design (DDD), the pattern complements DDD well. In DDD contexts, CQRS enables different bounded contexts to maintain their own read models tailored to their specific ubiquitous language, while the write model protects domain invariants. This is why you'll often see them discussed together, though each can be applied independently.\n\n***The core motivation for these patterns is often to invert the dependency between systems, so that your downstream services do not need to know about your upstream services.***\n\n### The Developer's Struggle: When Domain Events Become Database Events\n\nChris Kiehl puts it bluntly in his article \"[Don't Let the Internet Dupe You, Event Sourcing is Hard](https://chriskiehl.com/article/event-sourcing-is-hard)\": *\"The sheer volume of plumbing code involved is staggering‚Äîinstead of a friendly N-tier setup, you now have classes for commands, command handlers, command validators, events, aggregates, and then projections, model classes, access classes, custom materialization code, and so on.\"*\n\nBut the real tragedy isn't the boilerplate, it's what happens to those carefully crafted domain events. As developers are disconnected from the real-world business, they struggle to understand the nuances of domain events, a dangerous pattern emerges. Instead of modeling meaningful business processes, teams default to what they know: CRUD.\n\nYour event stream starts looking like this:\n\n***OrderCreated***\n\n***OrderUpdated***\n\n***OrderUpdated*** (again)\n\n***OrderUpdated*** (wait, what changed?)\n\n***OrderDeleted***\n\nAs one developer [noted on LinkedIn](https://www.linkedin.com/pulse/anti-patterns-event-driven-architecture-arpit-jain), these \"CRUD events\" are really just *\"leaky events that lack clarity and should not be used to replicate databases as this leaks implementation details and couples services to a shared data model.\"*\n\nDennis Doomen, reflecting on [real-world production issues](https://www.dennisdoomen.com/2017/11/the-ugly-of-event-sourcingreal-world.html), observes: *\"It's only once you have a living, breathing machine, users which depend on you, consumers which you can't break, and all the other real-world complexities that plague software projects that the hard problems in event sourcing will rear their heads.\"*\n\nThe result? Your elegant event-driven architecture devolves into an expensive, brittle form of self-maintained Change Data Capture (CDC). You're not modeling business processes; you're just broadcasting database mutations with extra steps.\n\n### The Anti-Corruption Layer: Your Defense Against the Outside World\n\nIn DDD, an Anti-Corruption Layer (ACL) protects your bounded context from external models that would corrupt your domain. Think of it as a translator that speaks both languages, the messy external model and your clean internal model.\n\n![]()\n\nThe ACL ensures that changes to the external system don't ripple through your domain. If the legacy system changes its schema, you update the translator, not your entire domain model.\n\n### When Event Taxonomies Become Your ACL (And Why They Fail)\n\nIn most event-driven architectures, your event taxonomy is supposed to serve as the shared contract between services. Each service publishes events using its own ubiquitous language, and consumers translate these into their own models, this translation is the ACL.\n\nThe theory looks beautiful:\n\n![]()\n\nBut reality? Most teams end up with this:\n\n![]()\n\nInstead of ***OrderPaid*** events that carry business meaning, we get ***OrderUpdated*** events that force every consumer to reconstruct intent by diffing fields. When you change your database schema, say splitting the orders table or switching from SQL to NoSQL, every downstream service breaks because they're all coupled to your internal data model.\n\nYou haven't built an anti-corruption layer. You've built a corruption pipeline that efficiently distributes your internal implementation details across the entire system, forcing you to deploy all services in lock step and eroding the decoupling benefits you were supposed to get.\n\n## Enter Drasi: Continuous Queries\n\nThis is where Drasi changes the game. Instead of publishing events and hoping downstream services can make sense of them, Drasi tails the changelog of the data source itself and derives meaning through continuous queries.\n\nA continuous query in Drasi isn't just a query that runs repeatedly, it's a living, breathing projection that reacts to changes in real-time. Here's the key insight: instead of imperative code that processes events (\"when this happens, do that\"), you write declarative queries that describe the state you care about (\"I want to know about orders that are ready and have drivers waiting\").\n\nLet's break down what makes this powerful:\n\n### Declarative vs. Imperative\n\nTraditional event processing:\n\n![]()\n\nDrasi continuous query:\n\n![]()\n\n### Semantic Mapping from Low-Level Changes\n\nDrasi excels at transforming database-level changes into business-meaningful events. You're not reacting to \"row updated in orders table\", you're reacting to \"order ready for curbside pickup.\"\n\n***This enables the same core benefits of dependency inversion we get from event-driven architectures but at a fraction of the effort.***\n\n### Advanced Temporal Features\n\nRemember those developers struggling with \"*OrderUpdated*\" events, trying to figure out if something just happened or has been true for a while? Drasi handles this elegantly:\n\n![]()\n\nThis query only fires when a driver has been waiting for more than 10 minutes, no timestamp tracking, no state machines, no complex event correlation logic, imagine trying to manually implement this in a downstream event consumer. üò±\n\n### Cross-Source Aggregation Without Code\n\nWith Drasi, you can have live projections across PostgreSQL, MySQL, SQL Server, and Cosmos DB as if they were a single graph:\n\n![]()\n\nNo custom aggregation service. No event stitching logic. No custom downstream datastore to track the sum or keep a materialized projection. Just a query.\n\n### Continuous Queries as Your Shared Contract\n\nDrasi's continuous queries, combined with pre-processing middleware, can form the shared contract that your anti-corruption layer can depend on.\n\n![]()\n\nThe continuous query becomes your contract. Downstream systems don't know or care whether orders come from PostgreSQL, MongoDB, or a CSV file. They don't know if you normalized your database, denormalized it, or moved to event sourcing. They just consume the query results. Clean, semantic, and stable.\n\n### Reactions as your Declarative Consumers\n\nDrasi does not simply output a stream of raw change diffs, instead it has a library of interchangeable [Reactions](https://drasi.io/concepts/reactions/), that can act on the output of continuous queries. These are declared using YAML and can do anything from host a web-socket endpoint that provides a live projection to your UI, to calling an Http endpoint or publishing a message on a queue.\n\n## Example: The Curbside Pickup System\n\nLet's see how this works in Drasi's [curbside pickup tutorial](https://drasi.io/tutorials/curbside-pickup/). This example has two independent databases and serves as a great illustration of a real-time projection built from multiple upstream services.\n\n### The Business Problem\n\nA retail system needs to:\n\n1. Match ready orders with drivers who've arrived at pickup zones\n2. Alert staff when drivers wait more than 10 minutes without their order being ready\n3. Coordinate data from two different systems (retail ops in PostgreSQL, physical ops in MySQL)\n\n### Traditional Event-Driven Approach\n\nIn this architecture, you'd need something like:\n\n![]()![]()![]()![]()\n\nThat's just the happy path. We haven't handled:\n\n- Event ordering issues\n- Partial failures\n- Cache invalidation\n- Service restarts and replay\n- Duplicate events\n- Transactional outboxing\n\n### The Drasi Approach\n\nWith Drasi, the entire aggregation service above becomes two queries:\n\n**Delivery Dashboard Query:**\n\n![]()\n\n**Wait Detection Query:**\n\n![]()\n\nThat's it. No event handlers. No caching. No timers. No state management. Drasi handles:\n\n- Change detection across both databases\n- Correlation between orders and vehicles\n- Temporal logic for wait detection\n- Pushing updates to dashboards via SignalR\n\nThe queries define your business logic declaratively. When data changes in either database, Drasi automatically re-evaluates the queries and triggers reactions for any changes in the result set.\n\n## Drasi: The Non-Invasive Alternative to Legacy System Rewrites\n\nHere's perhaps the most compelling argument for Drasi: it doesn't require you to rewrite anything.\n\nTraditional event sourcing means:\n\n- Redesigning your application around events\n- Rewriting your persistence layer\n- Implementing transactional outboxes\n- Managing snapshots and replays\n- Training your team on new patterns, steep learning curve\n- Migrating existing data to event streams\n- Building projection infrastructure\n- Updating all consumers to handle events\n\nAs one developer noted about their [event sourcing journey](https://www.infoq.com/news/2019/09/cqrs-event-sourcing-production/): *\"Event Sourcing is a beautiful solution for high-performance or complex business systems, but you need to be aware that this also introduces challenges most people don't tell you about.\"*\n\nDrasi's approach:\n\n- Keep your existing databases\n- Keep your existing services\n- Keep your existing deployment model\n- Add continuous queries where you need reactive behavior\n- Get the benefits of dependency inversion\n- Gradually migrate complexity from code to queries\n\nYou can start with a single query on a single table and expand from there. No big bang. No feature freeze. No three-month architecture sprint or large multi-year investments, full of risk.\n\n### Migration Example: From Polling to Reactive\n\nLet's say you have a legacy order system where a scheduled job polls for ready orders every 30 seconds:\n\n![]()\n\nWith Drasi, you:\n\n1. Point Drasi at your existing database\n2. Write the continuous query\n3. Update your dashboard to receive pushes instead of polls\n4. Turn off the polling job\n\nYour database hasn't changed. Your order service hasn't changed. You've just added a reactive layer on top that eliminates polling overhead and reduces notification latency from 30 seconds to milliseconds.\n\nThe intellectually satisfying complexity of event sourcing often obscures a simple truth: most systems don't need it. They need to know when interesting things change in their data and react accordingly. They need to combine data from multiple sources without writing bespoke aggregation services. They need to transform low-level changes into business-meaningful events.\n\nDrasi delivers these capabilities without the ceremony.\n\n## Where Do We Go from Here?\n\nIf you're building a new system and your team has deep event sourcing experience embrace the pattern. Event sourcing shines for certain domains.\n\nBut if you're like many teams, trying to add reactive capabilities to existing systems, struggling with data synchronization across services, or finding that your \"events\" are just CRUD operations in disguise, consider the change-driven approach.\n\nStart small:\n\n1. Identify one painful polling loop or batch job\n2. Set up Drasi to monitor those same data sources\n3. Write a continuous query that captures the business condition\n4. Replace the polling with push-based reactions\n5. Measure the reduction in latency, overhead, and code complexity\n\nThe best architecture isn't the most sophisticated one, it's the one your team can understand, maintain, and evolve. Sometimes that means acknowledging that we've been mid-curving it with overly complex event-driven architectures.\n\nDrasi and change-driven architecture offer the power of reactive systems without the complexity tax. Your data changes. Your queries notice. Your systems react.\n\nIt makes it a non-event.\n\n*Want to explore Drasi further? Check out the* [*official documentation*](https://drasi.io/) *and try the* [*curbside pickup tutorial*](https://drasi.io/tutorials/curbside-pickup/) *to see change-driven architecture in action.*",
  "Title": "Event-Driven to Change-Driven: Low-cost dependency inversion",
  "FeedName": "Microsoft Tech Community",
  "Tags": [],
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure"
}
