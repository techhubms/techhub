{
  "Link": "https://techcommunity.microsoft.com/t5/linux-and-open-source-blog/dalec-declarative-package-and-container-builds/ba-p/4465290",
  "OutputDir": "_community",
  "Author": "SertacOzercan",
  "Title": "Dalec: Declarative Package and Container Builds",
  "FeedName": "Microsoft Tech Community",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "EnhancedContent": "## Build once, deploy everywhere. From a single YAML specification, Dalec produces native Linux packages (RPM, DEB) and container images - no Dockerfiles, no complex RPM spec or control files, just declarative configuration.\n\n[Dalec](https://github.com/project-dalec/dalec), a Cloud Native Computing Foundation (CNCF) Sandbox project, is a Docker BuildKit frontend that enables users to build system packages and container images from declarative YAML specifications. As a BuildKit frontend, Dalec integrates directly into the Docker build process, requiring no additional tools beyond Docker itself.\n\nDalec‚Äôs primary focus is building native Linux packages (RPM and DEB formats) from source, with optional container image creation from those packages. It supports RPM-based distributions such as Azure Linux, AlmaLinux, and Rocky Linux, as well as DEB-based distributions like Debian and Ubuntu. It also supports pluggable backends for additional operating systems.\n\nBy replacing complex spec files and multi-stage Dockerfiles with a single declarative configuration, Dalec simplifies package building while providing built-in support for SBOMs, provenance attestations, and package signing.\n\n## Why Dalec?\n\nBuilding packages traditionally requires:\n\n- Manual creation of distribution-specific spec files (.spec for RPM, debian/ directory for DEB)\n- Multi-stage Dockerfiles with complex build logic\n- Architecture-specific build configurations\n- Separate build processes for each target distribution\n- Manual dependency management and bootstrapping\n\nDalec replaces this complexity with a single declarative YAML specification that defines:\n\n- **Sources** - Git repositories, HTTP archives, or inline content\n- **Dependencies** - Build-time and runtime package dependencies\n- **Build steps** - Commands to compile and prepare artifacts\n- **Artifacts** - Binaries, configuration files, and systemd units to package\n- **Targets** - Distribution-specific customizations\n- **Tests** - Validation of the built package\n- **Image config** - Optional container image creation from the package\n\nThe result is a portable, and auditable build process.\n\n## Key Benefits\n\n**üê≥ Zero Installation** - Works with standard Docker. No specialized tooling, package managers, or daemon processes required. If you can run docker build, you can use Dalec.\n\n**üöÄ Fast and Cacheable** - BuildKit‚Äôs intelligent caching means rebuilds are lightning fast. Change one source file, rebuild only what‚Äôs affected.\n\n**ü§ù Integration** ‚Äì Dalec integrates at both the package manager level and with language toolchains such as Go and Rust. This allows Dalec to automatically manage caches for items such as Go modules, incremental compiler caches, and packages across builds.\n\n**üîí Secure by Default** - Automatic SBOM generation, provenance attestations, and package signing built into the workflow. Supply chain security without extra steps.\n\n**üì¶ Package and Container** - Build once, output both. Get installable RPM/DEB packages for traditional deployments AND minimal container images for Kubernetes from the same specification.\n\n**üåç Multi-Distribution** - One spec, multiple targets. Build for Ubuntu, Debian, Azure Linux, Rocky Linux, and AlmaLinux without maintaining separate build configurations.\n\n**‚úçÔ∏èBetter Composition** - Declarative configurations compose cleanly. You can override specific parts for different distributions or targets without rewriting the entire build logic, and focusing on the package level makes it more natural to break components down into more composable pieces.\n\n**üîç Fully Auditable** - Declarative configuration means no hidden build steps. Every artifact‚Äôs provenance is traceable, meeting compliance and security requirements.\n\n## Who Should Use Dalec?\n\nDalec makes it easy for different audiences to achieve their goals:\n\n#### For Application Developers\n\nConvert your source code into distributable packages without learning RPM spec files or Debian packaging conventions. Focus on your application, not build infrastructure.\n\n#### For Platform Operators\n\nMaintain a consistent build process across your organization. Centralize packaging expertise in reusable specifications instead of scattered Dockerfiles and build scripts. Enforce security and compliance requirements at build time.\n\n#### For Package Maintainers\n\nBuild packages for multiple distributions from a single source of truth. Reduce maintenance burden and ensure consistency across your supported platforms.\n\n## How Dalec Works\n\nDalec is implemented as a [BuildKit frontend](https://docs.docker.com/build/buildkit/frontend/). When you specify # syntax=ghcr.io/project-dalec/dalec/frontend:latest at the top of your spec file, Docker BuildKit automatically pulls and executes the Dalec frontend, which translates your YAML specification into low-level build instructions (LLB graphs).\n\n**The Build Flow:**\n\n1. **Source acquisition** - Clone git repositories, download archives, generate dependency manifests (like Go modules, npm packages, or Python wheels)\n2. **Package build** - Execute build steps in isolated environments with dependencies installed\n3. **Package creation** - Create RPM or DEB packages with artifacts and metadata\n4. **Package testing** - Install and validate the package in a clean environment\n5. **Container creation** (optional) - Install packages into a minimal base image\n\nFrom a single YAML file, you can generate multi-architecture packages that work across distributions, then optionally compose them into minimal container images‚Äîall without writing a single line of Dockerfile or distribution-specific spec.\n\n## Real-World Use Cases\n\n**Open Source Projects** - Distribute your software across multiple Linux distributions without maintaining separate packaging workflows. A single Dalec spec replaces RPM spec files, debian/ directories, and custom build scripts.\n\n**Enterprise Deployments** - Build compliant, auditable packages for both traditional VM-based deployments and modern Kubernetes clusters. The same build produces installable packages for your data center and container images for your cloud infrastructure.\n\n**CI/CD Pipelines** - Integrate seamlessly into GitHub Actions, GitLab CI, or any CI system that supports Docker. No special runners or build agents required, just standard Docker.\n\n**Security-Critical Applications** - Leverage BuildKit's built-in SBOM and provenance generation to meet supply chain security requirements. Every build produces attestations that prove what went into your packages and containers.\n\n**Multi-Architecture Builds** - Build for x86\\_64, ARM64, and other architectures with a single command. BuildKit handles the complexity of cross-compilation automatically.\n\n## A Simple Example\n\nHere‚Äôs what a Dalec spec looks like. This example builds go-md2man, a tool that converts Markdown to man pages:\n\n```\n# syntax=ghcr.io/project-dalec/dalec/frontend:latest\n\nname: go-md2man version: 2.0.3 revision: \"1\" packager: Dalec Example vendor: Dalec Example license: MIT description: A tool to convert markdown into man pages (roff). website: https://github.com/cpuguy83/go-md2man\n\nsources: src: generate:\n- gomod: {} # Pre-downloads Go modules (network disabled during build)\ngit: url: https://github.com/cpuguy83/go-md2man.git commit: v2.0.3\n\ndependencies: build: golang:\n\nbuild: env: CGO_ENABLED: \"0\" steps:\n- command: |\ncd src go build -o go-md2man .\n\nartifacts: binaries: src/go-md2man:\n\nimage: entrypoint: go-md2man cmd: --help\n\ntests:\n- name: Check bin\nfiles: /usr/bin/go-md2man: permissions: 0755 ```\n\nFrom this single YAML file, you can build RPM packages, DEB packages, and container images for multiple distributions and architectures using standard docker build commands.\n\nDalec can also create minimal container images with just runtime dependencies, no source code building required. This is perfect for creating lightweight containers with only the packages you need.\n\nHere‚Äôs a minimal example that creates a container with curl and bash:\n\n```\n# syntax=ghcr.io/project-dalec/dalec/frontend:latest name: my-minimal-image version: 0.1.0 revision: \"1\" license: MIT description: A minimal image with only curl and shell access dependencies: runtime: curl: bash: image: entrypoint: /bin/bash\n```\n\nBuild it with:\n\n``` docker build -f my-minimal-image.yml --target=azlinux3 -t my-minimal-image:0.1.0 . ```\n\nThis produces a minimal image built from scratch containing only curl, bash, and their dependencies.\n\n**Pro tip:** You can skip creating a spec file entirely by passing dependencies on the command line:\n\n``` docker build -t my-minimal-image:0.1.0 --build-arg BUILDKIT_SYNTAX=ghcr.io/project-dalec/dalec/frontend:latest --target=azlinux3/container/depsonly - <<<\"$(jq -c '.dependencies.runtime = {\"curl\": {}, \"bash\": {}} | .image.entrypoint = \"/bin/bash\"' <<<\"{}\")\" ```\n\nLearn more in the [Container-only builds documentation](https://project-dalec.github.io/dalec/container-only-builds).\n\n## Getting Started\n\nReady to build your first package and container image? The [Dalec Quickstart](https://project-dalec.github.io/dalec/quickstart) walks you through building go-md2man, a real-world example that demonstrates:\n\n- Creating a declarative YAML specification\n- Building RPM and DEB packages\n- Creating minimal container images\n- Multi-architecture builds\n\nThe quickstart shows how a single spec can produce packages for multiple distributions (Azure Linux, Ubuntu, Debian) and architectures (x86\\_64, ARM64) using standard docker build commands.\n\n## CI/CD Integration\n\nDalec integrates seamlessly into any CI/CD system that supports Docker, including GitHub Actions, GitLab CI, Jenkins, and cloud-native build systems. Since Dalec builds use standard docker build commands, no special runners or build agents are required‚Äîjust a standard Docker environment.\n\nThanks to BuildKit, Dalec can also build directly on Kubernetes clusters using the [Kubernetes driver](https://docs.docker.com/build/builders/drivers/kubernetes/). This enables scalable, cloud-native builds without requiring dedicated build VMs, making it ideal for large-scale CI/CD pipelines.\n\nThis makes it easy to:\n\n- Build and publish packages on every release\n- Generate multi-architecture artifacts in parallel\n- Integrate SBOM generation and signing into your pipeline\n- Push containers to any OCI-compliant registry\n- Scale builds elastically on Kubernetes infrastructure\n\n## Supply Chain Security\n\n### SBOM and Provenance Attestations\n\nBuildKit provides integrated support for Software Bill of Materials (SBOM) generation and provenance attestations. SBOMs automatically catalog every package and dependency in your build, providing complete transparency into what‚Äôs inside your artifacts. Provenance attestations are cryptographically-signed records that prove how your image was built, including the source repository, build parameters, and execution environment. This enables verification throughout your deployment pipeline. Learn more about configuring these features in the [BuildKit attestations documentation](https://docs.docker.com/build/metadata/attestations/).\n\n### Package Signing\n\nDalec supports GPG [signing of packages](https://project-dalec.github.io/dalec/signing) for additional trust and verification:\n\n``` package_config:¬† signer:¬†¬†¬† frontend:¬†¬†¬†¬†¬† image: <signer-image> ```\n\nSigned packages ensure recipients can verify authenticity and detect tampering.\n\n## Conclusion\n\nDalec provides a modern, declarative approach to building system packages and containers. By leveraging Docker BuildKit as a frontend, it eliminates the need for complex build toolchains while providing secure builds across multiple Linux distributions.\n\nFor open-source projects that need to distribute both packages and containers, Dalec offers a unified build process that simplifies CI/CD while strengthening supply chain security.\n\nWhether you‚Äôre migrating from traditional RPM spec files, consolidating Dockerfiles, or building a new project from scratch, Dalec provides the simplicity of modern container tools with the flexibility of native package formats.\n\n## Get Started\n\nReady to try Dalec? You‚Äôre just one docker build command away:\n\n1. **Explore the documentation**: [project-dalec.github.io/dalec](https://project-dalec.github.io/dalec/)\n2. **Try the** [**quickstart tutorial**](https://project-dalec.github.io/dalec/quickstart): Build your first package and container\n3. **Browse examples**: See real-world specs in the [examples directory](https://github.com/Azure/dalec/tree/main/docs/examples)\n4. **Join the community**: Connect with us in the [#dalec](https://cloud-native.slack.com/archives/C09MHVDGMAB) channel on [CNCF Slack](https://communityinviter.com/apps/cloud-native/cncf)\n5. **Contribute**: Dalec is an open-source project under the CNCF. Contributions are welcome! Check out the [contributing guide](https://github.com/project-dalec/dalec/blob/main/CONTRIBUTING.md) to get involved\n\nUpdated Oct 29, 2025\n\nVersion 2.0\n\n[almalinux](/tag/almalinux?nodeId=board%3ALinuxandOpenSourceBlog)\n\n[azure linux](/tag/azure%20linux?nodeId=board%3ALinuxandOpenSourceBlog)\n\n[debian](/tag/debian?nodeId=board%3ALinuxandOpenSourceBlog)\n\n[linux on azure](/tag/linux%20on%20azure?nodeId=board%3ALinuxandOpenSourceBlog)\n\n[red hat](/tag/red%20hat?nodeId=board%3ALinuxandOpenSourceBlog)\n\n[security](/tag/security?nodeId=board%3ALinuxandOpenSourceBlog)\n\n[ubuntu](/tag/ubuntu?nodeId=board%3ALinuxandOpenSourceBlog)\n\n[!\\[SertacOzercan&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0xMTc1MDA5LWJGc0lWZA?image-coordinates=0%2C0%2C400%2C400&amp;image-dimensions=50x50)](/users/sertacozercan/1175009) [SertacOzercan](/users/sertacozercan/1175009) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined October 05, 2021\n\n[View Profile](/users/sertacozercan/1175009)\n\n/category/azure/blog/linuxandopensourceblog [Linux and Open Source Blog](/category/azure/blog/linuxandopensourceblog) Follow this blog board to get notified when there's new activity",
  "Description": "[Dalec](https://github.com/project-dalec/dalec), a Cloud Native Computing Foundation (CNCF) Sandbox project, is a Docker BuildKit frontend that enables users to build system packages and container images from declarative YAML specifications. As a BuildKit frontend, Dalec integrates directly into the Docker build process, requiring no additional tools beyond Docker itself.\n\nDalec‚Äôs primary focus is building native Linux packages (RPM and DEB formats) from source, with optional container image creation from those packages. It supports RPM-based distributions such as Azure Linux, AlmaLinux, and Rocky Linux, as well as DEB-based distributions like Debian and Ubuntu. It also supports pluggable backends for additional operating systems.\n\nBy replacing complex spec files and multi-stage Dockerfiles with a single declarative configuration, Dalec simplifies package building while providing built-in support for SBOMs, provenance attestations, and package signing.\n\n## Why Dalec?\n\nBuilding packages traditionally requires:\n\n- Manual creation of distribution-specific spec files (.spec for RPM, debian/ directory for DEB)\n- Multi-stage Dockerfiles with complex build logic\n- Architecture-specific build configurations\n- Separate build processes for each target distribution\n- Manual dependency management and bootstrapping\n\nDalec replaces this complexity with a single declarative YAML specification that defines:\n\n- **Sources** - Git repositories, HTTP archives, or inline content\n- **Dependencies** - Build-time and runtime package dependencies\n- **Build steps** - Commands to compile and prepare artifacts\n- **Artifacts** - Binaries, configuration files, and systemd units to package\n- **Targets** - Distribution-specific customizations\n- **Tests** - Validation of the built package\n- **Image config** - Optional container image creation from the package\n\nThe result is a portable, and auditable build process.\n\n## Key Benefits\n\n**üê≥ Zero Installation** - Works with standard Docker. No specialized tooling, package managers, or daemon processes required. If you can run docker build, you can use Dalec.\n\n**üöÄ Fast and Cacheable** - BuildKit‚Äôs intelligent caching means rebuilds are lightning fast. Change one source file, rebuild only what‚Äôs affected.\n\n**ü§ù Integration** ‚Äì Dalec integrates at both the package manager level and with language toolchains such as Go and Rust. This allows Dalec to automatically manage caches for items such as Go modules, incremental compiler caches, and packages across builds.\n\n**üîí Secure by Default** - Automatic SBOM generation, provenance attestations, and package signing built into the workflow. Supply chain security without extra steps.\n\n**üì¶ Package and Container** - Build once, output both. Get installable RPM/DEB packages for traditional deployments AND minimal container images for Kubernetes from the same specification.\n\n**üåç Multi-Distribution** - One spec, multiple targets. Build for Ubuntu, Debian, Azure Linux, Rocky Linux, and AlmaLinux without maintaining separate build configurations.\n\n**‚úçÔ∏èBetter Composition** - Declarative configurations compose cleanly. You can override specific parts for different distributions or targets without rewriting the entire build logic, and focusing on the package level makes it more natural to break components down into more composable pieces.\n\n**üîç Fully Auditable** - Declarative configuration means no hidden build steps. Every artifact‚Äôs provenance is traceable, meeting compliance and security requirements.\n\n## Who Should Use Dalec?\n\nDalec makes it easy for different audiences to achieve their goals:\n\n#### For Application Developers\n\nConvert your source code into distributable packages without learning RPM spec files or Debian packaging conventions. Focus on your application, not build infrastructure.\n\n#### For Platform Operators\n\nMaintain a consistent build process across your organization. Centralize packaging expertise in reusable specifications instead of scattered Dockerfiles and build scripts. Enforce security and compliance requirements at build time.\n\n#### For Package Maintainers\n\nBuild packages for multiple distributions from a single source of truth. Reduce maintenance burden and ensure consistency across your supported platforms.\n\n## How Dalec Works\n\nDalec is implemented as a [BuildKit frontend](https://docs.docker.com/build/buildkit/frontend/). When you specify # syntax=ghcr.io/project-dalec/dalec/frontend:latest at the top of your spec file, Docker BuildKit automatically pulls and executes the Dalec frontend, which translates your YAML specification into low-level build instructions (LLB graphs).\n\n**The Build Flow:**\n\n1. **Source acquisition** - Clone git repositories, download archives, generate dependency manifests (like Go modules, npm packages, or Python wheels)\n2. **Package build** - Execute build steps in isolated environments with dependencies installed\n3. **Package creation** - Create RPM or DEB packages with artifacts and metadata\n4. **Package testing** - Install and validate the package in a clean environment\n5. **Container creation** (optional) - Install packages into a minimal base image\n\nFrom a single YAML file, you can generate multi-architecture packages that work across distributions, then optionally compose them into minimal container images‚Äîall without writing a single line of Dockerfile or distribution-specific spec.\n\n## Real-World Use Cases\n\n**Open Source Projects** - Distribute your software across multiple Linux distributions without maintaining separate packaging workflows. A single Dalec spec replaces RPM spec files, debian/ directories, and custom build scripts.\n\n**Enterprise Deployments** - Build compliant, auditable packages for both traditional VM-based deployments and modern Kubernetes clusters. The same build produces installable packages for your data center and container images for your cloud infrastructure.\n\n**CI/CD Pipelines** - Integrate seamlessly into GitHub Actions, GitLab CI, or any CI system that supports Docker. No special runners or build agents required, just standard Docker.\n\n**Security-Critical Applications** - Leverage BuildKit's built-in SBOM and provenance generation to meet supply chain security requirements. Every build produces attestations that prove what went into your packages and containers.\n\n**Multi-Architecture Builds** - Build for x86\\_64, ARM64, and other architectures with a single command. BuildKit handles the complexity of cross-compilation automatically.\n\n## A Simple Example\n\nHere‚Äôs what a Dalec spec looks like. This example builds go-md2man, a tool that converts Markdown to man pages:\n\n- # syntax=ghcr.io/project-dalec/dalec/frontend:latest\n\nname: go-md2man version: 2.0.3 revision: \"1\" packager: Dalec Example vendor: Dalec Example license: MIT description: A tool to convert markdown into man pages (roff). website: https://github.com/cpuguy83/go-md2man\n\nsources: src: generate:\n- gomod: {} # Pre-downloads Go modules (network disabled during build)\ngit: url: https://github.com/cpuguy83/go-md2man.git commit: v2.0.3\n\ndependencies: build: golang:\n\nbuild: env: CGO\\_ENABLED: \"0\" steps:\n- command: |\ncd src go build -o go-md2man .\n\nartifacts: binaries: src/go-md2man:\n\nimage: entrypoint: go-md2man cmd: --help\n\ntests:\n- name: Check bin\nfiles: /usr/bin/go-md2man: permissions: 0755\n\nFrom this single YAML file, you can build RPM packages, DEB packages, and container images for multiple distributions and architectures using standard docker build commands.\n\nDalec can also create minimal container images with just runtime dependencies, no source code building required. This is perfect for creating lightweight containers with only the packages you need.\n\nHere‚Äôs a minimal example that creates a container with curl and bash:\n- # syntax=ghcr.io/project-dalec/dalec/frontend:latest name: my-minimal-image version: 0.1.0 revision: \"1\" license: MIT description: A minimal image with only curl and shell access dependencies: runtime: curl: bash: image: entrypoint: /bin/bash\n\nBuild it with:\n- docker build -f my-minimal-image.yml --target=azlinux3 -t my-minimal-image:0.1.0 .\n\nThis produces a minimal image built from scratch containing only curl, bash, and their dependencies.\n\n**Pro tip:** You can skip creating a spec file entirely by passing dependencies on the command line:\n- docker build -t my-minimal-image:0.1.0 --build-arg BUILDKIT\\_SYNTAX=ghcr.io/project-dalec/dalec/frontend:latest --target=azlinux3/container/depsonly -\n\nLearn more in the [Container-only builds documentation](https://project-dalec.github.io/dalec/container-only-builds).\n\n## Getting Started\n\nReady to build your first package and container image? The [Dalec Quickstart](https://project-dalec.github.io/dalec/quickstart) walks you through building go-md2man, a real-world example that demonstrates:\n\n- Creating a declarative YAML specification\n- Building RPM and DEB packages\n- Creating minimal container images\n- Multi-architecture builds\n\nThe quickstart shows how a single spec can produce packages for multiple distributions (Azure Linux, Ubuntu, Debian) and architectures (x86\\_64, ARM64) using standard docker build commands.\n\n## CI/CD Integration\n\nDalec integrates seamlessly into any CI/CD system that supports Docker, including GitHub Actions, GitLab CI, Jenkins, and cloud-native build systems. Since Dalec builds use standard docker build commands, no special runners or build agents are required‚Äîjust a standard Docker environment.\n\nThanks to BuildKit, Dalec can also build directly on Kubernetes clusters using the [Kubernetes driver](https://docs.docker.com/build/builders/drivers/kubernetes/). This enables scalable, cloud-native builds without requiring dedicated build VMs, making it ideal for large-scale CI/CD pipelines.\n\nThis makes it easy to:\n\n- Build and publish packages on every release\n- Generate multi-architecture artifacts in parallel\n- Integrate SBOM generation and signing into your pipeline\n- Push containers to any OCI-compliant registry\n- Scale builds elastically on Kubernetes infrastructure\n\n## Supply Chain Security\n\n### SBOM and Provenance Attestations\n\nBuildKit provides integrated support for Software Bill of Materials (SBOM) generation and provenance attestations. SBOMs automatically catalog every package and dependency in your build, providing complete transparency into what‚Äôs inside your artifacts. Provenance attestations are cryptographically-signed records that prove how your image was built, including the source repository, build parameters, and execution environment. This enables verification throughout your deployment pipeline. Learn more about configuring these features in the [BuildKit attestations documentation](https://docs.docker.com/build/metadata/attestations/).\n\n### Package Signing\n\nDalec supports GPG [signing of packages](https://project-dalec.github.io/dalec/signing) for additional trust and verification:\n\n``` package_config: signer: frontend: image: ```\n\nSigned packages ensure recipients can verify authenticity and detect tampering.\n\n## Conclusion\n\nDalec provides a modern, declarative approach to building system packages and containers. By leveraging Docker BuildKit as a frontend, it eliminates the need for complex build toolchains while providing secure builds across multiple Linux distributions.\n\nFor open-source projects that need to distribute both packages and containers, Dalec offers a unified build process that simplifies CI/CD while strengthening supply chain security.\n\nWhether you‚Äôre migrating from traditional RPM spec files, consolidating Dockerfiles, or building a new project from scratch, Dalec provides the simplicity of modern container tools with the flexibility of native package formats.\n\n## Get Started\n\nReady to try Dalec? You‚Äôre just one docker build command away:\n\n1. **Explore the documentation**: [project-dalec.github.io/dalec](https://project-dalec.github.io/dalec/)\n2. **Try the** [**quickstart tutorial**](https://project-dalec.github.io/dalec/quickstart): Build your first package and container\n3. **Browse examples**: See real-world specs in the [examples directory](https://github.com/Azure/dalec/tree/main/docs/examples)\n4. **Join the community**: Connect with us in the [#dalec](https://cloud-native.slack.com/archives/C09MHVDGMAB) channel on [CNCF Slack](https://communityinviter.com/apps/cloud-native/cncf)\n5. **Contribute**: Dalec is an open-source project under the CNCF. Contributions are welcome! Check out the [contributing guide](https://github.com/project-dalec/dalec/blob/main/CONTRIBUTING.md) to get involved",
  "ProcessedDate": "2025-10-29 21:07:17",
  "Tags": [],
  "PubDate": "2025-10-29T20:33:52+00:00",
  "FeedLevelAuthor": "rss.livelink.threads-in-node"
}
