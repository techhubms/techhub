{
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=dotnet",
  "Link": "https://techcommunity.microsoft.com/t5/app-development/how-to-decouple-views-from-view-models-using-communitytoolkit/m-p/4432591#M1261",
  "Tags": [],
  "OutputDir": "_community",
  "FeedName": "Microsoft Tech Community",
  "ProcessedDate": "2025-08-08 15:42:09",
  "Title": "How to decouple views from view models using CommunityToolKit.mvvm",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "EnhancedContent": "I am writing my first MVVM app using CommunityTookit.mvvm.  I am using as reference the Micrsoft Learning link https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/ioc.  This link shows the setting of the viewmodel to the view DataContext using the following statement in the view's .cs file:\n\nthis.DataContext = App.Current.Services.GetService&lt;ContactsViewModel&gt;();\n\nThe problem with this as I see it is that this statement couples the view to the view model, in this case ContactsViewModel.  This means that in another app the view cannot be used with another viewmodel without modifying the view, i.e. changing ContactsViewModel above to another viewmodel type.  This means that the view cannot be stored in a common library that is shared among different apps.\n\nThere is a C# Corner example with the older MVVM TookKit that solved this problem using a ViewModelLocator class.  This project is found https://www.c-sharpcorner.com/article/getting-started-with-mvvm-light-with-wpf/.  The solution is to put the following code in the view's XAML file:\n\nDataContext=\"{Binding Main, Source={StaticResource Locator}}\"\n\nThe source object for the binding is found by looking for a ResourceDictionary that is in the scope of the view and which has an entry whose key is \"Locator\".  In app.xaml which by definition is always in scope we have:\n\n&lt;Application.Resources&gt; &lt;ResourceDictionary&gt; &lt;vm:ViewModelLocator x:Key=\"Locator\" d:IsDataSource=\"True\" /&gt; &lt;/ResourceDictionary&gt; &lt;/Application.Resources&gt;\n\nThe Dictionary element with key \"Locator\" is an object of type ViewModelLocator.   In the ViewModelLocator class there is a Main property that always returns an instance of MainViewModel:\n\npublic MainViewModel Main { get { return ServiceLocator.Current.GetInstance&lt;MainViewModel&gt;(); } }\n\nIn our example, the view's DataContext binds to the Main property of the ViewModelLocator object. The value of the Main property is a MainViewModel object and this becomes the DataContext of the view.\n\nWe can now in a different app re-use the view without changing it.  All we have to do in the next app is to create a different ViewModelLocator object that specifies a different viewmodel in its Main property.  The view is now completely decoupled from the view model.\n\nMy question is, how would we de-couple the view from the view model using the CommunityToolkit.Mvvm?  Do we also use a ViewModelLocator class?  Is there a more elegant way with dependency injection?\n\nAnother question I have is, suppose we want to use in one app the same view twice with different view models.  An example of where we might want to do this is if we had a view that displayed a chart.  It is conceivable that we might want to have more than one view model display its data using the same chart view.  I cannot see how to do this in either of the above Microsoft or C# Corner examples.",
  "Author": "CSharpDev",
  "PubDate": "2025-07-12T17:03:00+00:00",
  "Description": "I am writing my first MVVM app using CommunityTookit.mvvm. I am using as reference the Micrsoft Learning link [here](https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/ioc). This link shows the setting of the viewmodel to the view DataContext using the following statement in the view's .cs file:\n\nthis.DataContext = App.Current.Services.GetService();\n\nThe problem with this as I see it is that this statement couples the view to the view model, in this case ContactsViewModel. This means that in another app the view cannot be used with another viewmodel without modifying the view, i.e. changing ContactsViewModel above to another viewmodel type. This means that the view cannot be stored in a common library that is shared among different apps.\n\nThere is a C# Corner example with the older MVVM TookKit that solved this problem using a ViewModelLocator class. This project is found [here](https://www.c-sharpcorner.com/article/getting-started-with-mvvm-light-with-wpf/). The solution is to put the following code in the view's XAML file:\n\nDataContext=\"{Binding Main, Source={StaticResource Locator}}\"\n\nThe source object for the binding is found by looking for a ResourceDictionary that is in the scope of the view and which has an entry whose key is \"Locator\". In app.xaml which by definition is always in scope we have:\n\nThe Dictionary element with key \"Locator\" is an object of type ViewModelLocator. In the ViewModelLocator class there is a Main property that always returns an instance of MainViewModel:\n\npublic MainViewModel Main { get { return ServiceLocator.Current.GetInstance(); } }\n\nIn our example, the view's DataContext binds to the Main property of the ViewModelLocator object. The value of the Main property is a MainViewModel object and this becomes the DataContext of the view.\n\nWe can now in a different app re-use the view without changing it. All we have to do in the next app is to create a different ViewModelLocator object that specifies a different viewmodel in its Main property. The view is now completely decoupled from the view model.\n\nMy question is, how would we de-couple the view from the view model using the CommunityToolkit.Mvvm? Do we also use a ViewModelLocator class? Is there a more elegant way with dependency injection?\n\nAnother question I have is, suppose we want to use in one app the same view twice with different view models. An example of where we might want to do this is if we had a view that displayed a chart. It is conceivable that we might want to have more than one view model display its data using the same chart view. I cannot see how to do this in either of the above Microsoft or C# Corner examples."
}
