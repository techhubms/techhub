{
  "Tags": [],
  "Author": "greenie-msft",
  "ProcessedDate": "2025-09-25 12:24:02",
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/openai-agent-sdk-integration-with-azure-durable-functions/ba-p/4453402",
  "FeedName": "Microsoft Tech Community",
  "PubDate": "2025-09-25T12:00:00+00:00",
  "Title": "OpenAI Agent SDK Integration with Azure Durable Functions",
  "Description": "**Picture this**: Your agent authored with the OpenAI Agent SDK is halfway through analyzing 10,000 customer reviews when it hits a rate limit and dies. All that progress? Gone. Your multi-agent workflow that took 30 minutes to orchestrate? Back to square one because of a rate limit throttle.\n\nIf you've deployed AI agents in production, you probably know this frustration first-hand. Today, we're announcing a solution that makes your agents **reliable**: OpenAI Agent SDK Integration with Azure Durable Functions. This integration provides automatic state persistence, enabling your agents to survive any failure and continue exactly where they stopped. No more lost progress, no more starting over, just reliable agents that work.\n\n## **The Challenge with AI Agents**\n\nBuilding AI agents that work reliably in production environments has proven to be one of the most significant challenges in modern AI development. As agent sophistication increases with complex workflows involving multiple LLM calls, tool executions, and agent hand-offs, the likelihood of encountering failures increases.\n\nThis creates a fundamental problem for production AI systems where reliability is **essential**.\n\nCommon failure scenarios include:\n\n- **Rate Limiting**: Agents halt mid-process when hitting API rate limits during LLM calls\n- **Network Timeouts**: workflows terminate due to connectivity issues\n- **System Crashes**: Multi-agent systems fail when individual components encounter errors\n- **State Loss**: Complex workflows restart from the beginning after any interruption\n\nTraditional approaches force developers to choose between building complex retry logic with significant code changes or accepting unreliable agent behavior. Neither option is suitable for production-grade AI systems that businesses depend on and that’s why we’re introducing this integration.\n\n## **Key Benefits of the OpenAI Agent SDK Integration with Azure Durable Functions**\n\nOur solution leverages durable execution value propositions to address these reliability challenges while preserving the familiar OpenAI Agents Python SDK developer experience. The integration enables agent invocations hosted on Azure Functions to run within durable orchestration contexts where both agent LLM calls and tool calls are executed as durable operations.\n\nThis integration delivers significant advantages for production AI systems such as:\n\n- **Enhanced Agent Resilience**- Built-in retry mechanisms for LLM calls and tool executions enable agents to automatically recover from failures and continue from their last successful step\n- **Multi-Agent Orchestration Reliability**- Individual agent failures don't crash entire multi-agent workflows, and complex orchestrations maintain state across system restarts\n- **Built-in Observability**- Monitor agent progress through the Durable Task Scheduler dashboard with enhanced debugging and detailed execution tracking (only applicable when using the Durable Task Scheduler as the Durable Function backend).\n- **Seamless Developer Experience**- Keep using the OpenAI Agents SDK interface you already know with minimal code changes required to add reliability\n- **Distributed Compute and Scalability –** Agent workflow automatically scale across multiple compute instances.\n\n### **Core Integration Components:**\n\nThese powerful capabilities are enabled through just a few simple additions to your AI application:\n\n- **durable\\_openai\\_agent\\_orchestrator**: Decorator that enables durable execution for agent invocations\n- **run\\_sync**: Uses an existing OpenAI Agents SDK API that executes your agent with built-in durability\n- **create\\_activity\\_tool**: Wraps tool calls as durable activities with automatic retry capabilities\n- **State Persistence**: Maintains agentic workflow state across failures and restarts\n\n## **Hello World Example**\n\nLet's see how this works in practice. Here's what code written using the OpenAI Agent SDK looks like:\n\n- import asyncio\nfrom agents import Agent, Runner\n\nasync def main(): agent = Agent( name=\"Assistant\", instructions=\"You only respond in haikus.\", )\n\nresult = await Runner.run(agent, \"Tell me about recursion in programming.\") print(result.final\\_output)\n\nWith our added durable integration, it becomes:\n- from agents import Agent, Runner\n\n@app.orchestration\\_trigger(context\\_name=\"context\") @app.durable\\_openai\\_agent\\_orchestrator # Runs the agent invocation in the context of a durable orchestration def hello\\_world(context): agent = Agent( name=\"Assistant\", instructions=\"You only respond in haikus.\", )\n\nresult = Runner.run\\_sync(agent, \"Tell me about recursion in programming.\") # Provides synchronous execution with built-in durability return result.final\\_output\n\n![]()The Durable Task Scheduler dashboard showcasing the agent LLM call as a durable operation\n\nNotice how little actually changed. We added **[app​](javascript:void%280%29).** **durable\\_openai\\_agent\\_orchestrator** decorator but your core agent logic stays the same. The **run\\_sync\\*** method provides execution with built-in durability, enabling your agents to automatically recover from failures with minimal code changes.\n\nWhen using the Durable Task Scheduler as your Durable Functions backend, you gain access to a detailed monitoring dashboard that provides visibility into your agent executions. The dashboard displays detailed inputs and outputs for both LLM calls and tool invocations, along with clear success/failure indicators, making it straightforward to diagnose and troubleshoot any unexpected behavior in your agent processes.\n\n> >\n> A note about **'run\\_sync'**\n> > >\n> In Durable Functions, orchestrators don’t usually benefit from invoking code asynchronously because their role is to define the workflow—tracking state, scheduling activities, and so on—not to perform actual work. When you call an activity, the framework records the decision and suspends the orchestrator until the result is ready. For example, when you call run\\_sync, the deterministic part of the call completes almost instantly, and the LLM call activity is scheduled for asynchronous execution. Adding extra asynchronous code inside the orchestrator doesn’t improve performance; it only breaks determinism and complicates replay.\n> >\n\n## **Reliable Tool Invocation Example**\n\nFor agents requiring tool interactions, there are two implementation approaches. The first option uses the **@function\\_tool decorator** from the Open AI Agent SDK, which executes directly within the context of the durable orchestration. When using this approach, your tool functions must follow durable functions orchestration deterministic constraints. Additionally, since these functions run within the orchestration itself, they may be replayed as part of normal operations, making cost-conscious implementation necessary.\n- from agents import Agent, Runner, function\\_tool\n\nclass Weather(BaseModel): city: str temperature\\_range: str conditions: str\n\n@function\\_tool def get\\_weather(city: str) -> Weather: \"\"\"Get the current weather information for a specified city.\"\"\" print(\"[debug] get\\_weather called\") return Weather( city=city, temperature\\_range=\"14-20C\", conditions=\"Sunny with wind.\" )\n\n@app.orchestration\\_trigger(context\\_name=\"context\") @app.durable\\_openai\\_agent\\_orchestrator def tools(context): agent = Agent( name=\"Hello world\", instructions=\"You are a helpful agent.\", tools=[get\\_weather], )\n\nresult = Runner.run\\_sync(agent, input=\"What's the weather in Tokyo?\") return result.final\\_output\n\nThe second approach uses the **create\\_activity\\_tool** function, which is designed for non-deterministic code or scenarios where rerunning the tool is expensive (in terms of performance or cost). This approach executes the tool within the context of a durable orchestration activity, providing enhanced monitoring through the Durable Task Scheduler dashboard and ensuring that expensive operations are not unnecessarily repeated during orchestration replays.\n- from agents import Agent, Runner, function\\_tool\n\nclass Weather(BaseModel): city: str temperature\\_range: str conditions: str\n\n@app.orchestration\\_trigger(context\\_name=\"context\") @app.durable\\_openai\\_agent\\_orchestrator def weather\\_expert(context): agent = Agent( name=\"Hello world\", instructions=\"You are a helpful agent.\", tools=[ context.create\\_activity\\_tool(get\\_weather) ], )\n\nresult = Runner.run\\_sync(agent, \"What is the weather in Tokio?\") return result.final\\_output\n\n@app.activity\\_trigger(input\\_name=\"city\") async def get\\_weather(city: str) -> Weather: weather = Weather( city=city, temperature\\_range=\"14-20C\", conditions=\"Sunny with wind.\" ) return weather\n\n## **Leveraging Durable Functions Stateful App Patterns**\n\nBeyond basic durability of agents, this integration provides access to the full Durable Functions orchestration context, enabling developers to implement sophisticated stateful application patterns when needed, such as:\n\n- **External Event Handling**: Use **context.wait\\_for\\_external\\_event()** for human approvals, external system callbacks, or time-based triggers\n- **Fan-out/Fan-in**: Coordinate multiple tasks (including sub orchestrations invoking agents) in parallel.\n- **Long-running Workflows**: Implement workflows that span hours, days, or weeks with persistent state\n- **Conditional Logic**: Build dynamic agent workflows based on runtime decisions and external inputs\n\n### **Human Interaction and Approval Workflows Example**\n\nFor scenarios requiring human oversight, you can leverage the orchestration context to implement approval workflows:\n- .durable\\_openai\\_agent\\_orchestrator\ndef agent\\_with\\_approval(context):\n# Run initial agent analysis\nagent = Agent(name=\"DataAnalyzer\", instructions=\"Analyze the provided dataset\") initial\\_result = Runner.run\\_sync(agent, context.get\\_input())\n\n# Wait for human approval before proceeding\napproval\\_event = context.wait\\_for\\_external\\_event(\"approval\\_received\")\n\nif approval\\_event.get(\"approved\"):\n# Continue with next phase\nfinal\\_agent = Agent(name=\"Reporter\", instructions=\"Generate final report\") final\\_result = Runner.run\\_sync(final\\_agent, initial\\_result.final\\_output) return final\\_result.final\\_output else: return \"Workflow cancelled by user\"\n\nThis flexibility allows you to build sophisticated agentic applications that combine the power of AI agents with enterprise-grade workflow orchestration patterns, all while maintaining the familiar OpenAI Agents SDK experience.\n\n## **Get Started Today**\n\nThis article only scratches the surface of what's possible with the OpenAI Agent SDK integration for Durable Functions The combination of familiar OpenAI Agents SDK patterns with added reliability opens new possibilities for building sophisticated AI systems that can handle real-world production workloads.\n\nThe integration is designed for a smooth onboarding experience. Begin by selecting one of your existing agents and applying the transformation patterns demonstrated above (often requiring just a few lines of code changes).\n\n**Documentation**: [https://aka.ms/openai-agents-with-reliability-docs](https://aka.ms/openai-agents-with-reliability-docs)\n\n**Sample Applications**: [https://aka.ms/openai-agents-with-reliability-samples](https://aka.ms/openai-agents-with-reliability-samples)",
  "EnhancedContent": "## Make your agents resilient to failures and interruptions, so they remain reliable in production environments and critical business scenarios.\n\n**Picture this**: Your agent authored with the OpenAI Agent SDK is halfway through analyzing 10,000 customer reviews when it hits a rate limit and dies. All that progress? Gone. Your multi-agent workflow that took 30 minutes to orchestrate? Back to square one because of a rate limit throttle.\n\nIf you've deployed AI agents in production, you probably know this frustration first-hand. Today, we're announcing a solution that makes your agents **reliable**: OpenAI Agent SDK Integration with Azure Durable Functions. This integration provides automatic state persistence, enabling your agents to survive any failure and continue exactly where they stopped. No more lost progress, no more starting over, just reliable agents that work.\n\n## **The Challenge with AI Agents**\n\nBuilding AI agents that work reliably in production environments has proven to be one of the most significant challenges in modern AI development. As agent sophistication increases with complex workflows involving multiple LLM calls, tool executions, and agent hand-offs, the likelihood of encountering failures increases.\n\nThis creates a fundamental problem for production AI systems where reliability is **essential**.\n\nCommon failure scenarios include:\n\n- **Rate Limiting**: Agents halt mid-process when hitting API rate limits during LLM calls\n- **Network Timeouts**: workflows terminate due to connectivity issues\n- **System Crashes**: Multi-agent systems fail when individual components encounter errors\n- **State Loss**: Complex workflows restart from the beginning after any interruption\n\nTraditional approaches force developers to choose between building complex retry logic with significant code changes or accepting unreliable agent behavior. Neither option is suitable for production-grade AI systems that businesses depend on and that’s why we’re introducing this integration.\n\n## **Key Benefits of the OpenAI Agent SDK Integration with Azure Durable Functions**\n\nOur solution leverages durable execution value propositions to address these reliability challenges while preserving the familiar OpenAI Agents Python SDK developer experience. The integration enables agent invocations hosted on Azure Functions to run within durable orchestration contexts where both agent LLM calls and tool calls are executed as durable operations.\n\nThis integration delivers significant advantages for production AI systems such as:\n\n- **Enhanced Agent Resilience**- Built-in retry mechanisms for LLM calls and tool executions enable agents to automatically recover from failures and continue from their last successful step\n- **Multi-Agent Orchestration Reliability**- Individual agent failures don't crash entire multi-agent workflows, and complex orchestrations maintain state across system restarts\n- **Built-in Observability**- Monitor agent progress through the Durable Task Scheduler dashboard with enhanced debugging and detailed execution tracking (only applicable when using the Durable Task Scheduler as the Durable Function backend).\n- **Seamless Developer Experience**- Keep using the OpenAI Agents SDK interface you already know with minimal code changes required to add reliability\n- **Distributed Compute and Scalability –** Agent workflow automatically scale across multiple compute instances.\n\n### **Core Integration Components:**\n\nThese powerful capabilities are enabled through just a few simple additions to your AI application:\n\n- **durable\\_openai\\_agent\\_orchestrator**: Decorator that enables durable execution for agent invocations\n- **run\\_sync**: Uses an existing OpenAI Agents SDK API that executes your agent with built-in durability\n- **create\\_activity\\_tool**: Wraps tool calls as durable activities with automatic retry capabilities\n- **State Persistence**: Maintains agentic workflow state across failures and restarts\n\n## **Hello World Example**\n\nLet's see how this works in practice. Here's what code written using the OpenAI Agent SDK looks like:\n\n``` import asyncio from agents import Agent, Runner\n\nasync def main(): agent = Agent( name=\"Assistant\", instructions=\"You only respond in haikus.\", )\n\nresult = await Runner.run(agent, \"Tell me about recursion in programming.\") print(result.final_output) ```\n\nWith our added durable integration, it becomes:\n\n``` from agents import Agent, Runner\n\n@app.orchestration_trigger(context_name=\"context\") @app.durable_openai_agent_orchestrator # Runs the agent invocation in the context of a durable orchestration def hello_world(context): agent = Agent( name=\"Assistant\", instructions=\"You only respond in haikus.\", )\n\nresult = Runner.run_sync(agent, \"Tell me about recursion in programming.\") # Provides synchronous execution with built-in durability return result.final_output ```\n\nThe Durable Task Scheduler dashboard showcasing the agent LLM call as a durable operation\n\nNotice how little actually changed. We added **[app​](javascript:void%280%29).** **durable\\_openai\\_agent\\_orchestrator** decorator but your core agent logic stays the same. The **run\\_sync\\*** method provides execution with built-in durability, enabling your agents to automatically recover from failures with minimal code changes.\n\nWhen using the Durable Task Scheduler as your Durable Functions backend, you gain access to a detailed monitoring dashboard that provides visibility into your agent executions. The dashboard displays detailed inputs and outputs for both LLM calls and tool invocations, along with clear success/failure indicators, making it straightforward to diagnose and troubleshoot any unexpected behavior in your agent processes.\n\n> >\n> A note about **'run\\_sync'**\n> > >\n> In Durable Functions, orchestrators don’t usually benefit from invoking code asynchronously because their role is to define the workflow—tracking state, scheduling activities, and so on—not to perform actual work. When you call an activity, the framework records the decision and suspends the orchestrator until the result is ready. For example, when you call run\\_sync, the deterministic part of the call completes almost instantly, and the LLM call activity is scheduled for asynchronous execution. Adding extra asynchronous code inside the orchestrator doesn’t improve performance; it only breaks determinism and complicates replay.\n> >\n\n## **Reliable Tool Invocation Example**\n\nFor agents requiring tool interactions, there are two implementation approaches. The first option uses the **@function\\_tool decorator** from the Open AI Agent SDK, which executes directly within the context of the durable orchestration. When using this approach, your tool functions must follow durable functions orchestration deterministic constraints. Additionally, since these functions run within the orchestration itself, they may be replayed as part of normal operations, making cost-conscious implementation necessary.\n\n``` from agents import Agent, Runner, function_tool\n\nclass Weather(BaseModel): city: str temperature_range: str conditions: str\n\n@function_tool def get_weather(city: str) -> Weather: \"\"\"Get the current weather information for a specified city.\"\"\" print(\"[debug] get_weather called\") return Weather( city=city, temperature_range=\"14-20C\", conditions=\"Sunny with wind.\" )\n\n@app.orchestration_trigger(context_name=\"context\") @app.durable_openai_agent_orchestrator def tools(context): agent = Agent( name=\"Hello world\", instructions=\"You are a helpful agent.\", tools=[get_weather], )\n\nresult = Runner.run_sync(agent, input=\"What's the weather in Tokyo?\") return result.final_output ```\n\nThe second approach uses the **create\\_activity\\_tool**function, which is designed for non-deterministic code or scenarios where rerunning the tool is expensive (in terms of performance or cost). This approach executes the tool within the context of a durable orchestration activity, providing enhanced monitoring through the Durable Task Scheduler dashboard and ensuring that expensive operations are not unnecessarily repeated during orchestration replays.\n\n``` from agents import Agent, Runner, function_tool\n\nclass Weather(BaseModel): city: str temperature_range: str conditions: str\n\n@app.orchestration_trigger(context_name=\"context\") @app.durable_openai_agent_orchestrator def weather_expert(context): agent = Agent( name=\"Hello world\", instructions=\"You are a helpful agent.\", tools=[ context.create_activity_tool(get_weather) ], )\n\nresult = Runner.run_sync(agent, \"What is the weather in Tokio?\") return result.final_output\n\n@app.activity_trigger(input_name=\"city\") async def get_weather(city: str) -> Weather: weather = Weather( city=city, temperature_range=\"14-20C\", conditions=\"Sunny with wind.\" ) return weather ```\n\n## **Leveraging Durable Functions Stateful App Patterns**\n\nBeyond basic durability of agents, this integration provides access to the full Durable Functions orchestration context, enabling developers to implement sophisticated stateful application patterns when needed, such as:\n\n- **External Event Handling**: Use **context.wait\\_for\\_external\\_event()** for human approvals, external system callbacks, or time-based triggers\n- **Fan-out/Fan-in**: Coordinate multiple tasks (including sub orchestrations invoking agents) in parallel.\n- **Long-running Workflows**: Implement workflows that span hours, days, or weeks with persistent state\n- **Conditional Logic**: Build dynamic agent workflows based on runtime decisions and external inputs\n\n### **Human Interaction and Approval Workflows Example**\n\nFor scenarios requiring human oversight, you can leverage the orchestration context to implement approval workflows:\n\n``` .durable_openai_agent_orchestrator def agent_with_approval(context):\n# Run initial agent analysis\nagent = Agent(name=\"DataAnalyzer\", instructions=\"Analyze the provided dataset\") initial_result = Runner.run_sync(agent, context.get_input())\n\n# Wait for human approval before proceeding\napproval_event = context.wait_for_external_event(\"approval_received\")\n\nif approval_event.get(\"approved\"):\n# Continue with next phase\nfinal_agent = Agent(name=\"Reporter\", instructions=\"Generate final report\") final_result = Runner.run_sync(final_agent, initial_result.final_output) return final_result.final_output else: return \"Workflow cancelled by user\" ```\n\nThis flexibility allows you to build sophisticated agentic applications that combine the power of AI agents with enterprise-grade workflow orchestration patterns, all while maintaining the familiar OpenAI Agents SDK experience.\n\n## **Get Started Today**\n\nThis article only scratches the surface of what's possible with the OpenAI Agent SDK integration for Durable Functions The combination of familiar OpenAI Agents SDK patterns with added reliability opens new possibilities for building sophisticated AI systems that can handle real-world production workloads.\n\nThe integration is designed for a smooth onboarding experience. Begin by selecting one of your existing agents and applying the transformation patterns demonstrated above (often requiring just a few lines of code changes).\n\n**Documentation**: [https://aka.ms/openai-agents-with-reliability-docs](https://aka.ms/openai-agents-with-reliability-docs)\n\n**Sample Applications**: [https://aka.ms/openai-agents-with-reliability-samples](https://aka.ms/openai-agents-with-reliability-samples)\n\nUpdated Sep 25, 2025\n\nVersion 1.0\n\n[azure functions](/tag/azure%20functions?nodeId=board%3AAppsonAzureBlog)\n\n[durable functions](/tag/durable%20functions?nodeId=board%3AAppsonAzureBlog)\n\n[serverless](/tag/serverless?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[greenie-msft&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0xMzk5MjY2LTUyNTIxM2k0OUQzOTZENThENDM5NjVG?image-dimensions=50x50)](/users/greenie-msft/1399266) [greenie-msft](/users/greenie-msft/1399266) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined May 24, 2022\n\n[View Profile](/users/greenie-msft/1399266)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "OutputDir": "_community",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure"
}
