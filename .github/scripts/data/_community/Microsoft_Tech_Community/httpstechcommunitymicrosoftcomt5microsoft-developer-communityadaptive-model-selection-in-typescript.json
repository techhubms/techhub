{
  "ProcessedDate": "2025-11-11 08:05:21",
  "PubDate": "2025-11-11T08:00:00+00:00",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "EnhancedContent": "Model Router (preview) in Azure AI Foundry gives you a single chat deployment that *intelligently selects* an underlying model—small, large, or reasoning—per prompt. Instead of hard‑coding \"which model?\" decisions, you send one request and let the router optimize for capability and cost. In this blog, we will explore what the Model Router is, why to use it, how to implement it in TypeScript, versioning and monitoring strategies.\n\n## What Is the Model Router?\n\nModel Router is a deployable chat model in Azure AI Foundry that routes each prompt to the most suitable underlying chat or reasoning model (for example: gpt‑4.1-mini, gpt‑4.1-nano, o4-mini, gpt‑5 variants etc). You interact with it exactly like a standard Chat Completions deployment—same endpoint shape, almost similar response schema, and the `model` field in the response here reveals which underlying model actually produced the answer.\n\nKey architectural simplifications:\n\n- Single deployment: one set of content filtering and rate limits covers all underlying models.\n- Dynamic model choice: cheaper models for simple prompts, reasoning models when complexity warrants.\n- Future flexibility: newer underlying models appear with *Auto-update* enabled.\n\n## Why use the Model Router\n\n1. **Cost Efficiency:** Avoid overpaying by defaulting every prompt to a large reasoning model.\n2. **Operational Simplicity:** One deployment, one name in configuration, unified logging.\n3. **Performance Balance:** Get higher reasoning capacity only when needed.\n4. **Version Agility:** A less manual update path when Auto-update is set at deployment.\n5. **Observability:** Response JSON’s `model` field lets you split metrics by underlying models to build routing distribution dashboards.\n\nTake a scenario where a global SAAS platform supports three workloads:\n\n1. *Customer Support Triage:* Receives short classification prompts → router picks nano/mini models → low cost.\n2. *Developer Knowledge Assistant:* Occasionally consists of complex code reasoning → router escalates to o4-mini / gpt‑5 reasoning only when needed.\n3. *Strategic Analytics Q&A:* For deep analytical queries → router selects higher reasoning tier; fewer but more expensive calls.\n\n*Expected Impact:* By not defaulting workload #1 - Customer Support Triage to a fixed large reasoning model, monthly LLM spend drops while workloads #2 - Developer Knowledge Assistant & #3 - Strategic Analytics Q&A still gain high-quality answers when complexity triggers upscale routing to models designed for reasoning.\n\n## How to use it (TypeScript)\n\n### Pre-requisites\n\n- An Azure AI Foundry project\n- Model Router model deployment\n\nSet up your *endpoint* and *key*. In this example, we use the Azure Inference SDK and authenticate via API key for simplicity.\n\n> >\n> Go with the recommended Microsoft Entra ID (Managed Identity) authentication in production.\n> >\n\nA link to the full sample repo will be provided at the end of this blog, but here’s a minimal explanation of the core logic.\n\n``` const client = ModelClient(endpoint, new AzureKeyCredential(key));\n\nconst messages = [ { role: \"system\", content: \"You are a helpful assistant.\" }, { role: \"user\", content: \"Give me a concise 5-bullet travel safety list for solo backpacking in South America.\" } ];\n\nconst response = await client.path(\"/chat/completions\").post({ body: { model: \"model-router\", messages, max_tokens: 512, temperature: 0.7, top_p: 0.95 } });\n\nconsole.log(\"Model chosen by the router:\", (response as any).body?.model ?? \"(unknown)\"); console.log(\"Model response:\", (response as any).body?.choices?.[0]?.message?.content); console.log(\"Usage:\", (response as any).body?.usage); ```\n\nIn the above code:\n\n- We create a client with the mode-router endpoint and key.\n- We prepare a chat message array containing a system prompt and a single user prompt.\n- We send a POST request to `/chat/completions` with our request body with generation parameters.\n- From the response, we extract the `model` field to see which underlying model was selected by the router, along with the generated content and usage statistics.\n\nExpect an output similar to:\n\nOutput in terminal after running an API call through the model-router. Model chosen by the router: gpt-5-mini-2025-08-07\n\nIn a multi-turn conversation, you would observe the router potentially selecting different underlying models for each turn based on the evolving context and complexity of the conversation.\n\nSome recommended steps for multi-turn conversations include trimming chat history to control token growth (cost and context window limits)\n\n```\n\nfunction trimHistory(messages: ChatMessage[], maxHistoryTurns: number): ChatMessage[] { if (messages.length <= 1) return messages; const head = messages.slice(0, 1); // preserve system message const body = messages.slice(1); const keep = maxHistoryTurns * 2; // user message + assistant response pairs return [...head, ...body.slice(-keep)]; } ```\n\nExpected output:\n\nDifferent models being selected by model router based on prompt complexity\n\n## Versioning & Monitoring\n\n> >\n> Each router version maps to a fixed set of underlying models + versions. Upgrading the router could shift cost profiles, latency, and context window outcomes for the underlying models.\n> >\n\nUpgrade policy options (for standard deployments):\n\n- ***OnceNewDefaultVersionAvailable*** (auto upgrade soon after default changes)\n- ***OnceCurrentVersionExpired*** (upgrade at retirement boundary; default if policy isn't set)\n- ***NoAutoUpgrade*** (never auto; you must manually update or usage stops at retirement)\n\nA recommended approach:\n\n- ***Dev/Test:*** Enable auto-update to quickly assess improvements.\n- ***Staging:*** Compare token usage & routing distribution (e.g., percentage of reasoning models) before scaling.\n- ***Prod:*** Scale after regression checks (e.g., latency & cost KPIs).\n\nUse Azure Monitor and Application Insights to track routing distribution and performance metrics by filtering on your router deployment name and splitting by underlying model. In Cost Analysis, you can use the resource tag ‘Deployment’ to isolate router consumption based on KPIs like percentage of reasoning models used vs non-reasoning models, average tokens per turn etc.\n\n## Known Limitations\n\n- **Context Window Variability.** API calls with large prompts may fail if routed to a smaller-window model. To mitigate this, summarize/ truncate prompts before passing into the model to reduce input size.\n- **Parameter Dropping for Reasoning Models.** Parameters like *temperature*, *top\\_p*, don't apply to reasoning models because these models prioritize internal deterministic and multi-step reasoning processes over randomness. To mitigate this, specify critical control parameters via prompt engineering instead of relying on these parameters for output variability.\n- **Unsupported Modalities.** Model router currently only supports Text/ Image input and Text output. If your application requires audio or other modalities, you will need to process those requests separately.\n- **Latency Spikes.** Expect larger reasoning models to incur higher processing time compared to the smaller model alternatives. For this reason, monitor latency metrics and implement fallback mechanisms for time-sensitive workloads. For example, you could set up a circuit breaker that routes requests to a default cheaper & smaller model if latency exceeds a certain threshold.\n\n## Resources\n\n- Code examples (Python & TypeScript): [https://github.com/Azure-Samples/insideAIF/tree/main/Samples/Model-Router](https://github.com/Azure-Samples/insideAIF/tree/main/Samples/Model-Router)\n- Model Router How-To: [https://learn.microsoft.com/azure/ai-foundry/openai/how-to/model-router](https://learn.microsoft.com/azure/ai-foundry/openai/how-to/model-router)\n- Model Router Concepts: [https://learn.microsoft.com/azure/ai-foundry/openai/concepts/model-router](https://learn.microsoft.com/azure/ai-foundry/openai/concepts/model-router)\n- Working With Models (Version Upgrade Options): [https://learn.microsoft.com/azure/ai-foundry/openai/how-to/working-with-models](https://learn.microsoft.com/azure/ai-foundry/openai/how-to/working-with-models)\n- Quotas & Limits (Router rate limits, context guidance): [https://learn.microsoft.com/azure/ai-foundry/openai/quotas-limits](https://learn.microsoft.com/azure/ai-foundry/openai/quotas-limits)\n- Models Catalog (Router region availability & capabilities): [https://learn.microsoft.com/azure/ai-foundry/openai/concepts/models#model-router](https://learn.microsoft.com/azure/ai-foundry/openai/concepts/models#model-router)\n- Reasoning Models (parameter support differences): [https://learn.microsoft.com/azure/ai-foundry/openai/how-to/reasoning](https://learn.microsoft.com/azure/ai-foundry/openai/how-to/reasoning)\n\nUpdated Oct 30, 2025\n\nVersion 1.0\n\n[ai](/tag/ai?nodeId=board%3AAzureDevCommunityBlog)\n\n[azure ai foundry](/tag/azure%20ai%20foundry?nodeId=board%3AAzureDevCommunityBlog)\n\n[llm](/tag/llm?nodeId=board%3AAzureDevCommunityBlog)\n\n[!\\[Julia_Muiruri&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0xMzgyMDcyLTQ5NzkwN2k5QkM2MEJCQzA5ODNDN0Iy?image-dimensions=50x50)](/users/julia_muiruri/1382072) [Julia_Muiruri](/users/julia_muiruri/1382072) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined May 05, 2022\n\n[View Profile](/users/julia_muiruri/1382072)\n\n/category/azure/blog/azuredevcommunityblog [Microsoft Developer Community Blog](/category/azure/blog/azuredevcommunityblog) Follow this blog board to get notified when there's new activity",
  "Description": "Model Router (preview) in Azure AI Foundry gives you a single chat deployment that *intelligently selects* an underlying model—small, large, or reasoning—per prompt. Instead of hard‑coding \"which model?\" decisions, you send one request and let the router optimize for capability and cost. In this blog, we will explore what the Model Router is, why to use it, how to implement it in TypeScript, versioning and monitoring strategies.\n\n## What Is the Model Router?\n\nModel Router is a deployable chat model in Azure AI Foundry that routes each prompt to the most suitable underlying chat or reasoning model (for example: gpt‑4.1-mini, gpt‑4.1-nano, o4-mini, gpt‑5 variants etc). You interact with it exactly like a standard Chat Completions deployment—same endpoint shape, almost similar response schema, and the `model` field in the response here reveals which underlying model actually produced the answer.\n\nKey architectural simplifications:\n\n- Single deployment: one set of content filtering and rate limits covers all underlying models.\n- Dynamic model choice: cheaper models for simple prompts, reasoning models when complexity warrants.\n- Future flexibility: newer underlying models appear with *Auto-update* enabled.\n\n## Why use the Model Router\n\n1. **Cost Efficiency:** Avoid overpaying by defaulting every prompt to a large reasoning model.\n2. **Operational Simplicity:** One deployment, one name in configuration, unified logging.\n3. **Performance Balance:** Get higher reasoning capacity only when needed.\n4. **Version Agility:** A less manual update path when Auto-update is set at deployment.\n5. **Observability:** Response JSON’s `model` field lets you split metrics by underlying models to build routing distribution dashboards.\n\nTake a scenario where a global SAAS platform supports three workloads:\n\n1. *Customer Support Triage:* Receives short classification prompts → router picks nano/mini models → low cost.\n2. *Developer Knowledge Assistant:* Occasionally consists of complex code reasoning → router escalates to o4-mini / gpt‑5 reasoning only when needed.\n3. *Strategic Analytics Q&A:* For deep analytical queries → router selects higher reasoning tier; fewer but more expensive calls.\n\n*Expected Impact:* By not defaulting workload #1 - Customer Support Triage to a fixed large reasoning model, monthly LLM spend drops while workloads #2 - Developer Knowledge Assistant & #3 - Strategic Analytics Q&A still gain high-quality answers when complexity triggers upscale routing to models designed for reasoning.\n\n## How to use it (TypeScript)\n\n### Pre-requisites\n\n- An Azure AI Foundry project\n- Model Router model deployment\n\nSet up your *endpoint* and *key*. In this example, we use the Azure Inference SDK and authenticate via API key for simplicity.\n\n> >\n> Go with the recommended Microsoft Entra ID (Managed Identity) authentication in production.\n> >\n\nA link to the full sample repo will be provided at the end of this blog, but here’s a minimal explanation of the core logic.\n\n- const client = ModelClient(endpoint, new AzureKeyCredential(key));\n\nconst messages = [ { role: \"system\", content: \"You are a helpful assistant.\" }, { role: \"user\", content: \"Give me a concise 5-bullet travel safety list for solo backpacking in South America.\" } ];\n\nconst response = await client.path(\"/chat/completions\").post({ body: { model: \"model-router\", messages, max\\_tokens: 512, temperature: 0.7, top\\_p: 0.95 } });\n\nconsole.log(\"Model chosen by the router:\", (response as any).body?.model ?? \"(unknown)\"); console.log(\"Model response:\", (response as any).body?.choices?.[0]?.message?.content); console.log(\"Usage:\", (response as any).body?.usage);\n\nIn the above code:\n\n- We create a client with the mode-router endpoint and key.\n- We prepare a chat message array containing a system prompt and a single user prompt.\n- We send a POST request to `/chat/completions` with our request body with generation parameters.\n- From the response, we extract the `model` field to see which underlying model was selected by the router, along with the generated content and usage statistics.\n\nExpect an output similar to:\n\n![]()Output in terminal after running an API call through the model-router. Model chosen by the router: gpt-5-mini-2025-08-07\n\nIn a multi-turn conversation, you would observe the router potentially selecting different underlying models for each turn based on the evolving context and complexity of the conversation.\n\nSome recommended steps for multi-turn conversations include trimming chat history to control token growth (cost and context window limits)\n- function trimHistory(messages: ChatMessage[], maxHistoryTurns: number): ChatMessage[] {\nif (messages.length\n\nExpected output:\n\n![]()Different models being selected by model router based on prompt complexity\n\n## Versioning & Monitoring\n\n> >\n> Each router version maps to a fixed set of underlying models + versions. Upgrading the router could shift cost profiles, latency, and context window outcomes for the underlying models.\n> >\n\nUpgrade policy options (for standard deployments):\n\n- ***OnceNewDefaultVersionAvailable*** (auto upgrade soon after default changes)\n- ***OnceCurrentVersionExpired*** (upgrade at retirement boundary; default if policy isn't set)\n- ***NoAutoUpgrade*** (never auto; you must manually update or usage stops at retirement)\n\nA recommended approach:\n\n- ***Dev/Test:*** Enable auto-update to quickly assess improvements.\n- ***Staging:*** Compare token usage & routing distribution (e.g., percentage of reasoning models) before scaling.\n- ***Prod:*** Scale after regression checks (e.g., latency & cost KPIs).\n\nUse Azure Monitor and Application Insights to track routing distribution and performance metrics by filtering on your router deployment name and splitting by underlying model. In Cost Analysis, you can use the resource tag ‘Deployment’ to isolate router consumption based on KPIs like percentage of reasoning models used vs non-reasoning models, average tokens per turn etc.\n\n## Known Limitations\n\n- **Context Window Variability.** API calls with large prompts may fail if routed to a smaller-window model. To mitigate this, summarize/ truncate prompts before passing into the model to reduce input size.\n- **Parameter Dropping for Reasoning Models.** Parameters like *temperature*, *top\\_p*, don't apply to reasoning models because these models prioritize internal deterministic and multi-step reasoning processes over randomness. To mitigate this, specify critical control parameters via prompt engineering instead of relying on these parameters for output variability.\n- **Unsupported Modalities.** Model router currently only supports Text/ Image input and Text output. If your application requires audio or other modalities, you will need to process those requests separately.\n- **Latency Spikes.** Expect larger reasoning models to incur higher processing time compared to the smaller model alternatives. For this reason, monitor latency metrics and implement fallback mechanisms for time-sensitive workloads. For example, you could set up a circuit breaker that routes requests to a default cheaper & smaller model if latency exceeds a certain threshold.\n\n## Resources\n\n- Code examples (Python & TypeScript): [https://github.com/Azure-Samples/insideAIF/tree/main/Samples/Model-Router](https://github.com/Azure-Samples/insideAIF/tree/main/Samples/Model-Router)\n- Model Router How-To: [https://learn.microsoft.com/azure/ai-foundry/openai/how-to/model-router](https://learn.microsoft.com/azure/ai-foundry/openai/how-to/model-router)\n- Model Router Concepts: [https://learn.microsoft.com/azure/ai-foundry/openai/concepts/model-router](https://learn.microsoft.com/azure/ai-foundry/openai/concepts/model-router)\n- Working With Models (Version Upgrade Options): [https://learn.microsoft.com/azure/ai-foundry/openai/how-to/working-with-models](https://learn.microsoft.com/azure/ai-foundry/openai/how-to/working-with-models)\n- Quotas & Limits (Router rate limits, context guidance): [https://learn.microsoft.com/azure/ai-foundry/openai/quotas-limits](https://learn.microsoft.com/azure/ai-foundry/openai/quotas-limits)\n- Models Catalog (Router region availability & capabilities): [https://learn.microsoft.com/azure/ai-foundry/openai/concepts/models#model-router](https://learn.microsoft.com/azure/ai-foundry/openai/concepts/models#model-router)\n- Reasoning Models (parameter support differences): [https://learn.microsoft.com/azure/ai-foundry/openai/how-to/reasoning](https://learn.microsoft.com/azure/ai-foundry/openai/how-to/reasoning)",
  "Link": "https://techcommunity.microsoft.com/t5/microsoft-developer-community/adaptive-model-selection-in-typescript-with-the-model-router/ba-p/4465192",
  "OutputDir": "_community",
  "Author": "Julia_Muiruri",
  "Tags": [],
  "Title": "Adaptive Model Selection in TypeScript with the Model Router",
  "FeedName": "Microsoft Tech Community"
}
