{
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Description": "Picture Carl, a Data Analyst, asked to prepare a comparison of mean petal length across Iris species. Instead of manually writing SQL and charting logic, he prompts an internal GPT-5 Agent: “Compute species-level means, then visualize petal length.” Behind the scenes, his Agentic workflow has two **custom tools:**\n\n- ***sql\\_exec\\_csv** –* accepts **raw SQL** and returns CSV results from an Iris dataset.\n- ***code\\_exec\\_javascript** –* executes raw JavaScript inside a hardened vm sandbox, parsing the CSV and rendering *iris\\_plot.svg*.\n\nGPT-5 emits a SQL query (that's not wrapped in JSON), receives CSV output, generates JavaScript code that builds a chart, and finally summarizes the workflow—all in a handful of turns. This smooth, multi-tool flow is enabled by **GPT-5’s FreeForm (custom) tool calling.**\n\n## What Is FreeForm?\n\nFreeForm (custom) tool calling allows GPT-5 to issue tool invocations whose payload is arbitrary unstructured raw text - SQL queries, Python scripts, JavaScript programs, Bash, config files, without being bound to JSON arguments conforming to a defined schema.\n\nTraditional structured function calling solves reliable argument passing workloads but introduces friction for code-heavy and DSL-heavy workflows. You'd have to wrap code inside JSON strings, escape characters, then unpack and execute. With Freeform tool calling, you eliminate this round trip by registering a tool with ***{ \"type\": \"custom\" }*** and GPT-5 can emit the exact text payload the tool expects - without the JSON envelope.\n\n### Why does this matter?\n\n- **No schema friction:** The model speaks in the tool's native language allowing you to run what it produces, rather than parsing JSON to recover string values.\n- **Improved intermediate reasoning**: Freeform output lets GPT-5 interleave natural-language commentary, raw code, and tool calls in a single response.\n- **Multi-step chaining:** Each tool output re-enters the conversation as plain text, and GPT-5 can reason on it directly.\n\n| **Dimension** | **Structured Function Tools (JSON Schema)** | **FreeForm Custom Tools** | | --- | --- | --- | | Payload Shape | ```<br>Example { \"name\":\"fn\",<br>```<br><br><br><br>```<br> \"arguments\":{...}<br>```<br><br><br><br>```<br>}<br>``` | Raw text (code/query/script) | | Validation | Automatic via schema (types, required) | Semantic validation implemented in executor | | Parsing Overhead | JSON parsing + argument mapping | Minimal (string pass-through) | | Ease of Tool Evolution | Schema changes would require code and prompt updates | Only need to update tool/ prompt descriptions | | Readability in Logs (Observability) | Nested JSON obscures code | Natural language | | Chaining Complexity | Each step returns JSON that must be parsed | Directly feed raw output back for the model to reason over | | Errors | JSON malformed or missing required fields | Runtime execution errors | | Application | <ol><br><li>When strict argument validation is required. Schema enforces shape & type (Ex. Deterministic APIs)</li><br><br><li>When downstream systems auto-ingest structured data</li><br><br></ol> | <ol><br><li>When payload is primarily executable code. Skip JSON wrapping overhead especially when it adds no validation value</li><br><br></ol> | | Tool discoverability | Model matches tool name, description and the expected schema | Model matches tool name and description |\n\n### When ***Not*** to Use FreeForm\n\n- When **strict validation is required** (Ex. financial transaction parameters, coordinates, PII-handling flags).\n- For **complex nested data** (arrays of objects, deeply nested configs) where schema ensures shape.\n- For **mass extraction tasks** where consistent JSON accelerates downstream parsing.\n\n> >\n> Note: Depending on the scenario, you can implement a hybrid design to use structured tools for parameter selection and strict validation, then pass to custom (freeform) tools for code/ query execution.\n> >\n\n## Implementation breakdown - How Carl's Iris workflow is assembled\n\n### Pre-requisites\n\n1. Azure AI Foundry project\n2. GPT-5 model deployment - *v1 API is required to access the latest model features*\n\nA link to the full sample code will be provided at the end of this blog, but here’s a minimal explanation of the core logic.\n\nUser prompt asking the model to produce SQL/ JavaScript as code blocks: -\n\n1. > Write SQL to compute mean of sepal\\_length, sepal\\_width, petal\\_length, petal\\_width grouped by species. Return a tidy CSV with species and the four means (rounded to 2 decimals).\n2. > Then write JavaScript to read that CSV string (provided as tool output), pretty-print a table, and produce a bar chart of mean petal\\_length by species.\n\n**Tool registry:** Two custom tools are defined for the Responses API:\n\n- ```\nsql_exec_csv ```\n\nWraps an in-memory Iris dataset and returns CSV for SELECT queries, including a specialized path for group-by averages.\n\n- ```\ncode_exec_javascript ```\n\nExecutes Node.js-compatible JavaScript inside a hardened vm context, capturing console output and rendering SVG charts via helper utilities.\n\n![]()Tools configuration of type custom - sql\\_exec\\_csv and code\\_exec\\_javascript\n\n**SQL Query generation and execution**: First, the model generates the raw SQL query ...\n\n![]()GPT-5 generated raw SQL query following the prompt\n\n... then it explicitly asks to call the *sql\\_exec\\_csv* tool, passing in the full SQL string as the payload.\n\nIn structured function calling, you’d expect to see JSON input like:\n\n``` \"arguments\": \"{\\\"query\\\":\\\"SELECT ...\\\"}\" ```\n\nbut in freeform tool calling, our custom tool isn't restricted to formatting the input in a JSON wrapper. Instead, it executes the raw SQL and returns a tidy CSV with the mean values rounded to 2 decimals, which is then wrapped in a *function\\_call\\_output* and inserted back into the conversation to feed into the context.\n\n![]()sql\\_exec\\_function executes the SQL from the model and returns CSV\n\n**JavaScript Code Execution:** GPT-5 calls the *code\\_exec\\_javascript* tool to parse the CSV, pretty-print a table in the console, create and save the chart visual. The model provides full executable code as the tool argument there being no schema to tell it what fields to send. It simply writes the program\n\n![]()The JS code is executed using code\\_exec\\_javascript code\n\nOur output is a mix of the requested result and commentary from the model\n\n![]()Output including a console table, commentary from GPT-5 and the location of the chart file![]()The generated chart file\n\nGPT-5 FreeForm tool calling elevates agentic development with less schema scaffolding, more expressive multi-step execution, and execute deterministically. Combined with Azure AI Foundry’s enterprise-grade governance stack, developers can prototype analytical workflows (like Carl's Iris example) and harden them for production quickly.\n\n## Resources\n\n1. [Unlocking GPT-5’s Freeform Tool Calling: A New Era of Seamless Integration](https://devblogs.microsoft.com/foundry/unlocking-gpt-5s-freeform-tool-calling-a-new-era-of-seamless-integration/)\n2. [Free‑Form Function Calling - OpenAI Cookbook](https://cookbook.openai.com/examples/gpt-5/gpt-5_new_params_and_tools#2-freeform-function-calling)\n3. [Python & TypeScript Code examples](https://github.com/Azure-Samples/insideAIF/tree/main/Samples/Freeform-Tool-Calling)",
  "Link": "https://techcommunity.microsoft.com/t5/microsoft-developer-community/gpt-5-freeform-tool-calling-in-typescript-on-azure-ai-foundry/ba-p/4469682",
  "Tags": [],
  "Author": "Julia_Muiruri",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "EnhancedContent": "Picture Carl, a Data Analyst, asked to prepare a comparison of mean petal length across Iris species. Instead of manually writing SQL and charting logic, he prompts an internal GPT-5 Agent: “Compute species-level means, then visualize petal length.” Behind the scenes, his Agentic workflow has two **custom tools:**\n\n- ***sql\\_exec\\_csv** –* accepts **raw SQL** and returns CSV results from an Iris dataset.\n- ***code\\_exec\\_javascript** –* executes raw JavaScript inside a hardened vm sandbox, parsing the CSV and rendering *iris\\_plot.svg*.\n\nGPT-5 emits a SQL query (that's not wrapped in JSON), receives CSV output, generates JavaScript code that builds a chart, and finally summarizes the workflow—all in a handful of turns. This smooth, multi-tool flow is enabled by **GPT-5’s FreeForm (custom) tool calling.**\n\n## What Is FreeForm?\n\nFreeForm (custom) tool calling allows GPT-5 to issue tool invocations whose payload is arbitrary unstructured raw text - SQL queries, Python scripts, JavaScript programs, Bash, config files, without being bound to JSON arguments conforming to a defined schema.\n\nTraditional structured function calling solves reliable argument passing workloads but introduces friction for code-heavy and DSL-heavy workflows. You'd have to wrap code inside JSON strings, escape characters, then unpack and execute. With Freeform tool calling, you eliminate this round trip by registering a tool with ***{ \"type\": \"custom\" }*** and GPT-5 can emit the exact text payload the tool expects - without the JSON envelope.\n\n### Why does this matter?\n\n- **No schema friction:** The model speaks in the tool's native language allowing you to run what it produces, rather than parsing JSON to recover string values.\n- **Improved intermediate reasoning**: Freeform output lets GPT-5 interleave natural-language commentary, raw code, and tool calls in a single response.\n- **Multi-step chaining:** Each tool output re-enters the conversation as plain text, and GPT-5 can reason on it directly.\n\n| **Dimension** | **Structured Function Tools (JSON Schema)** | **FreeForm Custom Tools** | | --- | --- | --- | | Payload Shape | ```<br>Example { \"name\":\"fn\",<br>```<br><br><br><br>```<br> \"arguments\":{...}<br>```<br><br><br><br>```<br>}<br>``` | Raw text (code/query/script) | | Validation | Automatic via schema (types, required) | Semantic validation implemented in executor | | Parsing Overhead | JSON parsing + argument mapping | Minimal (string pass-through) | | Ease of Tool Evolution | Schema changes would require code and prompt updates | Only need to update tool/ prompt descriptions | | Readability in Logs (Observability) | Nested JSON obscures code | Natural language | | Chaining Complexity | Each step returns JSON that must be parsed | Directly feed raw output back for the model to reason over | | Errors | JSON malformed or missing required fields | Runtime execution errors | | Application | <ol><br><li>When strict argument validation is required. Schema enforces shape &amp; type (Ex. Deterministic APIs)</li><br><br><li>When downstream systems auto-ingest structured data</li><br><br></ol> | <ol><br><li>When payload is primarily executable code. Skip JSON wrapping overhead especially when it adds no validation value</li><br><br></ol> | | Tool discoverability | Model matches tool name, description and the expected schema | Model matches tool name and description |\n\n### When ***Not*** to Use FreeForm\n\n- When **strict validation is required** (Ex. financial transaction parameters, coordinates, PII-handling flags).\n- For **complex nested data** (arrays of objects, deeply nested configs) where schema ensures shape.\n- For **mass extraction tasks** where consistent JSON accelerates downstream parsing.\n\n> >\n> Note: Depending on the scenario, you can implement a hybrid design to use structured tools for parameter selection and strict validation, then pass to custom (freeform) tools for code/ query execution.\n> >\n\n## Implementation breakdown - How Carl's Iris workflow is assembled\n\n### Pre-requisites\n\n1. Azure AI Foundry project\n2. GPT-5 model deployment - *v1 API is required to access the latest model features*\n\nA link to the full sample code will be provided at the end of this blog, but here’s a minimal explanation of the core logic.\n\nUser prompt asking the model to produce SQL/ JavaScript as code blocks: -\n\n1. > Write SQL to compute mean of sepal\\_length, sepal\\_width, petal\\_length, petal\\_width grouped by species. Return a tidy CSV with species and the four means (rounded to 2 decimals).\n2. > Then write JavaScript to read that CSV string (provided as tool output), pretty-print a table, and produce a bar chart of mean petal\\_length by species.\n\n**Tool registry:** Two custom tools are defined for the Responses API:\n\n- ```\nsql_exec_csv ```\n\nWraps an in-memory Iris dataset and returns CSV for SELECT queries, including a specialized path for group-by averages.\n\n- ```\ncode_exec_javascript ```\n\nExecutes Node.js-compatible JavaScript inside a hardened vm context, capturing console output and rendering SVG charts via helper utilities.\n\nTools configuration of type custom - sql\\_exec\\_csv and code\\_exec\\_javascript\n\n**SQL Query generation and execution**: First, the model generates the raw SQL query ...\n\nGPT-5 generated raw SQL query following the prompt\n\n... then it explicitly asks to call the *sql\\_exec\\_csv* tool, passing in the full SQL string as the payload.\n\nIn structured function calling, you’d expect to see JSON input like:\n\n``` \"arguments\": \"{\\\"query\\\":\\\"SELECT ...\\\"}\" ```\n\nbut in freeform tool calling, our custom tool isn't restricted to formatting the input in a JSON wrapper. Instead, it executes the raw SQL and returns a tidy CSV with the mean values rounded to 2 decimals, which is then wrapped in a *function\\_call\\_output* and inserted back into the conversation to feed into the context.\n\nsql\\_exec\\_function executes the SQL from the model and returns CSV\n\n**JavaScript Code Execution:** GPT-5 calls the *code\\_exec\\_javascript* tool to parse the CSV, pretty-print a table in the console, create and save the chart visual. The model provides full executable code as the tool argument there being no schema to tell it what fields to send. It simply writes the program\n\nThe JS code is executed using code\\_exec\\_javascript code\n\nOur output is a mix of the requested result and commentary from the model\n\nOutput including a console table, commentary from GPT-5 and the location of the chart fileThe generated chart file\n\nGPT-5 FreeForm tool calling elevates agentic development with less schema scaffolding, more expressive multi-step execution, and execute deterministically. Combined with Azure AI Foundry’s enterprise-grade governance stack, developers can prototype analytical workflows (like Carl's Iris example) and harden them for production quickly.\n\n## Resources\n\n1. [Unlocking GPT-5’s Freeform Tool Calling: A New Era of Seamless Integration](https://devblogs.microsoft.com/foundry/unlocking-gpt-5s-freeform-tool-calling-a-new-era-of-seamless-integration/)\n2. [Free‑Form Function Calling - OpenAI Cookbook](https://cookbook.openai.com/examples/gpt-5/gpt-5_new_params_and_tools#2-freeform-function-calling)\n3. [Python & TypeScript Code examples](https://github.com/Azure-Samples/insideAIF/tree/main/Samples/Freeform-Tool-Calling)\n\nUpdated Nov 14, 2025\n\nVersion 1.0\n\n[azure ai foundry](/tag/azure%20ai%20foundry?nodeId=board%3AAzureDevCommunityBlog)\n\n[!\\[Julia_Muiruri&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0xMzgyMDcyLTQ5NzkwN2k5QkM2MEJCQzA5ODNDN0Iy?image-dimensions=50x50)](/users/julia_muiruri/1382072) [Julia_Muiruri](/users/julia_muiruri/1382072) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined May 05, 2022\n\n[View Profile](/users/julia_muiruri/1382072)\n\n/category/azure/blog/azuredevcommunityblog [Microsoft Developer Community Blog](/category/azure/blog/azuredevcommunityblog) Follow this blog board to get notified when there's new activity",
  "PubDate": "2025-11-19T18:29:45+00:00",
  "ProcessedDate": "2025-11-19 19:04:57",
  "OutputDir": "_community",
  "FeedName": "Microsoft Tech Community",
  "Title": "GPT-5 FreeForm Tool Calling in TypeScript on Azure AI Foundry"
}
