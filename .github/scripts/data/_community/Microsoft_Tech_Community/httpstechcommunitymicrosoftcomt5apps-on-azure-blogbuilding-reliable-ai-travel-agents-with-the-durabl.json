{
  "ProcessedDate": "2025-12-18 19:06:16",
  "Tags": [],
  "FeedName": "Microsoft Tech Community",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "PubDate": "2025-12-18T18:35:34+00:00",
  "EnhancedContent": "## AI agents that remember everything across failures, coordinate like a well-rehearsed team, and cost nothing while waiting for human input.\n\nThe [durable task extension for Microsoft Agent Framework](https://learn.microsoft.com/agent-framework/user-guide/agents/agent-types/durable-agent/create-durable-agent) makes all this possible.\n\nIn this post, we'll walk through the [AI Travel Planner](https://github.com/Azure-Samples/durable-agents-travel-planner), a C# application I built that demonstrates how to build reliable, scalable multi-agent applications using the durable task extension for Microsoft agent framework. While I work on the python version, I've included code snippets that show the python equivalent.\n\nIf you haven't already seen the announcement post on the durable task extension for Microsoft Agent Framework, I suggest you read that first before continuing with this post: [http://aka.ms/durable-extension-for-af-blog.](http://aka.ms/durable-extension-for-af-blog)\n\nIn brief, production AI agents face real challenges: crashes can lose conversation history, unpredictable behavior makes debugging difficult, human-in-the-loop workflows require waiting without wasting resources, and variable demand needs flexible scaling. The durable task extension addresses each of these:\n\n- **Serverless Hosting:**Deploy agents on Azure Functions with auto-scaling from thousands of instances to zero, while retaining full control in a serverless architecture.\n- **Automatic Session Management**: Agents maintain persistent sessions with full conversation context that survives process crashes, restarts, and distributed execution across instances\n- **Deterministic Multi-Agent Orchestrations**: Coordinate specialized durable agents with predictable, repeatable, code-driven execution patterns\n- **Human-in-the-Loop with Serverless Cost Savings**: Pause for human input without consuming compute resources or incurring costs\n- **Built-in Observability with Durable Task Scheduler**: Deep visibility into agent operations and orchestrations through the Durable Task Scheduler UI dashboard\n\n## **AI Travel Planner Architecture Overview**\n\nThe Travel Planner application takes user trip preferences and starts a workflow that orchestrates three specialized agent framework agents (a **Destination Recommender**, an **Itinerary Planner**, and a **Local Recommender**) to build a comprehensive, personalized travel plan.\n\nOnce a travel plan is created, the workflow includes human-in-the-loop approval before booking the trip (mocked), showcasing how the durable task extension handles long-running operations easily:\n\n### **Application Workflow**\n\n1. **User Request:** User submits travel preferences via React frontend\n2. **Orchestration Scheduled:** Azure Functions backend receives the request and schedules a deterministic agentic workflow using the Durable Task Extension for Agent Framework.\n3. **Destination Recommendation:** The orchestrator first coordinates the Destination Recommender agent to analyze preferences and suggest destinations\n4. **Itinerary Planning and Local** **Recommendations:** The orchestrator then parallelizes the invocation of the Itinerary Planner agent to create detailed day-by-day plans for the given destination and the Local Recommendations agent to add insider tips and attractions\n5. **Storage:** Created travel plan is saved to Azure Blob Storage\n6. **Approval:** User reviews and approves the plan (human-in-the-loop)\n7. **Booking:** Upon approval, booking of the trip completes\n\n### **Key Components**\n\n- **Azure Static Web Apps:** Hosts the React frontend\n- **Azure Functions (.NET 9):** Serverless compute hosting the agents and workflow with automatic scaling\n- **Durable Task Extension for Microsoft Agent Framework:** The AI agent SDK with durable task extension\n- **Durable Task Scheduler:** Manages state persistence, orchestration, and observability\n- **Azure OpenAI (GPT-4o-mini):** Powers the AI agents\n\nNow let’s dive into the code. Along the way, I’ll highlight the value the durable task extension brings and patterns you can apply to your own applications.\n\n## **Creating** **Durable Agents**\n\nMaking the standard Agent Framework agents durable agents is simple. Include the durable task extension package and register your agents within the **ConfigureDurableAgents**extension method and you automatically get:\n\n- Persistent conversation sessions that survive restarts\n- HTTP endpoints for agent interactions\n- Automatic state checkpointing that survive restarts\n- Distributed execution across instances\n\n#### C#\n\n``` FunctionsApplication .CreateBuilder(args) .ConfigureDurableAgents(configure => { configure.AddAIAgentFactory(\"DestinationRecommenderAgent\", sp => chatClient.CreateAIAgent( instructions: \"You are a travel destination expert...\", name: \"DestinationRecommenderAgent\", services: sp));\n\nconfigure.AddAIAgentFactory(\"ItineraryPlannerAgent\", sp => chatClient.CreateAIAgent( instructions: \"You are a travel itinerary planner...\", name: \"ItineraryPlannerAgent\", services: sp, tools: [AIFunctionFactory.Create(CurrencyConverterTool.ConvertCurrency)]));\n\nconfigure.AddAIAgentFactory(\"LocalRecommendationsAgent\", sp => chatClient.CreateAIAgent( instructions: \"You are a local expert...\", name: \"LocalRecommendationsAgent\", services: sp)); });\n\n```\n\n#### Python\n\n```\n# Create the Azure OpenAI chat client\nchat_client = AzureOpenAIChatClient( endpoint=endpoint, deployment_name=deployment_name, credential=DefaultAzureCredential() )\n\n# Destination Recommender Agent\ndestination_recommender_agent = chat_client.create_agent( name=\"DestinationRecommenderAgent\", instructions=\"You are a travel destination expert...\" )\n\n# Itinerary Planner Agent (with tools)\nitinerary_planner_agent = chat_client.create_agent( name=\"ItineraryPlannerAgent\", instructions=\"You are a travel itinerary planner...\", tools=[get_exchange_rate, convert_currency] )\n\n# Local Recommendations Agent\nlocal_recommendations_agent = chat_client.create_agent( name=\"LocalRecommendationsAgent\", instructions=\"You are a local expert...\" )\n\n# Configure Function App with Durable Agents. AgentFunctionApp is where the magic happens\napp = AgentFunctionApp(agents=[ destination_recommender_agent, itinerary_planner_agent, local_recommendations_agent ]) ```\n\n## **The Orchestration Programming Model**\n\nThe durable task extension uses an intuitive async/await programming model for deterministic orchestration. You write orchestration logic as ordinary imperative code (if/else, try/catch), and the framework handles all the complexity of coordination, durability, retries, and distributed execution.\n\n### **The Travel Planner Orchestration**\n\nHere's the actual orchestration from the application that coordinates all three agents, runs tasks in parallel, handles human approval, and books the trip:\n\n#### C#\n\n``` [Function(nameof(RunTravelPlannerOrchestration))] public async Task<TravelPlanResult> RunTravelPlannerOrchestration( [OrchestrationTrigger] TaskOrchestrationContext context) { var travelRequest = context.GetInput<TravelRequest>()!;\n\n// Get durable agents and create conversation threads DurableAIAgent destinationAgent = context.GetAgent(\"DestinationRecommenderAgent\"); DurableAIAgent itineraryAgent = context.GetAgent(\"ItineraryPlannerAgent\"); DurableAIAgent localAgent = context.GetAgent(\"LocalRecommendationsAgent\");\n\n// Step 1: Get destination recommendations var destinations = await destinationAgent.RunAsync<DestinationRecommendations>( $\"Recommend destinations for {travelRequest.Preferences}\", destinationAgent.GetNewThread());\n\nvar topDestination = destinations.Result.Recommendations.First();\n\n// Steps 2 & 3: Run itinerary and local recommendations IN PARALLEL var itineraryTask = itineraryAgent.RunAsync<TravelItinerary>( $\"Create itinerary for {topDestination.Name}\", itineraryAgent.GetNewThread());\n\nvar localTask = localAgent.RunAsync<LocalRecommendations>( $\"Local recommendations for {topDestination.Name}\", localAgent.GetNewThread());\n\nawait Task.WhenAll(itineraryTask, localTask);\n\n// Step 4: Save to blob storage await context.CallActivityAsync(nameof(SaveTravelPlanToBlob), travelPlan);\n\n// Step 5: Wait for human approval (NO COMPUTE COSTS while waiting!) var approval = await context.WaitForExternalEvent<ApprovalResponse>( \"ApprovalEvent\", TimeSpan.FromDays(7));\n\n// Step 6: Book if approved if (approval.Approved) await context.CallActivityAsync(nameof(BookTrip), travelPlan);\n\nreturn new TravelPlanResult(travelPlan, approval.Approved); } ```\n\n#### Python\n\n``` app.orchestration_trigger(context_name=\"context\") def travel_planner_orchestration(context: df.DurableOrchestrationContext): travel_request_data = context.get_input() travel_request = TravelRequest(**travel_request_data)\n\n# Get durable agents and create conversation threads\ndestination_agent = app.get_agent(context, \"DestinationRecommenderAgent\") itinerary_agent = app.get_agent(context, \"ItineraryPlannerAgent\") local_agent = app.get_agent(context, \"LocalRecommendationsAgent\")\n\n# Step 1: Get destination recommendations\ndestinations_result = yield destination_agent.run( messages=f\"Recommend destinations for {travel_request.preferences}\", thread=destination_agent.get_new_thread(), response_format=DestinationRecommendations ) destinations = cast(DestinationRecommendations, destinations_result.value) top_destination = destinations.recommendations[0]\n\n# Steps 2 & 3: Run itinerary and local recommendations IN PARALLEL\nitinerary_task = itinerary_agent.run( messages=f\"Create itinerary for {top_destination.destination_name}\", thread=itinerary_agent.get_new_thread(), response_format=Itinerary ) local_task = local_agent.run( messages=f\"Local recommendations for {top_destination.destination_name}\", thread=local_agent.get_new_thread(), response_format=LocalRecommendations )\n\nresults = yield context.task_all([itinerary_task, local_task]) itinerary = cast(Itinerary, results[0].value) local_recs = cast(LocalRecommendations, results[1].value)\n\n# Step 4: Save to blob storage\nyield context.call_activity(\"save_travel_plan_to_blob\", travel_plan)\n\n# Step 5: Wait for human approval (NO COMPUTE COSTS while waiting!)\napproval_task = context.wait_for_external_event(\"ApprovalEvent\") timeout_task = context.create_timer( context.current_utc_datetime + timedelta(days=7))\n\nwinner = yield context.task_any([approval_task, timeout_task])\n\nif winner == approval_task: timeout_task.cancel() approval = approval_task.result\n\n# Step 6: Book if approved\nif approval.get(\"approved\"): yield context.call_activity(\"book_trip\", travel_plan)\n\nreturn TravelPlanResult(plan=travel_plan, approved=approval.get(\"approved\"))\n\nreturn TravelPlanResult(plan=travel_plan, approved=False) ```\n\nNotice how the orchestration combines:\n\n- **Agent calls** (await agent.RunAsync(...)) for AI-driven decisions\n- **Parallel execution** (Task.WhenAll) for running multiple agents concurrently\n- **Activity calls** (await context.CallActivityAsync(...)) for non-intelligent business tasks\n- **Human-in-the-loop** (await context.WaitForExternalEvent(...)) for approval workflows\n\nThe orchestration automatically checkpoints after each step. If a failure occurs, completed steps aren't re-executed. The orchestration resumes exactly where it left off, no need for manual intervention.\n\n## **Agent Patterns in Action**\n\n### **Agent Chaining: Sequential Handoffs**\n\nThe Travel Planner demonstrates **agent chaining** where the Destination Recommender's output feeds into both the Itinerary Planner and Local Recommendations agents:\n\n#### C#\n\n``` // Agent 1: Get destination recommendations var destinations = await destinationAgent.RunAsync<DestinationRecommendations>(prompt, thread); var topDestination = destinations.Result.Recommendations.First();\n\n// Agent 2: Create itinerary based on Agent 1's output var itinerary = await itineraryAgent.RunAsync<TravelItinerary>( $\"Create itinerary for {topDestination.Name}\", thread); ```\n\n#### Python\n\n```\n# Agent 1: Get destination recommendations\ndestinations_result = yield destination_agent.run( messages=prompt, thread=thread, response_format=DestinationRecommendations ) destinations = cast(DestinationRecommendations, destinations_result.value) top_destination = destinations.recommendations[0]\n\n# Agent 2: Create itinerary based on Agent 1's output\nitinerary_result = yield itinerary_agent.run( messages=f\"Create itinerary for {top_destination.destination_name}\", thread=thread, response_format=Itinerary ) itinerary = cast(Itinerary, itinerary_result.value) ```\n\n### **Agent Parallelization: Concurrent Execution**\n\nThe app runs the Itinerary Planner and Local Recommendations agents **in parallel** to reduce latency:\n\n#### C#\n\n``` // Launch both agent calls simultaneously var itineraryTask = itineraryAgent.RunAsync<TravelItinerary>(itineraryPrompt, thread1); var localTask = localAgent.RunAsync<LocalRecommendations>(localPrompt, thread2);\n\n// Wait for both to complete await Task.WhenAll(itineraryTask, localTask); ```\n\n#### Python\n\n```\n# Launch both agent calls simultaneously\nitinerary_task = itinerary_agent.run( messages=itinerary_prompt, thread=thread1, response_format=Itinerary ) local_task = local_agent.run( messages=local_prompt, thread=thread2, response_format=LocalRecommendations )\n\n# Wait for both to complete\nresults = yield context.task_all([itinerary_task, local_task])\n\nitinerary = cast(Itinerary, results[0].value) local_recs = cast(LocalRecommendations, results[1].value) ```\n\n### **Human-in-the-Loop: Approval Workflows**\n\nThe Travel Planner includes a complete human-in-the-loop pattern. After generating the travel plan, the workflow pauses for user approval:\n\n#### C#\n\n``` // Send approval request notification await context.CallActivityAsync(nameof(RequestApproval), travelPlan);\n\n// Wait for approval - NO COMPUTE COSTS OR LLM TOKENS while waiting! var approval = await context.WaitForExternalEvent<ApprovalResponse>( \"ApprovalEvent\", TimeSpan.FromDays(7));\n\nif (approval.Approved) await context.CallActivityAsync(nameof(BookTrip), travelPlan); ```\n\n#### Python\n\n```\n# Send approval request notification\nawait context.CallActivityAsync(nameof(RequestApproval), travelPlan);\n\n# Wait for approval - NO COMPUTE COSTS OR LLM TOKENS while waiting!\nvar approval = await context.WaitForExternalEvent<ApprovalResponse>( \"ApprovalEvent\", TimeSpan.FromDays(7));\n\nif (approval.Approved) await context.CallActivityAsync(nameof(BookTrip), travelPlan); ```\n\nThe API endpoint to handle approval responses:\n\n#### C#\n\n``` [Function(nameof(HandleApprovalResponse))] public async Task HandleApprovalResponse( [HttpTrigger(\"post\", Route = \"approve/{instanceId}\")] HttpRequestData req, string instanceId, [DurableClient] DurableTaskClient client) { var approval = await req.ReadFromJsonAsync<ApprovalResponse>(); await client.RaiseEventAsync(instanceId, \"ApprovalEvent\", approval); } ```\n\n#### Python\n\n``` app.function_name(name=\"ApproveTravelPlan\") app.route(route=\"travel-planner/approve/{instance_id}\", methods=[\"POST\"]) app.durable_client_input(client_name=\"client\") async def approve_travel_plan(req: func.HttpRequest, client) -> func.HttpResponse: instance_id = req.route_params.get(\"instance_id\") approval = req.get_json() await client.raise_event(instance_id, \"ApprovalEvent\", approval)\n\nreturn func.HttpResponse( json.dumps({\"message\": \"Approval processed\"}), status_code=200, mimetype=\"application/json\" ) ```\n\nThe workflow generates a complete travel plan and waits up to 7 days for user approval. During this entire waiting period, since we're hosting this application on the [Functions Flex Consumption plan](https://learn.microsoft.com/en-us/azure/azure-functions/flex-consumption-plan), the app scales down and zero compute resources or LLM tokens are consumed. When the user approves (or the timeout expires), the app scales back up and the orchestration automatically resumes with full context intact.\n\n## **Real-Time Monitoring with the Durable Task Scheduler**\n\nSince we're using the [Durable Task Scheduler](https://learn.microsoft.com/azure/azure-functions/durable/durable-task-scheduler/durable-task-scheduler) as the backend for our durable agents, we're provided with a built-in dashboard for monitoring our agents and orchestrations in real-time.\n\n### **Agent Thread Insights**\n\n- **Conversation history:** View complete conversation threads for each agent session, including all messages, tool calls, and agent decisions\n- **Task timing:** Monitor how long specific tasks and agent interactions take to complete\n\n### **Orchestration Insights**\n\n- **Multi-agent visualization:** See the execution flow across multiple agents with visual representation of parallel executions and branching\n- **Real-time monitoring:** Track active orchestrations, queued work items, and agent states\n- **Performance metrics:** Monitor response times, token usage, and orchestration duration\n\n### **Debugging Capabilities**\n\n- View structured inputs and outputs for activities, agents, and tool calls\n- Trace tool invocations and their outcomes\n- Monitor external event handling for human-in-the-loop scenarios\n\nThe dashboard enables you to understand exactly what your agents and workflows are doing, diagnose issues quickly, and optimize performance, all without adding custom logging to your code.\n\n## **Try The Travel Planner Application**\n\nThat’s it! That’s the gist of how the AI Travel Planner application is put together and some of the key components that it took to build it.\n\nI'd love for you to try the application out for yourself. It's fully instrumented with the Azure Developer CLI and Bicep, so you can deploy it to Azure with a few simple CLI commands.\n\n## **[Click here to try the AI Travel Planner sample](https://github.com/Azure-Samples/durable-agents-travel-planner)Python version coming soon!**\n\n## **Demo Video**\n\n## **Learn More**\n\n- [Durable Task Extension Overview](https://learn.microsoft.com/agent-framework/user-guide/agents/agent-types/durable-agent/create-durable-agent)\n- [Durable Agent Features](https://learn.microsoft.com/agent-framework/user-guide/agents/agent-types/durable-agent/features)\n- [Durable Task Scheduler](https://learn.microsoft.com/azure/azure-functions/durable/durable-task-scheduler/durable-task-scheduler)\n- [AI Travel Planner GitHub Repository](https://github.com/Azure-Samples/durable-agents-travel-planner)\n\nUpdated Dec 18, 2025\n\nVersion 4.0\n\n[azure functions](/tag/azure%20functions?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[greenie-msft&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0xMzk5MjY2LTUyNTIxM2k0OUQzOTZENThENDM5NjVG?image-dimensions=50x50)](/users/greenie-msft/1399266) [greenie-msft](/users/greenie-msft/1399266) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined May 24, 2022\n\n[View Profile](/users/greenie-msft/1399266)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "Author": "greenie-msft",
  "Title": "Building Reliable AI Travel Agents with the Durable Task Extension for Microsoft Agent Framework",
  "Description": "The [durable task extension for Microsoft Agent Framework](https://learn.microsoft.com/agent-framework/user-guide/agents/agent-types/durable-agent/create-durable-agent) makes all this possible.\n\nIn this post, we'll walk through the [AI Travel Planner](https://github.com/Azure-Samples/durable-agents-travel-planner), a C# application I built that demonstrates how to build reliable, scalable multi-agent applications using the durable task extension for Microsoft agent framework. While I work on the python version, I've included code snippets that show the python equivalent.\n\nIf you haven't already seen the announcement post on the durable task extension for Microsoft Agent Framework, I suggest you read that first before continuing with this post: [http://aka.ms/durable-extension-for-af-blog.](http://aka.ms/durable-extension-for-af-blog)\n\nIn brief, production AI agents face real challenges: crashes can lose conversation history, unpredictable behavior makes debugging difficult, human-in-the-loop workflows require waiting without wasting resources, and variable demand needs flexible scaling. The durable task extension addresses each of these:\n\n- **Serverless Hosting:** Deploy agents on Azure Functions with auto-scaling from thousands of instances to zero, while retaining full control in a serverless architecture.\n- **Automatic Session Management**: Agents maintain persistent sessions with full conversation context that survives process crashes, restarts, and distributed execution across instances\n- **Deterministic Multi-Agent Orchestrations**: Coordinate specialized durable agents with predictable, repeatable, code-driven execution patterns\n- **Human-in-the-Loop with Serverless Cost Savings**: Pause for human input without consuming compute resources or incurring costs\n- **Built-in Observability with Durable Task Scheduler**: Deep visibility into agent operations and orchestrations through the Durable Task Scheduler UI dashboard\n\n## **AI Travel Planner Architecture Overview**\n\n![]()\n\nThe Travel Planner application takes user trip preferences and starts a workflow that orchestrates three specialized agent framework agents (a **Destination Recommender**, an **Itinerary Planner**, and a **Local Recommender**) to build a comprehensive, personalized travel plan.\n\n![]()\n\nOnce a travel plan is created, the workflow includes human-in-the-loop approval before booking the trip (mocked), showcasing how the durable task extension handles long-running operations easily:\n\n![]()\n\n### **Application Workflow**\n\n1. **User Request:** User submits travel preferences via React frontend\n2. **Orchestration Scheduled:** Azure Functions backend receives the request and schedules a deterministic agentic workflow using the Durable Task Extension for Agent Framework.\n3. **Destination Recommendation:** The orchestrator first coordinates the Destination Recommender agent to analyze preferences and suggest destinations\n4. **Itinerary Planning and Local** **Recommendations:** The orchestrator then parallelizes the invocation of the Itinerary Planner agent to create detailed day-by-day plans for the given destination and the Local Recommendations agent to add insider tips and attractions\n5. **Storage:** Created travel plan is saved to Azure Blob Storage\n6. **Approval:** User reviews and approves the plan (human-in-the-loop)\n7. **Booking:** Upon approval, booking of the trip completes\n\n### **Key Components**\n\n- **Azure Static Web Apps:** Hosts the React frontend\n- **Azure Functions (.NET 9):** Serverless compute hosting the agents and workflow with automatic scaling\n- **Durable Task Extension for Microsoft Agent Framework:** The AI agent SDK with durable task extension\n- **Durable Task Scheduler:** Manages state persistence, orchestration, and observability\n- **Azure OpenAI (GPT-4o-mini):** Powers the AI agents\n\nNow let’s dive into the code. Along the way, I’ll highlight the value the durable task extension brings and patterns you can apply to your own applications.\n\n## **Creating** **Durable Agents**\n\nMaking the standard Agent Framework agents durable agents is simple. Include the durable task extension package and register your agents within the **ConfigureDurableAgents** extension method and you automatically get:\n\n- Persistent conversation sessions that survive restarts\n- HTTP endpoints for agent interactions\n- Automatic state checkpointing that survive restarts\n- Distributed execution across instances\n\n#### C#\n\n- FunctionsApplication\n.CreateBuilder(args) .ConfigureDurableAgents(configure => { configure.AddAIAgentFactory(\"DestinationRecommenderAgent\", sp => chatClient.CreateAIAgent( instructions: \"You are a travel destination expert...\", name: \"DestinationRecommenderAgent\", services: sp));\n\nconfigure.AddAIAgentFactory(\"ItineraryPlannerAgent\", sp => chatClient.CreateAIAgent( instructions: \"You are a travel itinerary planner...\", name: \"ItineraryPlannerAgent\", services: sp, tools: [AIFunctionFactory.Create(CurrencyConverterTool.ConvertCurrency)]));\n\nconfigure.AddAIAgentFactory(\"LocalRecommendationsAgent\", sp => chatClient.CreateAIAgent( instructions: \"You are a local expert...\", name: \"LocalRecommendationsAgent\", services: sp)); });\n\n#### Python\n- # Create the Azure OpenAI chat client\nchat\\_client = AzureOpenAIChatClient( endpoint=endpoint, deployment\\_name=deployment\\_name, credential=DefaultAzureCredential() )\n\n# Destination Recommender Agent\ndestination\\_recommender\\_agent = chat\\_client.create\\_agent( name=\"DestinationRecommenderAgent\", instructions=\"You are a travel destination expert...\" )\n\n# Itinerary Planner Agent (with tools)\nitinerary\\_planner\\_agent = chat\\_client.create\\_agent( name=\"ItineraryPlannerAgent\", instructions=\"You are a travel itinerary planner...\", tools=[get\\_exchange\\_rate, convert\\_currency] )\n\n# Local Recommendations Agent\nlocal\\_recommendations\\_agent = chat\\_client.create\\_agent( name=\"LocalRecommendationsAgent\", instructions=\"You are a local expert...\" )\n\n# Configure Function App with Durable Agents. AgentFunctionApp is where the magic happens\napp = AgentFunctionApp(agents=[ destination\\_recommender\\_agent, itinerary\\_planner\\_agent, local\\_recommendations\\_agent ])\n\n## **The Orchestration Programming Model**\n\nThe durable task extension uses an intuitive async/await programming model for deterministic orchestration. You write orchestration logic as ordinary imperative code (if/else, try/catch), and the framework handles all the complexity of coordination, durability, retries, and distributed execution.\n\n### **The Travel Planner Orchestration**\n\nHere's the actual orchestration from the application that coordinates all three agents, runs tasks in parallel, handles human approval, and books the trip:\n\n#### C#\n- [Function(nameof(RunTravelPlannerOrchestration))]\npublic async Task RunTravelPlannerOrchestration( [OrchestrationTrigger] TaskOrchestrationContext context) { var travelRequest = context.GetInput()!;\n\n// Get durable agents and create conversation threads DurableAIAgent destinationAgent = context.GetAgent(\"DestinationRecommenderAgent\"); DurableAIAgent itineraryAgent = context.GetAgent(\"ItineraryPlannerAgent\"); DurableAIAgent localAgent = context.GetAgent(\"LocalRecommendationsAgent\");\n\n// Step 1: Get destination recommendations var destinations = await destinationAgent.RunAsync( $\"Recommend destinations for {travelRequest.Preferences}\", destinationAgent.GetNewThread());\n\nvar topDestination = destinations.Result.Recommendations.First();\n\n// Steps 2 & 3: Run itinerary and local recommendations IN PARALLEL var itineraryTask = itineraryAgent.RunAsync( $\"Create itinerary for {topDestination.Name}\", itineraryAgent.GetNewThread());\n\nvar localTask = localAgent.RunAsync( $\"Local recommendations for {topDestination.Name}\", localAgent.GetNewThread());\n\nawait Task.WhenAll(itineraryTask, localTask);\n\n// Step 4: Save to blob storage await context.CallActivityAsync(nameof(SaveTravelPlanToBlob), travelPlan);\n\n// Step 5: Wait for human approval (NO COMPUTE COSTS while waiting!) var approval = await context.WaitForExternalEvent( \"ApprovalEvent\", TimeSpan.FromDays(7));\n\n// Step 6: Book if approved if (approval.Approved) await context.CallActivityAsync(nameof(BookTrip), travelPlan);\n\nreturn new TravelPlanResult(travelPlan, approval.Approved); }\n\n#### Python\n- app.orchestration\\_trigger(context\\_name=\"context\")\ndef travel\\_planner\\_orchestration(context: df.DurableOrchestrationContext): travel\\_request\\_data = context.get\\_input() travel\\_request = TravelRequest(\\*\\*travel\\_request\\_data)\n\n# Get durable agents and create conversation threads\ndestination\\_agent = app.get\\_agent(context, \"DestinationRecommenderAgent\") itinerary\\_agent = app.get\\_agent(context, \"ItineraryPlannerAgent\") local\\_agent = app.get\\_agent(context, \"LocalRecommendationsAgent\")\n\n# Step 1: Get destination recommendations\ndestinations\\_result = yield destination\\_agent.run( messages=f\"Recommend destinations for {travel\\_request.preferences}\", thread=destination\\_agent.get\\_new\\_thread(), response\\_format=DestinationRecommendations ) destinations = cast(DestinationRecommendations, destinations\\_result.value) top\\_destination = destinations.recommendations[0]\n\n# Steps 2 & 3: Run itinerary and local recommendations IN PARALLEL\nitinerary\\_task = itinerary\\_agent.run( messages=f\"Create itinerary for {top\\_destination.destination\\_name}\", thread=itinerary\\_agent.get\\_new\\_thread(), response\\_format=Itinerary ) local\\_task = local\\_agent.run( messages=f\"Local recommendations for {top\\_destination.destination\\_name}\", thread=local\\_agent.get\\_new\\_thread(), response\\_format=LocalRecommendations )\n\nresults = yield context.task\\_all([itinerary\\_task, local\\_task]) itinerary = cast(Itinerary, results[0].value) local\\_recs = cast(LocalRecommendations, results[1].value)\n\n# Step 4: Save to blob storage\nyield context.call\\_activity(\"save\\_travel\\_plan\\_to\\_blob\", travel\\_plan)\n\n# Step 5: Wait for human approval (NO COMPUTE COSTS while waiting!)\napproval\\_task = context.wait\\_for\\_external\\_event(\"ApprovalEvent\") timeout\\_task = context.create\\_timer( context.current\\_utc\\_datetime + timedelta(days=7))\n\nwinner = yield context.task\\_any([approval\\_task, timeout\\_task])\n\nif winner == approval\\_task: timeout\\_task.cancel() approval = approval\\_task.result\n\n# Step 6: Book if approved\nif approval.get(\"approved\"): yield context.call\\_activity(\"book\\_trip\", travel\\_plan)\n\nreturn TravelPlanResult(plan=travel\\_plan, approved=approval.get(\"approved\"))\n\nreturn TravelPlanResult(plan=travel\\_plan, approved=False)\n\nNotice how the orchestration combines:\n\n- **Agent calls** (await agent.RunAsync(...)) for AI-driven decisions\n- **Parallel execution** (Task.WhenAll) for running multiple agents concurrently\n- **Activity calls** (await context.CallActivityAsync(...)) for non-intelligent business tasks\n- **Human-in-the-loop** (await context.WaitForExternalEvent(...)) for approval workflows\n\nThe orchestration automatically checkpoints after each step. If a failure occurs, completed steps aren't re-executed. The orchestration resumes exactly where it left off, no need for manual intervention.\n\n## **Agent Patterns in Action**\n\n### **Agent Chaining: Sequential Handoffs**\n\nThe Travel Planner demonstrates **agent chaining** where the Destination Recommender's output feeds into both the Itinerary Planner and Local Recommendations agents:\n\n#### C#\n- // Agent 1: Get destination recommendations\nvar destinations = await destinationAgent.RunAsync(prompt, thread); var topDestination = destinations.Result.Recommendations.First();\n\n// Agent 2: Create itinerary based on Agent 1's output var itinerary = await itineraryAgent.RunAsync( $\"Create itinerary for {topDestination.Name}\", thread);\n\n#### Python\n- # Agent 1: Get destination recommendations\ndestinations\\_result = yield destination\\_agent.run( messages=prompt, thread=thread, response\\_format=DestinationRecommendations ) destinations = cast(DestinationRecommendations, destinations\\_result.value) top\\_destination = destinations.recommendations[0]\n\n# Agent 2: Create itinerary based on Agent 1's output\nitinerary\\_result = yield itinerary\\_agent.run( messages=f\"Create itinerary for {top\\_destination.destination\\_name}\", thread=thread, response\\_format=Itinerary ) itinerary = cast(Itinerary, itinerary\\_result.value)\n\n### **Agent Parallelization: Concurrent Execution**\n\nThe app runs the Itinerary Planner and Local Recommendations agents **in parallel** to reduce latency:\n\n#### C#\n- // Launch both agent calls simultaneously\nvar itineraryTask = itineraryAgent.RunAsync(itineraryPrompt, thread1); var localTask = localAgent.RunAsync(localPrompt, thread2);\n\n// Wait for both to complete await Task.WhenAll(itineraryTask, localTask);\n\n#### Python\n- # Launch both agent calls simultaneously\nitinerary\\_task = itinerary\\_agent.run( messages=itinerary\\_prompt, thread=thread1, response\\_format=Itinerary ) local\\_task = local\\_agent.run( messages=local\\_prompt, thread=thread2, response\\_format=LocalRecommendations )\n\n# Wait for both to complete\nresults = yield context.task\\_all([itinerary\\_task, local\\_task])\n\nitinerary = cast(Itinerary, results[0].value) local\\_recs = cast(LocalRecommendations, results[1].value)\n\n### **Human-in-the-Loop: Approval Workflows**\n\nThe Travel Planner includes a complete human-in-the-loop pattern. After generating the travel plan, the workflow pauses for user approval:\n\n#### C#\n- // Send approval request notification\nawait context.CallActivityAsync(nameof(RequestApproval), travelPlan);\n\n// Wait for approval - NO COMPUTE COSTS OR LLM TOKENS while waiting! var approval = await context.WaitForExternalEvent( \"ApprovalEvent\", TimeSpan.FromDays(7));\n\nif (approval.Approved) await context.CallActivityAsync(nameof(BookTrip), travelPlan);\n\n#### Python\n- # Send approval request notification\nawait context.CallActivityAsync(nameof(RequestApproval), travelPlan);\n\n# Wait for approval - NO COMPUTE COSTS OR LLM TOKENS while waiting!\nvar approval = await context.WaitForExternalEvent( \"ApprovalEvent\", TimeSpan.FromDays(7));\n\nif (approval.Approved) await context.CallActivityAsync(nameof(BookTrip), travelPlan);\n\nThe API endpoint to handle approval responses:\n\n#### C#\n- [Function(nameof(HandleApprovalResponse))]\npublic async Task HandleApprovalResponse( [HttpTrigger(\"post\", Route = \"approve/{instanceId}\")] HttpRequestData req, string instanceId, [DurableClient] DurableTaskClient client) { var approval = await req.ReadFromJsonAsync(); await client.RaiseEventAsync(instanceId, \"ApprovalEvent\", approval); }\n\n#### Python\n- app.function\\_name(name=\"ApproveTravelPlan\")\napp.route(route=\"travel-planner/approve/{instance\\_id}\", methods=[\"POST\"]) app.durable\\_client\\_input(client\\_name=\"client\") async def approve\\_travel\\_plan(req: func.HttpRequest, client) -> func.HttpResponse: instance\\_id = req.route\\_params.get(\"instance\\_id\") approval = req.get\\_json() await client.raise\\_event(instance\\_id, \"ApprovalEvent\", approval)\n\nreturn func.HttpResponse( json.dumps({\"message\": \"Approval processed\"}), status\\_code=200, mimetype=\"application/json\" )\n\nThe workflow generates a complete travel plan and waits up to 7 days for user approval. During this entire waiting period, since we're hosting this application on the [Functions Flex Consumption plan](https://learn.microsoft.com/en-us/azure/azure-functions/flex-consumption-plan), the app scales down and zero compute resources or LLM tokens are consumed. When the user approves (or the timeout expires), the app scales back up and the orchestration automatically resumes with full context intact.\n\n## **Real-Time Monitoring with the Durable Task Scheduler**\n\nSince we're using the [Durable Task Scheduler](https://learn.microsoft.com/azure/azure-functions/durable/durable-task-scheduler/durable-task-scheduler) as the backend for our durable agents, we're provided with a built-in dashboard for monitoring our agents and orchestrations in real-time.\n\n### **Agent Thread Insights**\n\n![]()![]()\n- **Conversation history:** View complete conversation threads for each agent session, including all messages, tool calls, and agent decisions\n- **Task timing:** Monitor how long specific tasks and agent interactions take to complete\n\n### **Orchestration Insights**\n\n![]()\n- **Multi-agent visualization:** See the execution flow across multiple agents with visual representation of parallel executions and branching\n- **Real-time monitoring:** Track active orchestrations, queued work items, and agent states\n- **Performance metrics:** Monitor response times, token usage, and orchestration duration\n\n### **Debugging Capabilities**\n\n- View structured inputs and outputs for activities, agents, and tool calls\n- Trace tool invocations and their outcomes\n- Monitor external event handling for human-in-the-loop scenarios\n\nThe dashboard enables you to understand exactly what your agents and workflows are doing, diagnose issues quickly, and optimize performance, all without adding custom logging to your code.\n\n## **Try The Travel Planner Application**\n\nThat’s it! That’s the gist of how the AI Travel Planner application is put together and some of the key components that it took to build it.\n\nI'd love for you to try the application out for yourself. It's fully instrumented with the Azure Developer CLI and Bicep, so you can deploy it to Azure with a few simple CLI commands.\n\n## **[Click here to try the AI Travel Planner sample](https://github.com/Azure-Samples/durable-agents-travel-planner)Python version coming soon!**\n\n## **Demo Video**\n\n## **Learn More**\n\n- [Durable Task Extension Overview](https://learn.microsoft.com/agent-framework/user-guide/agents/agent-types/durable-agent/create-durable-agent)\n- [Durable Agent Features](https://learn.microsoft.com/agent-framework/user-guide/agents/agent-types/durable-agent/features)\n- [Durable Task Scheduler](https://learn.microsoft.com/azure/azure-functions/durable/durable-task-scheduler/durable-task-scheduler)\n- [AI Travel Planner GitHub Repository](https://github.com/Azure-Samples/durable-agents-travel-planner)",
  "OutputDir": "_community",
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/building-reliable-ai-travel-agents-with-the-durable-task/ba-p/4478913",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure"
}
