{
  "FeedName": "Microsoft Tech Community",
  "PubDate": "2025-11-04T15:35:47+00:00",
  "Title": "Part 3: Client-Side Multi-Agent Orchestration on Azure App Service with Microsoft Agent Framework",
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/part-3-client-side-multi-agent-orchestration-on-azure-app/ba-p/4466728",
  "EnhancedContent": "## Take full control of your AI agents with ChatClientAgent‚Äîthe client-side alternative to server-side Foundry agents from Part 2.\n\nIn [Part 2 of this series](https://techcommunity.microsoft.com/blog/appsonazureblog/part-2-build-long-running-ai-agents-on-azure-app-service-with-microsoft-agent-fr/4465825), I showed you how to build sophisticated multi-agent systems on Azure App Service using **Azure AI Foundry Agents**‚Äîserver-side managed agents that run as Azure resources. Now I want to show you another alternative that gives you **full control** over agent orchestration, chat history management, and provider flexibility: **client-side agents** using **ChatClientAgent**. But this alternative raises an important question:\n\n**How do you choose between client-side and server-side agents?**\n\nThis is an important question that points to a fundamental choice in Agent Framework: **client-side agents vs. server-side agents**. I'm not going to go into extreme detail here; my goal for this post is to show you how to build client-side multi-agent systems with ChatClientAgent and Azure App Service, but I will highlight the key differences and trade-offs that are going through my mind when considering this to help you make an informed decision.\n\nIn Part 2, I mentioned:\n\n> \"In my next blog post, I'll demonstrate an alternative approach using a different agent type‚Äîlikely the Azure OpenAI ChatCompletion agent type‚Äîwhich doesn't create server-side Foundry resources. Instead, you orchestrate the agent behavior yourself while still benefiting from the Agent Framework's unified programming model.\"\n\nToday, I'm delivering on that promise! We're going to rebuild the same travel planner sample using **ChatClientAgent**‚Äîa client-side agent type that gives you complete control over orchestration, chat history, and agent lifecycle.\n\nIn this post, we'll explore:\n\n‚úÖ **Client-side agent orchestration** with full workflow control ‚úÖ **ChatClientAgent** architecture and implementation patterns ‚úÖ **When to choose client-side vs. server-side agents** ‚úÖ **How Azure App Service supports both approaches equally well** ‚úÖ **Managing chat history your way** (Cosmos DB, Redis, or any storage you choose)\n\nüîó **Full Sample Code**: [https://github.com/Azure-Samples/app-service-maf-openai-travel-agent-dotnet](https://github.com/Azure-Samples/app-service-maf-openai-travel-agent-dotnet)\n\n## The Key Question: Who's in Charge?\n\nWhen building multi-agent systems with Agent Framework, you face a fundamental architectural decision. Microsoft Agent Framework supports [multiple agent types](https://learn.microsoft.com/agent-framework/user-guide/agents/agent-types/?pivots=programming-language-csharp), but the choice typically comes down to:\n\n**Server-Side (Foundry Agents - Part 2)**\n\n- Azure AI Foundry manages agent lifecycle, threads, and execution\n- Agents exist as Azure resources in your AI Project\n- Conversation history stored in Foundry threads\n- Built-in orchestration patterns and features\n\n**Client-Side (ChatClientAgent - This Post)**\n\n- Your application code manages agent lifecycle and orchestration\n- Agents are C# objects created on-demand\n- Conversation history stored wherever you choose (Cosmos DB, Redis, etc.)\n- You write the orchestration logic yourself\n\nBoth approaches run well on Azure App Service‚Äîthe platform doesn't care which agent type you use. What matters is which approach fits your requirements better.\n\n## What's Different: ChatClientAgent Architecture\n\nLet's see what changes when you switch from Foundry agents to ChatClientAgent.\n\n### The Same Multi-Agent Workflow\n\nBoth samples implement the **exact same travel planner** with 6 specialized agents:\n\n1. **Currency Converter Agent** - Real-time exchange rates\n2. **Weather Advisor Agent** - Forecasts and packing tips\n3. **Local Knowledge Agent** - Cultural insights\n4. **Itinerary Planner Agent** - Day-by-day schedules\n5. **Budget Optimizer Agent** - Cost allocation\n6. **Coordinator Agent** - Final assembly\n\nThe agents collaborate through the same 4-phase workflow:\n\n- **Phase 1**: Parallel information gathering (Currency + Weather + Local)\n- **Phase 2**: Itinerary planning\n- **Phase 3**: Budget optimization\n- **Phase 4**: Final assembly\n\n**Same workflow, different execution model.**\n\n### How ChatClientAgent Works\n\nHere's the architecture stack for the client-side approach:\n\nThe architecture shows:\n\n- **Your Application Code**: TravelPlanningWorkflow orchestrating 6 ChatClientAgents with client-side chat history\n- **Microsoft.Agents.AI**: ChatClientAgent wrapper adding instructions and tools\n- **Microsoft.Extensions.AI**: IChatClient abstraction with Azure OpenAI implementation\n- **Azure Services**: Azure OpenAI, Cosmos DB for chat history, and external APIs\n\n**Key components:**\n\n1. **TravelPlanningWorkflow** - Your orchestration code that coordinates agent execution\n2. **ChatClientAgent** - Agent Framework wrapper that adds instructions and tools to IChatClient\n3. **IChatClient** - Standard abstraction from Microsoft.Extensions.AI\n4. **Client-Side Chat History** - Dictionary storing conversation per agent (you manage this!)\n5. **Azure OpenAI** - Direct chat completion API calls (no AI Project endpoint needed)\n6. **Cosmos DB** - Your choice for chat history persistence\n\n### Implementation: BaseAgent Pattern\n\nHere's how you create a ChatClientAgent in code:\n\n```\n\n```\n\n``` public abstract class BaseAgent : IAgent { protected readonly ChatClientAgent Agent;\n\nprotected abstract string AgentName { get; } protected abstract string Instructions { get; }\n\n// Constructor for simple agents without tools protected BaseAgent( ILogger logger, IOptions<AgentOptions> options, IChatClient chatClient) { Agent = new ChatClientAgent(chatClient, new ChatClientAgentOptions { Name = AgentName, Instructions = Instructions }); }\n\n// Constructor for agents with tools (weather, currency APIs) protected BaseAgent( ILogger logger, IOptions<AgentOptions> options, IChatClient chatClient, ChatOptions chatOptions) { Agent = new ChatClientAgent(chatClient, new ChatClientAgentOptions { Name = AgentName, Instructions = Instructions, ChatOptions = chatOptions // Tools via AIFunctionFactory }); }\n\npublic async Task<ChatMessage> InvokeAsync( IList<ChatMessage> chatHistory, CancellationToken cancellationToken = default) { var response = await Agent.RunAsync( chatHistory, thread: null, options: null, cancellationToken);\n\nreturn response.Messages.LastOrDefault() ?? new ChatMessage(ChatRole.Assistant, \"No response generated.\"); } } ```\n\n**What's happening here?**\n\n- You create a `ChatClientAgent`\nby wrapping an `IChatClient`\n- You provide instructions (the agent's system prompt)\n- Optionally, you provide tools via `ChatOptions`\n(using `AIFunctionFactory` )\n- When you call `RunAsync`\n, you pass the chat history yourself\n- The agent returns a response, and **you** decide what to do with the chat history\n\nCompare this to Foundry agents where you create the agent once in Azure AI Foundry, and the platform manages threads and execution for you.\n\n### Client-Side Chat History Management\n\nOne of the biggest differences is **you control the chat history**:\n\n```\n\n```\n\n``` public class WorkflowState { // Each agent gets its own conversation history public Dictionary<string, List<ChatMessage>> AgentChatHistories { get; set; } = new();\n\npublic List<ChatMessage> GetChatHistory(string agentType) { if (!AgentChatHistories.ContainsKey(agentType)) { AgentChatHistories[agentType] = new List<ChatMessage>(); } return AgentChatHistories[agentType]; } } ```\n\n**Workflow orchestration:**\n\n``` // Phase 1: Currency Converter Agent var currencyChatHistory = state.GetChatHistory(\"CurrencyConverter\"); currencyChatHistory.Add(new ChatMessage(ChatRole.User, $\"Convert {request.Budget} {request.Currency} to local currency for {request.Destination}\"));\n\nvar currencyResponse = await _currencyAgent.InvokeAsync(currencyChatHistory, cancellationToken); currencyChatHistory.Add(currencyResponse); // You manage the history!\n\n// Store in workflow state for downstream agents state.AddToContext(\"CurrencyInfo\", currencyResponse.Text ?? \"\"); ```\n\n` `\n\n**Benefits:**\n\n- Store chat history in Cosmos DB, Redis, SQL, or any data store\n- Query conversation history with your own logic\n- Implement custom retention policies\n- Export chat logs for analytics or compliance\n\nWith Foundry agents, chat history lives in Foundry threads‚Äîyou don't directly control where or how it's stored. This may be fine for many scenarios, but if you need custom storage or compliance, client-side management is powerful.\n\n### Tool Integration with AIFunctionFactory\n\nExternal API tools (weather, currency) are registered as C# methods:\n\n``` // Weather Service public class NWSWeatherService : IWeatherService { [Description(\"Get weather forecast for a US city\")] public async Task<WeatherForecast> GetWeatherAsync( [Description(\"City name (e.g., 'San Francisco')\")] string city, [Description(\"State code (e.g., 'CA')\")] string state, CancellationToken cancellationToken = default) { // Implementation calls NWS API } }\n\n// Register as tools with ChatClientAgent var weatherTools = AIFunctionFactory.Create(weatherService); var chatOptions = new ChatOptions { Tools = weatherTools };\n\nvar agent = new ChatClientAgent(chatClient, new ChatClientAgentOptions { Name = \"WeatherAdvisor\", Instructions = \"Provide weather forecasts and packing recommendations...\", ChatOptions = chatOptions }); ```\n\nThe agent can now call `GetWeatherAsync` via function calling‚Äîsame capability as Foundry agents, but configured in code instead of the portal.\n\n## Why Choose Client-Side Agents (ChatClientAgent)?\n\nHere's when ChatClientAgent shines:\n\n### ‚úÖ Full Orchestration Control\n\n**You write the workflow logic:**\n\n``` // Phase 1: Run 3 agents in parallel (your code!) var currencyTask = GatherCurrencyInfoAsync(request, state, progress, cancellationToken); var weatherTask = GatherWeatherInfoAsync(request, state, progress, cancellationToken); var localTask = GatherLocalKnowledgeAsync(request, state, progress, cancellationToken);\n\nawait Task.WhenAll(currencyTask, weatherTask, localTask);\n\n// Phase 2: Sequential itinerary planning (your code!) await PlanItineraryAsync(request, state, progress, cancellationToken); ```\n\n` `\n\nWith Foundry agents, orchestration patterns are limited to what the platform provides.\n\n### ‚úÖ Cost-Effective\n\n**No separate agent infrastructure:**\n\n- ChatClientAgent: Pay only for Azure OpenAI API calls\n- Foundry Agents: Pay for Azure OpenAI + AI Project resources + agent storage\n\nFor high-volume scenarios, this can add up to significant savings.\n\n### ‚úÖ DevOps-Friendly\n\n**Everything in code:**\n\n- Agent definitions tracked in Git\n- Testable with unit tests\n- CI/CD pipelines deploy everything together\n- No manual portal configuration steps\n- Infrastructure as Code (Bicep) covers all resources\n\n### ‚úÖ Flexible Chat History\n\n**Store conversations your way:**\n\n- Cosmos DB for global distribution and rich queries\n- Redis for ultra-low latency caching\n- SQL Database for complex relational queries\n- Blob Storage for long-term archival\n- Custom encryption and retention policies\n\n### ‚úÖ Provider Flexibility\n\n**Works with any IChatClient:**\n\n- Azure OpenAI (this sample)\n- OpenAI directly\n- Local models via Ollama\n- Azure AI Foundry model catalog\n- Custom chat implementations\n\nSwitching providers is just a configuration change‚Äîno agent re-creation needed.\n\n### ‚úÖ Multi-Agent Coordination Patterns\n\n**Implement complex workflows:**\n\n- Parallel execution (Phase 1 in our sample)\n- Sequential dependencies (Phase 2-4)\n- Conditional branching based on agent responses\n- Agent-to-agent negotiation\n- Hierarchical supervisor patterns\n- Custom retry logic per agent\n\nYou have complete freedom to orchestrate however your scenario requires.\n\n## Why Choose Server-Side Agents (Azure AI Foundry)?\n\nTo be fair, Foundry agents from Part 2 have their own advantages and this post isn't about dismissing them. They are a powerful option for many scenarios. Here are some reasons to choose Foundry agents:\n\n### ‚úÖ Managed Lifecycle\n\n**Platform handles the heavy lifting:**\n\n- Agents persist as Azure resources\n- Threads automatically manage conversation state\n- Runs track execution progress server-side\n- No orchestration code to write or maintain\n\n### ‚úÖ Built-In Features\n\n**Rich capabilities out of the box:**\n\n- File search for RAG scenarios\n- Code interpreter for data analysis\n- Automatic conversation threading\n- Built-in retry and error handling\n\n### ‚úÖ Portal UI\n\n**Configure without code:**\n\n- Create agents in Azure AI Foundry portal\n- Test agents interactively\n- View conversation threads and runs\n- Adjust instructions without redeployment\n\n### ‚úÖ Less Code\n\n**Simpler for basic scenarios:**\n\n``` // Foundry Agent (Part 2 sample) var agent = await agentsClient.CreateAgentAsync( \"gpt-4o\", instructions: \"You are a travel planning expert...\", tools: new List<ToolDefinition> { new FunctionTool(...) });\n\nvar thread = await agentsClient.CreateThreadAsync(); var run = await agentsClient.CreateRunAsync(thread.Id, agent.Id); ```\n\n` `\n\nNo need to manage chat history, orchestration logic, or tool registration in code.\n\n## When to Choose Which Approach\n\nHere's my take on a decision guide. This isn't exhaustive, but it covers key considerations. Others may disagree based on their priorities, but this is how I think about it:\n\n| Requirement | ChatClientAgent | Foundry Agents | | --- | --- | --- | | **Complex multi-agent workflows** | ‚úÖ Full control | ‚ö†Ô∏è Limited patterns | | **Custom chat history storage** | ‚úÖ Any data store | ‚ùå Foundry threads only | | **Cost optimization** | ‚úÖ LLM calls only | ‚ö†Ô∏è + Infrastructure | | **Code-first DevOps** | ‚úÖ Everything in Git | ‚ö†Ô∏è Portal config needed | | **Provider flexibility** | ‚úÖ Any IChatClient | ‚ö†Ô∏è Azure only | | **Built-in RAG (file search)** | ‚ùå DIY | ‚úÖ Built-in | | **Portal UI for testing** | ‚ùå Code only | ‚úÖ Full UI | | **Quick prototypes** | ‚ö†Ô∏è More code | ‚úÖ Fast setup | | **Learning curve** | ‚ö†Ô∏è More concepts | ‚úÖ Guided setup |\n\n**Use ChatClientAgent when:**\n\n- You need complex multi-agent coordination\n- Cost optimization is important\n- You want full control over orchestration\n- Code-first DevOps is a priority\n- You need custom chat history management\n\n**Use Foundry Agents when:**\n\n- Simple single-agent or basic multi-agent scenarios\n- You want built-in RAG and file search\n- Portal-based configuration is preferred\n- Quick prototyping and experimentation\n- Managed infrastructure over custom code\n\n## Azure App Service: Perfect for Both\n\nHere's the great part: **Azure App Service supports both approaches equally well.**\n\n### The Same Architecture\n\nBoth samples use identical infrastructure.\n\n**What's the same:**\n\n- ‚úÖ Async request-reply pattern (202 Accepted ‚Üí poll status)\n- ‚úÖ Service Bus for reliable message delivery\n- ‚úÖ Cosmos DB for task state with 24-hour TTL\n- ‚úÖ WebJob for background processing\n- ‚úÖ Managed Identity for authentication\n- ‚úÖ Premium App Service tier for Always On\n\n**What's different:**\n\n- ChatClientAgent: Azure OpenAI endpoint directly (`https://ai-xyz.openai.azure.com/`\n)\n- Foundry Agents: AI Project endpoint (`https://ai-xyz.services.ai.azure.com/api/projects/proj-xyz`\n)\n- ChatClientAgent: Chat history in Cosmos DB (your control)\n- Foundry Agents: Chat history in Foundry threads (platform managed)\n\n**Azure App Service doesn't care which you choose.** It just runs your .NET code, processes messages from Service Bus, and stores state in Cosmos DB. The agent execution model is an implementation detail. You can easily switch between approaches without changing your hosting platform, and even use a hybrid approach if desired.\n\n## Get Started Today\n\nReady to try client-side multi-agent orchestration on Azure App Service?\n\nüîó **GitHub Repository**: [https://github.com/Azure-Samples/app-service-maf-openai-travel-agent-dotnet](https://github.com/Azure-Samples/app-service-maf-openai-travel-agent-dotnet)\n\nThe repository includes:\n\n- ‚úÖ Complete .NET 9 source code with 6 specialized ChatClientAgents\n- ‚úÖ Infrastructure as Code (Bicep) for one-command deployment\n- ‚úÖ Web UI with real-time progress tracking\n- ‚úÖ Comprehensive README and architecture documentation\n- ‚úÖ External API integrations (weather, currency)\n- ‚úÖ Client-side chat history management with Cosmos DB\n\n### Deploy in Minutes\n\n```\n# Clone the repository\ngit clone https://github.com/Azure-Samples/app-service-maf-openai-travel-agent-dotnet.git cd app-service-maf-openai-travel-agent-dotnet\n\n# Login to Azure\nazd auth login\n\n# Provision infrastructure and deploy the API\nazd up ```\n\n` `\n\nThis provisions:\n\n- Azure App Service (P0v4 Premium Windows)\n- Azure Service Bus (message queue)\n- Azure Cosmos DB (state + chat history storage)\n- Azure AI Services (AI Services resource)\n- GPT-4o model deployment (GlobalStandard 50K TPM)\n\nThen manually deploy the WebJob following the [README instructions](https://github.com/Azure-Samples/app-service-maf-openai-travel-agent-dotnet#deploy-the-webjob).\n\n### Compare with Part 2\n\nWant to see the differences firsthand? Deploy both samples:\n\n**Part 2 - Server-Side Foundry Agents:** üîó [https://github.com/Azure-Samples/app-service-maf-workflow-travel-agent-dotnet](https://github.com/Azure-Samples/app-service-maf-workflow-travel-agent-dotnet)\n\n**Part 3 - Client-Side ChatClientAgent (this post):** üîó [https://github.com/Azure-Samples/app-service-maf-openai-travel-agent-dotnet](https://github.com/Azure-Samples/app-service-maf-openai-travel-agent-dotnet)\n\nSame travel planner, same workflow, same results‚Äîdifferent execution model. Try both and see which fits your needs!\n\n## Key Takeaways\n\n‚úÖ **Microsoft Agent Framework offers choice**: Client-side (ChatClientAgent) vs. Server-side (Foundry Agents)\n\n‚úÖ **ChatClientAgent gives you full control**: Orchestration, chat history, agent lifecycle‚Äîyou manage it all in code\n\n‚úÖ **Foundry Agents give you convenience**: Managed infrastructure, built-in features, portal UI‚Äîlet the platform handle the details\n\n‚úÖ **Azure App Service supports both equally**: Same async request-reply pattern, same WebJob architecture, same infrastructure\n\n‚úÖ **Pick the right tool for your needs**: Complex coordination and cost control ‚Üí ChatClientAgent. Simple scenarios and managed infrastructure ‚Üí Foundry Agents.\n\nWhether you choose client-side or server-side agents, Azure App Service provides the perfect platform for long-running AI workloads‚Äîreliable, scalable, and fully managed.\n\n## What's Next?\n\nThis completes our three-part series on building AI agents with Microsoft Agent Framework on Azure App Service:\n\n- **[Part 1](https://techcommunity.microsoft.com/blog/appsonazureblog/build-long-running-ai-agents-on-azure-app-service-with-microsoft-agent-framework/4463159)**: Introduction to Agent Framework and async request-reply pattern\n- **[Part 2](https://techcommunity.microsoft.com/blog/appsonazureblog/part-2-build-long-running-ai-agents-on-azure-app-service-with-microsoft-agent-fr/4465825)**: Multi-agent systems with server-side Foundry Agents\n- **Part 3 (this post)**: Client-side multi-agent orchestration with ChatClientAgent\n\nWhat would you like to see next? More advanced orchestration patterns? Integration with other Azure services?\n\nLet me know in the comments what you'd like to learn about next and I'll do my best to deliver!\n\nPublished Nov 04, 2025\n\nVersion 1.0\n\n[.net](/tag/.net?nodeId=board%3AAppsonAzureBlog)\n\n[azure app service](/tag/azure%20app%20service?nodeId=board%3AAppsonAzureBlog)\n\n[web apps](/tag/web%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[jordanselig&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0xMTg1ODUyLTQwNTU5Mmk4NTY0MjQ3RTE3NURDNzJC?image-dimensions=50x50)](/users/jordanselig/1185852) [jordanselig](/users/jordanselig/1185852) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined October 14, 2021\n\n[View Profile](/users/jordanselig/1185852)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Tags": [],
  "ProcessedDate": "2025-11-04 16:05:26",
  "OutputDir": "_community",
  "Author": "jordanselig",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Description": "In [Part 2 of this series](https://techcommunity.microsoft.com/blog/appsonazureblog/part-2-build-long-running-ai-agents-on-azure-app-service-with-microsoft-agent-fr/4465825), I showed you how to build sophisticated multi-agent systems on Azure App Service using **Azure AI Foundry Agents**‚Äîserver-side managed agents that run as Azure resources. Now I want to show you another alternative that gives you **full control** over agent orchestration, chat history management, and provider flexibility: **client-side agents** using **ChatClientAgent**. But this alternative raises an important question:\n\n**How do you choose between client-side and server-side agents?**\n\nThis is an important question that points to a fundamental choice in Agent Framework: **client-side agents vs. server-side agents**. I'm not going to go into extreme detail here; my goal for this post is to show you how to build client-side multi-agent systems with ChatClientAgent and Azure App Service, but I will highlight the key differences and trade-offs that are going through my mind when considering this to help you make an informed decision.\n\nIn Part 2, I mentioned:\n\n> \"In my next blog post, I'll demonstrate an alternative approach using a different agent type‚Äîlikely the Azure OpenAI ChatCompletion agent type‚Äîwhich doesn't create server-side Foundry resources. Instead, you orchestrate the agent behavior yourself while still benefiting from the Agent Framework's unified programming model.\"\n\nToday, I'm delivering on that promise! We're going to rebuild the same travel planner sample using **ChatClientAgent**‚Äîa client-side agent type that gives you complete control over orchestration, chat history, and agent lifecycle.\n\nIn this post, we'll explore:\n\n‚úÖ **Client-side agent orchestration** with full workflow control ‚úÖ **ChatClientAgent** architecture and implementation patterns ‚úÖ **When to choose client-side vs. server-side agents** ‚úÖ **How Azure App Service supports both approaches equally well** ‚úÖ **Managing chat history your way** (Cosmos DB, Redis, or any storage you choose)\n\nüîó **Full Sample Code**: [https://github.com/Azure-Samples/app-service-maf-openai-travel-agent-dotnet](https://github.com/Azure-Samples/app-service-maf-openai-travel-agent-dotnet)\n\n## The Key Question: Who's in Charge?\n\nWhen building multi-agent systems with Agent Framework, you face a fundamental architectural decision. Microsoft Agent Framework supports [multiple agent types](https://learn.microsoft.com/agent-framework/user-guide/agents/agent-types/?pivots=programming-language-csharp), but the choice typically comes down to:\n\n**Server-Side (Foundry Agents - Part 2)**\n\n- Azure AI Foundry manages agent lifecycle, threads, and execution\n- Agents exist as Azure resources in your AI Project\n- Conversation history stored in Foundry threads\n- Built-in orchestration patterns and features\n\n**Client-Side (ChatClientAgent - This Post)**\n\n- Your application code manages agent lifecycle and orchestration\n- Agents are C# objects created on-demand\n- Conversation history stored wherever you choose (Cosmos DB, Redis, etc.)\n- You write the orchestration logic yourself\n\nBoth approaches run well on Azure App Service‚Äîthe platform doesn't care which agent type you use. What matters is which approach fits your requirements better.\n\n## What's Different: ChatClientAgent Architecture\n\nLet's see what changes when you switch from Foundry agents to ChatClientAgent.\n\n### The Same Multi-Agent Workflow\n\nBoth samples implement the **exact same travel planner** with 6 specialized agents:\n\n1. **Currency Converter Agent** - Real-time exchange rates\n2. **Weather Advisor Agent** - Forecasts and packing tips\n3. **Local Knowledge Agent** - Cultural insights\n4. **Itinerary Planner Agent** - Day-by-day schedules\n5. **Budget Optimizer Agent** - Cost allocation\n6. **Coordinator Agent** - Final assembly\n\nThe agents collaborate through the same 4-phase workflow:\n\n- **Phase 1**: Parallel information gathering (Currency + Weather + Local)\n- **Phase 2**: Itinerary planning\n- **Phase 3**: Budget optimization\n- **Phase 4**: Final assembly\n\n**Same workflow, different execution model.**\n\n### How ChatClientAgent Works\n\nHere's the architecture stack for the client-side approach:\n\n![]()\n\nThe architecture shows:\n\n- **Your Application Code**: TravelPlanningWorkflow orchestrating 6 ChatClientAgents with client-side chat history\n- **Microsoft.Agents.AI**: ChatClientAgent wrapper adding instructions and tools\n- **Microsoft.Extensions.AI**: IChatClient abstraction with Azure OpenAI implementation\n- **Azure Services**: Azure OpenAI, Cosmos DB for chat history, and external APIs\n\n**Key components:**\n\n1. **TravelPlanningWorkflow** - Your orchestration code that coordinates agent execution\n2. **ChatClientAgent** - Agent Framework wrapper that adds instructions and tools to IChatClient\n3. **IChatClient** - Standard abstraction from Microsoft.Extensions.AI\n4. **Client-Side Chat History** - Dictionary storing conversation per agent (you manage this!)\n5. **Azure OpenAI** - Direct chat completion API calls (no AI Project endpoint needed)\n6. **Cosmos DB** - Your choice for chat history persistence\n\n### Implementation: BaseAgent Pattern\n\nHere's how you create a ChatClientAgent in code:\n\n```\n\n```\n\n- public abstract class BaseAgent : IAgent\n{ protected readonly ChatClientAgent Agent;\n\nprotected abstract string AgentName { get; } protected abstract string Instructions { get; }\n\n// Constructor for simple agents without tools protected BaseAgent( ILogger logger, IOptions options, IChatClient chatClient) { Agent = new ChatClientAgent(chatClient, new ChatClientAgentOptions { Name = AgentName, Instructions = Instructions }); }\n\n// Constructor for agents with tools (weather, currency APIs) protected BaseAgent( ILogger logger, IOptions options, IChatClient chatClient, ChatOptions chatOptions) { Agent = new ChatClientAgent(chatClient, new ChatClientAgentOptions { Name = AgentName, Instructions = Instructions, ChatOptions = chatOptions // Tools via AIFunctionFactory }); }\n\npublic async Task InvokeAsync( IList chatHistory, CancellationToken cancellationToken = default) { var response = await Agent.RunAsync( chatHistory, thread: null, options: null, cancellationToken);\n\nreturn response.Messages.LastOrDefault() ?? new ChatMessage(ChatRole.Assistant, \"No response generated.\"); } }\n\n**What's happening here?**\n\n- You create a `ChatClientAgent`\nby wrapping an `IChatClient`\n- You provide instructions (the agent's system prompt)\n- Optionally, you provide tools via `ChatOptions`\n(using `AIFunctionFactory` )\n- When you call `RunAsync`\n, you pass the chat history yourself\n- The agent returns a response, and **you** decide what to do with the chat history\n\nCompare this to Foundry agents where you create the agent once in Azure AI Foundry, and the platform manages threads and execution for you.\n\n### Client-Side Chat History Management\n\nOne of the biggest differences is **you control the chat history**:\n\n```\n\n```\n- public class WorkflowState\n{ // Each agent gets its own conversation history public Dictionary> AgentChatHistories { get; set; } = new();\n\npublic List GetChatHistory(string agentType) { if (!AgentChatHistories.ContainsKey(agentType)) { AgentChatHistories[agentType] = new List(); } return AgentChatHistories[agentType]; } }\n\n**Workflow orchestration:**\n- // Phase 1: Currency Converter Agent\nvar currencyChatHistory = state.GetChatHistory(\"CurrencyConverter\"); currencyChatHistory.Add(new ChatMessage(ChatRole.User, $\"Convert {request.Budget} {request.Currency} to local currency for {request.Destination}\"));\n\nvar currencyResponse = await \\_currencyAgent.InvokeAsync(currencyChatHistory, cancellationToken); currencyChatHistory.Add(currencyResponse); // You manage the history!\n\n// Store in workflow state for downstream agents state.AddToContext(\"CurrencyInfo\", currencyResponse.Text ?? \"\");\n\n` `\n\n**Benefits:**\n\n- Store chat history in Cosmos DB, Redis, SQL, or any data store\n- Query conversation history with your own logic\n- Implement custom retention policies\n- Export chat logs for analytics or compliance\n\nWith Foundry agents, chat history lives in Foundry threads‚Äîyou don't directly control where or how it's stored. This may be fine for many scenarios, but if you need custom storage or compliance, client-side management is powerful.\n\n### Tool Integration with AIFunctionFactory\n\nExternal API tools (weather, currency) are registered as C# methods:\n- // Weather Service\npublic class NWSWeatherService : IWeatherService { [Description(\"Get weather forecast for a US city\")] public async Task GetWeatherAsync( [Description(\"City name (e.g., 'San Francisco')\")] string city, [Description(\"State code (e.g., 'CA')\")] string state, CancellationToken cancellationToken = default) { // Implementation calls NWS API } }\n\n// Register as tools with ChatClientAgent var weatherTools = AIFunctionFactory.Create(weatherService); var chatOptions = new ChatOptions { Tools = weatherTools };\n\nvar agent = new ChatClientAgent(chatClient, new ChatClientAgentOptions { Name = \"WeatherAdvisor\", Instructions = \"Provide weather forecasts and packing recommendations...\", ChatOptions = chatOptions });\n\nThe agent can now call `GetWeatherAsync` via function calling‚Äîsame capability as Foundry agents, but configured in code instead of the portal.\n\n## Why Choose Client-Side Agents (ChatClientAgent)?\n\nHere's when ChatClientAgent shines:\n\n### ‚úÖ Full Orchestration Control\n\n**You write the workflow logic:**\n- // Phase 1: Run 3 agents in parallel (your code!)\nvar currencyTask = GatherCurrencyInfoAsync(request, state, progress, cancellationToken); var weatherTask = GatherWeatherInfoAsync(request, state, progress, cancellationToken); var localTask = GatherLocalKnowledgeAsync(request, state, progress, cancellationToken);\n\nawait Task.WhenAll(currencyTask, weatherTask, localTask);\n\n// Phase 2: Sequential itinerary planning (your code!) await PlanItineraryAsync(request, state, progress, cancellationToken);\n\n` `\n\nWith Foundry agents, orchestration patterns are limited to what the platform provides.\n\n### ‚úÖ Cost-Effective\n\n**No separate agent infrastructure:**\n\n- ChatClientAgent: Pay only for Azure OpenAI API calls\n- Foundry Agents: Pay for Azure OpenAI + AI Project resources + agent storage\n\nFor high-volume scenarios, this can add up to significant savings.\n\n### ‚úÖ DevOps-Friendly\n\n**Everything in code:**\n\n- Agent definitions tracked in Git\n- Testable with unit tests\n- CI/CD pipelines deploy everything together\n- No manual portal configuration steps\n- Infrastructure as Code (Bicep) covers all resources\n\n### ‚úÖ Flexible Chat History\n\n**Store conversations your way:**\n\n- Cosmos DB for global distribution and rich queries\n- Redis for ultra-low latency caching\n- SQL Database for complex relational queries\n- Blob Storage for long-term archival\n- Custom encryption and retention policies\n\n### ‚úÖ Provider Flexibility\n\n**Works with any IChatClient:**\n\n- Azure OpenAI (this sample)\n- OpenAI directly\n- Local models via Ollama\n- Azure AI Foundry model catalog\n- Custom chat implementations\n\nSwitching providers is just a configuration change‚Äîno agent re-creation needed.\n\n### ‚úÖ Multi-Agent Coordination Patterns\n\n**Implement complex workflows:**\n\n- Parallel execution (Phase 1 in our sample)\n- Sequential dependencies (Phase 2-4)\n- Conditional branching based on agent responses\n- Agent-to-agent negotiation\n- Hierarchical supervisor patterns\n- Custom retry logic per agent\n\nYou have complete freedom to orchestrate however your scenario requires.\n\n## Why Choose Server-Side Agents (Azure AI Foundry)?\n\nTo be fair, Foundry agents from Part 2 have their own advantages and this post isn't about dismissing them. They are a powerful option for many scenarios. Here are some reasons to choose Foundry agents:\n\n### ‚úÖ Managed Lifecycle\n\n**Platform handles the heavy lifting:**\n\n- Agents persist as Azure resources\n- Threads automatically manage conversation state\n- Runs track execution progress server-side\n- No orchestration code to write or maintain\n\n### ‚úÖ Built-In Features\n\n**Rich capabilities out of the box:**\n\n- File search for RAG scenarios\n- Code interpreter for data analysis\n- Automatic conversation threading\n- Built-in retry and error handling\n\n### ‚úÖ Portal UI\n\n**Configure without code:**\n\n- Create agents in Azure AI Foundry portal\n- Test agents interactively\n- View conversation threads and runs\n- Adjust instructions without redeployment\n\n### ‚úÖ Less Code\n\n**Simpler for basic scenarios:**\n- // Foundry Agent (Part 2 sample)\nvar agent = await agentsClient.CreateAgentAsync( \"gpt-4o\", instructions: \"You are a travel planning expert...\", tools: new List { new FunctionTool(...) });\n\nvar thread = await agentsClient.CreateThreadAsync(); var run = await agentsClient.CreateRunAsync(thread.Id, agent.Id);\n\n` `\n\nNo need to manage chat history, orchestration logic, or tool registration in code.\n\n## When to Choose Which Approach\n\nHere's my take on a decision guide. This isn't exhaustive, but it covers key considerations. Others may disagree based on their priorities, but this is how I think about it:\n\n| Requirement | ChatClientAgent | Foundry Agents | | --- | --- | --- | | **Complex multi-agent workflows** | ‚úÖ Full control | ‚ö†Ô∏è Limited patterns | | **Custom chat history storage** | ‚úÖ Any data store | ‚ùå Foundry threads only | | **Cost optimization** | ‚úÖ LLM calls only | ‚ö†Ô∏è + Infrastructure | | **Code-first DevOps** | ‚úÖ Everything in Git | ‚ö†Ô∏è Portal config needed | | **Provider flexibility** | ‚úÖ Any IChatClient | ‚ö†Ô∏è Azure only | | **Built-in RAG (file search)** | ‚ùå DIY | ‚úÖ Built-in | | **Portal UI for testing** | ‚ùå Code only | ‚úÖ Full UI | | **Quick prototypes** | ‚ö†Ô∏è More code | ‚úÖ Fast setup | | **Learning curve** | ‚ö†Ô∏è More concepts | ‚úÖ Guided setup |\n\n**Use ChatClientAgent when:**\n\n- You need complex multi-agent coordination\n- Cost optimization is important\n- You want full control over orchestration\n- Code-first DevOps is a priority\n- You need custom chat history management\n\n**Use Foundry Agents when:**\n\n- Simple single-agent or basic multi-agent scenarios\n- You want built-in RAG and file search\n- Portal-based configuration is preferred\n- Quick prototyping and experimentation\n- Managed infrastructure over custom code\n\n## Azure App Service: Perfect for Both\n\nHere's the great part: **Azure App Service supports both approaches equally well.**\n\n### The Same Architecture\n\nBoth samples use identical infrastructure.\n\n**What's the same:**\n\n- ‚úÖ Async request-reply pattern (202 Accepted ‚Üí poll status)\n- ‚úÖ Service Bus for reliable message delivery\n- ‚úÖ Cosmos DB for task state with 24-hour TTL\n- ‚úÖ WebJob for background processing\n- ‚úÖ Managed Identity for authentication\n- ‚úÖ Premium App Service tier for Always On\n\n**What's different:**\n\n- ChatClientAgent: Azure OpenAI endpoint directly (`https://ai-xyz.openai.azure.com/`\n)\n- Foundry Agents: AI Project endpoint (`https://ai-xyz.services.ai.azure.com/api/projects/proj-xyz`\n)\n- ChatClientAgent: Chat history in Cosmos DB (your control)\n- Foundry Agents: Chat history in Foundry threads (platform managed)\n\n**Azure App Service doesn't care which you choose.** It just runs your .NET code, processes messages from Service Bus, and stores state in Cosmos DB. The agent execution model is an implementation detail. You can easily switch between approaches without changing your hosting platform, and even use a hybrid approach if desired.\n\n## Get Started Today\n\nReady to try client-side multi-agent orchestration on Azure App Service?\n\nüîó **GitHub Repository**: [https://github.com/Azure-Samples/app-service-maf-openai-travel-agent-dotnet](https://github.com/Azure-Samples/app-service-maf-openai-travel-agent-dotnet)\n\nThe repository includes:\n\n- ‚úÖ Complete .NET 9 source code with 6 specialized ChatClientAgents\n- ‚úÖ Infrastructure as Code (Bicep) for one-command deployment\n- ‚úÖ Web UI with real-time progress tracking\n- ‚úÖ Comprehensive README and architecture documentation\n- ‚úÖ External API integrations (weather, currency)\n- ‚úÖ Client-side chat history management with Cosmos DB\n\n### Deploy in Minutes\n- # Clone the repository\ngit clone https://github.com/Azure-Samples/app-service-maf-openai-travel-agent-dotnet.git cd app-service-maf-openai-travel-agent-dotnet\n\n# Login to Azure\nazd auth login\n\n# Provision infrastructure and deploy the API\nazd up\n\n` `\n\nThis provisions:\n\n- Azure App Service (P0v4 Premium Windows)\n- Azure Service Bus (message queue)\n- Azure Cosmos DB (state + chat history storage)\n- Azure AI Services (AI Services resource)\n- GPT-4o model deployment (GlobalStandard 50K TPM)\n\nThen manually deploy the WebJob following the [README instructions](https://github.com/Azure-Samples/app-service-maf-openai-travel-agent-dotnet#deploy-the-webjob).\n\n### Compare with Part 2\n\nWant to see the differences firsthand? Deploy both samples:\n\n**Part 2 - Server-Side Foundry Agents:** üîó [https://github.com/Azure-Samples/app-service-maf-workflow-travel-agent-dotnet](https://github.com/Azure-Samples/app-service-maf-workflow-travel-agent-dotnet)\n\n**Part 3 - Client-Side ChatClientAgent (this post):** üîó [https://github.com/Azure-Samples/app-service-maf-openai-travel-agent-dotnet](https://github.com/Azure-Samples/app-service-maf-openai-travel-agent-dotnet)\n\nSame travel planner, same workflow, same results‚Äîdifferent execution model. Try both and see which fits your needs!\n\n## Key Takeaways\n\n‚úÖ **Microsoft Agent Framework offers choice**: Client-side (ChatClientAgent) vs. Server-side (Foundry Agents)\n\n‚úÖ **ChatClientAgent gives you full control**: Orchestration, chat history, agent lifecycle‚Äîyou manage it all in code\n\n‚úÖ **Foundry Agents give you convenience**: Managed infrastructure, built-in features, portal UI‚Äîlet the platform handle the details\n\n‚úÖ **Azure App Service supports both equally**: Same async request-reply pattern, same WebJob architecture, same infrastructure\n\n‚úÖ **Pick the right tool for your needs**: Complex coordination and cost control ‚Üí ChatClientAgent. Simple scenarios and managed infrastructure ‚Üí Foundry Agents.\n\nWhether you choose client-side or server-side agents, Azure App Service provides the perfect platform for long-running AI workloads‚Äîreliable, scalable, and fully managed.\n\n## What's Next?\n\nThis completes our three-part series on building AI agents with Microsoft Agent Framework on Azure App Service:\n\n- **[Part 1](https://techcommunity.microsoft.com/blog/appsonazureblog/build-long-running-ai-agents-on-azure-app-service-with-microsoft-agent-framework/4463159)**: Introduction to Agent Framework and async request-reply pattern\n- **[Part 2](https://techcommunity.microsoft.com/blog/appsonazureblog/part-2-build-long-running-ai-agents-on-azure-app-service-with-microsoft-agent-fr/4465825)**: Multi-agent systems with server-side Foundry Agents\n- **Part 3 (this post)**: Client-side multi-agent orchestration with ChatClientAgent\n\nWhat would you like to see next? More advanced orchestration patterns? Integration with other Azure services?\n\nLet me know in the comments what you'd like to learn about next and I'll do my best to deliver!"
}
