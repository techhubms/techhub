{
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/disciplined-guardrail-development-in-enterprise-application-with/ba-p/4455321",
  "PubDate": "2025-09-19T20:06:44+00:00",
  "FeedName": "Microsoft Tech Community",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Tags": [],
  "Description": "### What Is Disciplined Guardrail-Based Development?\n\nIn AI-assisted software development, approaches like *Vibe Coding*—which prioritize momentum and intuition—often fail to ensure code quality and maintainability. To address this, **Disciplined Guardrail-Based Development** introduces structured rules (\"guardrails\") that guide AI systems during coding and maintenance tasks, ensuring consistent quality and reliability.\n\nTo get AI (LLMs) to generate appropriate code, developers must provide clear and specific instructions. Two key elements are essential:\n\n1. What to build – Clarifying requirements and breaking down tasks\n2. How to build it – Defining the application architecture\n\nThe way these two elements are handled depends on the development methodology or process being used. Here are examples as follows.\n\n![]()\n\n### How to Set Up Disciplined Guardrails in GitHub Copilot\n\nTo implement **disciplined guardrail-based development** with GitHub Copilot, two key configuration features are used:\n\n###### 1. **Custom Instructions (.github/copilot-instructions.md):** This file allows you to define persistent instructions that GitHub Copilot will always refer to when generating code.\n\n- **Purpose**: Establish coding standards, architectural rules, naming conventions, and other quality guidelines.\n- **Best Practice**: Instead of placing all instructions in a single file, split them into multiple modular files and reference them accordingly. This improves maintainability and clarity.\n- **Example Use**: You might define rules like using camelCase for variables, enforcing error boundaries in React, or requiring TypeScript for all new code.\n- [https://docs.github.com/en/copilot/how-tos/configure-custom-instructions/add-repository-instructions](https://docs.github.com/en/copilot/how-tos/configure-custom-instructions/add-repository-instructions)\n\n###### 2. **Chat Modes (.github/chatmodes/\\*.chatmode.md):** These files define specialized chat modes tailored to specific tasks or workflows.\n\n- **Purpose**: Customize Copilot’s behavior for different development contexts (e.g., debugging, writing tests, refactoring).\n- **Structure**: Each .chatmode.md file includes metadata and instructions that guide Copilot’s responses in that mode.\n- **Example Use**: A debug.chatmode.md might instruct Copilot to focus on identifying and resolving runtime errors, while a test.chatmode.md could prioritize generating unit tests with specific frameworks.\n- [https://code.visualstudio.com/docs/copilot/customization/custom-chat-modes](https://code.visualstudio.com/docs/copilot/customization/custom-chat-modes)\n\nThe files to be created and their relationships are as follows.\n\n![]()\n\nNext, there are introductions for the specific creation method.\n\n#### **#1: Custom Instructions**\n\nWith custom instructions, you can define commands that are always provided to GitHub Copilot. The prepared files are always referenced during chat sessions and passed to the LLM (**this can also be confirmed from the chat history**). An important note is to split the content into several files and include links to those files within the .github/copilot-instructions.md file. Because it can become too long if everything is written in a single file.\n\n![]()\n\nThere are mainly two types of content that should be described in custom instructions:\n\n**A: Development Process (≒ outcome + Creation Method)**\n\n- What documents or code will be created: requirements specification, design documents, task breakdown tables, implementation code, etc.\n- In what order and by whom they will be created: for example, proceed in the order of requirements definition → design → task breakdown → coding.\n\n**B: Application Architecture**\n\n- How will the outcome be defined in A be created?\n- What technology stack and component structure will be used?\n\nA concrete example of **copilot-instructions.md** is shown below.\n\n- # Development Rules\n\n## Architecture\n- When performing design and coding tasks, always refer to the following architecture documents and strictly follow them as rules.\n\n### Product Overview\n- Document the product overview in `.github/architecture/product.md`\n\n### Technology Stack\n- Document the technologies used in `.github/architecture/techstack.md`\n\n### Coding Standards\n- Document coding standards in `.github/architecture/codingrule.md`\n\n### Project Structure\n- Document the project directory structure in `.github/architecture/structure.md`\n\n### Glossary (Japanese-English)\n- Document the list of terms used in the project in `.github/architecture/dictionary.md`\n\n## Development Flow\n- Follow a disciplined development flow and execute the following four stages in order (proceed to the next stage only after completing the current one):\n1. Requirement Definition\n2. Design\n3. Task Breakdown\n4. Coding\n\n### 1. Requirement Definition\n- Document requirements in `docs/[subsystem_name]/[business_name]/requirement.md`\n- Use `requirement.chatmode.md` to define requirements\n- Focus on clarifying objectives, understanding the current situation, and setting success criteria\n- Once requirements are defined, obtain user confirmation before proceeding to the next stage\n\n### 2. Design\n- Document design in `docs/[subsystem_name]/[business_name]/design.md`\n- Use `design.chatmode.md` to define the design\n- Define UI, module structure, and interface design\n- Once the design is complete, obtain user confirmation before proceeding to the next stage\n\n### 3. Task Breakdown\n- Document tasks in `docs/[subsystem_name]/[business_name]/tasks.md`\n- Use `tasks.chatmode.md` to define tasks\n- Break down tasks into executable units and set priorities\n- Once task breakdown is complete, obtain user confirmation before proceeding to the next stage\n\n### 4. Coding\n- Implement code under `src/[subsystem_name]/[business_name]/`\n- Perform coding task by task\n- Update progress in `docs/[subsystem_name]/[business_name]/tasks.md`\n- Report to the user upon completion of each task\n\nNote: The only file that is always sent to the LLM is `copilot-instructions.md`. Documents linked from there (such as `product.md` or `techstack.md`) are not guaranteed to be read by the LLM. That said, a reasonably capable LLM will usually review these files before proceeding with the work.\n\nIf the LLM does not properly reference each file, you may explicitly add these architecture documents to the context. Another approach is to instruct the LLM to review these files in the \\*\\*chat mode settings\\*\\*, which will be described later.\n\nThere are various “schools of thought” regarding application architecture, and it is still an ongoing challenge to determine exactly what should be defined and what documents should be created. The choice of architecture depends on factors such as the business context, development scale, and team structure, so it is difficult to prescribe a one-size-fits-all approach. That said, as a general guideline, it is desirable to summarize the following:\n\n- **Product Overview**: Overview of the product, service, or business, including its overall characteristics\n- **Technology Stack**: What technologies will be used to develop the application?\n- **Project Structure**: How will folders and directories be organized during development?\n- **Module Structure**: How will the application be divided into modules?\n- **Coding Rules**: Rules for handling exceptions, naming conventions, and other coding practices\n\nWriting all of this from scratch can be challenging. A practical approach is to create template information with the help of Copilot and then refine it. Specifically, you can:\n\n- Use tools like **M365 Copilot Researcher** to create content based on general principles\n- Analyze a prototype application and have the architecture information summarized (using **Ask mode** or **Edit mode**, feed the solution files to a capable LLM for analysis)\n\nHowever, in most cases, the output cannot be used as-is.\n\n- The structure may not be analyzed correctly (hallucinations may occur)\n- Project-specific practices and rules may not be captured\n\nUse the generated content as a starting point, and then refine it to create architecture documentation tailored to your own project.\n\n![]()\n\nWhen creating architecture documents for enterprise-scale application development, a useful approach is to distinguish between the **foundational parts** and the **individual application parts**. Discipline-based guardrail development is particularly effective when building multiple applications in a “cookie-cutter” style on top of a common foundation. A cler example of this is **Data-Oriented Architecture (DOA)**. In DOA, individual business applications are built on top of a shared database that serves as the overall common foundation.\n\nIn this case, the **foundational parts** (the database layer) should not be modified arbitrarily by individual developers. Instead, focus on how to standardize the development of the **individual application parts** (the blue-framed sections) while ensuring consistency. Architecture documentation should be organized with this distinction in mind, emphasizing the uniformity of application-level development built upon the stable foundation.\n\n![]()\n\n#### **#2 Chat Mode**\n\nBy default, GitHub Copilot provides three chat modes: **Ask**, **Edit**, and **Agent**. However, by creating files under .github/chatmodes/\\*.chatmode.md, you can **customize the Agent mode** to create chat modes tailored for specific tasks.\n\n![]()\n\nSpecifically, you can configure the following three aspects. Functionally, this allows you to perform a specific task without having to manually change the model or tools, or write detailed instructions each time:\n\n- **model**: Specify the default LLM to use\n*(Note: The user can still manually switch to another LLM if desired)*\n- **tools**: Restrict which tools can be used\n*(Note: The user can still manually select other tools if desired)*\n- **custom instructions**: Provide custom instructions specific to this chat mode\n\n![]()\n\nA concrete example of .github/chatmodes/\\*.chatmode.md is shown below.\n- description: This mode is used for requirement definition tasks.\n\nmodel: Claude Sonnet 4\n\ntools: ['changes', 'codebase', 'editFiles', 'fetch', 'findTestFiles', 'githubRepo', 'new', 'openSimpleBrowser', 'runCommands', 'search', 'searchResults', 'terminalLastCommand', 'terminalSelection', 'usages', 'vscodeAPI', 'mssql\\_connect', 'mssql\\_disconnect', 'mssql\\_list\\_servers', 'mssql\\_show\\_schema']\n\n---\n\n# Requirement Definition Mode\nIn this mode, requirement definition tasks are performed. Specifically, the project requirements are clarified, and necessary functions and specifications are defined. Based on instructions or interviews with the user, document the requirements according to the format below. If any specifications are ambiguous or unclear, Copilot should ask the user questions to clarify them.\n\n## File Storage Location\nSave the requirement definition file in the following location:\n- Save as `requirement.md` under the directory `docs/[subsystem_name]/[business_name]/`\n\n## Requirement Definition Format\nWhile interviewing the user, document the following items in the Markdown file:\n- \\*\\*Subsystem Name\\*\\*: The name of the subsystem to which this business belongs\n- \\*\\*Business Name\\*\\*: The name of the business\n- \\*\\*Overview\\*\\*: A summary of the business\n- \\*\\*Use Cases\\*\\*: Clarify who uses this business, when/under what circumstances, and for what purpose, using the following structure:\n- \\*\\*Who (Persona)\\*\\*: User or system roles\n- \\*\\*When/Under What Circumstances (Scenario)\\*\\*: Timing when the business is executed\n- \\*\\*Purpose (Goal)\\*\\*: Objectives or expected outcomes of the business\n- \\*\\*Importance\\*\\*: The importance of the business (e.g., High, Medium, Low)\n- \\*\\*Acceptance Criteria\\*\\*: Conditions that must be satisfied for the requirement to be considered met\n- \\*\\*Status\\*\\*: Current state of the requirement (e.g., In Progress, Completed)\n\n## After Completion\n- Once requirement definition is complete, obtain user confirmation and proceed to the next stage (Design).\n\n##### **Tips for Creating Chat Modes**\n\nHere are some tips for creating custom chat modes:\n\n- **Align with the development process**: Create chat modes based on the workflow and the deliverables.\n- **Instruct the LLM to ask the user when unsure**: Direct the LLM to request clarification from the user if any information is missing.\n- **Clarify what deliverables to create and where to save them**: Make it explicit which outputs are expected and their storage locations.\n\nThe second point is particularly important. Many AI (LLMs) tend to respond to user prompts in a sycophantic manner (known as **sycophancy**). As a result, they may fill in unspecified requirements or perform tasks that were not requested, often with the intention of being helpful.\n\nThe key difference between **Ask/Edit modes** and **Agent mode** is that Agent mode allows the LLM to proactively ask questions and engage in dialogue with the user. However, unless the user explicitly includes a prompt such as “ask if you don’t know,” the AI rarely initiates questions on its own. By creating a custom chat mode and instructing the LLM to “ask the user when unsure,” you can fully leverage the benefits of Agent mode.\n\n##### **About Tools**\n\nYou can easily check tool names from the list of available tools in the command palette.\n\n![]()\n\nAlternatively, as shown in the diagram below, it can be convenient to open the custom chat mode file and specify the **tool configuration**. You can specify not only the MCP server functionality but also built-in tools and Copilot Extensions.\n\n![]()\n\n###### **Example of Actual Operation**\n\nAn example interaction when using this chat mode is as follows:\n\n- The LLM behaves according to the custom instructions defined in the chat mode.\n- When you answer questions from GHC, the LLM uses that information to reason and proceed with the task.\n- However, the output is not guaranteed to be correct (hallucinations may occur) → A human should review the output and make any necessary corrections before committing.\n\nThe basic approach to disciplined guardrail-based development has been covered above. In actual business application development, it is also helpful to understand the following two points:\n\n1. **Referencing the database schema**\n2. **Integrated management of design documents and implementation code**\n\n###### (Important) Reading the Database Schema\n\nIn business application development, requirements definition and functional design are often based on the schema information of entities. There are two main ways to allow the system to read schema information:\n\n1. **Dynamically read the schema from a development/test DB server** using MCP or similar tools.\n2. **Include a file containing schema information within the project** and read from it.\n\nA development/test database can be prepared, and schema information can be read via the MCP server or Copilot Extensions. For SQL Server or Azure SQL Database, an MCP Server is available, but its setup can be cumbersome. Therefore, using Copilot Extensions is often easier and recommended. This approach is often seen online, but it is not recommended for the following reasons:\n\n- Setting up MCP Server or Copilot Extensions can be cumbersome (installation, connection string management, etc.)\n- It is time-consuming (the LLM needs schema information → reads the schema → writes code based on it)\n\nConnecting to a DB server via MCP or similar tools is useful for scenarios such as “querying a database in natural language” for non-engineers performing data analysis. However, if the goal is simply to **obtain the schema information of entities needed for business application development**, the method described below is much simpler.\n\n###### Storing Schema Information Within the Project\n\nPlace a file containing the schema information inside the project. Any of the following formats is recommended. Write custom instructions so that development refers to this file:\n\n- **DDL** (full CREATE DATABASE scripts)\n- **O/R mapper files** (e.g., Entity Framework context files)\n- **Text files documenting schema information**, etc.\n\nDDL files are difficult for humans to read, but AI (LLMs) can easily read and accurately understand them. In .NET + SQL development, it is recommended to include both the DDL and EF O/R mapper files. Additionally, if you include links to these files in your architecture documents and chat mode instructions, the LLM can generate code while understanding the schema with high accuracy.\n\n###### **Integrated Management of Design Documents and Implementation Code**\n\nDisciplined guardrail-based development with LLMs has made it practical to synchronize and manage design documents and implementation code together—something that was traditionally very difficult. In long-standing systems, it is common for old design documents to become largely useless.\n\n- During maintenance, code changes are often prioritized.\n- As a result, updating and maintaining design documents tends to be neglected, leading to a significant divergence between design documents and the actual code.\n\nFor these reasons, the following have been considered best practices (though often not followed in reality):\n\n- Limit requirements and external design documents to the minimum necessary.\n- Do not create internal design documents; instead, document within the code itself.\n- Always update design documents **before** making changes to the implementation code.\n\nWhen using LLMs, guardrail-based development makes it easier to enforce a “write the documentation first” workflow. Following the flow of **defining specifications, updating the documents, and then writing code** also helps the LLM generate appropriate code more reliably. Even if code is written first, LLM-assisted code analysis can significantly reduce the effort required to update the documentation afterward. However, the following points should be noted when doing this:\n\n- Create and manage design documents as **text files**, not Word, Excel, or PowerPoint.\n- Use text-based technologies like **Mermaid** for diagrams.\n- Clearly define how design documents correspond to the code.\n\nThe last point is especially important. It is crucial to align the structure of requirements and design documents with the structure of the implementation code. For example:\n\n- Place design documents directly alongside the implementation code.\n- Align folder structures, e.g., /doc and /src.\n\nInformation about grouping methods and folder mapping should be explicitly included in the custom instructions.\n\n![]()\n\n#### Conclusion of Disciplined Guardrail-Based Development with GHC\n\nFormalizing and Applying Guardrails\n\n- Define the development flow and architecture documents in .github/copilot-instructions.md using split references.\n- Prepare .github/chatmodes/\\* for each development phase, enforcing **“ask the AI if anything is unclear.”**\n\nSynchronization of Documents and Implementation Code\n\n- Update docs first → use the diff as the basis for implementation (**Doc-first**).\n- Keep docs in text format (Markdown/Mermaid). Fix folder correspondence between /docs and /src.\n\nHandling Schemas\n\n- Store DDL/O-R mapper files (e.g., EF) in the repository and have the LLM reference them.\n- Minimize dynamic DB connections, prioritizing speed, reproducibility, and security.\n\nThis **disciplined guardrail-based development** technique is an AI-assisted approach that significantly improves the **quality, maintainability, and team efficiency** of enterprise business application development. Adapt it appropriately to each project to maximize productivity in application development.",
  "Title": "Disciplined Guardrail Development in enterprise application with GitHub Copilot",
  "OutputDir": "_community",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "ProcessedDate": "2025-09-19 20:15:02",
  "EnhancedContent": "### What Is Disciplined Guardrail-Based Development?\n\nIn AI-assisted software development, approaches like *Vibe Coding*—which prioritize momentum and intuition—often fail to ensure code quality and maintainability. To address this, **Disciplined Guardrail-Based Development** introduces structured rules (\"guardrails\") that guide AI systems during coding and maintenance tasks, ensuring consistent quality and reliability.\n\nTo get AI (LLMs) to generate appropriate code, developers must provide clear and specific instructions. Two key elements are essential:\n\n1. What to build – Clarifying requirements and breaking down tasks\n2. How to build it – Defining the application architecture\n\nThe way these two elements are handled depends on the development methodology or process being used. Here are examples as follows.\n\n### How to Set Up Disciplined Guardrails in GitHub Copilot\n\nTo implement **disciplined guardrail-based development** with GitHub Copilot, two key configuration features are used:\n\n###### 1. **Custom Instructions (.github/copilot-instructions.md):** This file allows you to define persistent instructions that GitHub Copilot will always refer to when generating code.\n\n- **Purpose**: Establish coding standards, architectural rules, naming conventions, and other quality guidelines.\n- **Best Practice**: Instead of placing all instructions in a single file, split them into multiple modular files and reference them accordingly. This improves maintainability and clarity.\n- **Example Use**: You might define rules like using camelCase for variables, enforcing error boundaries in React, or requiring TypeScript for all new code.\n- [https://docs.github.com/en/copilot/how-tos/configure-custom-instructions/add-repository-instructions](https://docs.github.com/en/copilot/how-tos/configure-custom-instructions/add-repository-instructions)\n\n###### 2. **Chat Modes (.github/chatmodes/\\*.chatmode.md):** These files define specialized chat modes tailored to specific tasks or workflows.\n\n- **Purpose**: Customize Copilot’s behavior for different development contexts (e.g., debugging, writing tests, refactoring).\n- **Structure**: Each .chatmode.md file includes metadata and instructions that guide Copilot’s responses in that mode.\n- **Example Use**: A debug.chatmode.md might instruct Copilot to focus on identifying and resolving runtime errors, while a test.chatmode.md could prioritize generating unit tests with specific frameworks.\n- [https://code.visualstudio.com/docs/copilot/customization/custom-chat-modes](https://code.visualstudio.com/docs/copilot/customization/custom-chat-modes)\n\nThe files to be created and their relationships are as follows.\n\nNext, there are introductions for the specific creation method.\n\n#### **#1:  Custom Instructions**\n\nWith custom instructions, you can define commands that are always provided to GitHub Copilot. The prepared files are always referenced during chat sessions and passed to the LLM (**this can also be confirmed from the chat history**). An important note is to split the content into several files and include links to those files within the .github/copilot-instructions.md file. Because it can become too long if everything is written in a single file.\n\nThere are mainly two types of content that should be described in custom instructions:\n\n**A: Development Process (≒ outcome + Creation Method)**\n\n- What documents or code will be created: requirements specification, design documents, task breakdown tables, implementation code, etc.\n- In what order and by whom they will be created: for example, proceed in the order of requirements definition → design → task breakdown → coding.\n\n**B: Application Architecture**\n\n- How will the outcome be defined in A be created?\n- What technology stack and component structure will be used?\n\nA concrete example of **copilot-instructions.md** is shown below.\n\n```\n# Development Rules\n\n## Architecture\n- When performing design and coding tasks, always refer to the following architecture documents and strictly follow them as rules.\n\n### Product Overview\n- Document the product overview in `.github/architecture/product.md`\n\n### Technology Stack\n- Document the technologies used in `.github/architecture/techstack.md`\n\n### Coding Standards\n- Document coding standards in `.github/architecture/codingrule.md`\n\n### Project Structure\n- Document the project directory structure in `.github/architecture/structure.md`\n\n### Glossary (Japanese-English)\n- Document the list of terms used in the project in `.github/architecture/dictionary.md`\n\n## Development Flow\n- Follow a disciplined development flow and execute the following four stages in order (proceed to the next stage only after completing the current one):\n1. Requirement Definition\n2. Design\n3. Task Breakdown\n4. Coding\n\n### 1. Requirement Definition\n- Document requirements in `docs/[subsystem_name]/[business_name]/requirement.md`\n- Use `requirement.chatmode.md` to define requirements\n- Focus on clarifying objectives, understanding the current situation, and setting success criteria\n- Once requirements are defined, obtain user confirmation before proceeding to the next stage\n\n### 2. Design\n- Document design in `docs/[subsystem_name]/[business_name]/design.md`\n- Use `design.chatmode.md` to define the design\n- Define UI, module structure, and interface design\n- Once the design is complete, obtain user confirmation before proceeding to the next stage\n\n### 3. Task Breakdown\n- Document tasks in `docs/[subsystem_name]/[business_name]/tasks.md`\n- Use `tasks.chatmode.md` to define tasks\n- Break down tasks into executable units and set priorities\n- Once task breakdown is complete, obtain user confirmation before proceeding to the next stage\n\n### 4. Coding\n- Implement code under `src/[subsystem_name]/[business_name]/`\n- Perform coding task by task\n- Update progress in `docs/[subsystem_name]/[business_name]/tasks.md`\n- Report to the user upon completion of each task\n\n```\n\nNote: The only file that is always sent to the LLM is `copilot-instructions.md`.  Documents linked from there (such as `product.md` or `techstack.md`) are not guaranteed to be read by the LLM. That said, a reasonably capable LLM will usually review these files before proceeding with the work.\n\nIf the LLM does not properly reference each file, you may explicitly add these architecture documents to the context. Another approach is to instruct the LLM to review these files in the \\*\\*chat mode settings\\*\\*, which will be described later.\n\nThere are various “schools of thought” regarding application architecture, and it is still an ongoing challenge to determine exactly what should be defined and what documents should be created. The choice of architecture depends on factors such as the business context, development scale, and team structure, so it is difficult to prescribe a one-size-fits-all approach. That said, as a general guideline, it is desirable to summarize the following:\n\n- **Product Overview**: Overview of the product, service, or business, including its overall characteristics\n- **Technology Stack**: What technologies will be used to develop the application?\n- **Project Structure**: How will folders and directories be organized during development?\n- **Module Structure**: How will the application be divided into modules?\n- **Coding Rules**: Rules for handling exceptions, naming conventions, and other coding practices\n\nWriting all of this from scratch can be challenging. A practical approach is to create template information with the help of Copilot and then refine it. Specifically, you can:\n\n- Use tools like **M365 Copilot Researcher** to create content based on general principles\n- Analyze a prototype application and have the architecture information summarized (using **Ask mode** or **Edit mode**, feed the solution files to a capable LLM for analysis)\n\nHowever, in most cases, the output cannot be used as-is.\n\n- The structure may not be analyzed correctly (hallucinations may occur)\n- Project-specific practices and rules may not be captured\n\nUse the generated content as a starting point, and then refine it to create architecture documentation tailored to your own project.\n\nWhen creating architecture documents for enterprise-scale application development, a useful approach is to distinguish between the **foundational parts** and the **individual application parts**. Discipline-based guardrail development is particularly effective when building multiple applications in a “cookie-cutter” style on top of a common foundation. A cler example of this is **Data-Oriented Architecture (DOA)**. In DOA, individual business applications are built on top of a shared database that serves as the overall common foundation.\n\nIn this case, the **foundational parts** (the database layer) should not be modified arbitrarily by individual developers. Instead, focus on how to standardize the development of the **individual application parts** (the blue-framed sections) while ensuring consistency. Architecture documentation should be organized with this distinction in mind, emphasizing the uniformity of application-level development built upon the stable foundation.\n\n#### **#2 Chat Mode**\n\nBy default, GitHub Copilot provides three chat modes: **Ask**, **Edit**, and **Agent**. However, by creating files under .github/chatmodes/\\*.chatmode.md, you can **customize the Agent mode** to create chat modes tailored for specific tasks.\n\nSpecifically, you can configure the following three aspects. Functionally, this allows you to perform a specific task without having to manually change the model or tools, or write detailed instructions each time:\n\n- **model**: Specify the default LLM to use\n*(Note: The user can still manually switch to another LLM if desired)*\n- **tools**: Restrict which tools can be used\n*(Note: The user can still manually select other tools if desired)*\n- **custom instructions**: Provide custom instructions specific to this chat mode\n\nA concrete example of .github/chatmodes/\\*.chatmode.md is shown below.\n\n``` description: This mode is used for requirement definition tasks.\n\nmodel: Claude Sonnet 4\n\ntools: ['changes', 'codebase', 'editFiles', 'fetch', 'findTestFiles', 'githubRepo', 'new', 'openSimpleBrowser', 'runCommands', 'search', 'searchResults', 'terminalLastCommand', 'terminalSelection', 'usages', 'vscodeAPI', 'mssql_connect', 'mssql_disconnect', 'mssql_list_servers', 'mssql_show_schema']\n\n---\n\n# Requirement Definition Mode\nIn this mode, requirement definition tasks are performed. Specifically, the project requirements are clarified, and necessary functions and specifications are defined. Based on instructions or interviews with the user, document the requirements according to the format below. If any specifications are ambiguous or unclear, Copilot should ask the user questions to clarify them.\n\n## File Storage Location\nSave the requirement definition file in the following location:\n- Save as `requirement.md` under the directory `docs/[subsystem_name]/[business_name]/`\n\n## Requirement Definition Format\nWhile interviewing the user, document the following items in the Markdown file:\n- **Subsystem Name**: The name of the subsystem to which this business belongs\n- **Business Name**: The name of the business\n- **Overview**: A summary of the business\n- **Use Cases**: Clarify who uses this business, when/under what circumstances, and for what purpose, using the following structure:\n- **Who (Persona)**: User or system roles\n- **When/Under What Circumstances (Scenario)**: Timing when the business is executed\n- **Purpose (Goal)**: Objectives or expected outcomes of the business\n- **Importance**: The importance of the business (e.g., High, Medium, Low)\n- **Acceptance Criteria**: Conditions that must be satisfied for the requirement to be considered met\n- **Status**: Current state of the requirement (e.g., In Progress, Completed)\n\n## After Completion\n- Once requirement definition is complete, obtain user confirmation and proceed to the next stage (Design).\n\n```\n\n##### **Tips for Creating Chat Modes**\n\nHere are some tips for creating custom chat modes:\n\n- **Align with the development process**: Create chat modes based on the workflow and the deliverables.\n- **Instruct the LLM to ask the user when unsure**: Direct the LLM to request clarification from the user if any information is missing.\n- **Clarify what deliverables to create and where to save them**: Make it explicit which outputs are expected and their storage locations.\n\nThe second point is particularly important. Many AI (LLMs) tend to respond to user prompts in a sycophantic manner (known as **sycophancy**). As a result, they may fill in unspecified requirements or perform tasks that were not requested, often with the intention of being helpful.\n\nThe key difference between **Ask/Edit modes** and **Agent mode** is that Agent mode allows the LLM to proactively ask questions and engage in dialogue with the user. However, unless the user explicitly includes a prompt such as “ask if you don’t know,” the AI rarely initiates questions on its own. By creating a custom chat mode and instructing the LLM to “ask the user when unsure,” you can fully leverage the benefits of Agent mode.\n\n##### **About Tools**\n\nYou can easily check tool names from the list of available tools in the command palette.\n\nAlternatively, as shown in the diagram below, it can be convenient to open the custom chat mode file and specify the **tool configuration**. You can specify not only the MCP server functionality but also built-in tools and Copilot Extensions.\n\n###### **Example of Actual Operation**\n\nAn example interaction when using this chat mode is as follows:\n\n- The LLM behaves according to the custom instructions defined in the chat mode.\n- When you answer questions from GHC, the LLM uses that information to reason and proceed with the task.\n- However, the output is not guaranteed to be correct (hallucinations may occur) → A human should review the output and make any necessary corrections before committing.\n\nThe basic approach to disciplined guardrail-based development has been covered above. In actual business application development, it is also helpful to understand the following two points:\n\n1. **Referencing the database schema**\n2. **Integrated management of design documents and implementation code**\n\n###### (Important) Reading the Database Schema\n\nIn business application development, requirements definition and functional design are often based on the schema information of entities. There are two main ways to allow the system to read schema information:\n\n1. **Dynamically read the schema from a development/test DB server** using MCP or similar tools.\n2. **Include a file containing schema information within the project** and read from it.\n\nA development/test database can be prepared, and schema information can be read via the MCP server or Copilot Extensions. For SQL Server or Azure SQL Database, an MCP Server is available, but its setup can be cumbersome. Therefore, using Copilot Extensions is often easier and recommended. This approach is often seen online, but it is not recommended for the following reasons:\n\n- Setting up MCP Server or Copilot Extensions can be cumbersome (installation, connection string management, etc.)\n- It is time-consuming (the LLM needs schema information → reads the schema → writes code based on it)\n\nConnecting to a DB server via MCP or similar tools is useful for scenarios such as “querying a database in natural language” for non-engineers performing data analysis. However, if the goal is simply to **obtain the schema information of entities needed for business application development**, the method described below is much simpler.\n\n###### Storing Schema Information Within the Project\n\nPlace a file containing the schema information inside the project. Any of the following formats is recommended. Write custom instructions so that development refers to this file:\n\n- **DDL** (full CREATE DATABASE scripts)\n- **O/R mapper files** (e.g., Entity Framework context files)\n- **Text files documenting schema information**, etc.\n\nDDL files are difficult for humans to read, but AI (LLMs) can easily read and accurately understand them. In .NET + SQL development, it is recommended to include both the DDL and EF O/R mapper files. Additionally, if you include links to these files in your architecture documents and chat mode instructions, the LLM can generate code while understanding the schema with high accuracy.\n\n###### **Integrated Management of Design Documents and Implementation Code**\n\nDisciplined guardrail-based development with LLMs has made it practical to synchronize and manage design documents and implementation code together—something that was traditionally very difficult. In long-standing systems, it is common for old design documents to become largely useless.\n\n- During maintenance, code changes are often prioritized.\n- As a result, updating and maintaining design documents tends to be neglected, leading to a significant divergence between design documents and the actual code.\n\nFor these reasons, the following have been considered best practices (though often not followed in reality):\n\n- Limit requirements and external design documents to the minimum necessary.\n- Do not create internal design documents; instead, document within the code itself.\n- Always update design documents **before** making changes to the implementation code.\n\nWhen using LLMs, guardrail-based development makes it easier to enforce a “write the documentation first” workflow. Following the flow of **defining specifications, updating the documents, and then writing code** also helps the LLM generate appropriate code more reliably. Even if code is written first, LLM-assisted code analysis can significantly reduce the effort required to update the documentation afterward. However, the following points should be noted when doing this:\n\n- Create and manage design documents as **text files**, not Word, Excel, or PowerPoint.\n- Use text-based technologies like **Mermaid** for diagrams.\n- Clearly define how design documents correspond to the code.\n\nThe last point is especially important. It is crucial to align the structure of requirements and design documents with the structure of the implementation code. For example:\n\n- Place design documents directly alongside the implementation code.\n- Align folder structures, e.g., /doc and /src.\n\nInformation about grouping methods and folder mapping should be explicitly included in the custom instructions.\n\n#### Conclusion of Disciplined Guardrail-Based Development with GHC\n\nFormalizing and Applying Guardrails\n\n- Define the development flow and architecture documents in .github/copilot-instructions.md using split references.\n- Prepare .github/chatmodes/\\* for each development phase, enforcing **“ask the AI if anything is unclear.”**\n\nSynchronization of Documents and Implementation Code\n\n- Update docs first → use the diff as the basis for implementation (**Doc-first**).\n- Keep docs in text format (Markdown/Mermaid). Fix folder correspondence between /docs and /src.\n\nHandling Schemas\n\n- Store DDL/O-R mapper files (e.g., EF) in the repository and have the LLM reference them.\n- Minimize dynamic DB connections, prioritizing speed, reproducibility, and security.\n\nThis **disciplined guardrail-based development** technique is an AI-assisted approach that significantly improves the **quality, maintainability, and team efficiency** of enterprise business application development. Adapt it appropriately to each project to maximize productivity in application development.\n\nUpdated Sep 19, 2025\n\nVersion 1.0\n\n[.net](/tag/.net?nodeId=board%3AAppsonAzureBlog)\n\n[.net core](/tag/.net%20core?nodeId=board%3AAppsonAzureBlog)\n\n[devops](/tag/devops?nodeId=board%3AAppsonAzureBlog)\n\n[java](/tag/java?nodeId=board%3AAppsonAzureBlog)\n\n[java ee](/tag/java%20ee?nodeId=board%3AAppsonAzureBlog)\n\n[node.js](/tag/node.js?nodeId=board%3AAppsonAzureBlog)\n\n[php](/tag/php?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[daisami&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS00Nzk2OTItMjM1NDE4aUUyRDFCMDFGQ0EzRDgwMkE?image-dimensions=50x50)](/users/daisami/479692) [daisami](/users/daisami/479692) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined December 06, 2019\n\n[View Profile](/users/daisami/479692)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "Author": "daisami"
}
