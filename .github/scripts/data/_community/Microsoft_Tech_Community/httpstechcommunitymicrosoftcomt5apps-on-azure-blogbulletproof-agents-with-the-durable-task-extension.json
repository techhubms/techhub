{
  "OutputDir": "_community",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Description": "Today, we're thrilled to announce the public preview of the **durable task extension for Microsoft Agent Framework**. This extension transforms how you build production-ready, resilient and scalable AI agents by bringing the proven durable execution (survives crashes and restarts) and distributed execution (runs across multiple instances) capabilities of [Azure Durable Functions](https://learn.microsoft.com/azure/azure-functions/durable/) directly into the [Microsoft Agent Framework](https://learn.microsoft.com/agent-framework/). Now you can deploy stateful, resilient AI agents to Azure that automatically handle session management, failure recovery, and scaling, freeing you to focus entirely on your agent logic.\n\nWhether you're building customer service agents that maintain context across multi-day conversations, content pipelines with human-in-the-loop approval workflows, or fully automated multi-agent systems coordinating specialized AI models, the durable task extension gives you production-grade reliability, scalability and coordination with serverless simplicity.\n\nKey features of the durable task extension include:\n\n- **Automatic Session Management**: Agents maintain persistent sessions with full conversation context that survives process crashes, restarts, and distributed execution across instances\n- **Deterministic Multi-Agent Orchestrations**: Coordinate specialized durable agents with predictable, repeatable, code-driven execution patterns\n- **Human-in-the-Loop with Serverless Cost Savings**: Pause for human input without consuming compute resources or incurring costs\n- **Built-in Observability with Durable Task Scheduler**: Deep visibility into agent operations and orchestrations through the Durable Task Scheduler UI dashboard\n\n#### [Click here to create and run a durable agent](https://aka.ms/create-and-run-durable-agent)\n\n- # Python\n\nendpoint = os.getenv(\"AZURE\\_OPENAI\\_ENDPOINT\") deployment\\_name = os.getenv(\"AZURE\\_OPENAI\\_DEPLOYMENT\\_NAME\", \"gpt-4o-mini\")\n\n# Create an AI agent following the standard Microsoft Agent Framework pattern\nagent = AzureOpenAIChatClient( endpoint=endpoint, deployment\\_name=deployment\\_name, credential=AzureCliCredential() ).create\\_agent( instructions=\"You are good at telling jokes.\", name=\"Joker\" )\n\n# Configure the function app to host the agent with durable session management\napp = AgentFunctionApp(agents=[agent])\n\napp.run()\n- // C#\n\nvar endpoint = Environment.GetEnvironmentVariable(\"AZURE\\_OPENAI\\_ENDPOINT\"); var deploymentName = Environment.GetEnvironmentVariable(\"AZURE\\_OPENAI\\_DEPLOYMENT\") ?? \"gpt-4o-mini\";\n\n// Create an AI agent following the standard Microsoft Agent Framework pattern AIAgent agent = new AzureOpenAIClient(new Uri(endpoint), new AzureCliCredential()) .GetChatClient(deploymentName) .CreateAIAgent( instructions: \"You are good at telling jokes.\", name: \"Joker\");\n\n// Configure the function app to host the agent with durable thread management // This automatically creates HTTP endpoints and manages state persistence using IHost app = FunctionsApplication .CreateBuilder(args) .ConfigureFunctionsWebApplication() .ConfigureDurableAgents(options => options.AddAIAgent(agent) ) .Build(); app.Run();\n\n## **Why the durable task extension?**\n\nAs AI agents evolve from simple chatbots to sophisticated systems handling complex, long-running tasks, new challenges emerge:\n\n- Conversations span multiple days and weeks, requiring persistent state across process restarts, crashes, and disruptions.\n- Tool calls might take longer than typical timeouts allow, needing automatic checkpointing and recovery.\n- High-volume workloads require elastic scaling across distributed instances to handle thousands of concurrent agent conversations.\n- Multiple specialized agents need coordination with predictable, repeatable execution for reliable business processes.\n- Agents sometimes must wait for human approval before proceeding, ideally without consuming resources.\n\nThe Durable Extension addresses these challenges by extending [Microsoft Agent Framework](https://learn.microsoft.com/agent-framework/) with capabilities from [Azure Durable Functions](https://learn.microsoft.com/azure/azure-functions/durable/), enabling you to build AI agents that survive failures, scale elastically, and execute predictably through durable and distributed execution.\n\nThe extension is built on four foundational value pillars, which we refer to as **the 4D’s**:\n\n##### **Durability**\n\nEvery agent state change (messages, tool calls, decisions) is durably checkpointed automatically. Agents survive and automatically resume from infrastructure updates, crashes, and can be unloaded from memory during long waiting periods without losing context. This is essential for agents that orchestrate long-running operations or wait for external events.\n\n##### **Distributed**\n\nAgent execution is accessible across all instances, enabling elastic scaling and automatic failover. Healthy nodes seamlessly take over work from failed instances, ensuring continuous operation. This distributed execution model allows thousands of stateful agents to scale up and run in parallel.\n\n##### **Deterministic**\n\nAgent orchestrations execute predictably using imperative logic written as ordinary code. Define the execution path, enabling automated testing, verifiable guardrails, and business-critical workflows that stakeholders can trust. This complements agent-directed workflows by providing explicit control flow when needed.\n\n##### **Debuggability**\n\nUse familiar development tools (IDEs, debuggers, breakpoints, stack traces, and unit tests) and programming languages to develop and debug. Your agent and agent orchestrations are expressed as code, making them easily testable, *debuggable*, and maintainable.\n\n## **Features in action**\n\n### **Serverless hosting**\n\nDeploy agents to [Azure Functions](https://learn.microsoft.com/azure/azure-functions/) (with expansion to other Azure computes soon) with automatic scaling to thousands of instances or down to zero when not in use. Pay only for the compute resources you consume. This code-first deployment approach gives you full control over the compute environment while maintaining the benefits of a serverless architecture.\n- # Python\n\nendpoint = os.getenv(\"AZURE\\_OPENAI\\_ENDPOINT\") deployment\\_name = os.getenv(\"AZURE\\_OPENAI\\_DEPLOYMENT\\_NAME\", \"gpt-4o-mini\")\n\n# Create an AI agent following the standard Microsoft Agent Framework pattern\nagent = AzureOpenAIChatClient( endpoint=endpoint, deployment\\_name=deployment\\_name, credential=AzureCliCredential() ).create\\_agent( instructions=\"You are good at telling jokes.\", name=\"Joker\" )\n\n# Configure the function app to host the agent with durable session management\napp = AgentFunctionApp(agents=[agent])\n\napp.run()\n\n### **Automatic session management**\n\nAgent sessions are automatically checkpointed in durable storage that you configure in your function app, enabling durable and distributed execution across multiple instances. Any instance can resume an agent's execution after interruptions or process failures, ensuring continuous operation.\n\nUnder the hood, agents are implemented as [durable entities](https://learn.microsoft.com/azure/azure-functions/durable/durable-functions-entities). These are stateful objects that maintain their state across executions. This architecture enables each agent session to function as a reliable, long-lived entity with preserved conversation history and context.\n\n**Example scenario**: A customer service agent handling a complex support case over multiple days and weeks. The conversation history, context, and progress are preserved even if the agent is redeployed or moves to a different instance.\n- # First interaction - start a new thread\ncurl -X POST https://your-function-app.azurewebsites.net/api/agents/Joker/threads \\ -H \"Content-Type: application/json\" \\ -d '{\"message\": \"Tell me a joke about pirates\"}'\n\n# Response includes thread ID and joke\n# {\"threadId\": \"abc123\", \"response\": \"Why do pirates make terrible singers? Because they hit the high Cs!\"}\n\n# Second interaction - continue the same thread with context\ncurl -X POST https://your-function-app.azurewebsites.net/api/agents/Joker/threads/abc123 \\ -H \"Content-Type: application/json\" \\ -d '{\"message\": \"Tell me another one about the same topic\"}'\n\n# Agent remembers the pirate context from the first message\n# {\"threadId\": \"abc123\", \"response\": \"What's a pirate's favorite letter? You'd think it's R, but it's actually the C!\"}\n\n### **Deterministic multi-agent orchestrations**\n\nCoordinate multiple specialized durable agents using imperative code where you define the control flow. This differs from agent-directed workflows where the agent decides the next steps. Deterministic Orchestrations provide predictable, repeatable execution patterns with automatic checkpointing and recovery.\n\n**Example scenario**: An email processing system that uses a spam detection agent, then conditionally routes to different specialized agents based on the classification. The orchestration automatically recovers if any step fails and completed agent calls are not re-executed.\n- # Python\n\napp.orchestration\\_trigger(context\\_name=\"context\") def spam\\_detection\\_orchestration(context: DurableOrchestrationContext): \"\"\"Deterministic orchestration coordinating multiple specialized agents.\"\"\" email = context.get\\_input()\n\n# Get specialized agents from the orchestration context\nspam\\_agent = context.get\\_agent(\"SpamDetectionAgent\") email\\_agent = context.get\\_agent(\"EmailAssistantAgent\")\n\n# Step 1: Check if the email is spam\nspam\\_result = yield spam\\_agent.run( messages=f\"Analyze this email for spam: {email.content}\", response\\_schema=SpamDetectionResult )\n\n# Step 2: Conditional logic based on spam detection\nif spam\\_result.is\\_spam:\n# Handle spam email\nreturn yield context.call\\_activity(\"handle\\_spam\\_email\", spam\\_result.reason)\n\n# Step 3: Generate professional response for legitimate email\nemail\\_response = yield email\\_agent.run( messages=f\"Draft a professional response to: {email.content}\", response\\_schema=EmailResponse )\n\n# Step 4: Send the generated response\nreturn yield context.call\\_activity(\"send\\_email\", email\\_response.text)\n\n### **Human-in-the-loop**\n\nOrchestrations and agents can pause for human input, approval, or review without consuming compute resources. Durable execution enables orchestrations to wait for days or even weeks while waiting for human responses, even if the app crashes or restarts. When combined with serverless hosting, all compute resources are spun down during the wait period, eliminating compute costs until the human provides their input.\n\n**Example scenario**: A content publishing agent that generates drafts, sends them to human reviewers, and waits days for approval without running (or paying for) compute resources during the review period. When the human response arrives, the orchestration automatically resumes with full conversation context and execution state intact.\n- # Python\n\napp.orchestration\\_trigger(context\\_name=\"context\") def content\\_approval\\_workflow(context: DurableOrchestrationContext): \"\"\"Human-in-the-loop workflow with zero-cost waiting.\"\"\" topic = context.get\\_input()\n\n# Step 1: Generate content using an agent\ncontent\\_agent = context.get\\_agent(\"ContentGenerationAgent\") draft\\_content = yield content\\_agent.run(f\"Write an article about {topic}\")\n\n# Step 2: Send for human review\nyield context.call\\_activity(\"notify\\_reviewer\", draft\\_content)\n\n# Step 3: Wait for approval - no compute resources consumed while waiting\napproval\\_event = context.wait\\_for\\_external\\_event(\"ApprovalDecision\") timeout\\_task = context.create\\_timer(context.current\\_utc\\_datetime + timedelta(hours=24))\n\nwinner = yield context.task\\_any([approval\\_event, timeout\\_task])\n\nif winner == approval\\_event: timeout\\_task.cancel() approved = approval\\_event.result\n\nif approved: result = yield context.call\\_activity(\"publish\\_content\", draft\\_content) return result else: return \"Content rejected\" else:\n# Timeout - escalate for review\nresult = yield context.call\\_activity(\"escalate\\_for\\_review\", draft\\_content) return result\n\n### **Built-in agent observability**\n\nConfigure your Function App with the [Durable Task Scheduler](https://learn.microsoft.com/azure/container-apps/durable-task-scheduler) as the durable backend (what persists agents and orchestration state). The Durable Task Scheduler is the recommended durable backend for your durable agents, offering the best throughput performance, fully managed infrastructure, and built-in observability through a UI dashboard.\n\nThe Durable Task Scheduler dashboard provides deep visibility into your agent operations:\n\n- **Conversation history**: View complete conversation threads for each agent session, including all messages, tool calls, and conversation context at any point in time\n- **Multi-agent visualization**: See the execution flow when calling multiple specialized agents with visual representation of agent handoffs, parallel executions, and conditional branching\n- **Performance metrics**: Monitor agent response times, token usage, and orchestration duration\n- **Execution history**: Access detailed execution logs with full replay capability for debugging\n\n![]()![]()![]()\n\n## **Language support**\n\nThe Durable Extension supports:\n\n- C# (.NET 8.0+) with Azure Functions\n- Python (3.10+) with Azure Functions\n\nSupport for additional computes coming soon.\n\n## **Get started today**\n\n#### [Create and run a durable agent](https://aka.ms/create-and-run-durable-agent)\n\n## **Learn more**\n\n- [Overview documentation](https://aka.ms/durable-extension-for-af)\n- [C# Samples](https://aka.ms/durable-extension-csharp-samples)\n- [Python Samples](https://aka.ms/durable-extension-python-samples)",
  "Title": "Bulletproof agents with the durable task extension for Microsoft Agent Framework",
  "Author": "greenie-msft",
  "EnhancedContent": "## What if your AI agents could survive crashes, execute across thousands of instances, wait weeks for human approval, and cost you nothing while idle, all automatically?\n\nToday, we're thrilled to announce the public preview of the **durable task extension for Microsoft Agent Framework**. This extension transforms how you build production-ready, resilient and scalable AI agents by bringing the proven durable execution (survives crashes and restarts) and distributed execution (runs across multiple instances) capabilities of [Azure Durable Functions](https://learn.microsoft.com/azure/azure-functions/durable/) directly into the [Microsoft Agent Framework](https://learn.microsoft.com/agent-framework/). Now you can deploy stateful, resilient AI agents to Azure that automatically handle session management, failure recovery, and scaling, freeing you to focus entirely on your agent logic.\n\nWhether you're building customer service agents that maintain context across multi-day conversations, content pipelines with human-in-the-loop approval workflows, or fully automated multi-agent systems coordinating specialized AI models, the durable task extension gives you production-grade reliability, scalability and coordination with serverless simplicity.\n\nKey features of the durable task extension include:\n\n- **Automatic Session Management**: Agents maintain persistent sessions with full conversation context that survives process crashes, restarts, and distributed execution across instances\n- **Deterministic Multi-Agent Orchestrations**: Coordinate specialized durable agents with predictable, repeatable, code-driven execution patterns\n- **Human-in-the-Loop with Serverless Cost Savings**: Pause for human input without consuming compute resources or incurring costs\n- **Built-in Observability with Durable Task Scheduler**: Deep visibility into agent operations and orchestrations through the Durable Task Scheduler UI dashboard\n\n#### [Click here to create and run a durable agent](https://aka.ms/create-and-run-durable-agent)\n\n```\n# Python\n\nendpoint = os.getenv(\"AZURE_OPENAI_ENDPOINT\") deployment_name = os.getenv(\"AZURE_OPENAI_DEPLOYMENT_NAME\", \"gpt-4o-mini\")\n\n# Create an AI agent following the standard Microsoft Agent Framework pattern\nagent = AzureOpenAIChatClient( endpoint=endpoint, deployment_name=deployment_name, credential=AzureCliCredential() ).create_agent( instructions=\"You are good at telling jokes.\", name=\"Joker\" )\n\n# Configure the function app to host the agent with durable session management\napp = AgentFunctionApp(agents=[agent])\n\napp.run() ```\n\n``` // C#\n\nvar endpoint = Environment.GetEnvironmentVariable(\"AZURE_OPENAI_ENDPOINT\"); var deploymentName = Environment.GetEnvironmentVariable(\"AZURE_OPENAI_DEPLOYMENT\") ?? \"gpt-4o-mini\";\n\n// Create an AI agent following the standard Microsoft Agent Framework pattern AIAgent agent = new AzureOpenAIClient(new Uri(endpoint), new AzureCliCredential()) .GetChatClient(deploymentName) .CreateAIAgent( instructions: \"You are good at telling jokes.\", name: \"Joker\");\n\n// Configure the function app to host the agent with durable thread management // This automatically creates HTTP endpoints and manages state persistence using IHost app = FunctionsApplication .CreateBuilder(args) .ConfigureFunctionsWebApplication() .ConfigureDurableAgents(options => options.AddAIAgent(agent) ) .Build(); app.Run(); ```\n\n## **Why the durable task extension?**\n\nAs AI agents evolve from simple chatbots to sophisticated systems handling complex, long-running tasks, new challenges emerge:\n\n- Conversations span multiple days and weeks, requiring persistent state across process restarts, crashes, and disruptions.\n- Tool calls might take longer than typical timeouts allow, needing automatic checkpointing and recovery.\n- High-volume workloads require elastic scaling across distributed instances to handle thousands of concurrent agent conversations.\n- Multiple specialized agents need coordination with predictable, repeatable execution for reliable business processes.\n- Agents sometimes must wait for human approval before proceeding, ideally without consuming resources.\n\nThe Durable Extension addresses these challenges by extending [Microsoft Agent Framework](https://learn.microsoft.com/agent-framework/) with capabilities from [Azure Durable Functions](https://learn.microsoft.com/azure/azure-functions/durable/), enabling you to build AI agents that survive failures, scale elastically, and execute predictably through durable and distributed execution.\n\nThe extension is built on four foundational value pillars, which we refer to as **the 4D’s**:\n\n##### **Durability**\n\nEvery agent state change (messages, tool calls, decisions) is durably checkpointed automatically. Agents survive and automatically resume from infrastructure updates, crashes, and can be unloaded from memory during long waiting periods without losing context. This is essential for agents that orchestrate long-running operations or wait for external events.\n\n##### **Distributed**\n\nAgent execution is accessible across all instances, enabling elastic scaling and automatic failover. Healthy nodes seamlessly take over work from failed instances, ensuring continuous operation. This distributed execution model allows thousands of stateful agents to scale up and run in parallel.\n\n##### **Deterministic**\n\nAgent orchestrations execute predictably using imperative logic written as ordinary code. Define the execution path, enabling automated testing, verifiable guardrails, and business-critical workflows that stakeholders can trust. This complements agent-directed workflows by providing explicit control flow when needed.\n\n##### **Debuggability**\n\nUse familiar development tools (IDEs, debuggers, breakpoints, stack traces, and unit tests) and programming languages to develop and debug. Your agent and agent orchestrations are expressed as code, making them easily testable, *debuggable*, and maintainable.\n\n## **Features in action**\n\n### **Serverless hosting**\n\nDeploy agents to [Azure Functions](https://learn.microsoft.com/azure/azure-functions/) (with expansion to other Azure computes soon) with automatic scaling to thousands of instances or down to zero when not in use. Pay only for the compute resources you consume. This code-first deployment approach gives you full control over the compute environment while maintaining the benefits of a serverless architecture.\n\n```\n# Python\n\nendpoint = os.getenv(\"AZURE_OPENAI_ENDPOINT\") deployment_name = os.getenv(\"AZURE_OPENAI_DEPLOYMENT_NAME\", \"gpt-4o-mini\")\n\n# Create an AI agent following the standard Microsoft Agent Framework pattern\nagent = AzureOpenAIChatClient( endpoint=endpoint, deployment_name=deployment_name, credential=AzureCliCredential() ).create_agent( instructions=\"You are good at telling jokes.\", name=\"Joker\" )\n\n# Configure the function app to host the agent with durable session management\napp = AgentFunctionApp(agents=[agent])\n\napp.run() ```\n\n### **Automatic session management**\n\nAgent sessions are automatically checkpointed in durable storage that you configure in your function app, enabling durable and distributed execution across multiple instances. Any instance can resume an agent's execution after interruptions or process failures, ensuring continuous operation.\n\nUnder the hood, agents are implemented as [durable entities](https://learn.microsoft.com/azure/azure-functions/durable/durable-functions-entities). These are stateful objects that maintain their state across executions. This architecture enables each agent session to function as a reliable, long-lived entity with preserved conversation history and context.\n\n**Example scenario**: A customer service agent handling a complex support case over multiple days and weeks. The conversation history, context, and progress are preserved even if the agent is redeployed or moves to a different instance.\n\n```\n# First interaction - start a new thread\ncurl -X POST https://your-function-app.azurewebsites.net/api/agents/Joker/threads \\ -H \"Content-Type: application/json\" \\ -d '{\"message\": \"Tell me a joke about pirates\"}'\n\n# Response includes thread ID and joke\n# {\"threadId\": \"abc123\", \"response\": \"Why do pirates make terrible singers? Because they hit the high Cs!\"}\n\n# Second interaction - continue the same thread with context\ncurl -X POST https://your-function-app.azurewebsites.net/api/agents/Joker/threads/abc123 \\ -H \"Content-Type: application/json\" \\ -d '{\"message\": \"Tell me another one about the same topic\"}'\n\n# Agent remembers the pirate context from the first message\n# {\"threadId\": \"abc123\", \"response\": \"What's a pirate's favorite letter? You'd think it's R, but it's actually the C!\"}\n```\n\n### **Deterministic multi-agent orchestrations**\n\nCoordinate multiple specialized durable agents using imperative code where you define the control flow. This differs from agent-directed workflows where the agent decides the next steps. Deterministic Orchestrations provide predictable, repeatable execution patterns with automatic checkpointing and recovery.\n\n**Example scenario**: An email processing system that uses a spam detection agent, then conditionally routes to different specialized agents based on the classification. The orchestration automatically recovers if any step fails and completed agent calls are not re-executed.\n\n```\n# Python\n\napp.orchestration_trigger(context_name=\"context\") def spam_detection_orchestration(context: DurableOrchestrationContext): \"\"\"Deterministic orchestration coordinating multiple specialized agents.\"\"\" email = context.get_input()\n\n# Get specialized agents from the orchestration context\nspam_agent = context.get_agent(\"SpamDetectionAgent\") email_agent = context.get_agent(\"EmailAssistantAgent\")\n\n# Step 1: Check if the email is spam\nspam_result = yield spam_agent.run( messages=f\"Analyze this email for spam: {email.content}\", response_schema=SpamDetectionResult )\n\n# Step 2: Conditional logic based on spam detection\nif spam_result.is_spam:\n# Handle spam email\nreturn yield context.call_activity(\"handle_spam_email\", spam_result.reason)\n\n# Step 3: Generate professional response for legitimate email\nemail_response = yield email_agent.run( messages=f\"Draft a professional response to: {email.content}\", response_schema=EmailResponse )\n\n# Step 4: Send the generated response\nreturn yield context.call_activity(\"send_email\", email_response.text) ```\n\n### **Human-in-the-loop**\n\nOrchestrations and agents can pause for human input, approval, or review without consuming compute resources. Durable execution enables orchestrations to wait for days or even weeks while waiting for human responses, even if the app crashes or restarts. When combined with serverless hosting, all compute resources are spun down during the wait period, eliminating compute costs until the human provides their input.\n\n**Example scenario**: A content publishing agent that generates drafts, sends them to human reviewers, and waits days for approval without running (or paying for) compute resources during the review period. When the human response arrives, the orchestration automatically resumes with full conversation context and execution state intact.\n\n```\n# Python\n\napp.orchestration_trigger(context_name=\"context\") def content_approval_workflow(context: DurableOrchestrationContext): \"\"\"Human-in-the-loop workflow with zero-cost waiting.\"\"\" topic = context.get_input()\n\n# Step 1: Generate content using an agent\ncontent_agent = context.get_agent(\"ContentGenerationAgent\") draft_content = yield content_agent.run(f\"Write an article about {topic}\")\n\n# Step 2: Send for human review\nyield context.call_activity(\"notify_reviewer\", draft_content)\n\n# Step 3: Wait for approval - no compute resources consumed while waiting\napproval_event = context.wait_for_external_event(\"ApprovalDecision\") timeout_task = context.create_timer(context.current_utc_datetime + timedelta(hours=24))\n\nwinner = yield context.task_any([approval_event, timeout_task])\n\nif winner == approval_event: timeout_task.cancel() approved = approval_event.result\n\nif approved: result = yield context.call_activity(\"publish_content\", draft_content) return result else: return \"Content rejected\" else:\n# Timeout - escalate for review\nresult = yield context.call_activity(\"escalate_for_review\", draft_content) return result ```\n\n### **Built-in agent observability**\n\nConfigure your Function App with the [Durable Task Scheduler](https://learn.microsoft.com/azure/container-apps/durable-task-scheduler) as the durable backend (what persists agents and orchestration state). The Durable Task Scheduler is the recommended durable backend for your durable agents, offering the best throughput performance, fully managed infrastructure, and built-in observability through a UI dashboard.\n\nThe Durable Task Scheduler dashboard provides deep visibility into your agent operations:\n\n- **Conversation history**: View complete conversation threads for each agent session, including all messages, tool calls, and conversation context at any point in time\n- **Multi-agent visualization**: See the execution flow when calling multiple specialized agents with visual representation of agent handoffs, parallel executions, and conditional branching\n- **Performance metrics**: Monitor agent response times, token usage, and orchestration duration\n- **Execution history**: Access detailed execution logs with full replay capability for debugging\n\n## **Language support**\n\nThe Durable Extension supports:\n\n- C# (.NET 8.0+) with Azure Functions\n- Python (3.10+) with Azure Functions\n\nSupport for additional computes coming soon.\n\n## **Get started today**\n\n#### [Create and run a durable agent](https://aka.ms/create-and-run-durable-agent)\n\n## **Learn more**\n\n- [Overview documentation](https://aka.ms/durable-extension-for-af)\n- [C# Samples](https://aka.ms/durable-extension-csharp-samples)\n- [Python Samples](https://aka.ms/durable-extension-python-samples)\n\nUpdated Nov 13, 2025\n\nVersion 1.0\n\n[azure functions](/tag/azure%20functions?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[greenie-msft&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0xMzk5MjY2LTUyNTIxM2k0OUQzOTZENThENDM5NjVG?image-dimensions=50x50)](/users/greenie-msft/1399266) [greenie-msft](/users/greenie-msft/1399266) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined May 24, 2022\n\n[View Profile](/users/greenie-msft/1399266)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "PubDate": "2025-11-13T20:33:42+00:00",
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/bulletproof-agents-with-the-durable-task-extension-for-microsoft/ba-p/4467122",
  "ProcessedDate": "2025-11-13 21:05:44",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Tags": [],
  "FeedName": "Microsoft Tech Community"
}
