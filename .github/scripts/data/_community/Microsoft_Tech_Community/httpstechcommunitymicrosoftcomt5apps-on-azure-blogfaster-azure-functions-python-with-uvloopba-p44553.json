{
  "FeedName": "Microsoft Tech Community",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Author": "eroman",
  "EnhancedContent": "## Speed is in the loop. With uvloop powering Python 3.13+ apps on Azure Functions, asynchronous workloads run faster, scale better, and keep up with demanding serverless scenarios.\n\nPython 3.13+ apps on Azure Functions are now faster by default. By replacing the standard event loop with [*uvloop*](https://github.com/MagicStack/uvloop), the Functions Python worker delivers higher throughput and lower latency for asynchronous workloads — no code changes required.\n\n## Introduction\n\nAzure Functions powers millions of customer scenarios, from real-time APIs to event-driven automation. For Python developers, scalability often comes down to how efficiently the runtime handles I/O, concurrency, and asynchronous workloads.\n\nThat’s why, starting with Python 3.13, the Azure Functions Python worker now uses *uvloop* as its default event loop. Built on top of [libuv](https://github.com/libuv/libuv) (the same library behind Node.js), *uvloop* provides a drop-in replacement for Python’s standard asyncio loop with measurable performance improvements.\n\nFor customers, this means faster request handling and more responsive serverless applications — without having to update a single line of app code.\n\n## Why Event Loops Matter\n\nThe event loop is the backbone of any asynchronous Python application. It schedules coroutines, manages I/O events, and drives concurrency. In serverless workloads like Azure Functions, this loop runs continuously to:\n\n- Handle incoming HTTP requests\n- Dispatch and complete async tasks (like database queries or service calls)\n- Manage parallel event processing (Event Hubs, Service Bus, etc.)\n\nThe default Python event loop (*UnixSelectorEventLoop*) is reliable, but it wasn’t designed for high-throughput scenarios at massive scale. *Uvloop*, by contrast, is a high-performance reimplementation in Cython that consistently outperforms the built-in loop in both throughput and latency.\n\n## How It Works in Azure Functions\n\nIn Python 3.13+, the Azure Functions Python worker sets *uvloop* as the default event loop policy at startup:\n\n``` import uvloop, asyncio asyncio.set_event_loop_policy(uvloop.EventLoopPolicy()) ```\n\nThis means any async workload — whether you’re using async def in your functions, calling external APIs, or parallelizing work with asyncio.gather — benefits immediately from *uvloop*’s faster scheduling and I/O handling. It is already available in the Functions runtime environment.\n\nNo configuration changes, no **requirements.txt** edits, and no feature flags. If you’re running Functions on Python 3.13 or higher, *uvloop* is already in play.\n\n## Measuring the Performance Gains\n\nWe tested *uvloop* against the existing Unix event loop across several realistic workloads. For testing with Flex Consumption on Azure, the app with no *uvloop* is on Python 3.12, while the app with *uvloop* is on Python 3.13. The Flex Consumption app has an instance size of 2048 MB. Results were measured by taking the median of three runs for each test case.\n\n##### Test 1: 10k Requests, 50 Virtual Users\n\n| **Environment** | **Event Loop** | **Average HTTP Request Time (ms)** | **Requests per second** | **% Diff vs** ***unix*** | | --- | --- | --- | --- | --- | | **Local** | *unix* | 96.95 | 515 | - | | | *uvloop* | 87.99 | 565 | **+9.7%** | | **Azure** | *unix* | 54.34 | 882 | - | | | *uvloop* | 51.77 | 923 | **+4.8%** |\n\n##### Test 2: Sustained Load, 100 Virtual Users (5 min)\n\n| **Environment** | **Event Loop** | **Number of Requests** | **Requests per second** | **% Diff vs** ***unix*** | | --- | --- | --- | --- | --- | | **Local** | *unix* | 157,580 | 525 | - | | | *uvloop* | 167,928 | 560 | **+6.4%** | | **Azure** | *unix* | 571,797 | 1,898 | - | | | *uvloop* | 588,458 | 1,961 | **+2.9%** |\n\n##### Test 3: Heavy Concurrency, 500 Virtual Users + 5 async tasks per request\n\n| **Environment** | **Event Loop** | **Number of Requests** | **Requests per second** | **% Diff vs** ***unix*** | | --- | --- | --- | --- | --- | | **Local** | *unix* | 216,212 | 720 | - | | | *uvloop* | 231,878 | 772 | **+7%** | | **Azure** | *unix* | 1,791,600 | 5,696 | - | | | *uvloop* | 1,806,750 | 6,020 | **+1%** |\n\n*The Unix Event Loop started showing failures in both environments in ~2% of requests.*\n\nAcross the board, *uvloop* delivered measurable improvements in throughput and latency — especially under high concurrency.\n\n## Why Only Python 3.13+?\n\nWhile *uvloop* works with older versions of Python, we rolled it out as the default starting in 3.13 because:\n\n- It ensured the change was strictly a net positive in performance and stability\n- Easier rollout for all available Azure Functions SKUs, avoiding breaking existing customers\n- Python 3.13 for the Azure Functions Worker introduces a Proxy Worker, so this is an additional performance boost to help with the extra overhead introduced\n\nOlder runtimes remain on the standard event loop to minimize compatibility risks.\n\n## Challenges and Lessons Learned\n\nIntegrating *uvloop* into the Functions Python worker surfaced a few interesting challenges:\n\n- **Compatibility:** Ensuring *uvloop* worked seamlessly across Linux environments at scale\n- **Observability:** Updating logs to confirm which event loop policy was active\n- **Benchmark design:** Testing realistic workloads (HTTP requests, async fan-out) to validate improvements beyond microbenchmarks\n\nThrough this process, we confirmed *uvloop* consistently improved throughput and latency without regressions.\n\n## Future Directions\n\nSwitching to *uvloop* is just one step in making Azure Functions Python faster and more scalable. Looking ahead, we’re exploring:\n\n- **Deeper async optimizations:** further tuning around asyncio and gRPC handling\n- **Serialization improvements:** building on work like *orjson* for faster data processing\n- **Cold start performance:** reducing startup overhead in Python workers\n\n## Conclusion\n\nBy adopting *uvloop* as the default event loop for Python 3.13+, Azure Functions makes async workloads faster, more reliable, and more scalable — all without requiring customers to change their code.\n\nIf you’re upgrading to Python 3.13 for your Functions apps, *uvloop* is already running under the hood to give you better performance out of the box.\n\n### Further Reading\n\n- [Azure Functions](https://learn.microsoft.com/en-us/azure/azure-functions/functions-overview)\n- [Azure Functions Python Developer Reference Guide](https://learn.microsoft.com/en-us/azure/azure-functions/functions-reference-python?tabs=get-started%2Casgi%2Capplication-level&amp;pivots=python-mode-decorators)\n- [Azure Functions Performance Optimizer](https://learn.microsoft.com/en-us/azure/app-testing/load-testing/how-to-optimize-azure-functions)\n- [Azure Functions Python Worker](https://github.com/Azure/azure-functions-python-worker)\n- [Azure Functions Python Library](https://github.com/Azure/azure-functions-python-library)\n- [Azure Loading Testing Overview](https://learn.microsoft.com/en-us/azure/app-testing/load-testing/overview-what-is-azure-load-testing)\n\nUpdated Dec 01, 2025\n\nVersion 1.0\n\n[azure app service](/tag/azure%20app%20service?nodeId=board%3AAppsonAzureBlog)\n\n[azure functions](/tag/azure%20functions?nodeId=board%3AAppsonAzureBlog)\n\n[python](/tag/python?nodeId=board%3AAppsonAzureBlog)\n\n[web apps](/tag/web%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[eroman&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0zMDk1MzQxLWd6REdRaA?image-coordinates=27%2C17%2C296%2C285&amp;image-dimensions=50x50)](/users/eroman/3095341) [eroman](/users/eroman/3095341) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined July 02, 2025\n\n[View Profile](/users/eroman/3095341)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "PubDate": "2025-12-01T19:58:50+00:00",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "ProcessedDate": "2025-12-01 20:04:58",
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/faster-azure-functions-python-with-uvloop/ba-p/4455323",
  "OutputDir": "_community",
  "Title": "Faster Azure Functions Python with uvloop",
  "Tags": [],
  "Description": "Python 3.13+ apps on Azure Functions are now faster by default. By replacing the standard event loop with [*uvloop*](https://github.com/MagicStack/uvloop), the Functions Python worker delivers higher throughput and lower latency for asynchronous workloads — no code changes required.\n\n## Introduction\n\nAzure Functions powers millions of customer scenarios, from real-time APIs to event-driven automation. For Python developers, scalability often comes down to how efficiently the runtime handles I/O, concurrency, and asynchronous workloads.\n\nThat’s why, starting with Python 3.13, the Azure Functions Python worker now uses *uvloop* as its default event loop. Built on top of [libuv](https://github.com/libuv/libuv) (the same library behind Node.js), *uvloop* provides a drop-in replacement for Python’s standard asyncio loop with measurable performance improvements.\n\nFor customers, this means faster request handling and more responsive serverless applications — without having to update a single line of app code.\n\n## Why Event Loops Matter\n\nThe event loop is the backbone of any asynchronous Python application. It schedules coroutines, manages I/O events, and drives concurrency. In serverless workloads like Azure Functions, this loop runs continuously to:\n\n- Handle incoming HTTP requests\n- Dispatch and complete async tasks (like database queries or service calls)\n- Manage parallel event processing (Event Hubs, Service Bus, etc.)\n\nThe default Python event loop (*UnixSelectorEventLoop*) is reliable, but it wasn’t designed for high-throughput scenarios at massive scale. *Uvloop*, by contrast, is a high-performance reimplementation in Cython that consistently outperforms the built-in loop in both throughput and latency.\n\n## How It Works in Azure Functions\n\nIn Python 3.13+, the Azure Functions Python worker sets *uvloop* as the default event loop policy at startup:\n\n- import uvloop, asyncio\nasyncio.set\\_event\\_loop\\_policy(uvloop.EventLoopPolicy())\n\nThis means any async workload — whether you’re using async def in your functions, calling external APIs, or parallelizing work with asyncio.gather — benefits immediately from *uvloop*’s faster scheduling and I/O handling. It is already available in the Functions runtime environment.\n\nNo configuration changes, no **requirements.txt** edits, and no feature flags. If you’re running Functions on Python 3.13 or higher, *uvloop* is already in play.\n\n## Measuring the Performance Gains\n\nWe tested *uvloop* against the existing Unix event loop across several realistic workloads. For testing with Flex Consumption on Azure, the app with no *uvloop* is on Python 3.12, while the app with *uvloop* is on Python 3.13. The Flex Consumption app has an instance size of 2048 MB. Results were measured by taking the median of three runs for each test case.\n\n##### Test 1: 10k Requests, 50 Virtual Users\n\n| **Environment** | **Event Loop** | **Average HTTP Request Time (ms)** | **Requests per second** | **% Diff vs** ***unix*** | | --- | --- | --- | --- | --- | | **Local** | *unix* | 96.95 | 515 | - | | | *uvloop* | 87.99 | 565 | **+9.7%** | | **Azure** | *unix* | 54.34 | 882 | - | | | *uvloop* | 51.77 | 923 | **+4.8%** |\n\n##### Test 2: Sustained Load, 100 Virtual Users (5 min)\n\n| **Environment** | **Event Loop** | **Number of Requests** | **Requests per second** | **% Diff vs** ***unix*** | | --- | --- | --- | --- | --- | | **Local** | *unix* | 157,580 | 525 | - | | | *uvloop* | 167,928 | 560 | **+6.4%** | | **Azure** | *unix* | 571,797 | 1,898 | - | | | *uvloop* | 588,458 | 1,961 | **+2.9%** |\n\n##### Test 3: Heavy Concurrency, 500 Virtual Users + 5 async tasks per request\n\n| **Environment** | **Event Loop** | **Number of Requests** | **Requests per second** | **% Diff vs** ***unix*** | | --- | --- | --- | --- | --- | | **Local** | *unix* | 216,212 | 720 | - | | | *uvloop* | 231,878 | 772 | **+7%** | | **Azure** | *unix* | 1,791,600 | 5,696 | - | | | *uvloop* | 1,806,750 | 6,020 | **+1%** |\n\n*The Unix Event Loop started showing failures in both environments in ~2% of requests.*\n\nAcross the board, *uvloop* delivered measurable improvements in throughput and latency — especially under high concurrency.\n\n## Why Only Python 3.13+?\n\nWhile *uvloop* works with older versions of Python, we rolled it out as the default starting in 3.13 because:\n\n- It ensured the change was strictly a net positive in performance and stability\n- Easier rollout for all available Azure Functions SKUs, avoiding breaking existing customers\n- Python 3.13 for the Azure Functions Worker introduces a Proxy Worker, so this is an additional performance boost to help with the extra overhead introduced\n\nOlder runtimes remain on the standard event loop to minimize compatibility risks.\n\n## Challenges and Lessons Learned\n\nIntegrating *uvloop* into the Functions Python worker surfaced a few interesting challenges:\n\n- **Compatibility:** Ensuring *uvloop* worked seamlessly across Linux environments at scale\n- **Observability:** Updating logs to confirm which event loop policy was active\n- **Benchmark design:** Testing realistic workloads (HTTP requests, async fan-out) to validate improvements beyond microbenchmarks\n\nThrough this process, we confirmed *uvloop* consistently improved throughput and latency without regressions.\n\n## Future Directions\n\nSwitching to *uvloop* is just one step in making Azure Functions Python faster and more scalable. Looking ahead, we’re exploring:\n\n- **Deeper async optimizations:** further tuning around asyncio and gRPC handling\n- **Serialization improvements:** building on work like *orjson* for faster data processing\n- **Cold start performance:** reducing startup overhead in Python workers\n\n## Conclusion\n\nBy adopting *uvloop* as the default event loop for Python 3.13+, Azure Functions makes async workloads faster, more reliable, and more scalable — all without requiring customers to change their code.\n\nIf you’re upgrading to Python 3.13 for your Functions apps, *uvloop* is already running under the hood to give you better performance out of the box.\n\n### Further Reading\n\n- [Azure Functions](https://learn.microsoft.com/en-us/azure/azure-functions/functions-overview)\n- [Azure Functions Python Developer Reference Guide](https://learn.microsoft.com/en-us/azure/azure-functions/functions-reference-python?tabs=get-started%2Casgi%2Capplication-level&pivots=python-mode-decorators)\n- [Azure Functions Performance Optimizer](https://learn.microsoft.com/en-us/azure/app-testing/load-testing/how-to-optimize-azure-functions)\n- [Azure Functions Python Worker](https://github.com/Azure/azure-functions-python-worker)\n- [Azure Functions Python Library](https://github.com/Azure/azure-functions-python-library)\n- [Azure Loading Testing Overview](https://learn.microsoft.com/en-us/azure/app-testing/load-testing/overview-what-is-azure-load-testing)"
}
