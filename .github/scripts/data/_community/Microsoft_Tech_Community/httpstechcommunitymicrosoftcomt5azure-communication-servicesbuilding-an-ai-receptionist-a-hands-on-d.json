<<<<<<< HEAD
{
  "ProcessedDate": "2025-08-15 14:40:33",
  "PubDate": "2025-08-13T16:35:46+00:00",
  "Link": "https://techcommunity.microsoft.com/t5/azure-communication-services/building-an-ai-receptionist-a-hands-on-demo-with-azure/ba-p/4442959",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Author": "seankeegan",
  "FeedName": "Microsoft Tech Community",
  "EnhancedContent": "Ever missed an appointment because of a rigid SMS system? What if you could text a change and get an immediate, natural response that understands your intent and confirms a new slot quickly?\n\nIn this post, we'll show you how to build an AI receptionist that does just that, using Azure Communication Services and Azure OpenAI. We'll guide you through a hands-on demo that uses a simulated but realistic calendar for reliable confirmations and rescheduling, and show you how to make it production-ready.\n\nA natural text thread with the scheduling agent\n\n#### Watch the Walkthrough\n\nPrefer a walkthrough? Watch the video demo to see the app in action with live code explanations.\n\nThis demo is ideal for anyone who wants to explore conversational AI with minimal setup -- whether you're a developer, product manager, or just curious about integrating Azure services.\n\n## What Actually Happens Under the Hood\n\nHere’s the simple set of moving parts behind the “AI receptionist” feel. First a quick look at each piece, then the exact path a message takes.\n\nCore pieces we’re using for this demo:\n\n- **Azure Communication Services**: Provides the real phone number, receives incoming text messages, and sends replies.\n- **Azure Event Grid**: Immediately forwards each new message event to a public URL (the webhook) your app exposes.\n- **FastAPI**: Hosts that webhook (an HTTP endpoint) and keeps simple in‑memory conversation and calendar data.\n- **Azure OpenAI**: Generates the receptionist’s reply using the running conversation plus a small snapshot of available appointment times.\n- **Simulated calendar**: Thirty upcoming business days with realistic fullness so the system can offer believable open slots.\n\nThen the message moves through this path:\n\n1. You send a text message to the demo phone number (handled by Azure Communication Services).\n2. Azure Communication Services raises a “message received” event.\n3. Azure Event Grid delivers that event as an HTTP POST to the FastAPI webhook (a regular URL).\n4. The webhook quickly returns “OK” and kicks off a background function (process\\_sms in *main.py*) so the user is never kept waiting.\n5. If this is your first message, it creates a mock appointment for “tomorrow” and sends a reminder; otherwise it adds your new message to the conversation history.\n6. It selects a few upcoming open slots from the simulated calendar, adds them to the system prompt, asks Azure OpenAI for a receptionist‑style reply, and receives the response.\n7. The reply goes back through Azure Communication Services, and the conversation state stays in memory.\n\nThat’s the loop. An event arrives, flows through a thin path, and a reply goes out. No constant checking (polling) or scheduled scripts needed.\n\n#### Demo vs Production\n\nIn the demo you start the conversation by texting the number. In a production rollout, you usually send an automated reminder (for example 24 hours before) and let the patient reply to confirm or change. From there the path is straightforward: swap the simulated calendar for a real scheduling API, persist conversation and appointment state, add authentication and signed webhook validation, and layer in logging and compliance. The event flow itself staysthe same.\n\n#### The Calendar Trick\n\nWe prebuild the next 30 business days (weekdays only), 09:00–17:00 in 30-minute slots, mark about 80 percent as “booked,” and keep the rest “available.” On each turn we pull a small handful of near-term open times and add them to the system prompt. That gives the model concrete, bounded choices and prevents it from inventing odd times like “3:10 AM” or “Saturday 7 PM.” A single snapshot replaces custom slot logic while still feeling live.\n\nThe FastAPI routes for getting calendar logic\n\n#### Prompt Strategy\n\nThe system prompt frames a single role: a friendly receptionist limited to scheduling (no medical advice, within business hours, 30-minute increments). Each user message refreshes the availability lines so the model always sees current openings. The rules: only offer specific times when rescheduling, stay concise, and confirm final details. This balance keeps replies natural while keeping time suggestions controlled.\n\n#### Where to Take It Next\n\nTo evolve the demo into a dependable production service you layer durability, richer scheduling logic, safety, and observability onto the same event path - no rewrite required.\n\n**Productization**\n\n- Persist conversations and appointments (database + real scheduling/calendar API)\n- Authentication, signed webhook validation, rate limiting\n- Structured logging, tracing, latency and token metrics\n\n**Scheduling intelligence**\n\n- Function / tool calls for explicit slot selection\n- Real calendar integration (Outlook, scheduling API, electronic health record system)\n- Time zones, appointment types, user preferences (language, time windows)\n\n**Safety & context**\n\n- Moderation / compliance filters\n- Retrieval for policies, preparation instructions, service types\n\n**Insights & analytics**\n\n- Analytics (reminder → confirmation rate, response latency, fallback counts)\n\n## Getting It Running (You’ll Spend Minutes, Not Hours)\n\nThis setup is intentionally light. The only potentially slow step is acquiring a phone number in Azure Communication Services (see [the official quickstart](https://learn.microsoft.com/en-us/azure/communication-services/quickstarts/telephony/get-phone-number?tabs=windows&amp;pivots=platform-azp-new)). Full step-by-step instructions (environment variables, dev tunnel, Event Grid subscription) live in [the demo repository README](https://github.com/pereiralex/sms-appointment-scheduler). The high-level overview is:\n\n1. Clone the repository and copy *.env.example* to *.env*\n2. Add Azure Communication Services connection string + phone number and Azure OpenAI endpoint/key/model.\n3. Install dependencies and start the app on port 8000.\n4. Expose port 8000 with a dev tunnel and point an Event Grid *SMSReceived* subscription to */api/sms/webhook*.\n5. Text your Azure Communication Services number and observe inbound event and reply in the terminal.\n\nScreenshot of a terminal log with inbound event + “SMS sent to ACS number\"\n\n## Closing\n\nYou now have an event‑driven SMS conversation that feels like a live receptionist using only a phone number, a webhook, a lightweight availability snapshot, and a model prompt. [**Clone the repository**](https://github.com/pereiralex/sms-appointment-scheduler), run the demo, and try a reschedule from your own phone. Extend it and make it your own - whether that means integrating a real scheduling API, adding persistence, or incorporating compliance features. We’d love to see what you build.\n\nPublished Aug 13, 2025\n\nVersion 1.0\n\n[ai](/tag/ai?nodeId=board%3AAzureCommunicationServicesBlog)\n\n[customer engagement](/tag/customer%20engagement?nodeId=board%3AAzureCommunicationServicesBlog)\n\n[sms](/tag/sms?nodeId=board%3AAzureCommunicationServicesBlog)\n\n[!\\[seankeegan&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0yNjM0MTA4LTYyNjk5MmlFQ0Q2NzA2NDJBMDM0NzlD?image-dimensions=50x50)](/users/seankeegan/2634108) [seankeegan](/users/seankeegan/2634108) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined August 22, 2024\n\n[View Profile](/users/seankeegan/2634108)\n\n/category/azure/blog/azurecommunicationservicesblog [Azure Communication Services Blog](/category/azure/blog/azurecommunicationservicesblog) Follow this blog board to get notified when there's new activity",
  "Title": "Building an AI Receptionist: A Hands-On Demo with Azure Communication Services and OpenAI",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "OutputDir": "_community",
  "Description": "Ever missed an appointment because of a rigid SMS system? What if you could text a change and get an immediate, natural response that understands your intent and confirms a new slot quickly?\n\nIn this post, we'll show you how to build an AI receptionist that does just that, using Azure Communication Services and Azure OpenAI. We'll guide you through a hands-on demo that uses a simulated but realistic calendar for reliable confirmations and rescheduling, and show you how to make it production-ready.\n\n![]()\n\nA natural text thread with the scheduling agent\n\n#### Watch the Walkthrough\n\nPrefer a walkthrough? Watch the video demo to see the app in action with live code explanations.\n\nThis demo is ideal for anyone who wants to explore conversational AI with minimal setup -- whether you're a developer, product manager, or just curious about integrating Azure services.\n\n## What Actually Happens Under the Hood\n\nHere’s the simple set of moving parts behind the “AI receptionist” feel. First a quick look at each piece, then the exact path a message takes.\n\nCore pieces we’re using for this demo:\n\n- **Azure Communication Services**: Provides the real phone number, receives incoming text messages, and sends replies.\n- **Azure Event Grid**: Immediately forwards each new message event to a public URL (the webhook) your app exposes.\n- **FastAPI**: Hosts that webhook (an HTTP endpoint) and keeps simple in‑memory conversation and calendar data.\n- **Azure OpenAI**: Generates the receptionist’s reply using the running conversation plus a small snapshot of available appointment times.\n- **Simulated calendar**: Thirty upcoming business days with realistic fullness so the system can offer believable open slots.\n\nThen the message moves through this path:\n\n1. You send a text message to the demo phone number (handled by Azure Communication Services).\n2. Azure Communication Services raises a “message received” event.\n3. Azure Event Grid delivers that event as an HTTP POST to the FastAPI webhook (a regular URL).\n4. The webhook quickly returns “OK” and kicks off a background function (process\\_sms in *main.py*) so the user is never kept waiting.\n5. If this is your first message, it creates a mock appointment for “tomorrow” and sends a reminder; otherwise it adds your new message to the conversation history.\n6. It selects a few upcoming open slots from the simulated calendar, adds them to the system prompt, asks Azure OpenAI for a receptionist‑style reply, and receives the response.\n7. The reply goes back through Azure Communication Services, and the conversation state stays in memory.\n\nThat’s the loop. An event arrives, flows through a thin path, and a reply goes out. No constant checking (polling) or scheduled scripts needed.\n\n#### Demo vs Production\n\nIn the demo you start the conversation by texting the number. In a production rollout, you usually send an automated reminder (for example 24 hours before) and let the patient reply to confirm or change. From there the path is straightforward: swap the simulated calendar for a real scheduling API, persist conversation and appointment state, add authentication and signed webhook validation, and layer in logging and compliance. The event flow itself staysthe same.\n\n#### The Calendar Trick\n\nWe prebuild the next 30 business days (weekdays only), 09:00–17:00 in 30-minute slots, mark about 80 percent as “booked,” and keep the rest “available.” On each turn we pull a small handful of near-term open times and add them to the system prompt. That gives the model concrete, bounded choices and prevents it from inventing odd times like “3:10 AM” or “Saturday 7 PM.” A single snapshot replaces custom slot logic while still feeling live.\n\n![]()\n\nThe FastAPI routes for getting calendar logic\n\n#### Prompt Strategy\n\nThe system prompt frames a single role: a friendly receptionist limited to scheduling (no medical advice, within business hours, 30-minute increments). Each user message refreshes the availability lines so the model always sees current openings. The rules: only offer specific times when rescheduling, stay concise, and confirm final details. This balance keeps replies natural while keeping time suggestions controlled.\n\n#### Where to Take It Next\n\nTo evolve the demo into a dependable production service you layer durability, richer scheduling logic, safety, and observability onto the same event path - no rewrite required.\n\n**Productization**\n\n- Persist conversations and appointments (database + real scheduling/calendar API)\n- Authentication, signed webhook validation, rate limiting\n- Structured logging, tracing, latency and token metrics\n\n**Scheduling intelligence**\n\n- Function / tool calls for explicit slot selection\n- Real calendar integration (Outlook, scheduling API, electronic health record system)\n- Time zones, appointment types, user preferences (language, time windows)\n\n**Safety & context**\n\n- Moderation / compliance filters\n- Retrieval for policies, preparation instructions, service types\n\n**Insights & analytics**\n\n- Analytics (reminder → confirmation rate, response latency, fallback counts)\n\n## Getting It Running (You’ll Spend Minutes, Not Hours)\n\nThis setup is intentionally light. The only potentially slow step is acquiring a phone number in Azure Communication Services (see [the official quickstart](https://learn.microsoft.com/en-us/azure/communication-services/quickstarts/telephony/get-phone-number?tabs=windows&pivots=platform-azp-new)). Full step-by-step instructions (environment variables, dev tunnel, Event Grid subscription) live in [the demo repository README](https://github.com/pereiralex/sms-appointment-scheduler). The high-level overview is:\n\n1. Clone the repository and copy *.env.example* to *.env*\n2. Add Azure Communication Services connection string + phone number and Azure OpenAI endpoint/key/model.\n3. Install dependencies and start the app on port 8000.\n4. Expose port 8000 with a dev tunnel and point an Event Grid *SMSReceived* subscription to */api/sms/webhook*.\n5. Text your Azure Communication Services number and observe inbound event and reply in the terminal.\n\n![]()\n\nScreenshot of a terminal log with inbound event + “SMS sent to ACS number\"\n\n## Closing\n\nYou now have an event‑driven SMS conversation that feels like a live receptionist using only a phone number, a webhook, a lightweight availability snapshot, and a model prompt. [**Clone the repository**](https://github.com/pereiralex/sms-appointment-scheduler), run the demo, and try a reschedule from your own phone. Extend it and make it your own - whether that means integrating a real scheduling API, adding persistence, or incorporating compliance features. We’d love to see what you build.",
  "Tags": []
}
=======
{
  "OutputDir": "_community",
  "Link": "https://techcommunity.microsoft.com/t5/azure-communication-services/building-an-ai-receptionist-a-hands-on-demo-with-azure/ba-p/4442959",
  "Tags": [],
  "Description": "Ever missed an appointment because of a rigid SMS system? What if you could text a change and get an immediate, natural response that understands your intent and confirms a new slot quickly?\n\nIn this post, we'll show you how to build an AI receptionist that does just that, using Azure Communication Services and Azure OpenAI. We'll guide you through a hands-on demo that uses a simulated but realistic calendar for reliable confirmations and rescheduling, and show you how to make it production-ready.\n\n![]()\n\nA natural text thread with the scheduling agent\n\n#### Watch the Walkthrough\n\nPrefer a walkthrough? Watch the video demo to see the app in action with live code explanations.\n\nThis demo is ideal for anyone who wants to explore conversational AI with minimal setup -- whether you're a developer, product manager, or just curious about integrating Azure services.\n\n## What Actually Happens Under the Hood\n\nHere’s the simple set of moving parts behind the “AI receptionist” feel. First a quick look at each piece, then the exact path a message takes.\n\nCore pieces we’re using for this demo:\n\n- **Azure Communication Services**: Provides the real phone number, receives incoming text messages, and sends replies.\n- **Azure Event Grid**: Immediately forwards each new message event to a public URL (the webhook) your app exposes.\n- **FastAPI**: Hosts that webhook (an HTTP endpoint) and keeps simple in‑memory conversation and calendar data.\n- **Azure OpenAI**: Generates the receptionist’s reply using the running conversation plus a small snapshot of available appointment times.\n- **Simulated calendar**: Thirty upcoming business days with realistic fullness so the system can offer believable open slots.\n\nThen the message moves through this path:\n\n1. You send a text message to the demo phone number (handled by Azure Communication Services).\n2. Azure Communication Services raises a “message received” event.\n3. Azure Event Grid delivers that event as an HTTP POST to the FastAPI webhook (a regular URL).\n4. The webhook quickly returns “OK” and kicks off a background function (process\\_sms in *main.py*) so the user is never kept waiting.\n5. If this is your first message, it creates a mock appointment for “tomorrow” and sends a reminder; otherwise it adds your new message to the conversation history.\n6. It selects a few upcoming open slots from the simulated calendar, adds them to the system prompt, asks Azure OpenAI for a receptionist‑style reply, and receives the response.\n7. The reply goes back through Azure Communication Services, and the conversation state stays in memory.\n\nThat’s the loop. An event arrives, flows through a thin path, and a reply goes out. No constant checking (polling) or scheduled scripts needed.\n\n#### Demo vs Production\n\nIn the demo you start the conversation by texting the number. In a production rollout, you usually send an automated reminder (for example 24 hours before) and let the patient reply to confirm or change. From there the path is straightforward: swap the simulated calendar for a real scheduling API, persist conversation and appointment state, add authentication and signed webhook validation, and layer in logging and compliance. The event flow itself staysthe same.\n\n#### The Calendar Trick\n\nWe prebuild the next 30 business days (weekdays only), 09:00–17:00 in 30-minute slots, mark about 80 percent as “booked,” and keep the rest “available.” On each turn we pull a small handful of near-term open times and add them to the system prompt. That gives the model concrete, bounded choices and prevents it from inventing odd times like “3:10 AM” or “Saturday 7 PM.” A single snapshot replaces custom slot logic while still feeling live.\n\n![]()\n\nThe FastAPI routes for getting calendar logic\n\n#### Prompt Strategy\n\nThe system prompt frames a single role: a friendly receptionist limited to scheduling (no medical advice, within business hours, 30-minute increments). Each user message refreshes the availability lines so the model always sees current openings. The rules: only offer specific times when rescheduling, stay concise, and confirm final details. This balance keeps replies natural while keeping time suggestions controlled.\n\n#### Where to Take It Next\n\nTo evolve the demo into a dependable production service you layer durability, richer scheduling logic, safety, and observability onto the same event path - no rewrite required.\n\n**Productization**\n\n- Persist conversations and appointments (database + real scheduling/calendar API)\n- Authentication, signed webhook validation, rate limiting\n- Structured logging, tracing, latency and token metrics\n\n**Scheduling intelligence**\n\n- Function / tool calls for explicit slot selection\n- Real calendar integration (Outlook, scheduling API, electronic health record system)\n- Time zones, appointment types, user preferences (language, time windows)\n\n**Safety & context**\n\n- Moderation / compliance filters\n- Retrieval for policies, preparation instructions, service types\n\n**Insights & analytics**\n\n- Analytics (reminder → confirmation rate, response latency, fallback counts)\n\n## Getting It Running (You’ll Spend Minutes, Not Hours)\n\nThis setup is intentionally light. The only potentially slow step is acquiring a phone number in Azure Communication Services (see [the official quickstart](https://learn.microsoft.com/en-us/azure/communication-services/quickstarts/telephony/get-phone-number?tabs=windows&pivots=platform-azp-new)). Full step-by-step instructions (environment variables, dev tunnel, Event Grid subscription) live in [the demo repository README](https://github.com/pereiralex/sms-appointment-scheduler). The high-level overview is:\n\n1. Clone the repository and copy *.env.example* to *.env*\n2. Add Azure Communication Services connection string + phone number and Azure OpenAI endpoint/key/model.\n3. Install dependencies and start the app on port 8000.\n4. Expose port 8000 with a dev tunnel and point an Event Grid *SMSReceived* subscription to */api/sms/webhook*.\n5. Text your Azure Communication Services number and observe inbound event and reply in the terminal.\n\n![]()\n\nScreenshot of a terminal log with inbound event + “SMS sent to ACS number\"\n\n## Closing\n\nYou now have an event‑driven SMS conversation that feels like a live receptionist using only a phone number, a webhook, a lightweight availability snapshot, and a model prompt. [**Clone the repository**](https://github.com/pereiralex/sms-appointment-scheduler), run the demo, and try a reschedule from your own phone. Extend it and make it your own - whether that means integrating a real scheduling API, adding persistence, or incorporating compliance features. We’d love to see what you build.",
  "PubDate": "2025-08-13T16:35:46+00:00",
  "FeedName": "Microsoft Tech Community",
  "ProcessedDate": "2025-08-13 17:06:40",
  "EnhancedContent": "Ever missed an appointment because of a rigid SMS system? What if you could text a change and get an immediate, natural response that understands your intent and confirms a new slot quickly?\n\nIn this post, we'll show you how to build an AI receptionist that does just that, using Azure Communication Services and Azure OpenAI. We'll guide you through a hands-on demo that uses a simulated but realistic calendar for reliable confirmations and rescheduling, and show you how to make it production-ready.\n\nA natural text thread with the scheduling agent\n\n#### Watch the Walkthrough\n\nPrefer a walkthrough? Watch the video demo to see the app in action with live code explanations.\n\nThis demo is ideal for anyone who wants to explore conversational AI with minimal setup -- whether you're a developer, product manager, or just curious about integrating Azure services.\n\n## What Actually Happens Under the Hood\n\nHere’s the simple set of moving parts behind the “AI receptionist” feel. First a quick look at each piece, then the exact path a message takes.\n\nCore pieces we’re using for this demo:\n\n- **Azure Communication Services**: Provides the real phone number, receives incoming text messages, and sends replies.\n- **Azure Event Grid**: Immediately forwards each new message event to a public URL (the webhook) your app exposes.\n- **FastAPI**: Hosts that webhook (an HTTP endpoint) and keeps simple in‑memory conversation and calendar data.\n- **Azure OpenAI**: Generates the receptionist’s reply using the running conversation plus a small snapshot of available appointment times.\n- **Simulated calendar**: Thirty upcoming business days with realistic fullness so the system can offer believable open slots.\n\nThen the message moves through this path:\n\n1. You send a text message to the demo phone number (handled by Azure Communication Services).\n2. Azure Communication Services raises a “message received” event.\n3. Azure Event Grid delivers that event as an HTTP POST to the FastAPI webhook (a regular URL).\n4. The webhook quickly returns “OK” and kicks off a background function (process\\_sms in *main.py*) so the user is never kept waiting.\n5. If this is your first message, it creates a mock appointment for “tomorrow” and sends a reminder; otherwise it adds your new message to the conversation history.\n6. It selects a few upcoming open slots from the simulated calendar, adds them to the system prompt, asks Azure OpenAI for a receptionist‑style reply, and receives the response.\n7. The reply goes back through Azure Communication Services, and the conversation state stays in memory.\n\nThat’s the loop. An event arrives, flows through a thin path, and a reply goes out. No constant checking (polling) or scheduled scripts needed.\n\n#### Demo vs Production\n\nIn the demo you start the conversation by texting the number. In a production rollout, you usually send an automated reminder (for example 24 hours before) and let the patient reply to confirm or change. From there the path is straightforward: swap the simulated calendar for a real scheduling API, persist conversation and appointment state, add authentication and signed webhook validation, and layer in logging and compliance. The event flow itself staysthe same.\n\n#### The Calendar Trick\n\nWe prebuild the next 30 business days (weekdays only), 09:00–17:00 in 30-minute slots, mark about 80 percent as “booked,” and keep the rest “available.” On each turn we pull a small handful of near-term open times and add them to the system prompt. That gives the model concrete, bounded choices and prevents it from inventing odd times like “3:10 AM” or “Saturday 7 PM.” A single snapshot replaces custom slot logic while still feeling live.\n\nThe FastAPI routes for getting calendar logic\n\n#### Prompt Strategy\n\nThe system prompt frames a single role: a friendly receptionist limited to scheduling (no medical advice, within business hours, 30-minute increments). Each user message refreshes the availability lines so the model always sees current openings. The rules: only offer specific times when rescheduling, stay concise, and confirm final details. This balance keeps replies natural while keeping time suggestions controlled.\n\n#### Where to Take It Next\n\nTo evolve the demo into a dependable production service you layer durability, richer scheduling logic, safety, and observability onto the same event path - no rewrite required.\n\n**Productization**\n\n- Persist conversations and appointments (database + real scheduling/calendar API)\n- Authentication, signed webhook validation, rate limiting\n- Structured logging, tracing, latency and token metrics\n\n**Scheduling intelligence**\n\n- Function / tool calls for explicit slot selection\n- Real calendar integration (Outlook, scheduling API, electronic health record system)\n- Time zones, appointment types, user preferences (language, time windows)\n\n**Safety & context**\n\n- Moderation / compliance filters\n- Retrieval for policies, preparation instructions, service types\n\n**Insights & analytics**\n\n- Analytics (reminder → confirmation rate, response latency, fallback counts)\n\n## Getting It Running (You’ll Spend Minutes, Not Hours)\n\nThis setup is intentionally light. The only potentially slow step is acquiring a phone number in Azure Communication Services (see [the official quickstart](https://learn.microsoft.com/en-us/azure/communication-services/quickstarts/telephony/get-phone-number?tabs=windows&amp;pivots=platform-azp-new)). Full step-by-step instructions (environment variables, dev tunnel, Event Grid subscription) live in [the demo repository README](https://github.com/pereiralex/sms-appointment-scheduler). The high-level overview is:\n\n1. Clone the repository and copy *.env.example* to *.env*\n2. Add Azure Communication Services connection string + phone number and Azure OpenAI endpoint/key/model.\n3. Install dependencies and start the app on port 8000.\n4. Expose port 8000 with a dev tunnel and point an Event Grid *SMSReceived* subscription to */api/sms/webhook*.\n5. Text your Azure Communication Services number and observe inbound event and reply in the terminal.\n\nScreenshot of a terminal log with inbound event + “SMS sent to ACS number\"\n\n## Closing\n\nYou now have an event‑driven SMS conversation that feels like a live receptionist using only a phone number, a webhook, a lightweight availability snapshot, and a model prompt. [**Clone the repository**](https://github.com/pereiralex/sms-appointment-scheduler), run the demo, and try a reschedule from your own phone. Extend it and make it your own - whether that means integrating a real scheduling API, adding persistence, or incorporating compliance features. We’d love to see what you build.\n\nPublished Aug 13, 2025\n\nVersion 1.0\n\n[ai](/tag/ai?nodeId=board%3AAzureCommunicationServicesBlog)\n\n[customer engagement](/tag/customer%20engagement?nodeId=board%3AAzureCommunicationServicesBlog)\n\n[sms](/tag/sms?nodeId=board%3AAzureCommunicationServicesBlog)\n\n[!\\[seankeegan&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0yNjM0MTA4LTYyNjk5MmlFQ0Q2NzA2NDJBMDM0NzlD?image-dimensions=50x50)](/users/seankeegan/2634108) [seankeegan](/users/seankeegan/2634108) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined August 22, 2024\n\n[View Profile](/users/seankeegan/2634108)\n\n/category/azure/blog/azurecommunicationservicesblog [Azure Communication Services Blog](/category/azure/blog/azurecommunicationservicesblog) Follow this blog board to get notified when there's new activity",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Community",
  "Title": "Building an AI Receptionist: A Hands-On Demo with Azure Communication Services and OpenAI",
  "Author": "seankeegan"
}
>>>>>>> f38d706 (Articles from old repo, styling and some other fixes)
