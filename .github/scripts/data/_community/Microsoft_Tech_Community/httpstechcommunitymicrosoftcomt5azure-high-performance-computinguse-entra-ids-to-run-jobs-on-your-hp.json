{
  "Author": "trcooper",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Title": "Use Entra IDs to run jobs on your HPC cluster",
  "OutputDir": "_community",
  "ProcessedDate": "2025-09-29 18:04:35",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "EnhancedContent": "## This blog demonstrates the practical implementation of System Security Services Daemon (SSSD) with the recently introduced “idp” provider that can be used on Azure Linux 3.0 HPC clusters to provide consistent Usernames, UIDs and GIDs across the cluster all rooted in Microsoft Entra ID.\n\n## Introduction\n\nThis blog demonstrates the practical implementation of System Security Services Daemon (SSSD) with the recently introduced “idp” provider that can be used on Azure Linux 3.0 HPC clusters to provide consistent Usernames, UIDs and GIDs across the cluster all rooted in Microsoft Entra ID.\n\nHaving consistent Identities across the cluster is a fundamental requirement that is commonly met using SSSD and a provider such as LDAP, FreeIPA, or ADDS, or if no IdP is available by managing local accounts across all nodes.\n\nSSSD 2.11.0 introduced a new generic “idp” provider that can integrate Linux systems with Microsoft Entra ID via OAuth2/OpenID Connect. This means we can now define a domain in sssd.conf with id\\_provider = idp and idp\\_type = entra\\_id, along with Entra tenant and app credentials. With SSSD configured and running, getent can now resolve Entra users and groups via Entra ID, fetching the Entra user’s POSIX info consistently across the cluster.\n\nAs this new capability is very new (it’s being included in the Fedora 43 pre-release) this blog intends to cover the steps required to implement it on Azure Linux 3.0 for those that would like to explore this on their own VMs and Clusters.\n\n## Implementation\n\n### 1. Build RPMs\n\nAs we are deploying on Azure Linux 3.0 and RPMs are not available in packages.microsoft.com (PMC) we must download the release package 2.11.0 from [Releases · SSSD/sssd](https://github.com/SSSD/sssd/releases) and follow the guidance from [Building SSSD - sssd.io](https://sssd.io/contrib/building-sssd.html)\n\nA virtual machine running Azure Linux 3.0 HPC edition which provides many of the build tools required (and is our target operating system) was used. A number of dependencies must still be installed to perform the make but these are all available from PMC and the make runs without issue.\n\n```\n# Install dependencies sudo tdnf -y install \\\nc-ares-devel \\ cifs-utils-devel \\ curl-devel \\ cyrus-sasl-devel \\ dbus-devel \\ jansson-devel \\ krb5-devel \\ libcap-devel \\ libdhash-devel \\ libldb-devel \\ libini_config-devel \\ libjose-devel \\ libnfsidmap-devel \\ libsemanage-devel \\ libsmbclient-devel \\ libtalloc-devel \\ libtdb-devel \\ libtevent-devel \\ libunistring-devel \\ libwbclient-devel \\ p11-kit-devel \\ samba-devel \\ samba-winbind sudo\n\nln -s /etc/alternatives/libwbclient.so-64 /usr/lib/libwbclient.so.0\n\n# Build SSSD from source\nwget https://github.com/SSSD/sssd/releases/download/2.11.0/sssd-2.11.0.tar.gz tar -xvf sssd-2.11.0.tar.gz cd sssd-2.11.0 autoreconf -if ./configure --enable-nsslibdir=/lib64 --enable-pammoddir=/lib64/security --enable-silent-rules --with-smb-idmap-interface-version=6 make # Success!! ```\n\nBuilding the RPMs is more complex as there are many more dependencies, some dependencies not available on PMC and we are also reusing the generic **sssd.spec** file. However, this can be performed to create a working set of required SSSD RPMs.\n\nFirst install the dependencies available from PMC:\n\n```\n# Add dependencies for rpmbuild\nsudo tdnf -y install \\ doxygen \\ libcmocka-devel \\ nss_wrapper \\ pam_wrapper \\ po4a \\ shadow-utils-subid-devel \\ softhsm \\ systemtap-sdt-devel \\ uid_wrapper ```\n\nThe remaining four dependencies are sourced from Fedora 42 builds and may be installed using tdnf:\n\n```\n# gdm-pam-extensions-devel\nwget https://kojipkgs.fedoraproject.org//packages/gdm/48.0/3.fc42/x86_64/gdm-pam-extensions-devel-48.0-3.fc42.x86_64.rpm sudo tdnf install ./gdm-pam-extensions-devel-48.0-3.fc42.x86_64.rpm\n\n# libfido2-devel\nwget https://dl.fedoraproject.org/pub/epel/8/Everything/x86_64/Packages/l/libcbor-0.7.0-6.el8.x86_64.rpm wget https://dl.fedoraproject.org/pub/epel/8/Everything/x86_64/Packages/l/libfido2-1.11.0-2.el8.x86_64.rpm wget https://dl.fedoraproject.org/pub/epel/8/Everything/x86_64/Packages/l/libfido2-devel-1.11.0-2.el8.x86_64.rpm sudo tdnf install ./libcbor-0.7.0-6.el8.x86_64.rpm --nogpgcheck sudo tdnf install ./libfido2-1.11.0-2.el8.x86_64.rpm --nogpgcheck sudo tdnf install ./libfido2-devel-1.11.0-2.el8.x86_64.rpm --nogpgcheck ```\n\nThe **sudo make rpms** can now be initiated. It will fail but establishes much of what we need for a successful **rpmbuild** using the following steps:\n\n```\n# rpmbuild\nsudo make rpms\n# will error with: File /rpmbuild/SOURCES/sssd-2.11.0.tar.gz: No such file or directory\nsudo cp ../sssd-2.11.0.tar.gz /rpmbuild/SOURCES/ cd /rpmbuild sudo vi SPECS/sssd.spec # edit build_passkey 1 in SPECS/sssd.spec to 0 to skip passkey support sudo rpmbuild --define \"_topdir /rpmbuild\" -ba SPECS/sssd.spec ```\n\nAnd we have RPMs\n\n``` #RPMS!!! libipa_hbac-2.11.0-0.azl3.x86_64.rpm libipa_hbac-devel-2.11.0-0.azl3.x86_64.rpm libsss_autofs-2.11.0-0.azl3.x86_64.rpm libsss_certmap-2.11.0-0.azl3.x86_64.rpm libsss_certmap-devel-2.11.0-0.azl3.x86_64.rpm libsss_idmap-2.11.0-0.azl3.x86_64.rpm libsss_idmap-devel-2.11.0-0.azl3.x86_64.rpm libsss_nss_idmap-2.11.0-0.azl3.x86_64.rpm libsss_nss_idmap-devel-2.11.0-0.azl3.x86_64.rpm libsss_sudo-2.11.0-0.azl3.x86_64.rpm python3-libipa_hbac-2.11.0-0.azl3.x86_64.rpm python3-libsss_nss_idmap-2.11.0-0.azl3.x86_64.rpm python3-sss-2.11.0-0.azl3.x86_64.rpm python3-sss-murmur-2.11.0-0.azl3.x86_64.rpm python3-sssdconfig-2.11.0-0.azl3.noarch.rpm sssd-2.11.0-0.azl3.x86_64.rpm sssd-ad-2.11.0-0.azl3.x86_64.rpm sssd-client-2.11.0-0.azl3.x86_64.rpm sssd-common-2.11.0-0.azl3.x86_64.rpm sssd-common-pac-2.11.0-0.azl3.x86_64.rpm sssd-dbus-2.11.0-0.azl3.x86_64.rpm sssd-debuginfo-2.11.0-0.azl3.x86_64.rpm sssd-idp-2.11.0-0.azl3.x86_64.rpm sssd-ipa-2.11.0-0.azl3.x86_64.rpm sssd-kcm-2.11.0-0.azl3.x86_64.rpm sssd-krb5-2.11.0-0.azl3.x86_64.rpm sssd-krb5-common-2.11.0-0.azl3.x86_64.rpm sssd-ldap-2.11.0-0.azl3.x86_64.rpm sssd-nfs-idmap-2.11.0-0.azl3.x86_64.rpm sssd-proxy-2.11.0-0.azl3.x86_64.rpm sssd-tools-2.11.0-0.azl3.x86_64.rpm sssd-winbind-idmap-2.11.0-0.azl3.x86_64.rpm ```\n\n### 2. Deploy RPMs\n\nWith the RPMs created we can now move to installing them on our Cluster. In my case I am using a customised image with other tunings and packages so these can be included in my Ansible Playbook and an updated image produced. The following details the rpms (a subset of the 30 or so created) installed into the image:\n\n```\n# Pre install sssd rpms\n- name: Copy sssd rpms onto host\nansible.builtin.copy: src: sssd-2.11.0/ dest: /tmp/sssd/\n- name: Install sssd rpms\nansible.builtin.shell: | tdnf -y install /tmp/sssd/libsss_certmap-2.11.0-0.azl3.x86_64.rpm tdnf -y install /tmp/sssd/libsss_certmap-devel-2.11.0-0.azl3.x86_64.rpm tdnf -y install /tmp/sssd/libsss_idmap-2.11.0-0.azl3.x86_64.rpm tdnf -y install /tmp/sssd/libsss_nss_idmap-2.11.0-0.azl3.x86_64.rpm tdnf -y install /tmp/sssd/sssd-client-2.11.0-0.azl3.x86_64.rpm tdnf -y install /tmp/sssd/libsss_sudo-2.11.0-0.azl3.x86_64.rpm tdnf -y install /tmp/sssd/sssd-nfs-idmap-2.11.0-0.azl3.x86_64.rpm tdnf -y install /tmp/sssd/sssd-common-2.11.0-0.azl3.x86_64.rpm tdnf -y install /tmp/sssd/sssd-common-pac-2.11.0-0.azl3.x86_64.rpm tdnf -y install /tmp/sssd/sssd-idp-2.11.0-0.azl3.x86_64.rpm tdnf -y install /tmp/sssd/sssd-krb5-common-2.11.0-0.azl3.x86_64.rpm tdnf -y install /tmp/sssd/sssd-ad-2.11.0-0.azl3.x86_64.rpm tdnf -y install /tmp/sssd/libipa_hbac-2.11.0-0.azl3.x86_64.rpm tdnf -y install /tmp/sssd/sssd-ipa-2.11.0-0.azl3.x86_64.rpm tdnf -y install /tmp/sssd/sssd-krb5-2.11.0-0.azl3.x86_64.rpm tdnf -y install /tmp/sssd/sssd-ldap-2.11.0-0.azl3.x86_64.rpm tdnf -y install /tmp/sssd/sssd-proxy-2.11.0-0.azl3.x86_64.rpm tdnf -y install /tmp/sssd/sssd-2.11.0-0.azl3.x86_64.rpm\n\n```\n\n### 3. Create an App Registration\n\nFor the SSSD “idp” provider to be able to read Entra ID user and group attributes we must create an Application ID with Secret in our Entra tenant.\n\nThe Application will require the following API permissions:\n\nAdditionally the Application must be assigned the **Directory Readers** permissions over the directory. This can be done through the Graph API using the following template:\n\n``` POST https://graph.microsoft.com/v1.0/roleManagement/directory/roleAssignments { \"principalId\": \"<objectid of=\"\" your=\"\" spn=\"\">\", \"roleDefinitionId\": \"<roledefinitionid for=\"\" directory=\"\" readers=\"\">\", \"directoryScopeId\": \"/\" }</roledefinitionid></objectid> ```\n\nNote the Application (client) ID and its secret as these will be required to for the SSSD configuration.\n\n### 4. Configure SSSD & NSSWITCH\n\nFor these I have used cloud init to add the **sssd.conf** and amend the **nsswitch.conf** during deployment across Slurm Controllers, Login nodes and Compute nodes. The SSSD service is also enabled and started. The resulting files should look like the following customized to your own domain, app Id and secret.\n\n**/etc/sssd/sssd.conf**\n\n``` [sssd] config_file_version = 2 services = nss, pam domains = mydomain.onmicrosoft.com\n\n[domain/mydomain.onmicrosoft.com] id_provider = idp idp_type = entra_id idp_client_id = ########-####-####-####-############ idp_client_secret = ######################################## idp_token_endpoint = https://login.microsoftonline.com/937d5829-df9d-46b6-ad5a-718ebc33371e/oauth2/v2.0/token idp_userinfo_endpoint = https://graph.microsoft.com/v1.0/me idp_device_auth_endpoint = https://login.microsoftonline.com/937d5829-df9d-46b6-ad5a-718ebc33371e/oauth2/v2.0/devicecode idp_id_scope = https%3A%2F%2Fgraph.microsoft.com%2F.default idp_auth_scope = openid profile email auto_private_groups = true use_fully_qualified_names = false cache_credentials = true entry_cache_timeout = 5400 entry_cache_nowait_percentage = 50 refresh_expired_interval = 4050 enumerate = false debug_level = 2\n\n[nss] debug_level = 2 default_shell = /bin/bash fallback_homedir = /shared/home/%u\n\n[pam] debug_level = 2 ```\n\n**/etc/nsswitch.conf**\n\n```\n# Begin /etc/nsswitch.conf\n\npasswd: files sss group: files sss shadow: files sss\n\nhosts: files dns networks: files\n\nprotocols: files services: files ethers: files rpc: files\n# End /etc/nsswitch.conf\n```\n\n### 5. Create User home directories\n\nThe use of Device Auth for Entra users over SSH is not currently supported so for now my Entra users will authenticate using SSH Public Key Auth. For that to work their $HOME directories must be pre-created, and their public keys added to .ssh/authorized\\_keys. This is simplified by having SSSD in place as we can use **getent passwd** to get a user’s $HOME and set directory and file permissions using the usual **chown** command.\n\nThe following example script will create the users directory, add their public key, and creates a keypair for internal use across the cluster:\n\n``` #!/bin/bash\n# Script to create a user home directory and populate it with a given SSH public key.\n# Must be executed as root or via sudo.\n\nUSER_NAME=$1 USER_PUBKEY=$2\n\nif [ -z \"${USER_NAME}\" ] || [ -z \"${USER_PUBKEY}\" ]; then echo \"Usage: $0 \" exit 1 fi\n\nentry=$(getent passwd \"${USER_NAME}\") export USER_UID=$(echo \"$entry\" | awk -F: '{print $3}') export USER_HOME=$(echo \"$entry\" | awk -F: '{print $6}') #if directory exists, we're good if [ -d \"${USER_HOME}\" ]; then echo \"Directory ${USER_HOME} exists, do not modify.\" else mkdir -p \"${USER_HOME}\" chown $USER_UID:$USER_UID $USER_HOME chmod 700 $USER_HOME cp -r /etc/skel/. $USER_HOME mkdir -p $USER_HOME/.ssh chmod 700 $USER_HOME/.ssh touch $USER_HOME/.ssh/authorized_keys chmod 644 $USER_HOME/.ssh/authorized_keys echo \"${USER_PUBKEY}\" >> $USER_HOME/.ssh/authorized_keys { echo \"# Automatically generated - StrictHostKeyChecking is disabled to allow for passwordless SSH between Azure nodes\" echo \"Host *\" echo \" StrictHostKeyChecking no\" } >> \"$USER_HOME/.ssh/config\" chmod 644 \"$USER_HOME/.ssh/config\" chown -R $USER_UID:$USER_UID $USER_HOME sudo -u $USER_NAME ssh-keygen -f $USER_HOME/.ssh/id_ed25519 -N \"\" -q cat $USER_HOME/.ssh/id_ed25519.pub >> $USER_HOME/.ssh/authorized_keys fi ```\n\n### 6. Run jobs as Entra user\n\nLogged in Entra user:\n\n``` john.doe@tst4-login-0 [ ~ ]$ id uid=1137116670(john.doe) gid=1137116670(john.doe) groups=1137116670(john.doe) john.doe@tst4-login-0 [ ~ ]$ getent passwd john.doe john.doe:*:1137116670:1137116670::/shared/home/john.doe:/bin/bash ```\n\nAnd running an MPI job:\n\n``` john.doe@tst4-login-0 [ ~ ]$ sbatch -p hbv4 /cvmfs/az.pe/1.2.6/tests/imb/imb-env-intel-oneapi.sh Submitted batch job 330 john.doe@tst4-login-0 [ ~ ]$ squeue JOBID PARTITION NAME USER ST TIME NODES NODELIST(REASON) 330 hbv4 imb-env- john.doe R 0:06 2 tst4-hbv4-[114-115] john.doe@tst4-login-0 [ ~ ]$ cat slurm-imb-env-intel-oneapi-330.out Testing IMB using Spack environment intel-oneapi ... Setting up Azure PE version 1.2.6 for azurelinux3.0 on x86_64 Testing IMB using srun... #----------------------------------------------------------------\n# Intel(R) MPI Benchmarks 2021.7, MPI-1 part\n#----------------------------------------------------------------\n# Date : Mon Sep 29 15:24:24 2025\n# Machine : x86_64\n# System : Linux\n# Release : 6.6.96.1-1.azl3\n# Version : #1 SMP PREEMPT_DYNAMIC Tue Jul 29 02:44:24 UTC 2025\n# MPI Version : 4.1\n# MPI Thread Environment:\n```\n\n## Summary\n\nSo, early days and requires a little prep but hopefully this demonstrates that using the new SSSD “idp” provider we can finally use Entra and the source of user identities on our HPC clusters.\n\nUpdated Sep 29, 2025\n\nVersion 1.0\n\n[hpc](/tag/hpc?nodeId=board%3AAzureHighPerformanceComputingBlog)\n\n[!\\[trcooper&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/m_assets/avatars/default/avatar-12.svg?image-dimensions=50x50)](/users/trcooper/250452) [trcooper](/users/trcooper/250452) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined December 06, 2018\n\n[View Profile](/users/trcooper/250452)\n\n/category/azure/blog/azurehighperformancecomputingblog [Azure High Performance Computing (HPC) Blog](/category/azure/blog/azurehighperformancecomputingblog) Follow this blog board to get notified when there's new activity",
  "Link": "https://techcommunity.microsoft.com/t5/azure-high-performance-computing/use-entra-ids-to-run-jobs-on-your-hpc-cluster/ba-p/4457932",
  "FeedName": "Microsoft Tech Community",
  "PubDate": "2025-09-29T17:50:46+00:00",
  "Description": "## Introduction\n\nThis blog demonstrates the practical implementation of System Security Services Daemon (SSSD) with the recently introduced “idp” provider that can be used on Azure Linux 3.0 HPC clusters to provide consistent Usernames, UIDs and GIDs across the cluster all rooted in Microsoft Entra ID.\n\nHaving consistent Identities across the cluster is a fundamental requirement that is commonly met using SSSD and a provider such as LDAP, FreeIPA, or ADDS, or if no IdP is available by managing local accounts across all nodes.\n\nSSSD 2.11.0 introduced a new generic “idp” provider that can integrate Linux systems with Microsoft Entra ID via OAuth2/OpenID Connect. This means we can now define a domain in sssd.conf with id\\_provider = idp and idp\\_type = entra\\_id, along with Entra tenant and app credentials. With SSSD configured and running, getent can now resolve Entra users and groups via Entra ID, fetching the Entra user’s POSIX info consistently across the cluster.\n\nAs this new capability is very new (it’s being included in the Fedora 43 pre-release) this blog intends to cover the steps required to implement it on Azure Linux 3.0 for those that would like to explore this on their own VMs and Clusters.\n\n## Implementation\n\n### 1. Build RPMs\n\nAs we are deploying on Azure Linux 3.0 and RPMs are not available in packages.microsoft.com (PMC) we must download the release package 2.11.0 from [Releases · SSSD/sssd](https://github.com/SSSD/sssd/releases) and follow the guidance from [Building SSSD - sssd.io](https://sssd.io/contrib/building-sssd.html)\n\nA virtual machine running Azure Linux 3.0 HPC edition which provides many of the build tools required (and is our target operating system) was used. A number of dependencies must still be installed to perform the make but these are all available from PMC and the make runs without issue.\n\n- # Install dependencies sudo tdnf -y install \\\nc-ares-devel \\ cifs-utils-devel \\ curl-devel \\ cyrus-sasl-devel \\ dbus-devel \\ jansson-devel \\ krb5-devel \\ libcap-devel \\ libdhash-devel \\ libldb-devel \\ libini\\_config-devel \\ libjose-devel \\ libnfsidmap-devel \\ libsemanage-devel \\ libsmbclient-devel \\ libtalloc-devel \\ libtdb-devel \\ libtevent-devel \\ libunistring-devel \\ libwbclient-devel \\ p11-kit-devel \\ samba-devel \\ samba-winbind sudo\n\nln -s /etc/alternatives/libwbclient.so-64 /usr/lib/libwbclient.so.0\n\n# Build SSSD from source\nwget https://github.com/SSSD/sssd/releases/download/2.11.0/sssd-2.11.0.tar.gz tar -xvf sssd-2.11.0.tar.gz cd sssd-2.11.0 autoreconf -if ./configure --enable-nsslibdir=/lib64 --enable-pammoddir=/lib64/security --enable-silent-rules --with-smb-idmap-interface-version=6 make # Success!!\n\nBuilding the RPMs is more complex as there are many more dependencies, some dependencies not available on PMC and we are also reusing the generic **sssd.spec** file. However, this can be performed to create a working set of required SSSD RPMs.\n\nFirst install the dependencies available from PMC:\n- # Add dependencies for rpmbuild\nsudo tdnf -y install \\ doxygen \\ libcmocka-devel \\ nss\\_wrapper \\ pam\\_wrapper \\ po4a \\ shadow-utils-subid-devel \\ softhsm \\ systemtap-sdt-devel \\ uid\\_wrapper\n\nThe remaining four dependencies are sourced from Fedora 42 builds and may be installed using tdnf:\n- # gdm-pam-extensions-devel\nwget https://kojipkgs.fedoraproject.org//packages/gdm/48.0/3.fc42/x86\\_64/gdm-pam-extensions-devel-48.0-3.fc42.x86\\_64.rpm sudo tdnf install ./gdm-pam-extensions-devel-48.0-3.fc42.x86\\_64.rpm\n\n# libfido2-devel\nwget https://dl.fedoraproject.org/pub/epel/8/Everything/x86\\_64/Packages/l/libcbor-0.7.0-6.el8.x86\\_64.rpm wget https://dl.fedoraproject.org/pub/epel/8/Everything/x86\\_64/Packages/l/libfido2-1.11.0-2.el8.x86\\_64.rpm wget https://dl.fedoraproject.org/pub/epel/8/Everything/x86\\_64/Packages/l/libfido2-devel-1.11.0-2.el8.x86\\_64.rpm sudo tdnf install ./libcbor-0.7.0-6.el8.x86\\_64.rpm --nogpgcheck sudo tdnf install ./libfido2-1.11.0-2.el8.x86\\_64.rpm --nogpgcheck sudo tdnf install ./libfido2-devel-1.11.0-2.el8.x86\\_64.rpm --nogpgcheck\n\nThe **sudo make rpms** can now be initiated. It will fail but establishes much of what we need for a successful **rpmbuild** using the following steps:\n- # rpmbuild\nsudo make rpms\n# will error with: File /rpmbuild/SOURCES/sssd-2.11.0.tar.gz: No such file or directory\nsudo cp ../sssd-2.11.0.tar.gz /rpmbuild/SOURCES/ cd /rpmbuild sudo vi SPECS/sssd.spec # edit build\\_passkey 1 in SPECS/sssd.spec to 0 to skip passkey support sudo rpmbuild --define \"\\_topdir /rpmbuild\" -ba SPECS/sssd.spec\n\nAnd we have RPMs\n- #RPMS!!!\nlibipa\\_hbac-2.11.0-0.azl3.x86\\_64.rpm libipa\\_hbac-devel-2.11.0-0.azl3.x86\\_64.rpm libsss\\_autofs-2.11.0-0.azl3.x86\\_64.rpm libsss\\_certmap-2.11.0-0.azl3.x86\\_64.rpm libsss\\_certmap-devel-2.11.0-0.azl3.x86\\_64.rpm libsss\\_idmap-2.11.0-0.azl3.x86\\_64.rpm libsss\\_idmap-devel-2.11.0-0.azl3.x86\\_64.rpm libsss\\_nss\\_idmap-2.11.0-0.azl3.x86\\_64.rpm libsss\\_nss\\_idmap-devel-2.11.0-0.azl3.x86\\_64.rpm libsss\\_sudo-2.11.0-0.azl3.x86\\_64.rpm python3-libipa\\_hbac-2.11.0-0.azl3.x86\\_64.rpm python3-libsss\\_nss\\_idmap-2.11.0-0.azl3.x86\\_64.rpm python3-sss-2.11.0-0.azl3.x86\\_64.rpm python3-sss-murmur-2.11.0-0.azl3.x86\\_64.rpm python3-sssdconfig-2.11.0-0.azl3.noarch.rpm sssd-2.11.0-0.azl3.x86\\_64.rpm sssd-ad-2.11.0-0.azl3.x86\\_64.rpm sssd-client-2.11.0-0.azl3.x86\\_64.rpm sssd-common-2.11.0-0.azl3.x86\\_64.rpm sssd-common-pac-2.11.0-0.azl3.x86\\_64.rpm sssd-dbus-2.11.0-0.azl3.x86\\_64.rpm sssd-debuginfo-2.11.0-0.azl3.x86\\_64.rpm sssd-idp-2.11.0-0.azl3.x86\\_64.rpm sssd-ipa-2.11.0-0.azl3.x86\\_64.rpm sssd-kcm-2.11.0-0.azl3.x86\\_64.rpm sssd-krb5-2.11.0-0.azl3.x86\\_64.rpm sssd-krb5-common-2.11.0-0.azl3.x86\\_64.rpm sssd-ldap-2.11.0-0.azl3.x86\\_64.rpm sssd-nfs-idmap-2.11.0-0.azl3.x86\\_64.rpm sssd-proxy-2.11.0-0.azl3.x86\\_64.rpm sssd-tools-2.11.0-0.azl3.x86\\_64.rpm sssd-winbind-idmap-2.11.0-0.azl3.x86\\_64.rpm\n\n### 2. Deploy RPMs\n\nWith the RPMs created we can now move to installing them on our Cluster. In my case I am using a customised image with other tunings and packages so these can be included in my Ansible Playbook and an updated image produced. The following details the rpms (a subset of the 30 or so created) installed into the image:\n- # Pre install sssd rpms\n- name: Copy sssd rpms onto host\nansible.builtin.copy: src: sssd-2.11.0/ dest: /tmp/sssd/\n- name: Install sssd rpms\nansible.builtin.shell: | tdnf -y install /tmp/sssd/libsss\\_certmap-2.11.0-0.azl3.x86\\_64.rpm tdnf -y install /tmp/sssd/libsss\\_certmap-devel-2.11.0-0.azl3.x86\\_64.rpm tdnf -y install /tmp/sssd/libsss\\_idmap-2.11.0-0.azl3.x86\\_64.rpm tdnf -y install /tmp/sssd/libsss\\_nss\\_idmap-2.11.0-0.azl3.x86\\_64.rpm tdnf -y install /tmp/sssd/sssd-client-2.11.0-0.azl3.x86\\_64.rpm tdnf -y install /tmp/sssd/libsss\\_sudo-2.11.0-0.azl3.x86\\_64.rpm tdnf -y install /tmp/sssd/sssd-nfs-idmap-2.11.0-0.azl3.x86\\_64.rpm tdnf -y install /tmp/sssd/sssd-common-2.11.0-0.azl3.x86\\_64.rpm tdnf -y install /tmp/sssd/sssd-common-pac-2.11.0-0.azl3.x86\\_64.rpm tdnf -y install /tmp/sssd/sssd-idp-2.11.0-0.azl3.x86\\_64.rpm tdnf -y install /tmp/sssd/sssd-krb5-common-2.11.0-0.azl3.x86\\_64.rpm tdnf -y install /tmp/sssd/sssd-ad-2.11.0-0.azl3.x86\\_64.rpm tdnf -y install /tmp/sssd/libipa\\_hbac-2.11.0-0.azl3.x86\\_64.rpm tdnf -y install /tmp/sssd/sssd-ipa-2.11.0-0.azl3.x86\\_64.rpm tdnf -y install /tmp/sssd/sssd-krb5-2.11.0-0.azl3.x86\\_64.rpm tdnf -y install /tmp/sssd/sssd-ldap-2.11.0-0.azl3.x86\\_64.rpm tdnf -y install /tmp/sssd/sssd-proxy-2.11.0-0.azl3.x86\\_64.rpm tdnf -y install /tmp/sssd/sssd-2.11.0-0.azl3.x86\\_64.rpm\n\n### 3. Create an App Registration\n\nFor the SSSD “idp” provider to be able to read Entra ID user and group attributes we must create an Application ID with Secret in our Entra tenant.\n\nThe Application will require the following API permissions:\n\n![]()\n\nAdditionally the Application must be assigned the **Directory Readers** permissions over the directory. This can be done through the Graph API using the following template:\n- POST https://graph.microsoft.com/v1.0/roleManagement/directory/roleAssignments\n{ \"principalId\": \"\", \"roleDefinitionId\": \"\", \"directoryScopeId\": \"/\" }\n\nNote the Application (client) ID and its secret as these will be required to for the SSSD configuration.\n\n### 4. Configure SSSD & NSSWITCH\n\nFor these I have used cloud init to add the **sssd.conf** and amend the **nsswitch.conf** during deployment across Slurm Controllers, Login nodes and Compute nodes. The SSSD service is also enabled and started. The resulting files should look like the following customized to your own domain, app Id and secret.\n\n**/etc/sssd/sssd.conf**\n- [sssd]\nconfig\\_file\\_version = 2 services = nss, pam domains = mydomain.onmicrosoft.com\n\n[domain/mydomain.onmicrosoft.com] id\\_provider = idp idp\\_type = entra\\_id idp\\_client\\_id = ########-####-####-####-############ idp\\_client\\_secret = ######################################## idp\\_token\\_endpoint = https://login.microsoftonline.com/937d5829-df9d-46b6-ad5a-718ebc33371e/oauth2/v2.0/token idp\\_userinfo\\_endpoint = https://graph.microsoft.com/v1.0/me idp\\_device\\_auth\\_endpoint = https://login.microsoftonline.com/937d5829-df9d-46b6-ad5a-718ebc33371e/oauth2/v2.0/devicecode idp\\_id\\_scope = https%3A%2F%2Fgraph.microsoft.com%2F.default idp\\_auth\\_scope = openid profile email auto\\_private\\_groups = true use\\_fully\\_qualified\\_names = false cache\\_credentials = true entry\\_cache\\_timeout = 5400 entry\\_cache\\_nowait\\_percentage = 50 refresh\\_expired\\_interval = 4050 enumerate = false debug\\_level = 2\n\n[nss] debug\\_level = 2 default\\_shell = /bin/bash fallback\\_homedir = /shared/home/%u\n\n[pam] debug\\_level = 2\n\n**/etc/nsswitch.conf**\n- # Begin /etc/nsswitch.conf\n\npasswd: files sss group: files sss shadow: files sss\n\nhosts: files dns networks: files\n\nprotocols: files services: files ethers: files rpc: files\n# End /etc/nsswitch.conf\n\n### 5. Create User home directories\n\nThe use of Device Auth for Entra users over SSH is not currently supported so for now my Entra users will authenticate using SSH Public Key Auth. For that to work their $HOME directories must be pre-created, and their public keys added to .ssh/authorized\\_keys. This is simplified by having SSSD in place as we can use **getent passwd** to get a user’s $HOME and set directory and file permissions using the usual **chown** command.\n\nThe following example script will create the users directory, add their public key, and creates a keypair for internal use across the cluster:\n- #!/bin/bash\n# Script to create a user home directory and populate it with a given SSH public key.\n# Must be executed as root or via sudo.\n\nUSER\\_NAME=$1 USER\\_PUBKEY=$2\n\nif [ -z \"${USER\\_NAME}\" ] || [ -z \"${USER\\_PUBKEY}\" ]; then echo \"Usage: $0 \" exit 1 fi\n\nentry=$(getent passwd \"${USER\\_NAME}\") export USER\\_UID=$(echo \"$entry\" | awk -F: '{print $3}') export USER\\_HOME=$(echo \"$entry\" | awk -F: '{print $6}') #if directory exists, we're good if [ -d \"${USER\\_HOME}\" ]; then echo \"Directory ${USER\\_HOME} exists, do not modify.\" else mkdir -p \"${USER\\_HOME}\" chown $USER\\_UID:$USER\\_UID $USER\\_HOME chmod 700 $USER\\_HOME cp -r /etc/skel/. $USER\\_HOME mkdir -p $USER\\_HOME/.ssh chmod 700 $USER\\_HOME/.ssh touch $USER\\_HOME/.ssh/authorized\\_keys chmod 644 $USER\\_HOME/.ssh/authorized\\_keys echo \"${USER\\_PUBKEY}\" >> $USER\\_HOME/.ssh/authorized\\_keys { echo \"# Automatically generated - StrictHostKeyChecking is disabled to allow for passwordless SSH between Azure nodes\" echo \"Host \\*\" echo \" StrictHostKeyChecking no\" } >> \"$USER\\_HOME/.ssh/config\" chmod 644 \"$USER\\_HOME/.ssh/config\" chown -R $USER\\_UID:$USER\\_UID $USER\\_HOME sudo -u $USER\\_NAME ssh-keygen -f $USER\\_HOME/.ssh/id\\_ed25519 -N \"\" -q cat $USER\\_HOME/.ssh/id\\_ed25519.pub >> $USER\\_HOME/.ssh/authorized\\_keys fi\n\n### 6. Run jobs as Entra user\n\nLogged in Entra user:\n- john.doe@tst4-login-0 [ ~ ]$ id\nuid=1137116670(john.doe) gid=1137116670(john.doe) groups=1137116670(john.doe) john.doe@tst4-login-0 [ ~ ]$ getent passwd john.doe john.doe:\\*:1137116670:1137116670::/shared/home/john.doe:/bin/bash\n\nAnd running an MPI job:\n- john.doe@tst4-login-0 [ ~ ]$ sbatch -p hbv4 /cvmfs/az.pe/1.2.6/tests/imb/imb-env-intel-oneapi.sh\nSubmitted batch job 330 john.doe@tst4-login-0 [ ~ ]$ squeue JOBID PARTITION NAME USER ST TIME NODES NODELIST(REASON) 330 hbv4 imb-env- john.doe R 0:06 2 tst4-hbv4-[114-115] john.doe@tst4-login-0 [ ~ ]$ cat slurm-imb-env-intel-oneapi-330.out Testing IMB using Spack environment intel-oneapi ... Setting up Azure PE version 1.2.6 for azurelinux3.0 on x86\\_64 Testing IMB using srun... #----------------------------------------------------------------\n# Intel(R) MPI Benchmarks 2021.7, MPI-1 part\n#----------------------------------------------------------------\n# Date : Mon Sep 29 15:24:24 2025\n# Machine : x86\\_64\n# System : Linux\n# Release : 6.6.96.1-1.azl3\n# Version : #1 SMP PREEMPT\\_DYNAMIC Tue Jul 29 02:44:24 UTC 2025\n# MPI Version : 4.1\n# MPI Thread Environment:\n\n## Summary\n\nSo, early days and requires a little prep but hopefully this demonstrates that using the new SSSD “idp” provider we can finally use Entra and the source of user identities on our HPC clusters.",
  "Tags": []
}
