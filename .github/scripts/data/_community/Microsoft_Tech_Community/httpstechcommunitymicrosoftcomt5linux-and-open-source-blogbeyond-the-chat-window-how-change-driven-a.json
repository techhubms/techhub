{
  "FeedName": "Microsoft Tech Community",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "PubDate": "2025-12-03T23:09:40+00:00",
  "EnhancedContent": "## Author: Daniel Gerlag, Principal Software Engineer\n\nAI agents are everywhere now. Powering chat interfaces, answering questions, helping with code. We've gotten remarkably good at this conversational paradigm. But while the world has been focused on chat experiences, something new is quietly emerging: ambient agents. These aren't replacements for chat, they're an entirely new category of AI system that operates in the background, sensing, processing, and responding to the world in real time. And here's the thing, this is a new frontier. The infrastructure we need to build these systems barely exists yet.\n\nOr at least, it didn't until now.\n\n#### Two Worlds: Conversational and Ambient\n\nLet me paint you a picture of the conversational AI paradigm we know well. You open a chat window. You type a question. You wait. The AI responds. Rinse and repeat. It's the digital equivalent of having a brilliant assistant sitting at a desk, ready to help when you tap them on the shoulder.\n\nNow imagine a completely different kind of assistant. One that watches for important changes, anticipates needs, and springs into action without being asked. That's the promise of ambient agents. AI systems that, as [LangChain puts it](https://blog.langchain.com/introducing-ambient-agents/): \"listen to an event stream and act on it accordingly, potentially acting on multiple events at a time.\"\n\nThis isn't an evolution of chat; it's a fundamentally different interaction paradigm. Both have their place. Chat is great for collaboration and back-and-forth reasoning. Ambient agents excel at continuous monitoring and autonomous response. Instead of human-initiated conversations, ambient agents operate through detecting changes in upstream systems and maintaining context across time without constant prompting.\n\nThe use cases are compelling and distinct from chat. Imagine a project management assistant that operates in two modes: you can chat with it to ask, \"summarize project status\", but it also runs in the background, constantly monitoring new tickets that are created, or deployment pipelines that fail, automatically reassigning tasks. Or consider a DevOps agent that you can query conversationally (\"what's our current CPU usage?\") but also monitors your infrastructure continuously, detecting anomalies and starting remediation before you even know there's a problem.\n\n#### The Challenge: Real-Time Change Detection\n\nHere's where building ambient agents gets tricky. While chat-based agents work perfectly within the request-response paradigm, ambient agents need something entirely different: continuous monitoring and real-time change detection. How do you efficiently detect changes across multiple data sources? How do you avoid the performance nightmare of constant polling? How do you ensure your agent reacts instantly when something critical happens?\n\nDevelopers trying to build ambient agents hit the same wall: creating a reliable, scalable change detection system is hard. You either end up with:\n\n**Polling hell****:** Constantly querying databases, burning through resources, and still missing changes between polls\n\n**Legacy system rewrites****:** Massive expensive multi-year projects to re-write legacy systems so that they produce domain events\n\n**Webhook spaghetti****:** Managing dozens of event sources, each with different formats and reliability guarantees\n\nThis is where the story takes an interesting turn.\n\n#### Enter Drasi: The Change Detection Engine You Didn't Know You Needed\n\n[Drasi](https://drasi.io/) is not another AI framework. Instead, it solves the problem that ambient agents need solved: intelligent change detection. Think of it as the sensory system for your AI agents, the infrastructure that lets them perceive changes in the world.\n\nDrasi is built around three simple components:\n\n**Sources****:** Connectivity to the systems that Drasi can observe as sources of change (PostgreSQL, MySQL, Cosmos DB, Kubernetes, EventHub)\n\n**Continuous Queries****:** Graph-based queries (using Cypher/GQL) that monitor for specific change patterns\n\n**Reactions****:** What happens when a continuous query detects changes, or lack thereof\n\nBut here's the killer feature: Drasi doesn't just detect that something changed. It understands what changed and why it matters, and even if something should have changed but did not. Using continuous queries, you can define complex conditions that your agents care about, and Drasi handles all the plumbing to deliver those insights in real time.\n\n#### The Bridge: langchain-drasi Integration\n\nNow, detecting changes is only part of the challenge. You need to connect those changes to your AI agents in a way that makes sense. That's where [langchain-drasi](https://github.com/drasi-project/langchain-drasi) comes in, a purpose-built integration that bridges Drasi's change detection with LangChain's agent frameworks. It achieves this by leveraging the Drasi MCP Reaction, which exposes Drasi continuous queries as [MCP resources](https://modelcontextprotocol.io/specification/2025-06-18/server/resources).\n\nThe integration provides a simple **Tool******that agents can use to:\n\n**Discover******available queries automatically\n\n**Read******current query results on demand\n\n**Subscribe******to real-time updates that flow directly into agent memory and workflow\n\nHere's what this looks like in practice:\n\n| ```<br>from langchain_drasi import create_drasi_tool, MCPConnectionConfig# Configure connection to Drasi MCP servermcp_config = MCPConnectionConfig(server_url=\"http://localhost:8083\")# Create the tool with notification handlers drasi_tool = create_drasi_tool(     mcp_config=mcp_config,     notification_handlers=[buffer_handler, console_handler] )# Now your agent can discover and subscribe to data changes # No more polling, no more webhooks, just reactive intelligence <br>``` | | --- |\n\nThe beauty is in the notification handlers: pre-built components that determine how changes flow into your agent's consciousness:\n\n**BufferHandler**: Queues changes for sequential processing\n\n**LangGraphMemoryHandler**: Automatically integrates changes into agent checkpoints\n\n**LoggingHandler**: Integrates with standard logging infrastructure\n\nThis isn't just plumbing; it's the foundation for what we might call \"change-driven architecture\" for AI systems.\n\n#### Example: The Seeker Agent Has Entered the Chat\n\nLet's make this concrete with my favorite example from the langchain-drasi repository: a hide and seek inspired non-player character (NPC) AI agent that seeks human players in a multi-player game environment.\n\n##### The Scenario\n\nImagine a game where players move around a 2D map, updating their positions in a PostgreSQL database. But here's the twist: the NPC agent doesn't have omniscient vision. It can only detect players under specific conditions:\n\n**Stationary targets****:** When a player doesn't move for more than 3 seconds (they're exposed)\n\n**Frantic movement****:** When a player moves more than once in less than a second (panicking reveals your position)\n\nThis creates interesting strategic gameplay, players must balance staying still (safe from detection but vulnerable if found) with moving carefully (one move per second is the sweet spot). The NPC agent seeks based on these glimpses of player activity. These detection rules are defined as Drasi continuous queries that monitor the player positions table.\n\nFor reference, these are the two continuous queries we will use:\n\nWhen a player doesn't move for more than 3 seconds, this is a great example of detecting the absence of change use the [trueLater function](https://drasi.io/reference/query-language/drasi-custom-functions/#drasi-future-functions):\n\n``` MATCH     (p:player { type: 'human' }) WHERE drasi.trueLater(         drasi.changeDateTime(p) <= (datetime.realtime() - duration( { seconds: 3 } )),          drasi.changeDateTime(p) + duration( { seconds: 3 } )       ) RETURN     p.id,     p.x,     p.y ```\n\nWhen a player moves more than once in less than a second is an example of using the [previousValue function](https://drasi.io/reference/query-language/drasi-custom-functions/#drasi-delta-functions) to compare that current state with a prior state:\n\n``` MATCH     (p:player { type: 'human' }) WHERE drasi.changeDateTime(p).epochMillis - drasi.previousValue(drasi.changeDateTime(p).epochMillis) < 1000 RETURN     p.id,     p.x,     p.y ```\n\nHere's the neat part: you can dynamically adjust the game's difficulty by adding or removing queries with different conditions; no code changes required, just deploy new Drasi queries.\n\nThe traditional approach would have your agent constantly polling the data source checking these conditions: \"Any player moves? How about now? Now? Now?\"\n\n#### The Workflow in Action\n\nThe agent operates through a LangGraph based state machine with two distinct phases:\n\n1. **Setup Phase (First Run Only)**\n\n- **Setup queries prompt******- Prompts the AI model to discover available Drasi queries\n- **Setup queries call model** - AI model calls the Drasi tool with discover operation\n- **Setup queries tools** - Executes the Drasi tool calls to subscribe to relevant queries\n- This phase loops until the AI model has discovered and subscribed to all relevant queries\n\n2. **Main Seeking Loop (Continuous)**\n\n- **Check sensors** - Consumes any new Drasi notifications from the buffer into the workflow state\n- **Evaluate targets** - Uses AI model to parse sensor data and extract target positions\n- **Select and plan** - Selects closest target and plans path\n- **Execute move******- Executes the next move via game API\n- Loop continues indefinitely, reacting to new notifications\n\nNo polling. No delays. No wasted resources checking positions that don't meet the detection criteria. Just pure, reactive intelligence flowing from meaningful data changes to agent actions. The continuous queries act as intelligent filters, only alerting the agent when relevant changes occur.\n\n[Click here for the full implementation](https://github.com/drasi-project/langchain-drasi/tree/main/examples/hide_and_seek)\n\n#### The Bigger Picture: Change-Driven Architecture\n\nWhat we're seeing with Drasi and ambient agents isn't just a new tool, it's a new architectural pattern for AI systems. The core idea is profound: **AI agents can react to the world changing, not just wait to be asked about it.** This pattern enables entirely new categories of applications that complement traditional chat interfaces.\n\nThe example might seem playful, but it demonstrates that AI agents can perceive and react to their environment in real time. Today it's seeking players in a game. Tomorrow it could be:\n\n- Managing city traffic flows based on real-time sensor data\n- Coordinating disaster response as situations evolve\n- Optimizing supply chains as demand patterns shift\n- Protecting networks as threats emerge\n\nThe change detection infrastructure is here. The patterns are emerging. The only question is: what will you build?\n\n#### Where to Go from Here\n\nReady to dive deeper? Here are your next steps:\n\n**Explore Drasi****:** Head to [drasi.io](https://drasi.io/) and discover the power of the change detection platform\n\n**Try langchain-drasi****:** Clone the [GitHub repository](https://github.com/drasi-project/langchain-drasi) and run the Hide-and-Seek example yourself\n\n**Join the conversation****:** The space is new and needs diverse perspectives. Join the community on [Discord](https://discord.gg/AX7FneckBq). Let us know if you have built ambient agents and what challenges you faced with real-time change detection.\n\nPublished Dec 03, 2025\n\nVersion 1.0\n\n[monitoring](/tag/monitoring?nodeId=board%3ALinuxandOpenSourceBlog)\n\n[observability](/tag/observability?nodeId=board%3ALinuxandOpenSourceBlog)\n\n[!\\[CollinBrian&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/m_assets/avatars/default/avatar-5.svg?image-dimensions=50x50)](/users/collinbrian/1113044) [CollinBrian](/users/collinbrian/1113044) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined July 26, 2021\n\n[View Profile](/users/collinbrian/1113044)\n\n/category/azure/blog/linuxandopensourceblog [Linux and Open Source Blog](/category/azure/blog/linuxandopensourceblog) Follow this blog board to get notified when there's new activity",
  "Link": "https://techcommunity.microsoft.com/t5/linux-and-open-source-blog/beyond-the-chat-window-how-change-driven-architecture-enables/ba-p/4475026",
  "OutputDir": "_community",
  "Title": "Beyond the Chat Window: How Change-Driven Architecture Enables Ambient AI Agents",
  "Description": "AI agents are everywhere now. Powering chat interfaces, answering questions, helping with code. We've gotten remarkably good at this conversational paradigm. But while the world has been focused on chat experiences, something new is quietly emerging: ambient agents. These aren't replacements for chat, they're an entirely new category of AI system that operates in the background, sensing, processing, and responding to the world in real time. And here's the thing, this is a new frontier. The infrastructure we need to build these systems barely exists yet.\n\nOr at least, it didn't until now.\n\n#### Two Worlds: Conversational and Ambient\n\nLet me paint you a picture of the conversational AI paradigm we know well. You open a chat window. You type a question. You wait. The AI responds. Rinse and repeat. It's the digital equivalent of having a brilliant assistant sitting at a desk, ready to help when you tap them on the shoulder.\n\nNow imagine a completely different kind of assistant. One that watches for important changes, anticipates needs, and springs into action without being asked. That's the promise of ambient agents. AI systems that, as [LangChain puts it](https://blog.langchain.com/introducing-ambient-agents/): \"listen to an event stream and act on it accordingly, potentially acting on multiple events at a time.\"\n\nThis isn't an evolution of chat; it's a fundamentally different interaction paradigm. Both have their place. Chat is great for collaboration and back-and-forth reasoning. Ambient agents excel at continuous monitoring and autonomous response. Instead of human-initiated conversations, ambient agents operate through detecting changes in upstream systems and maintaining context across time without constant prompting.\n\nThe use cases are compelling and distinct from chat. Imagine a project management assistant that operates in two modes: you can chat with it to ask, \"summarize project status\", but it also runs in the background, constantly monitoring new tickets that are created, or deployment pipelines that fail, automatically reassigning tasks. Or consider a DevOps agent that you can query conversationally (\"what's our current CPU usage?\") but also monitors your infrastructure continuously, detecting anomalies and starting remediation before you even know there's a problem.\n\n#### The Challenge: Real-Time Change Detection\n\nHere's where building ambient agents gets tricky. While chat-based agents work perfectly within the request-response paradigm, ambient agents need something entirely different: continuous monitoring and real-time change detection. How do you efficiently detect changes across multiple data sources? How do you avoid the performance nightmare of constant polling? How do you ensure your agent reacts instantly when something critical happens?\n\nDevelopers trying to build ambient agents hit the same wall: creating a reliable, scalable change detection system is hard. You either end up with:\n\n**Polling hell****:** Constantly querying databases, burning through resources, and still missing changes between polls\n\n**Legacy system rewrites****:** Massive expensive multi-year projects to re-write legacy systems so that they produce domain events\n\n**Webhook spaghetti****:** Managing dozens of event sources, each with different formats and reliability guarantees\n\nThis is where the story takes an interesting turn.\n\n#### Enter Drasi: The Change Detection Engine You Didn't Know You Needed\n\n[Drasi](https://drasi.io/) is not another AI framework. Instead, it solves the problem that ambient agents need solved: intelligent change detection. Think of it as the sensory system for your AI agents, the infrastructure that lets them perceive changes in the world.\n\nDrasi is built around three simple components:\n\n**Sources****:** Connectivity to the systems that Drasi can observe as sources of change (PostgreSQL, MySQL, Cosmos DB, Kubernetes, EventHub)\n\n**Continuous Queries****:** Graph-based queries (using Cypher/GQL) that monitor for specific change patterns\n\n**Reactions****:** What happens when a continuous query detects changes, or lack thereof\n\nBut here's the killer feature: Drasi doesn't just detect that something changed. It understands what changed and why it matters, and even if something should have changed but did not. Using continuous queries, you can define complex conditions that your agents care about, and Drasi handles all the plumbing to deliver those insights in real time.\n\n#### The Bridge: langchain-drasi Integration\n\nNow, detecting changes is only part of the challenge. You need to connect those changes to your AI agents in a way that makes sense. That's where [langchain-drasi](https://github.com/drasi-project/langchain-drasi) comes in, a purpose-built integration that bridges Drasi's change detection with LangChain's agent frameworks. It achieves this by leveraging the Drasi MCP Reaction, which exposes Drasi continuous queries as [MCP resources](https://modelcontextprotocol.io/specification/2025-06-18/server/resources).\n\nThe integration provides a simple **Tool** **** that agents can use to:\n\n**Discover** **** available queries automatically\n\n**Read** **** current query results on demand\n\n**Subscribe** **** to real-time updates that flow directly into agent memory and workflow\n\nHere's what this looks like in practice:\n\n| ```<br>from langchain_drasi import create_drasi_tool, MCPConnectionConfig# Configure connection to Drasi MCP servermcp_config = MCPConnectionConfig(server_url=\"http://localhost:8083\")# Create the tool with notification handlers drasi_tool = create_drasi_tool( mcp_config=mcp_config, notification_handlers=[buffer_handler, console_handler] )# Now your agent can discover and subscribe to data changes # No more polling, no more webhooks, just reactive intelligence <br>``` | | --- |\n\nThe beauty is in the notification handlers: pre-built components that determine how changes flow into your agent's consciousness:\n\n**BufferHandler**: Queues changes for sequential processing\n\n**LangGraphMemoryHandler**: Automatically integrates changes into agent checkpoints\n\n**LoggingHandler**: Integrates with standard logging infrastructure\n\nThis isn't just plumbing; it's the foundation for what we might call \"change-driven architecture\" for AI systems.\n\n#### Example: The Seeker Agent Has Entered the Chat\n\nLet's make this concrete with my favorite example from the langchain-drasi repository: a hide and seek inspired non-player character (NPC) AI agent that seeks human players in a multi-player game environment.\n\n##### The Scenario\n\nImagine a game where players move around a 2D map, updating their positions in a PostgreSQL database. But here's the twist: the NPC agent doesn't have omniscient vision. It can only detect players under specific conditions:\n\n**Stationary targets****:** When a player doesn't move for more than 3 seconds (they're exposed)\n\n**Frantic movement****:** When a player moves more than once in less than a second (panicking reveals your position)\n\nThis creates interesting strategic gameplay, players must balance staying still (safe from detection but vulnerable if found) with moving carefully (one move per second is the sweet spot). The NPC agent seeks based on these glimpses of player activity. These detection rules are defined as Drasi continuous queries that monitor the player positions table.\n\nFor reference, these are the two continuous queries we will use:\n\nWhen a player doesn't move for more than 3 seconds, this is a great example of detecting the absence of change use the [trueLater function](https://drasi.io/reference/query-language/drasi-custom-functions/#drasi-future-functions):\n\n``` MATCH (p:player { type: 'human' }) WHERE drasi.trueLater( drasi.changeDateTime(p) datetime.realtime() - duration( { seconds: 3 } )), drasi.changeDateTime(p) + duration( { seconds: 3 } ) ) RETURN p.id, p.x, p.y ```\n\nWhen a player moves more than once in less than a second is an example of using the [previousValue function](https://drasi.io/reference/query-language/drasi-custom-functions/#drasi-delta-functions) to compare that current state with a prior state:\n\n``` MATCH (p:player { type: 'human' }) WHERE drasi.changeDateTime(p).epochMillis - drasi.previousValue(drasi.changeDateTime(p).epochMillis) 1000 RETURN p.id, p.x, p.y ```\n\nHere's the neat part: you can dynamically adjust the game's difficulty by adding or removing queries with different conditions; no code changes required, just deploy new Drasi queries.\n\nThe traditional approach would have your agent constantly polling the data source checking these conditions: \"Any player moves? How about now? Now? Now?\"\n\n#### The Workflow in Action\n\nThe agent operates through a LangGraph based state machine with two distinct phases:\n\n![]()\n\n1. **Setup Phase (First Run Only)**\n\n- **Setup queries prompt******- Prompts the AI model to discover available Drasi queries\n- **Setup queries call model** - AI model calls the Drasi tool with discover operation\n- **Setup queries tools** - Executes the Drasi tool calls to subscribe to relevant queries\n- This phase loops until the AI model has discovered and subscribed to all relevant queries\n\n2. **Main Seeking Loop (Continuous)**\n\n- **Check sensors** - Consumes any new Drasi notifications from the buffer into the workflow state\n- **Evaluate targets** - Uses AI model to parse sensor data and extract target positions\n- **Select and plan** - Selects closest target and plans path\n- **Execute move******- Executes the next move via game API\n- Loop continues indefinitely, reacting to new notifications\n\nNo polling. No delays. No wasted resources checking positions that don't meet the detection criteria. Just pure, reactive intelligence flowing from meaningful data changes to agent actions. The continuous queries act as intelligent filters, only alerting the agent when relevant changes occur.\n\n![]()\n\n[Click here for the full implementation](https://github.com/drasi-project/langchain-drasi/tree/main/examples/hide_and_seek)\n\n#### The Bigger Picture: Change-Driven Architecture\n\nWhat we're seeing with Drasi and ambient agents isn't just a new tool, it's a new architectural pattern for AI systems. The core idea is profound: **AI agents can react to the world changing, not just wait to be asked about it.** This pattern enables entirely new categories of applications that complement traditional chat interfaces.\n\nThe example might seem playful, but it demonstrates that AI agents can perceive and react to their environment in real time. Today it's seeking players in a game. Tomorrow it could be:\n\n- Managing city traffic flows based on real-time sensor data\n- Coordinating disaster response as situations evolve\n- Optimizing supply chains as demand patterns shift\n- Protecting networks as threats emerge\n\nThe change detection infrastructure is here. The patterns are emerging. The only question is: what will you build?\n\n#### Where to Go from Here\n\nReady to dive deeper? Here are your next steps:\n\n**Explore Drasi****:** Head to [drasi.io](https://drasi.io/) and discover the power of the change detection platform\n\n**Try langchain-drasi****:** Clone the [GitHub repository](https://github.com/drasi-project/langchain-drasi) and run the Hide-and-Seek example yourself\n\n**Join the conversation****:** The space is new and needs diverse perspectives. Join the community on [Discord](https://discord.gg/AX7FneckBq). Let us know if you have built ambient agents and what challenges you faced with real-time change detection.",
  "Author": "CollinBrian",
  "Tags": [],
  "ProcessedDate": "2025-12-04 00:10:53"
}
