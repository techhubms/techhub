{
  "FeedName": "Microsoft Tech Community",
  "Title": "Send signals from Micronaut applications to Azure Monitor through zero-code instrumentation",
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/send-signals-from-micronaut-applications-to-azure-monitor/ba-p/4443884",
  "Author": "Logico_jp",
  "EnhancedContent": "The original post (Japanese) was written on 13 August 2025.\n\n[Zero code instrumentationでMicronautアプリケーションからAzure Monitorにtraceやmetricを送信したい – Logico Inside](https://logico-jp.dev/2025/08/13/use-zero-code-instrumentation-to-send-traces-and-metrics-from-a-micronaut-application-to-azure-monitor/)\n\nThis entry is a series posts below. Please take a look for background information.\n\n[Send signals from Micronaut native image applications to Azure Monitor | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/appsonazureblog/send-signals-from-micronaut-native-image-applications-to-azure-monitor/4443735)\n\nReceived another question from the customer.\n\n> >\n> *I understand that I can get metrics and traces, but is it possible to send them to Azure Monitor (Application Insights) without using code?*\n> >\n\nIf you are not familiar with zero-code instrumentation, please check the following URL.\n\n[Zero-code | OpenTelemetry](https://opentelemetry.io/docs/concepts/instrumentation/zero-code/)\n\nThe customer wondered if the dependencies would take care of everything else when they only specified the dependencies and destinations. To confirm this (and to provide a sample), we have prepared the following environment. As I wrote in the previous post, logs are dealt with in a different way depending on how they are used (IaaS, PaaS, etc.), so they are not included in this example.\n\nThis example is a REST API application that can be used to find, add, change, and delete movie information. It uses PostgreSQL as a data store and sends information about how the system is performing to Azure Monitor, specifically Application Insights. You can find the code below.\n\n[GitHub - anishi1222/micronaut-telemetry-movie: Zero code instrumentation (Azure Monitor, GraalVM Native Image, and Micronaut)](https://github.com/anishi1222/micronaut-telemetry-movie)\n\n### Prerequisites\n\n- Maven: 3.9.10\n- JDK: 21\n- Micronaut: 4.9.0 or later\n\nAnd we need to provision an instance of Azure Monitor (application insights) and PostgreSQL Flexible Server.\n\n### Create an Archetype\n\nWe can create an archetype using Micronaut’s CLI (`mn` ) or Micronaut Launch.\n\n[Micronaut Launch](https://micronaut.io/launch/)\n\nIn this entry, use `application.yml` instead of `application.properties` for application configuration. So, we need to specify the feature “yaml” so that we can include dependencies for using yaml.\n\nThe following features are needed when creating an archetype for this app.\n\n- graalvm\n- management\n- micrometer-azure-monitor\n- azure-tracing\n- yaml\n- validation\n- postgres\n- jdbc-hikari\n- data-jpa\n\n### Dependencies\n\nThe basics of sending traces and metrics are as described in the previous two entries. In this post, we want to obtain traces for HTTP and JDBC connections, so we will add the following two dependencies.\n\n``` <dependency> <groupid>io.micronaut.tracing</groupid> <artifactid>micronaut-tracing-opentelemetry-http</artifactid> </dependency> <dependency> <groupid>io.micronaut.tracing</groupid> <artifactid>micronaut-tracing-opentelemetry-jdbc</artifactid> </dependency> ```\n\nAdditionally, we need to add this dependency to use the GraalVM Reachability Metadata Repository. The latest version is 0.11.0 as of 13 August, 2025.\n\n``` <dependency> <groupid>org.graalvm.buildtools</groupid> <artifactid>graalvm-reachability-metadata</artifactid> <version>0.11.0</version> </dependency> ```\n\nAdd the GraalVM Maven plugin and enable the use of GraalVM Reachability Metadata obtained from the above dependency. This plugin lets us set optimization levels using `buildArg` (in this example, the optimisation level is specified). We can also add it to `native-image.properties` , the `native-image` tool (and the Maven/Gradle plugin) will read it.\n\n``` <plugin> <groupid>org.graalvm.buildtools</groupid> <artifactid>native-maven-plugin</artifactid> <configuration> <metadatarepository> <enabled>true</enabled> </metadatarepository> <buildargs combine.children=\"append\"> <buildarg>-Ob</buildarg> </buildargs> <quickbuild>true</quickbuild> </configuration> </plugin> ```\n\n### Application configuration\n\nThis app connects to a database and Azure Monitor, so we need the following information.\n\n- Database where the app connects.\n- Azure Monitor related information.\n\n#### 1) Database\n\nWe specify data source information in `application.yml` .\n\n#### 2) Azure Monitor\n\nSet the connection string for Application Insights. Because of dependency issues, it is necessary to set different locations for Metric and Trace, which is a bit inconvenient. However, it is recommended to pass it via environment variables to make it as common as possible.\n\nHere is the sample of `application.yml` .\n\n``` micronaut: application: name: micronaut-telemetry-movie metrics: enabled: true binders: files: enabled: true jdbc: enabled: true jvm: enabled: true logback: enabled: true processor: enabled: true uptime: enabled: true web: enabled: true export: azuremonitor: enabled: true step: PT1M connectionString: ${AZURE_MONITOR_CONNECTION_STRING}\n\ndatasources: default: driver-class-name: org.postgresql.Driver db-type: postgres url: ${JDBC_URL} username: ${JDBC_USERNAME} password: ${JDBC_PASSWORD} dialect: POSTGRES schema-generate: CREATE_DROP hikari: connection-test-query: SELECT 1 connection-init-sql: SELECT 1 connection-timeout: 10000 idle-timeout: 30000 auto-commit: true leak-detection-threshold: 2000 maximum-pool-size: 10 max-lifetime: 60000 transaction-isolation: TRANSACTION_READ_COMMITTED\n\nazure: tracing: connection-string: ${AZURE_MONITOR_CONNECTION_STRING}\n\notel: exclusions: /health, /info, /metrics, /actuator/health, /actuator/info, /actuator/metrics ```\n\nFor now, let’s build it as a Java application.\n\n### Test as a Java application\n\nMake sure the application is running smoothly, that traces are being sent to Application Insights, and that metrics are being output. Now, run the application using the Tracing Agent and create the necessary configuration files.\n\n```\n# (1) Collect configuration files such as reflect-config.json\n$JAVA_HOME/bin/java \\ -agentlib:native-image-agent=config-output-dir=src/main/resources/META-INF/{groupId}/{artifactId}/ \\ -jar ./target/{artifactId}-{version}.jar\n# (2)-a Generate a trace file\n$JAVA_HOME/bin/java \\ -agentlib:native-image-agent=trace-output=/path/to/trace-file.json \\ -jar ./target/{artifactId}-{version}.jar\n# (2)-b Generate a reachability metadata file from the collected trace file\nnative-image-configure generate \\ --trace-input=/path/to/trace-file.json \\ --output-dir=/path/to/config-dir/ ```\n\n[Configure Native Image with the Tracing Agent](https://www.graalvm.org/latest/reference-manual/native-image/guides/configure-with-tracing-agent/)\n\n[Collect Metadata with the Tracing Agent](https://www.graalvm.org/latest/reference-manual/native-image/metadata/AutomaticMetadataCollection/)\n\nMake the following files in the specified folder.\n\n- `jni-config.json`\n- `reflect-config.json`\n- `proxy-config.json`\n- `resource-config.json`\n- `reachability-metadata.json`\n\nThese files can be located at `src/main/resources/META-INF/native-image` . The `native-image` tool picks up configuration files located in the directory `src/main/resources/META-INF/native-image` . However, it is recommended that we place the files in subdirectories divided by `groupId` and `artifactId` , as shown below.\n\n> > >\n> ```\n> src/main/resources/META-INF/native-image/{groupId}/{artifactId}\n> ```\n>\n\n### native-image.properties\n\nWhen creating a native image, we call the following command.\n\n``` mvn package -Dpackaging=native-image ```\n\nWe should specify the timing of class initialization (build time or runtime), the command line options for the `native-image` tool (the same command line options work in Maven/Gradle plugin), and the JVM arguments in the `native-image.properties` file. Indeed, these settings can be specified in `pom.xml` , but it is recommended that they be externalized.\n\nThis is also explained in the metric entry, so some details will be left out. If needed, please check the metric entry.\n\n[Send metrics from Micronaut native image applications to Azure Monitor | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/appsonazureblog/send-metrics-from-micronaut-native-image-applications-to-azure-monitor/4443763)\n\n### Build a Native Image application\n\nBuilding a native image application takes a long time (though it has got quicker over time). If building it for testing purpose, we strongly recommend enabling Quick Build and setting the optimization level to `-Ob` option (although this will still take time). See below for more information.\n\n[Maven plugin for GraalVM Native Image](https://graalvm.github.io/native-build-tools/latest/maven-plugin.html#native-image-options) [Gradle plugin for GraalVM Native Image](https://graalvm.github.io/native-build-tools/latest/gradle-plugin.html#native-image-options)\n\n[Optimizations and Performance](https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/#optimization-levels)\n\n### Test as a native image application\n\nLet’s check if the application works. At first, we have to populate initial data with the following command. This command adds 3 records.\n\n``` curl -X PUT https://<container apps=\"\" url=\"\">/api/movies</container> ```\n\n``` { \"message\":\"Database initialized with default movies.\" } ```\n\nNow let’s verify if three records exist.\n\n``` curl https://<container apps=\"\" url=\"\">/api/movies</container> ```\n\n``` [ { \"id\": 1, \"title\": \"Inception\", \"releaseYear\": 2010, \"directors\": \"Christopher Nolan\", \"actors\": \"Leonardo DiCaprio, Joseph Gordon-Levitt, Elliot Page\" }, { \"id\": 2, \"title\": \"The Shawshank Redemption\", \"releaseYear\": 1994, \"directors\": \"Frank Darabont\", \"actors\": \"Tim Robbins, Morgan Freeman, Bob Gunton\" }, { \"id\": 3, \"title\": \"The Godfather\", \"releaseYear\": 1972, \"directors\": \"Francis Ford Coppola\", \"actors\": \"Marlon Brando, Al Pacino, James Caan\" } ] ```\n\n#### (1) Azure Monitor (Application Insights)\n\nWe should see the images like this.\n\n#### (2) Metrics\n\nWe can see which metrics we can check with the API call GET /metrics.\n\n``` { \"names\": [ \"executor\", \"executor.active\", \"executor.completed\", \"executor.pool.core\", \"executor.pool.max\", \"executor.pool.size\", \"executor.queue.remaining\", \"executor.queued\", \"hikaricp.connections\", \"hikaricp.connections.acquire\", \"hikaricp.connections.active\", \"hikaricp.connections.creation\", \"hikaricp.connections.idle\", \"hikaricp.connections.max\", \"hikaricp.connections.min\", \"hikaricp.connections.pending\", \"hikaricp.connections.timeout\", \"hikaricp.connections.usage\", \"http.server.requests\", \"jvm.classes.loaded\", \"jvm.classes.unloaded\", \"jvm.memory.committed\", \"jvm.memory.max\", \"jvm.memory.used\", \"jvm.threads.daemon\", \"jvm.threads.live\", \"jvm.threads.peak\", \"jvm.threads.started\", \"jvm.threads.states\", \"logback.events\", \"process.cpu.time\", \"process.cpu.usage\", \"process.files.max\", \"process.files.open\", \"process.start.time\", \"process.uptime\", \"system.cpu.count\", \"system.cpu.usage\", \"system.load.average.1m\" ] } ```\n\nBut because this is a native image application, we can’t get the right information about the JVM. For example, if we invoke the API with GET /metrics/jvm.memory.max, we will see the following. What does -2 mean?\n\n``` { \"name\": \"jvm.memory.max\", \"measurements\": [ { \"statistic\": \"VALUE\", \"value\": -2.0 } ], \"availableTags\": [ { \"tag\": \"area\", \"values\": [ \"nonheap\" ] }, { \"tag\": \"id\", \"values\": [ \"runtime code cache (native metadata)\", \"runtime code cache (code and data)\" ] } ], \"description\": \"The maximum amount of memory in bytes that can be used for memory management\", \"baseUnit\": \"bytes\" } ```\n\nTo find out how much the CPU is being used, run GET /metrics/process.cpu.usage, and we’ll get this result.\n\n``` { \"name\": \"process.cpu.usage\", \"measurements\": [ { \"statistic\": \"VALUE\", \"value\": 0.0017692156477295067 } ], \"description\": \"The \\\"recent cpu usage\\\" for the Java Virtual Machine process\" } ```\n\n### To add logs to Azure Monitor “traces” table...\n\nSome of you might want to use the information in the following entry with zero-code instrumentation, but currently you cannot.\n\n[Send logs from Micronaut native image applications to Azure Monitor | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/appsonazureblog/send-logs-from-micronaut-native-image-applications-to-azure-monitor/4443867)\n\nThis is because we cannot get the `OpenTelemetry` object needed to write to the Application Insights `traces` table. Therefore, it must be explicitly declared. The following example clearly states and sets up `Appender` in the `MovieController` constructor. The way `Appender` is set up is not included here, as it was explained before.\n\n``` @Inject AzureTracingConfigurationProperties azureTracingConfigurationProperties;\n\nprivate static final Logger logger = LoggerFactory.getLogger(MovieController.class);\n\npublic MovieController(AzureTracingConfigurationProperties azureTracingConfigurationProperties) { this.azureTracingConfigurationProperties = azureTracingConfigurationProperties; AutoConfiguredOpenTelemetrySdkBuilder sdkBuilder = AutoConfiguredOpenTelemetrySdk.builder(); AzureMonitorAutoConfigure.customize(sdkBuilder, azureTracingConfigurationProperties.getConnectionString()); OpenTelemetryAppender.install(sdkBuilder.build().getOpenTelemetrySdk()); logger.info(\"OpenTelemetry configured for MovieController.\"); } ```\n\nAlthough explicit declaration is required, logs will be recorded in Traces as long as this setting is enabled.\n\nUpdated Aug 15, 2025\n\nVersion 2.0\n\n[azure container apps](/tag/azure%20container%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[java](/tag/java?nodeId=board%3AAppsonAzureBlog)\n\n[web apps](/tag/web%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[Logico_jp&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0yOTkyMzctNTQ3ODkyaTBFMzYwMUVGM0FBQkZBN0Y?image-dimensions=50x50)](/users/logico_jp/299237) [Logico_jp](/users/logico_jp/299237) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined March 12, 2019\n\n[View Profile](/users/logico_jp/299237)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "OutputDir": "_community",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Description": "The original post (Japanese) was written on 13 August 2025.\n\n[Zero code instrumentationでMicronautアプリケーションからAzure Monitorにtraceやmetricを送信したい – Logico Inside](https://logico-jp.dev/2025/08/13/use-zero-code-instrumentation-to-send-traces-and-metrics-from-a-micronaut-application-to-azure-monitor/)\n\nThis entry is a series posts below. Please take a look for background information.\n\n[Send signals from Micronaut native image applications to Azure Monitor | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/appsonazureblog/send-signals-from-micronaut-native-image-applications-to-azure-monitor/4443735)\n\nReceived another question from the customer.\n\n> >\n> *I understand that I can get metrics and traces, but is it possible to send them to Azure Monitor (Application Insights) without using code?*\n> >\n\nIf you are not familiar with zero-code instrumentation, please check the following URL.\n\n[Zero-code | OpenTelemetry](https://opentelemetry.io/docs/concepts/instrumentation/zero-code/)\n\nThe customer wondered if the dependencies would take care of everything else when they only specified the dependencies and destinations. To confirm this (and to provide a sample), we have prepared the following environment. As I wrote in the previous post, logs are dealt with in a different way depending on how they are used (IaaS, PaaS, etc.), so they are not included in this example.\n\n![]()\n\nThis example is a REST API application that can be used to find, add, change, and delete movie information. It uses PostgreSQL as a data store and sends information about how the system is performing to Azure Monitor, specifically Application Insights. You can find the code below.\n\n[GitHub - anishi1222/micronaut-telemetry-movie: Zero code instrumentation (Azure Monitor, GraalVM Native Image, and Micronaut)](https://github.com/anishi1222/micronaut-telemetry-movie)\n\n### Prerequisites\n\n- Maven: 3.9.10\n- JDK: 21\n- Micronaut: 4.9.0 or later\n\nAnd we need to provision an instance of Azure Monitor (application insights) and PostgreSQL Flexible Server.\n\n### Create an Archetype\n\nWe can create an archetype using Micronaut’s CLI (`mn` ) or Micronaut Launch.\n\n[Micronaut Launch](https://micronaut.io/launch/)\n\nIn this entry, use `application.yml` instead of `application.properties` for application configuration. So, we need to specify the feature “yaml” so that we can include dependencies for using yaml.\n\nThe following features are needed when creating an archetype for this app.\n\n- graalvm\n- management\n- micrometer-azure-monitor\n- azure-tracing\n- yaml\n- validation\n- postgres\n- jdbc-hikari\n- data-jpa\n\n### Dependencies\n\nThe basics of sending traces and metrics are as described in the previous two entries. In this post, we want to obtain traces for HTTP and JDBC connections, so we will add the following two dependencies.\n\n- io.micronaut.tracing\nmicronaut-tracing-opentelemetry-http io.micronaut.tracing micronaut-tracing-opentelemetry-jdbc\n\nAdditionally, we need to add this dependency to use the GraalVM Reachability Metadata Repository. The latest version is 0.11.0 as of 13 August, 2025.\n- org.graalvm.buildtools\ngraalvm-reachability-metadata 0.11.0\n\nAdd the GraalVM Maven plugin and enable the use of GraalVM Reachability Metadata obtained from the above dependency. This plugin lets us set optimization levels using `buildArg` (in this example, the optimisation level is specified). We can also add it to `native-image.properties` , the `native-image` tool (and the Maven/Gradle plugin) will read it.\n- org.graalvm.buildtools\nnative-maven-plugin\n\ntrue\n\n-Ob\n\ntrue\n\n### Application configuration\n\nThis app connects to a database and Azure Monitor, so we need the following information.\n\n- Database where the app connects.\n- Azure Monitor related information.\n\n#### 1) Database\n\nWe specify data source information in `application.yml` .\n\n#### 2) Azure Monitor\n\nSet the connection string for Application Insights. Because of dependency issues, it is necessary to set different locations for Metric and Trace, which is a bit inconvenient. However, it is recommended to pass it via environment variables to make it as common as possible.\n\nHere is the sample of `application.yml` .\n- micronaut:\napplication: name: micronaut-telemetry-movie metrics: enabled: true binders: files: enabled: true jdbc: enabled: true jvm: enabled: true logback: enabled: true processor: enabled: true uptime: enabled: true web: enabled: true export: azuremonitor: enabled: true step: PT1M connectionString: ${AZURE\\_MONITOR\\_CONNECTION\\_STRING}\n\ndatasources: default: driver-class-name: org.postgresql.Driver db-type: postgres url: ${JDBC\\_URL} username: ${JDBC\\_USERNAME} password: ${JDBC\\_PASSWORD} dialect: POSTGRES schema-generate: CREATE\\_DROP hikari: connection-test-query: SELECT 1 connection-init-sql: SELECT 1 connection-timeout: 10000 idle-timeout: 30000 auto-commit: true leak-detection-threshold: 2000 maximum-pool-size: 10 max-lifetime: 60000 transaction-isolation: TRANSACTION\\_READ\\_COMMITTED\n\nazure: tracing: connection-string: ${AZURE\\_MONITOR\\_CONNECTION\\_STRING}\n\notel: exclusions: /health, /info, /metrics, /actuator/health, /actuator/info, /actuator/metrics\n\nFor now, let’s build it as a Java application.\n\n### Test as a Java application\n\nMake sure the application is running smoothly, that traces are being sent to Application Insights, and that metrics are being output. Now, run the application using the Tracing Agent and create the necessary configuration files.\n- # (1) Collect configuration files such as reflect-config.json\n$JAVA\\_HOME/bin/java \\ -agentlib:native-image-agent=config-output-dir=src/main/resources/META-INF/{groupId}/{artifactId}/ \\ -jar ./target/{artifactId}-{version}.jar\n# (2)-a Generate a trace file\n$JAVA\\_HOME/bin/java \\ -agentlib:native-image-agent=trace-output=/path/to/trace-file.json \\ -jar ./target/{artifactId}-{version}.jar\n# (2)-b Generate a reachability metadata file from the collected trace file\nnative-image-configure generate \\ --trace-input=/path/to/trace-file.json \\ --output-dir=/path/to/config-dir/\n\n[Configure Native Image with the Tracing Agent](https://www.graalvm.org/latest/reference-manual/native-image/guides/configure-with-tracing-agent/)\n\n[Collect Metadata with the Tracing Agent](https://www.graalvm.org/latest/reference-manual/native-image/metadata/AutomaticMetadataCollection/)\n\nMake the following files in the specified folder.\n\n- `jni-config.json`\n- `reflect-config.json`\n- `proxy-config.json`\n- `resource-config.json`\n- `reachability-metadata.json`\n\nThese files can be located at `src/main/resources/META-INF/native-image` . The `native-image` tool picks up configuration files located in the directory `src/main/resources/META-INF/native-image` . However, it is recommended that we place the files in subdirectories divided by `groupId` and `artifactId` , as shown below.\n\n> > >\n> ```\n> src/main/resources/META-INF/native-image/{groupId}/{artifactId}\n> ```\n>\n\n### native-image.properties\n\nWhen creating a native image, we call the following command.\n- mvn package -Dpackaging=native-image\n\nWe should specify the timing of class initialization (build time or runtime), the command line options for the `native-image` tool (the same command line options work in Maven/Gradle plugin), and the JVM arguments in the `native-image.properties` file. Indeed, these settings can be specified in `pom.xml` , but it is recommended that they be externalized.\n\nThis is also explained in the metric entry, so some details will be left out. If needed, please check the metric entry.\n\n[Send metrics from Micronaut native image applications to Azure Monitor | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/appsonazureblog/send-metrics-from-micronaut-native-image-applications-to-azure-monitor/4443763)\n\n### Build a Native Image application\n\nBuilding a native image application takes a long time (though it has got quicker over time). If building it for testing purpose, we strongly recommend enabling Quick Build and setting the optimization level to `-Ob` option (although this will still take time). See below for more information.\n\n[Maven plugin for GraalVM Native Image](https://graalvm.github.io/native-build-tools/latest/maven-plugin.html#native-image-options) [Gradle plugin for GraalVM Native Image](https://graalvm.github.io/native-build-tools/latest/gradle-plugin.html#native-image-options)\n\n[Optimizations and Performance](https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/#optimization-levels)\n\n### Test as a native image application\n\nLet’s check if the application works. At first, we have to populate initial data with the following command. This command adds 3 records.\n- curl -X PUT https:///api/movies\n- {\n\"message\":\"Database initialized with default movies.\" }\n\nNow let’s verify if three records exist.\n- curl https:///api/movies\n- [\n{ \"id\": 1, \"title\": \"Inception\", \"releaseYear\": 2010, \"directors\": \"Christopher Nolan\", \"actors\": \"Leonardo DiCaprio, Joseph Gordon-Levitt, Elliot Page\" }, { \"id\": 2, \"title\": \"The Shawshank Redemption\", \"releaseYear\": 1994, \"directors\": \"Frank Darabont\", \"actors\": \"Tim Robbins, Morgan Freeman, Bob Gunton\" }, { \"id\": 3, \"title\": \"The Godfather\", \"releaseYear\": 1972, \"directors\": \"Francis Ford Coppola\", \"actors\": \"Marlon Brando, Al Pacino, James Caan\" } ]\n\n#### (1) Azure Monitor (Application Insights)\n\nWe should see the images like this.\n\n![]()\n\n![]()![]()![]()\n\n#### (2) Metrics\n\nWe can see which metrics we can check with the API call GET /metrics.\n- {\n\"names\": [ \"executor\", \"executor.active\", \"executor.completed\", \"executor.pool.core\", \"executor.pool.max\", \"executor.pool.size\", \"executor.queue.remaining\", \"executor.queued\", \"hikaricp.connections\", \"hikaricp.connections.acquire\", \"hikaricp.connections.active\", \"hikaricp.connections.creation\", \"hikaricp.connections.idle\", \"hikaricp.connections.max\", \"hikaricp.connections.min\", \"hikaricp.connections.pending\", \"hikaricp.connections.timeout\", \"hikaricp.connections.usage\", \"http.server.requests\", \"jvm.classes.loaded\", \"jvm.classes.unloaded\", \"jvm.memory.committed\", \"jvm.memory.max\", \"jvm.memory.used\", \"jvm.threads.daemon\", \"jvm.threads.live\", \"jvm.threads.peak\", \"jvm.threads.started\", \"jvm.threads.states\", \"logback.events\", \"process.cpu.time\", \"process.cpu.usage\", \"process.files.max\", \"process.files.open\", \"process.start.time\", \"process.uptime\", \"system.cpu.count\", \"system.cpu.usage\", \"system.load.average.1m\" ] }\n\nBut because this is a native image application, we can’t get the right information about the JVM. For example, if we invoke the API with GET /metrics/jvm.memory.max, we will see the following. What does -2 mean?\n- {\n\"name\": \"jvm.memory.max\", \"measurements\": [ { \"statistic\": \"VALUE\", \"value\": -2.0 } ], \"availableTags\": [ { \"tag\": \"area\", \"values\": [ \"nonheap\" ] }, { \"tag\": \"id\", \"values\": [ \"runtime code cache (native metadata)\", \"runtime code cache (code and data)\" ] } ], \"description\": \"The maximum amount of memory in bytes that can be used for memory management\", \"baseUnit\": \"bytes\" }\n\nTo find out how much the CPU is being used, run GET /metrics/process.cpu.usage, and we’ll get this result.\n- {\n\"name\": \"process.cpu.usage\", \"measurements\": [ { \"statistic\": \"VALUE\", \"value\": 0.0017692156477295067 } ], \"description\": \"The \\\"recent cpu usage\\\" for the Java Virtual Machine process\" }\n\n### To add logs to Azure Monitor “traces” table...\n\nSome of you might want to use the information in the following entry with zero-code instrumentation, but currently you cannot.\n\n[Send logs from Micronaut native image applications to Azure Monitor | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/appsonazureblog/send-logs-from-micronaut-native-image-applications-to-azure-monitor/4443867)\n\nThis is because we cannot get the `OpenTelemetry` object needed to write to the Application Insights `traces` table. Therefore, it must be explicitly declared. The following example clearly states and sets up `Appender` in the `MovieController` constructor. The way `Appender` is set up is not included here, as it was explained before.\n- @Inject\nAzureTracingConfigurationProperties azureTracingConfigurationProperties;\n\nprivate static final Logger logger = LoggerFactory.getLogger(MovieController.class);\n\npublic MovieController(AzureTracingConfigurationProperties azureTracingConfigurationProperties) { this.azureTracingConfigurationProperties = azureTracingConfigurationProperties; AutoConfiguredOpenTelemetrySdkBuilder sdkBuilder = AutoConfiguredOpenTelemetrySdk.builder(); AzureMonitorAutoConfigure.customize(sdkBuilder, azureTracingConfigurationProperties.getConnectionString()); OpenTelemetryAppender.install(sdkBuilder.build().getOpenTelemetrySdk()); logger.info(\"OpenTelemetry configured for MovieController.\"); }\n\nAlthough explicit declaration is required, logs will be recorded in Traces as long as this setting is enabled.\n\n![]()",
  "ProcessedDate": "2025-08-15 05:09:31",
  "Tags": [],
  "PubDate": "2025-08-15T04:55:03+00:00",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Community"
}
