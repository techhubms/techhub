{
  "Author": "Chameseddine",
  "OutputDir": "_community",
  "EnhancedContent": "Hello community,\n\nI recently faced a tricky data engineering challenge involving a lot of Parquet files (about 2 million records) that needed to be ingested, transformed, and split into different entities.\n\nThe hard part wasn't the volume, but the logic. We needed to generate globally unique, sequential IDs for specific columns while keeping the execution time under two hours.\n\nWe were restricted to using only Azure Functions, ADF, and Storage. This created a conflict: we needed parallel processing to meet the time limit, but parallel processing usually breaks sequential ID generation due to race conditions on the counters.\n\nI documented the three architecture patterns we tested to solve this:\n\n1. Sequential processing with ADF (Safe, but failed the 2-hour time limit).\n2. Parallel processing with external locking/e-tags on Table Storage (Too complex and we still hit issues with inserts).\n3. A \"Fan-Out/Fan-In\" pattern using Azure Durable Functions and Durable Entities.\n\nWe ended up going with Durable Entities. Since they act as stateful actors, they allowed us to handle the ID counter state sequentially in memory while the heavy lifting (transformation) ran in parallel. It solved the race condition issue without killing performance.\n\nI wrote a detailed breakdown of the logic and trade-offs here if anyone is interested in the implementation details:\n\nhttps://medium.com/@yahiachames/data-ingestion-pipeline-a-data-engineers-dilemma-and-azure-solutions-7c4b36f11351\n\nI am curious if others have used Durable Entities for this kind of ETL work, or if you usually rely on an external database sequence to handle ID generation in serverless setups?\n\nThanks, Chameseddine",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "PubDate": "2025-12-13T12:22:51+00:00",
  "ProcessedDate": "2025-12-15 15:07:39",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "FeedName": "Microsoft Tech Community",
  "Description": "Hello community,\n\nI recently faced a tricky data engineering challenge involving a lot of Parquet files (about 2 million records) that needed to be ingested, transformed, and split into different entities.\n\nThe hard part wasn't the volume, but the logic. We needed to generate globally unique, sequential IDs for specific columns while keeping the execution time under two hours.\n\nWe were restricted to using only Azure Functions, ADF, and Storage. This created a conflict: we needed parallel processing to meet the time limit, but parallel processing usually breaks sequential ID generation due to race conditions on the counters.\n\nI documented the three architecture patterns we tested to solve this:\n\n1. Sequential processing with ADF (Safe, but failed the 2-hour time limit).\n2. Parallel processing with external locking/e-tags on Table Storage (Too complex and we still hit issues with inserts).\n3. A \"Fan-Out/Fan-In\" pattern using Azure Durable Functions and Durable Entities.\n\nWe ended up going with Durable Entities. Since they act as stateful actors, they allowed us to handle the ID counter state sequentially in memory while the heavy lifting (transformation) ran in parallel. It solved the race condition issue without killing performance.\n\nI wrote a detailed breakdown of the logic and trade-offs here if anyone is interested in the implementation details:\n\n[Data Ingestion Pipeline: A Data Engineerâ€™s Dilemma and Azure Solutions](https://medium.com/@yahiachames/data-ingestion-pipeline-a-data-engineers-dilemma-and-azure-solutions-7c4b36f11351)\n\nI am curious if others have used Durable Entities for this kind of ETL work, or if you usually rely on an external database sequence to handle ID generation in serverless setups?\n\nThanks, Chameseddine",
  "Link": "https://techcommunity.microsoft.com/t5/azure-architecture/design-pattern-handling-race-conditions-and-state-in-serverless/m-p/4477664#M820",
  "Tags": [],
  "Title": "[Design Pattern] Handling race conditions and state in serverless data pipelines"
}
