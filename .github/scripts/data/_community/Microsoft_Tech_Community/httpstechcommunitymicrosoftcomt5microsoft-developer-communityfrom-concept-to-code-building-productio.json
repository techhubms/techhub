{
  "Author": "kinfey",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Link": "https://techcommunity.microsoft.com/t5/microsoft-developer-community/from-concept-to-code-building-production-ready-multi-agent/ba-p/4472752",
  "Tags": [],
  "ProcessedDate": "2025-11-25 08:05:23",
  "OutputDir": "_community",
  "Title": "From Concept to Code: Building Production-Ready Multi-Agent Systems with Microsoft Foundry",
  "FeedName": "Microsoft Tech Community",
  "EnhancedContent": "We have reached a critical inflection point in AI development. Within the Microsoft Foundry ecosystem, the core value proposition of \"Agents\" is shifting decisively—moving from passive **content generation** to active **task execution** and **process automation**.\n\nThese are no longer just conversational interfaces. They are intelligent entities capable of connecting models, data, and tools to actively execute complex business logic.\n\nTo support this evolution, Microsoft has introduced a powerful suite of capabilities: the **Microsoft Agent Framework** for sophisticated orchestration, the **Agent V2 SDK**, and integrated **Microsoft Foundry VSCode Extensions**. These innovations provide the tooling necessary to bridge the gap between theoretical research and secure, scalable enterprise landing.\n\nBut how do you turn these separate components into a cohesive business solution? That is the challenge we address today. This post dives into the practical application of these tools, demonstrating how to connect the dots and transform complex multi-agent concepts into deployed reality.\n\n## The Scenario: Recruitment through an \"Agentic Lens\"\n\nLet’s ground this theoretical discussion with a real-world scenario that perfectly models a multi-agent environment: **The Recruitment Process.**\n\nBy examining recruitment through an agentic lens, we can identify distinct entities with specific mandates:\n\n- **The Recruiter Agent:** Tasked with setting boundary conditions (job requirements) and preparing data retrieval mechanisms (interview questions).\n- **The Applicant Agent:** Objective is to process incoming queries and synthesize the best possible output to meet the recruiter's acceptance criteria.\n\n## **Phase 1: Design**\n\n### **Achieving Orchestration via Microsoft Foundry Workflows**\n\nTo bridge the gap between our scenario and technical reality, we start with **Foundry Workflows**.\n\nWorkflows serves as the visual integration environment within Foundry. It allows you to build declarative pipelines that seamlessly combine deterministic business logic with the probabilistic nature of autonomous AI agents.\n\nBy adopting this visual, low-code paradigm, you eliminate the need to write complex orchestration logic from scratch. Workflows empowers you to coordinate specialized agents intuitively, creating adaptive systems that solve complex business problems collaboratively.\n\n### **Visually Orchestrating the Cycle**\n\nMicrosoft Foundry provides an intuitive, web-based **drag-and-drop interface**. This canvas allows you to integrate specialized AI agents alongside standard procedural logic blocks, transforming abstract ideas into executable processes without writing extensive glue code.\n\nTo translate our recruitment scenario into a functional workflow, we follow a structured approach:\n\n1. **Agent Prerequisites:** We pre-configure our specialized agents within Foundry. We create a *Recruiter Agent* (prompted to generate evaluation criteria) and an *Applicant Agent* (prompted to synthesize responses).\n2. **Orchestrating the Interaction:** We drag these nodes onto the board and define the data flow. The process begins with the Recruiter generating questions, piping that output directly as input for the Applicant agent.\n3. **Adding Business Logic:** A true workflow requires decision-making. We introduce control flow logic, such as **IF/ELSE conditional blocks**, to evaluate the recruiter's questions based on predefined criteria. This allows the workflow to branch dynamically—if satisfied, the candidate answers the questions; if not, the questions are regenerated.\n\n### **Alternative: YAML Configuration**\n\nFor developers who prefer a code-first approach or wish to rapidly replicate this logic across environments, Foundry allows you to export the underlying YAML.\n\n``` kind: workflow trigger: kind: OnConversationStart id: trigger_wf actions:\n- kind: SetVariable\nid: action-1763742724000 variable: Local.LatestMessage value: =UserMessage(System.LastMessageText)\n- kind: InvokeAzureAgent\nid: action-1763736666888 agent: name: HiringManager input: messages: =System.LastMessage output: autoSend: true messages: Local.LatestMessage\n- kind: Question\nvariable: Local.Input id: action-1763737142539 entity: StringPrebuiltEntity skipQuestionMode: SkipOnFirstExecutionIfVariableHasValue prompt: Boss, can you confirm this ?\n- kind: ConditionGroup\nconditions:\n- condition: =Local.Input=\"Yes\"\nactions:\n- kind: InvokeAzureAgent\nid: action-1763744279421 agent: name: ApplyAgent input: messages: =Local.LatestMessage output: autoSend: true messages: Local.LatestMessage\n- kind: EndConversation\nid: action-1763740066007 id: if-action-1763736954795-0 id: action-1763736954795 elseActions:\n- kind: GotoAction\nactionId: action-1763736666888 id: action-1763737425562 id: \"\" name: HRDemo description: \"\" ```\n\n### **Simulating the End-to-End Process**\n\nOnce constructed, Foundry provides a robust, built-in testing environment. You can trigger the workflow with sample input data to simulate the end-to-end cycle. This allows you to debug hand-offs and interactions in real-time before writing a single line of application code.\n\n## **Phase 2: Develop**\n\n### **From Cloud Canvas to Local Code with VSCode**\n\nFoundry Workflows excels at rapid prototyping. However, a visual UI is rarely sufficient for enterprise-grade production. The critical question becomes: *How do we integrate these visual definitions into a rigorous Software Development Lifecycle (SDLC)?*\n\nWhile the cloud portal is ideal for design, enterprise application delivery happens in the local IDE. The **Microsoft Foundry VSCode Extension** bridges this gap.\n\nThis extension allows developers to:\n\n1. **Sync:** Pull down workflow definitions from the cloud to your local machine.\n2. **Inspect:** Review the underlying logic in your preferred environment.\n3. **Scaffold:** Rapidly generate the underlying code structures needed to run the flow.\n\nThis accelerates the shift from \"understanding\" the flow to \"implementing\" it.\n\n## **Phase 3: Deploy**\n\n#### **Productionizing Intelligence with the Microsoft Agent Framework**\n\nOnce the multi-agent orchestration has been validated locally, the final step is transforming it into a shipping application.\n\nThis is where the **Microsoft Agent Framework** shines as a runtime engine. It natively ingests the declarative Workflow definitions (YAML) exported from Foundry. This allows artifacts from the prototyping phase to be directly promoted to application deployment.\n\nBy simply referencing the workflow configuration libraries, you can \"hydrate\" the entire multi-agent system with minimal boilerplate. Here is the code required to initialize and run the workflow within your application.\n\n***Note - Check the source code  [https://github.com/microsoft/Agent-Framework-Samples/tree/main/09.Cases/MicrosoftFoundryWithAITKAndMAF](https://github.com/microsoft/Agent-Framework-Samples/tree/main/09.Cases/MicrosoftFoundryWithAITKAndMAF)***\n\n## **Summary: The Journey from Conversation to Action**\n\nMicrosoft Foundry is more than just a toolbox; it is a comprehensive solution designed to bridge the chasm between theoretical AI research and secure, scalable enterprise applications.\n\nIn this post, we walked through the three critical stages of modern AI development:\n\n1. **Design (Low-Code):** Leveraging Foundry Workflows to visually orchestrate specialized agents (Recruiter vs. Applicant) mixed with deterministic business rules.\n2. **Develop (Local SDLC):** Utilizing the VSCode Extension to break down the barriers between the cloud canvas and the local IDE, enabling seamless synchronization and debugging.\n3. **Deploy (Native Runtime):** Using the Microsoft Agent Framework to ingest declarative YAML, realizing the promise of \"Configuration as Code\" and eliminating tedious logic rewriting.\n\nBy following this path, developers can move beyond simple content generation and build adaptive, multi-agent systems that drive real business value.\n\n### **Learning Resoures**\n\n- What's Microsoft Foundry ([https://learn.microsoft.com/azure/ai-foundry/what-is-azure-ai-foundry?view=foundry](https://learn.microsoft.com/en-us/azure/ai-foundry/what-is-azure-ai-foundry?view=foundry))\n- Work with Declarative (Low-code) Agent workflows in Visual Studio Code (preview) ([https://learn.microsoft.com/azure/ai-foundry/agents/how-to/vs-code-agents-workflow-low-code?view=foundry](https://learn.microsoft.com/en-us/azure/ai-foundry/agents/how-to/vs-code-agents-workflow-low-code?view=foundry))\n- Microsoft Agent Framework([https://github.com/microsoft/agent-framework](https://github.com/microsoft/agent-framework))\n- Microsoft Foundry VSCode Extension([https://marketplace.visualstudio.com/items?itemName=TeamsDevApp.vscode-ai-foundry](https://marketplace.visualstudio.com/items?itemName=TeamsDevApp.vscode-ai-foundry))\n\nUpdated Nov 25, 2025\n\nVersion 1.0\n\n[.net](/tag/.net?nodeId=board%3AAzureDevCommunityBlog)\n\n[agents](/tag/agents?nodeId=board%3AAzureDevCommunityBlog)\n\n[ai](/tag/ai?nodeId=board%3AAzureDevCommunityBlog)\n\n[ai foundry](/tag/ai%20foundry?nodeId=board%3AAzureDevCommunityBlog)\n\n[genai](/tag/genai?nodeId=board%3AAzureDevCommunityBlog)\n\n[vs code](/tag/vs%20code?nodeId=board%3AAzureDevCommunityBlog)\n\n[!\\[kinfey&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0xMTU4ODcwLTU0ODQxMWlERTQ5OEYxMkNFQTBBQzcw?image-dimensions=50x50)](/users/kinfey/1158870) [kinfey](/users/kinfey/1158870) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined September 17, 2021\n\n[View Profile](/users/kinfey/1158870)\n\n/category/azure/blog/azuredevcommunityblog [Microsoft Developer Community Blog](/category/azure/blog/azuredevcommunityblog) Follow this blog board to get notified when there's new activity",
  "PubDate": "2025-11-25T08:00:00+00:00",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Description": "We have reached a critical inflection point in AI development. Within the Microsoft Foundry ecosystem, the core value proposition of \"Agents\" is shifting decisively—moving from passive **content generation** to active **task execution** and **process automation**.\n\nThese are no longer just conversational interfaces. They are intelligent entities capable of connecting models, data, and tools to actively execute complex business logic.\n\nTo support this evolution, Microsoft has introduced a powerful suite of capabilities: the **Microsoft Agent Framework** for sophisticated orchestration, the **Agent V2 SDK**, and integrated **Microsoft Foundry VSCode Extensions**. These innovations provide the tooling necessary to bridge the gap between theoretical research and secure, scalable enterprise landing.\n\nBut how do you turn these separate components into a cohesive business solution? That is the challenge we address today. This post dives into the practical application of these tools, demonstrating how to connect the dots and transform complex multi-agent concepts into deployed reality.\n\n![]()\n\n## The Scenario: Recruitment through an \"Agentic Lens\"\n\nLet’s ground this theoretical discussion with a real-world scenario that perfectly models a multi-agent environment: **The Recruitment Process.**\n\nBy examining recruitment through an agentic lens, we can identify distinct entities with specific mandates:\n\n- **The Recruiter Agent:** Tasked with setting boundary conditions (job requirements) and preparing data retrieval mechanisms (interview questions).\n- **The Applicant Agent:** Objective is to process incoming queries and synthesize the best possible output to meet the recruiter's acceptance criteria.\n\n## **Phase 1: Design**\n\n### **Achieving Orchestration via Microsoft Foundry Workflows**\n\nTo bridge the gap between our scenario and technical reality, we start with **Foundry Workflows**.\n\nWorkflows serves as the visual integration environment within Foundry. It allows you to build declarative pipelines that seamlessly combine deterministic business logic with the probabilistic nature of autonomous AI agents.\n\nBy adopting this visual, low-code paradigm, you eliminate the need to write complex orchestration logic from scratch. Workflows empowers you to coordinate specialized agents intuitively, creating adaptive systems that solve complex business problems collaboratively.\n\n### **Visually Orchestrating the Cycle**\n\nMicrosoft Foundry provides an intuitive, web-based **drag-and-drop interface**. This canvas allows you to integrate specialized AI agents alongside standard procedural logic blocks, transforming abstract ideas into executable processes without writing extensive glue code.\n\nTo translate our recruitment scenario into a functional workflow, we follow a structured approach:\n\n1. **Agent Prerequisites:** We pre-configure our specialized agents within Foundry. We create a *Recruiter Agent* (prompted to generate evaluation criteria) and an *Applicant Agent* (prompted to synthesize responses).\n2. **Orchestrating the Interaction:** We drag these nodes onto the board and define the data flow. The process begins with the Recruiter generating questions, piping that output directly as input for the Applicant agent.\n3. **Adding Business Logic:** A true workflow requires decision-making. We introduce control flow logic, such as **IF/ELSE conditional blocks**, to evaluate the recruiter's questions based on predefined criteria. This allows the workflow to branch dynamically—if satisfied, the candidate answers the questions; if not, the questions are regenerated.\n\n![]()\n\n### **Alternative: YAML Configuration**\n\nFor developers who prefer a code-first approach or wish to rapidly replicate this logic across environments, Foundry allows you to export the underlying YAML.\n\n- kind: workflow\ntrigger: kind: OnConversationStart id: trigger\\_wf actions:\n- kind: SetVariable\nid: action-1763742724000 variable: Local.LatestMessage value: =UserMessage(System.LastMessageText)\n- kind: InvokeAzureAgent\nid: action-1763736666888 agent: name: HiringManager input: messages: =System.LastMessage output: autoSend: true messages: Local.LatestMessage\n- kind: Question\nvariable: Local.Input id: action-1763737142539 entity: StringPrebuiltEntity skipQuestionMode: SkipOnFirstExecutionIfVariableHasValue prompt: Boss, can you confirm this ?\n- kind: ConditionGroup\nconditions:\n- condition: =Local.Input=\"Yes\"\nactions:\n- kind: InvokeAzureAgent\nid: action-1763744279421 agent: name: ApplyAgent input: messages: =Local.LatestMessage output: autoSend: true messages: Local.LatestMessage\n- kind: EndConversation\nid: action-1763740066007 id: if-action-1763736954795-0 id: action-1763736954795 elseActions:\n- kind: GotoAction\nactionId: action-1763736666888 id: action-1763737425562 id: \"\" name: HRDemo description: \"\"\n\n### **Simulating the End-to-End Process**\n\nOnce constructed, Foundry provides a robust, built-in testing environment. You can trigger the workflow with sample input data to simulate the end-to-end cycle. This allows you to debug hand-offs and interactions in real-time before writing a single line of application code.\n\n![]()\n\n## **Phase 2: Develop**\n\n### **From Cloud Canvas to Local Code with VSCode**\n\nFoundry Workflows excels at rapid prototyping. However, a visual UI is rarely sufficient for enterprise-grade production. The critical question becomes: *How do we integrate these visual definitions into a rigorous Software Development Lifecycle (SDLC)?*\n\nWhile the cloud portal is ideal for design, enterprise application delivery happens in the local IDE. The **Microsoft Foundry VSCode Extension** bridges this gap.\n\nThis extension allows developers to:\n\n1. **Sync:** Pull down workflow definitions from the cloud to your local machine.\n2. **Inspect:** Review the underlying logic in your preferred environment.\n3. **Scaffold:** Rapidly generate the underlying code structures needed to run the flow.\n\nThis accelerates the shift from \"understanding\" the flow to \"implementing\" it.\n\n![]()\n\n## **Phase 3: Deploy**\n\n#### **Productionizing Intelligence with the Microsoft Agent Framework**\n\nOnce the multi-agent orchestration has been validated locally, the final step is transforming it into a shipping application.\n\nThis is where the **Microsoft Agent Framework** shines as a runtime engine. It natively ingests the declarative Workflow definitions (YAML) exported from Foundry. This allows artifacts from the prototyping phase to be directly promoted to application deployment.\n\nBy simply referencing the workflow configuration libraries, you can \"hydrate\" the entire multi-agent system with minimal boilerplate. Here is the code required to initialize and run the workflow within your application.\n\n![]()\n\n***Note - Check the source code [https://github.com/microsoft/Agent-Framework-Samples/tree/main/09.Cases/MicrosoftFoundryWithAITKAndMAF](https://github.com/microsoft/Agent-Framework-Samples/tree/main/09.Cases/MicrosoftFoundryWithAITKAndMAF)***\n\n## **Summary: The Journey from Conversation to Action**\n\nMicrosoft Foundry is more than just a toolbox; it is a comprehensive solution designed to bridge the chasm between theoretical AI research and secure, scalable enterprise applications.\n\nIn this post, we walked through the three critical stages of modern AI development:\n\n1. **Design (Low-Code):** Leveraging Foundry Workflows to visually orchestrate specialized agents (Recruiter vs. Applicant) mixed with deterministic business rules.\n2. **Develop (Local SDLC):** Utilizing the VSCode Extension to break down the barriers between the cloud canvas and the local IDE, enabling seamless synchronization and debugging.\n3. **Deploy (Native Runtime):** Using the Microsoft Agent Framework to ingest declarative YAML, realizing the promise of \"Configuration as Code\" and eliminating tedious logic rewriting.\n\nBy following this path, developers can move beyond simple content generation and build adaptive, multi-agent systems that drive real business value.\n\n### **Learning Resoures**\n\n- What's Microsoft Foundry ([https://learn.microsoft.com/azure/ai-foundry/what-is-azure-ai-foundry?view=foundry](https://learn.microsoft.com/en-us/azure/ai-foundry/what-is-azure-ai-foundry?view=foundry))\n- Work with Declarative (Low-code) Agent workflows in Visual Studio Code (preview) ([https://learn.microsoft.com/azure/ai-foundry/agents/how-to/vs-code-agents-workflow-low-code?view=foundry](https://learn.microsoft.com/en-us/azure/ai-foundry/agents/how-to/vs-code-agents-workflow-low-code?view=foundry))\n- Microsoft Agent Framework([https://github.com/microsoft/agent-framework](https://github.com/microsoft/agent-framework))\n- Microsoft Foundry VSCode Extension([https://marketplace.visualstudio.com/items?itemName=TeamsDevApp.vscode-ai-foundry](https://marketplace.visualstudio.com/items?itemName=TeamsDevApp.vscode-ai-foundry))"
}
