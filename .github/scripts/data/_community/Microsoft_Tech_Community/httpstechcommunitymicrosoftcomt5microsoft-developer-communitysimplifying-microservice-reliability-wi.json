{
  "FeedName": "Microsoft Tech Community",
  "Description": "What is **Dapr**?\n\nDapr is an open-source runtime developed by Microsoft that is used in building **resilient, event-driven, and portable** applications. It works using the **sidecar pattern**, meaning every microservice gets a small companion container ‚Äî the Dapr sidecar ‚Äî which handles communication, retries, secrets, state, and more. What is **Sidecar** ? A sidecar is a helper process that runs beside your app, handling system tasks so your code can focus on business logic.\n\nLets see some offerings from Dapr along with examples.\n\n#1 . **Bindings** Connects your app to external systems (like queues, email, or storage) with zero SDK or protocol handling. Without Dapr ‚ùå\n\n``` var httpClient = new HttpClient(); await httpClient.PostAsJsonAsync(\"https://api.sendgrid.com/send\", email);\n\n```\n\n**\\*** Manage HTTP endpoints & credentials\n\n**\\*** Change provider ‚Üí rewrite logic With Dapr ‚úÖ\n\n- await daprClient.InvokeBindingAsync(\"send-email\", \"create\", email);\n\n**\\*** One call, no SDK\n\n**\\*** Replace SendGrid ‚Üí SMTP ‚Üí Twilio just by editing config\n\n**\\*** No code change, no redeploy\n\nHow to enable binding in for a Azure Container App\n\n1. **Open Azure Portal** ‚Üí go to your **Container App Environment**.\n2. From the left pane, click on **Container Apps**, and choose your **desired app** (e.g., orders-api).\n3. In the **Settings** section, select **Dapr**.\n4. **Enable Dapr** toggle ‚Üí switch it **ON**.\n5. Provide the basic Dapr settings:\n- **App ID:** A unique name (e.g., orders-app).\n- **App Port:** The internal port your API listens on (e.g., 8080).\n- **App Protocol:** Choose HTTP or gRPC (usually HTTP).\n6. Click **Save** to apply.\n7. Now, under the same Container App Environment, go to **Dapr Components**.\n8. Click **Create** ‚Üí select **Binding** ‚Üí choose the type of binding (e.g., azure.storagequeues).\n\n![]()\n\n#2 . **Configuration** Centralizes app settings, allowing live configuration updates without redeploying services. Without Dapr ‚ùå\n- var featureFlag = Configuration[\"FeatureX\"];\n\n**\\*** Requires redeploys for every config change\n\n**\\*** No centralized versioning or dynamic update With Dapr ‚úÖ\n- var config = await daprClient.GetConfiguration(\"appconfigstore\", new[] { \"FeatureX\" });\n\n**\\*** Use Azure App Config, Consul, or any provider\n\n**\\*** Centralized updates ‚Äî no redeploys\n\n**\\*** Consistent access via Dapr SDK\n\nHow to enable configuration in for a Azure Container App\n\n- 1. **Open Azure Portal** ‚Üí go to your **Container App Environment**.\n2. From the left pane, click on **Container Apps**, and choose your **desired app** (e.g., orders-api).\n3. In the **Settings** section, select **Dapr**.\n4. **Enable Dapr** toggle ‚Üí switch it **ON**.\n5. Provide the basic Dapr settings:\n- **App ID:** A unique name (e.g., orders-app).\n- **App Port:** The internal port your API listens on (e.g., 8080).\n- **App Protocol:** Choose HTTP or gRPC (usually HTTP).\n6. Click **Save** to apply.\n7. Now, under the same Container App Environment, go to **Dapr Components**.\n8. Click **Create** ‚Üí select **Configuration**‚Üí choose the type of configuration (e.g., configuration.azure.appconfig).\n![]()\n\n#3 . **Pub/Sub** Enables event-driven communication between microservices without needing to know each other's endpoints. Without Dapr ‚ùå\n- var client = new ServiceBusClient(\"\"); var sender = client.CreateSender(\"order-topic\"); await sender.SendMessageAsync(new ServiceBusMessage(orderJson));\n\n**\\*** Tied to **Azure Service Bus**\n\n**\\*** Must manage SDKs, connections, retries\n\n**\\*** Hard to switch to another broker (Kafka, RabbitMQ) With Dapr ‚úÖ\n- await daprClient.PublishEventAsync(\"pubsub\", \"order-created\", order);\n\n**\\*** pubsub component defined in YAML (can be Kafka, Redis Streams, etc.)\n\n**\\*** No SDK, no broker dependency\n\n**\\*** Just publish the event ‚Äî Dapr handles transport & retries\n\nHow to enable pub/sub in for a Azure Container App\n\n- 1. **Open Azure Portal** ‚Üí go to your **Container App Environment**.\n2. From the left pane, click on **Container Apps**, and choose your **desired app** (e.g., orders-api).\n3. In the **Settings** section, select **Dapr**.\n4. **Enable Dapr** toggle ‚Üí switch it **ON**.\n5. Provide the basic Dapr settings:\n- **App ID:** A unique name (e.g., orders-app).\n- **App Port:** The internal port your API listens on (e.g., 8080).\n- **App Protocol:** Choose HTTP or gRPC (usually HTTP).\n6. Click **Save** to apply.\n7. Now, under the same Container App Environment, go to **Dapr Components**.\n8. Click **Create** ‚Üí select **Pub/Sub**‚Üí choose the type of configuration (e.g., pubsub.azure.servicebus.topics).\n\n![]()\n\n#4 . **Secret Stores** Securely retrieves credentials and secrets from vaults, keeping them out of configs and code. Without Dapr ‚ùå\n- var connString = Configuration[\"ConnectionStrings:DB\"];\n\n**\\*** Secrets stored in configs or env vars\n\n**\\*** Risk of leaks and manual rotation\n\nWith Dapr ‚úÖ\n- var secret = await daprClient.GetSecretAsync(\"vault\", \"dbConnection\");\n\n**\\*** Fetch directly from Azure Key Vault, AWS Secrets, etc.\n\n**\\*** No secrets in configs\n\n**\\*** Secure by default, consistent across services\n\nHow to enable Secret Stores in for a Azure Container App\n\n1. 1. **Open Azure Portal** ‚Üí go to your **Container App Environment**.\n2. From the left pane, click on **Container Apps**, and choose your **desired app** (e.g., orders-api).\n3. In the **Settings** section, select **Dapr**.\n4. **Enable Dapr** toggle ‚Üí switch it **ON**.\n5. Provide the basic Dapr settings:\n- **App ID:** A unique name (e.g., orders-app).\n- **App Port:** The internal port your API listens on (e.g., 8080).\n- **App Protocol:** Choose HTTP or gRPC (usually HTTP).\n6. Click **Save** to apply.\n7. Now, under the same Container App Environment, go to **Dapr Components**.\n8. Click **Create** ‚Üí select **Secret stores**‚Üí choose the type of configuration (e.g., secretstores.azure.keyvault).\n\n![]()\n\n#5 . **State** Provides a consistent way to store and retrieve application data across services using a simple API. Without Dapr ‚ùå\n- var cosmosClient = new CosmosClient(connStr); var container = cosmosClient.GetContainer(\"db\", \"state\"); await container.UpsertItemAsync(order);\n\n**\\*** Direct dependency on **Cosmos DB**\n\n**\\*** Manual retry logic\n\n**\\*** Tight coupling to storage type\n\nWith Dapr ‚úÖ\n- await daprClient.SaveStateAsync(\"statestore\", \"order-101\", order); var data = await daprClient.GetStateAsync(\"statestore\", \"order-101\");\n\n**\\*** Plug any backend (Redis, Cosmos, PostgreSQL)\n\n**\\*** Dapr handles retries and consistency\n\n**\\*** Same code, different backend ‚Äî total flexibility\n\nHow to enable State in for a Azure Container App\n\n1. 1. **Open Azure Portal** ‚Üí go to your **Container App Environment**.\n2. From the left pane, click on **Container Apps**, and choose your **desired app** (e.g., orders-api).\n3. In the **Settings** section, select **Dapr**.\n4. **Enable Dapr** toggle ‚Üí switch it **ON**.\n5. Provide the basic Dapr settings:\n- **App ID:** A unique name (e.g., orders-app).\n- **App Port:** The internal port your API listens on (e.g., 8080).\n- **App Protocol:** Choose HTTP or gRPC (usually HTTP).\n6. Click **Save** to apply.\n7. Now, under the same Container App Environment, go to **Dapr Components**.\n8. Click **Create** ‚Üí select **State** ‚Üí choose the type of configuration (e.g., state.azure.cosmosdb).\n\n![]()\n\nüß© Summary\n\nThink of Dapr as your invisible co-pilot for building distributed apps. It abstracts away all the repetitive plumbing ‚Äî state management, pub/sub messaging, secret handling, and external bindings ‚Äî letting you focus on writing features that matter.\n\nWith Dapr, you don‚Äôt just write code that runs locally; you write code that just works across clouds, containers, and environments, without having to worry about wiring up retries, event delivery, or service-to-service communication manually.\n\nüß∞ Demo Source Code\n\nI've prepared complete sample on .Net core that touches all major Dapr features:\n\n**\\*** State Store **\\*** Pub/Sub **\\*** Bindings **\\*** Configuration **\\*** Secret Store\n\nYou can explore it from [Github-Dapr-Api](https://github.com/riturajjana0397/Dapr.Api)\n\nClone, run locally, and experiment ‚Äî the project uses in-memory storage to keep things lightweight for testing and learning.\n\nüìö References for Deep Dive\n\n- [Official Dapr Docs](https://docs.dapr.io)\n- [Dapr for .NET Developers ‚Äî Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/dapr-for-net-developers/)\n- [Dapr .NET SDK GitHub](https://github.com/dapr/dotnet-sdk)",
  "PubDate": "2025-11-08T14:39:53+00:00",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "OutputDir": "_community",
  "Author": "riturajjana",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "EnhancedContent": "## Dapr is a lightweight runtime that helps you build portable, resilient, and event-driven applications.\n\nWhat is **Dapr**?\n\nDapr is an open-source runtime developed by Microsoft that is used in building¬†**resilient, event-driven, and portable** applications. It works using the **sidecar pattern**, meaning every microservice gets a small companion container ‚Äî the Dapr sidecar ‚Äî which handles communication, retries, secrets, state, and more. What is **Sidecar** ? A sidecar is a helper process that runs beside your app, handling system tasks so your code can focus on business logic.\n\nLets see some offerings from Dapr along with examples.\n\n#1 . **Bindings** Connects your app to external systems (like queues, email, or storage) with zero SDK or protocol handling. Without Dapr ‚ùå\n\n``` var httpClient = new HttpClient(); await httpClient.PostAsJsonAsync(\"https://api.sendgrid.com/send\", email);\n\n```\n\n**\\*** Manage HTTP endpoints & credentials\n\n**\\*** Change provider ‚Üí rewrite logic With Dapr ‚úÖ\n\n``` await daprClient.InvokeBindingAsync(\"send-email\", \"create\", email); ```\n\n**\\*** One call, no SDK\n\n**\\*** Replace SendGrid ‚Üí SMTP ‚Üí Twilio just by editing config\n\n**\\*** No code change, no redeploy\n\nHow to enable binding in for a Azure Container App\n\n1. **Open Azure Portal** ‚Üí go to your **Container App Environment**.\n2. From the left pane, click on **Container Apps**, and choose your **desired app** (e.g., orders-api).\n3. In the **Settings** section, select **Dapr**.\n4. **Enable Dapr** toggle ‚Üí switch it **ON**.\n5. Provide the basic Dapr settings:\n- **App ID:** A unique name (e.g., orders-app).\n- **App Port:** The internal port your API listens on (e.g., 8080).\n- **App Protocol:** Choose HTTP or gRPC (usually HTTP).\n6. Click **Save** to apply.\n7. Now, under the same Container App Environment, go to **Dapr Components**.\n8. Click **Create** ‚Üí select **Binding** ‚Üí choose the type of binding (e.g., azure.storagequeues).\n\n#2 . **Configuration** Centralizes app settings, allowing live configuration updates without redeploying services. Without Dapr ‚ùå\n\n``` var featureFlag = Configuration[\"FeatureX\"]; ```\n\n**\\*** Requires redeploys for every config change\n\n**\\*** No centralized versioning or dynamic update With Dapr ‚úÖ\n\n``` var config = await daprClient.GetConfiguration(\"appconfigstore\", new[] { \"FeatureX\" }); ```\n\n**\\*** Use Azure App Config, Consul, or any provider\n\n**\\*** Centralized updates ‚Äî no redeploys\n\n**\\*** Consistent access via Dapr SDK\n\nHow to enable configuration in for a Azure Container App\n\n- 1. **Open Azure Portal** ‚Üí go to your **Container App Environment**.\n2. From the left pane, click on **Container Apps**, and choose your **desired app** (e.g., orders-api).\n3. In the **Settings** section, select **Dapr**.\n4. **Enable Dapr** toggle ‚Üí switch it **ON**.\n5. Provide the basic Dapr settings:\n- **App ID:** A unique name (e.g., orders-app).\n- **App Port:** The internal port your API listens on (e.g., 8080).\n- **App Protocol:** Choose HTTP or gRPC (usually HTTP).\n6. Click **Save** to apply.\n7. Now, under the same Container App Environment, go to **Dapr Components**.\n8. Click **Create** ‚Üí select **Configuration**‚Üí choose the type of configuration (e.g., configuration.azure.appconfig).\n\n#3 . **Pub/Sub** Enables event-driven communication between microservices without needing to know each other's endpoints. Without Dapr ‚ùå\n\n``` var client = new ServiceBusClient(\"<connection-string>\"); var sender = client.CreateSender(\"order-topic\"); await sender.SendMessageAsync(new ServiceBusMessage(orderJson)); ```\n\n**\\*** Tied to **Azure Service Bus**\n\n**\\*** Must manage SDKs, connections, retries\n\n**\\*** Hard to switch to another broker (Kafka, RabbitMQ) With Dapr ‚úÖ\n\n``` await daprClient.PublishEventAsync(\"pubsub\", \"order-created\", order); ```\n\n**\\*** pubsub component defined in YAML (can be Kafka, Redis Streams, etc.)\n\n**\\*** No SDK, no broker dependency\n\n**\\*** Just publish the event ‚Äî Dapr handles transport & retries\n\nHow to enable pub/sub in for a Azure Container App\n\n- 1. **Open Azure Portal** ‚Üí go to your **Container App Environment**.\n2. From the left pane, click on **Container Apps**, and choose your **desired app** (e.g., orders-api).\n3. In the **Settings** section, select **Dapr**.\n4. **Enable Dapr** toggle ‚Üí switch it **ON**.\n5. Provide the basic Dapr settings:\n- **App ID:** A unique name (e.g., orders-app).\n- **App Port:** The internal port your API listens on (e.g., 8080).\n- **App Protocol:** Choose HTTP or gRPC (usually HTTP).\n6. Click **Save** to apply.\n7. Now, under the same Container App Environment, go to **Dapr Components**.\n8. Click **Create** ‚Üí select **Pub/Sub**‚Üí choose the type of configuration (e.g., pubsub.azure.servicebus.topics).\n\n#4 . **Secret Stores** Securely retrieves credentials and secrets from vaults, keeping them out of configs and code. Without Dapr ‚ùå\n\n``` var connString = Configuration[\"ConnectionStrings:DB\"]; ```\n\n**\\*** Secrets stored in configs or env vars\n\n**\\*** Risk of leaks and manual rotation\n\nWith Dapr ‚úÖ\n\n``` var secret = await daprClient.GetSecretAsync(\"vault\", \"dbConnection\"); ```\n\n**\\*** Fetch directly from Azure Key Vault, AWS Secrets, etc.\n\n**\\*** No secrets in configs\n\n**\\*** Secure by default, consistent across services\n\nHow to enable Secret Stores in for a Azure Container App\n\n1. 1. **Open Azure Portal** ‚Üí go to your **Container App Environment**.\n2. From the left pane, click on **Container Apps**, and choose your **desired app** (e.g., orders-api).\n3. In the **Settings** section, select **Dapr**.\n4. **Enable Dapr** toggle ‚Üí switch it **ON**.\n5. Provide the basic Dapr settings:\n- **App ID:** A unique name (e.g., orders-app).\n- **App Port:** The internal port your API listens on (e.g., 8080).\n- **App Protocol:** Choose HTTP or gRPC (usually HTTP).\n6. Click **Save** to apply.\n7. Now, under the same Container App Environment, go to **Dapr Components**.\n8. Click **Create** ‚Üí select **Secret stores**‚Üí choose the type of configuration (e.g., secretstores.azure.keyvault).\n\n#5 . **State** Provides a consistent way to store and retrieve application data across services using a simple API. Without Dapr ‚ùå\n\n``` var cosmosClient = new CosmosClient(connStr); var container = cosmosClient.GetContainer(\"db\", \"state\"); await container.UpsertItemAsync(order); ```\n\n**\\*** Direct dependency on **Cosmos DB**\n\n**\\*** Manual retry logic\n\n**\\*** Tight coupling to storage type\n\nWith Dapr ‚úÖ\n\n``` await daprClient.SaveStateAsync(\"statestore\", \"order-101\", order); var data = await daprClient.GetStateAsync<Order>(\"statestore\", \"order-101\"); ```\n\n**\\*** Plug any backend (Redis, Cosmos, PostgreSQL)\n\n**\\*** Dapr handles retries and consistency\n\n**\\*** Same code, different backend ‚Äî total flexibility\n\nHow to enable State in for a Azure Container App\n\n1. 1. **Open Azure Portal** ‚Üí go to your **Container App Environment**.\n2. From the left pane, click on **Container Apps**, and choose your **desired app** (e.g., orders-api).\n3. In the **Settings** section, select **Dapr**.\n4. **Enable Dapr** toggle ‚Üí switch it **ON**.\n5. Provide the basic Dapr settings:\n- **App ID:** A unique name (e.g., orders-app).\n- **App Port:** The internal port your API listens on (e.g., 8080).\n- **App Protocol:** Choose HTTP or gRPC (usually HTTP).\n6. Click **Save** to apply.\n7. Now, under the same Container App Environment, go to **Dapr Components**.\n8. Click **Create** ‚Üí select **State** ‚Üí choose the type of configuration (e.g., state.azure.cosmosdb).\n\nüß© Summary\n\nThink of Dapr as your invisible co-pilot for building distributed apps. It abstracts away all the repetitive plumbing ‚Äî state management, pub/sub messaging, secret handling, and external bindings ‚Äî letting you focus on writing features that matter.\n\nWith Dapr, you don‚Äôt just write code that runs locally; you write code that just works across clouds, containers, and environments, without having to worry about wiring up retries, event delivery, or service-to-service communication manually.\n\nüß∞ Demo Source Code\n\nI've prepared complete sample on .Net core that touches all major Dapr features:\n\n**\\*** State Store **\\*** Pub/Sub **\\*** Bindings **\\*** Configuration **\\*** Secret Store\n\nYou can explore it from [Github-Dapr-Api](https://github.com/riturajjana0397/Dapr.Api)\n\nClone, run locally, and experiment ‚Äî the project uses in-memory storage to keep things lightweight for testing and learning.\n\nüìö References for Deep Dive\n\n- [Official Dapr Docs](https://docs.dapr.io)\n- [Dapr for .NET Developers ‚Äî Microsoft Learn](https://learn.microsoft.com/en-us/dotnet/architecture/dapr-for-net-developers/)\n- [Dapr .NET SDK GitHub](https://github.com/dapr/dotnet-sdk)\n\nUpdated Nov 08, 2025\n\nVersion 1.0\n\n[.net](/tag/.net?nodeId=board%3AAzureDevCommunityBlog)\n\n[azure](/tag/azure?nodeId=board%3AAzureDevCommunityBlog)\n\n[developer](/tag/developer?nodeId=board%3AAzureDevCommunityBlog)\n\n[software architecture](/tag/software%20architecture?nodeId=board%3AAzureDevCommunityBlog)\n\n[!\\[riturajjana&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0zMjQwMTQ3LUhqQ29PNQ?image-coordinates=0%2C69%2C662%2C731&amp;image-dimensions=50x50)](/users/riturajjana/3240147) [riturajjana](/users/riturajjana/3240147) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined October 24, 2025\n\n[View Profile](/users/riturajjana/3240147)\n\n/category/azure/blog/azuredevcommunityblog [Microsoft Developer Community Blog](/category/azure/blog/azuredevcommunityblog) Follow this blog board to get notified when there's new activity",
  "Link": "https://techcommunity.microsoft.com/t5/microsoft-developer-community/simplifying-microservice-reliability-with-dapr/ba-p/4468296",
  "ProcessedDate": "2025-11-08 15:03:27",
  "Tags": [],
  "Title": "Simplifying Microservice Reliability with Dapr"
}
