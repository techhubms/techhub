{
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Author": "HugoAffaticati",
  "Description": "*by Mishty Dhekial (Software Engineer Intern) and Hugo Affaticati (Cloud Infrastructure Engineer)*\n\n# Why Llama?\n\nThe Llama3 8B model was selected as the focus of this analysis due to its relevance as a modern, open-weight large language model (LLM) architecture. Llama models are widely used in both research and industry. Their transformer-based design, featuring multi-head self-attention and deep stacking of layers, reflects the current state-of-the-art in natural language processing and is now part of our [Azure AI benchmarking guide](https://github.com/Azure/AI-benchmarking-guide/tree/main).\n\n## Model Architecture\n\nThe Llama model’s architecture is designed for scalability and efficiency. It incorporates optimizations such as rotary positional embeddings and grouped-query attention, which improve both training speed and inference quality. The open availability of the Llama models and pretraining recipes from the [NVIDIA NeMo framework](https://docs.nvidia.com/nemo-framework/user-guide/latest/llms/llama3.html) also makes it accessible for experimentation and benchmarking, allowing for reproducible and transparent performance evaluation.\n\nThe 8B parameter size strikes a practical balance between model capacity and hardware requirements. Llama 3 70B is too large to fit onto the previous generations of virtual machines covered in our Azure AI Benchmarking guide, while the 3B model doesn’t fully stress the ND GB200 v6 VM. 8B is compact enough to fit on a single virtual machine while still presenting a demanding workload that fully utilizes the ND GB200 v6 VM’s four GPUs. This approach is ideal for conducting controlled, fine-grained validation and troubleshooting on a single VM as an initial step, before progressing to multi-node distributed training.\n\n# Performance Parameters Overview\n\nEfficiently training large language models depends on how the model is distributed across your virtual machine. This section explains parallelism parameters (tensor, pipeline, context, data) and micro batch size to maximize the Azure virtual machine’s performance and training speed.\n\n## Tensor Parallelism (TP)\n\nTensor parallelism splits individual layers of a model across multiple GPUs, allowing large models to be trained by distributing computations.\n\n![]()\n\nSource: [NVIDIA](https://docs.nvidia.com/nemo-framework/user-guide/latest/nemotoolkit/features/parallelisms.html), Accessed 8/5/2025\n\n## Pipeline Parallelism (PP)\n\nPipeline parallelism divides a model into sequential stages assigned to different GPUs.\n\n![]()\n\nSource: [NVIDIA](https://docs.nvidia.com/nemo-framework/user-guide/latest/nemotoolkit/features/parallelisms.html), Accessed 8/5/2025\n\n## Context Parallelism (CP)\n\nContext parallelism partitions long input sequences across multiple GPUs, reducing peak activation memory and enabling efficient training of large-context models.\n\n## Data Parallelism (DP)\n\nData parallelism replicates the model across multiple devices, each processing a different subset of the input data and synchronizing gradients after each step, enabling scalable training with minimal communication overhead. This is configured by default.\n\n![]()\n\nSource: [NVIDIA](https://docs.nvidia.com/nemo-framework/user-guide/latest/nemotoolkit/features/parallelisms.html), Accessed 8/5/2025\n\n## Micro Batch Size (MBS)\n\nMicro batch size is the size of the smaller batch of data processed per data parallel rank.\n\n# Understanding Telemetry and Parameter Impact\n\nTo fully understand how parallelism parameters affect both model training and cluster efficiency, it’s essential to monitor a range of telemetry and performance metrics. In this analysis, the following key metrics were tracked for each experiment:\n\n## GPU Utilization\n\nGPU utilization measures how effectively GPUs are being used. Higher utilization generally means better hardware efficiency.\n\n## Memory Usage\n\nMemory usage indicates how much GPU memory is consumed. This helps identify potential bottlenecks or opportunities to increase batch size.\n\n## Streaming Multiprocessor (SM) Clock Speed\n\nSM Clock Speed reflects the average operating frequency of the GPU’s SMs during training. Higher SM clock speeds can indicate more intensive computation but may also lead to increased power consumption and thermal load.\n\n## Training Step Time\n\nPretraining training step time is the average time to complete a training step. Shorter step times mean faster training.\n\n## Training Step Loss\n\nThe loss quantifies the discrepancy between predicted outputs and the true outputs. It measures how effectively the model is learning.\n\n# Methodology\n\nWe ran a sweep of all possible configurations from 1 to 16 for micro batch size and 1 to 4 for each parallelism parameter with fp16 with fp8 mixed precision on a single ND GB200 v6 VM. We recommend using bf16 with fp8 mixed precision for accurate pretraining like we’ve done on the fully automated Azure AI benchmarking guide.\n\n# Results\n\nThe following plots illustrate how each parameter influenced the pretraining speed, memory use, GPU Utilization, and SM clock speed.\n\n## MBS\n\nFirst, we analyzed the impact of micro batch size. With constant values for all parallelism parameters, the pretraining time per step (Figure 1) and the clock speed (Figure 4) decreases, as the MBS increases. On the other hand, the memory usage (Figure 2), and GPU utilization (Figure 3) increased with the batch size. Larger batch sizes require more memory and computational effort per step, which drives up these metrics.\n\n| ![]() | ![]() | | --- | --- | | Figure 1. Average pretraining time per step of the LLAMA3 8B model with NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of the micro batch size. | Figure 2. Average memory used of the LLAMA3 8B model with NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of the micro batch size. | | ![]() | ![]() | | Figure 3. Average GPU Utilization of LLAMA3 8B model with NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of the micro batch size. | Figure 4. Average SM clock speed of the LLAMA3 8B model with NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of the micro batch size. |\n\n## Tensor Parallelism\n\nAs Tensor Parallelism (TP) increased, the average memory usage per GPU (Figure 6) decreased, since computations were distributed more broadly. However, higher TP values introduced communication overhead, which led to increased pretraining step time (Figure 5) and reduced GPU utilization (Figure 7). SM clock speed (Figure 8) slightly increased with TP, reflecting the trade-off between memory efficiency and computational speed. Notably, TP=1 achieved the fastest step time, while higher TP values slowed pretraining despite reducing memory usage.\n\n| ![]() | ![]() | | --- | --- | | Figure 5. Average pretraining time per step of the LLAMA3 8B model with NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of TP. | Figure 6. Average memory used of the LLAMA3 8B model with NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of TP. | | ![]() | ![]() | | Figure 7. Average GPU Utilization of the LLAMA3 8B model with NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of TP. | Figure 8. Average SM clock speed of the LLAMA3 8B model with NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of TP. |\n\n## Pipeline Parallelism\n\nNext, we examined Pipeline Parallelism (PP). Increasing PP divided the model into more sequential stages. In our single VM, 4-GPU setup, higher PP values led to increased synchronization overhead and more idle time for GPUs, resulting in longer step times (Figure 9) and lower GPU utilization (Figure 11). Memory usage (Figure 10) decreased as PP increased, while SM clock speed (Figure 12) slightly increased. These results suggest that minimal pipeline parallelism is optimal for this hardware and model size which may not be benefit from pipeline parallelism.\n\n| ![]() | ![]() | | --- | --- | | Figure 9. Average pretraining time per step of the LLAMA3 8B model with NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of PP | Figure 10. Average memory used of the LLAMA3 8B model with NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of PP. | | ![]() | ![]() | | Figure 11. Average GPU Utilization of the LLAMA3 8B model with NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of PP. | Figure 12. Average SM clock speed of the LLAMA3 8B model with NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of PP. |\n\n## Context Parallelism\n\nFinally, we explored Context Parallelism (CP). Varying CP changed how input sequences were partitioned across GPUs. Increasing CP beyond 1 led to longer training step times (Figure 13) and underutilized resources with a steady decline in GPU utilization (Figure 15). Memory usage (Figure 14) and SM clock speed (Figure 16) all decreased with higher CP, but the best training speed was achieved with CP set to 1.\n\n| ![]() | ![]() | | --- | --- | | Figure 13. Average pretraining time per step of the LLAMA3 8B model with NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of CP. | Figure 14. Average memory used of the LLAMA3 8B model with NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of CP. | | ![]() | ![]() | | Figure 15. Average GPU Utilization of the LLAMA3 8B model with NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of CP. | Figure 16. Average SM clock speed of the LLAMA3 8B model with NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of CP. |\n\n# Conclusion\n\nAs our goal with validation is to stress the virtual machine, the optimal configuration is the one that has the highest memory and GPU utilization and the fastest pretraining steps. In the new pretraining section of our [Azure AI benchmarking guide](https://github.com/Azure/AI-benchmarking-guide/tree/main) we selected MBS = 4, TP = 1, PP = 2, and CP = 1 for automation. We invite you to reproduce our results by following the README.",
  "PubDate": "2025-08-18T22:45:01+00:00",
  "Title": "Optimizing Large-Scale AI Performance with Pretraining Validation on a Single Azure ND GB200 v6",
  "Tags": [],
  "ProcessedDate": "2025-08-18 23:11:24",
  "EnhancedContent": "## Small performance gaps on a single virtual machine lead to large and costly performance losses at scale. Running small-scale pretraining jobs enables single-VM validation and allows for fine-grained identification of issues such as performance degradation, hardware bottlenecks, or software inefficiencies ahead of large-scale runs. In this post, we present a practical methodology for benchmarking the ND GB200 v6 virtual machines (VMs). A single ND GB200 v6 VM on Azure is powered by two NVIDIA Grace CPUs and four NVIDIA Blackwell GPUs. To ensure reliability in production workloads we used automated pretraining of lightweight Llama models with the NVIDIA NeMo framework. By systematically exploring and tuning key performance parameters and rigorously cross-checking results with detailed telemetry, we identify conditions that most significantly stress the GPUs. You can reproduce and reuse these pretraining workloads from our fully automated Azure AI Benchmarking guide.\n\n*by Mishty Dhekial (Software Engineer Intern) and Hugo Affaticati (Cloud Infrastructure Engineer)*\n\n# Why Llama?\n\nThe Llama3 8B model was selected as the focus of this analysis due to its relevance as a modern, open-weight large language model (LLM) architecture. Llama models are widely used in both research and industry. Their transformer-based design, featuring multi-head self-attention and deep stacking of layers, reflects the current state-of-the-art in natural language processing and is now part of our [Azure AI benchmarking guide](https://github.com/Azure/AI-benchmarking-guide/tree/main).\n\n## Model Architecture\n\nThe Llama model’s architecture is designed for scalability and efficiency. It incorporates optimizations such as rotary positional embeddings and grouped-query attention, which improve both training speed and inference quality. The open availability of the Llama models and pretraining recipes from the [NVIDIA NeMo framework](https://docs.nvidia.com/nemo-framework/user-guide/latest/llms/llama3.html) also makes it accessible for experimentation and benchmarking, allowing for reproducible and transparent performance evaluation.\n\nThe 8B parameter size strikes a practical balance between model capacity and hardware requirements. Llama 3 70B is too large to fit onto the previous generations of virtual machines covered in our Azure AI Benchmarking guide, while the 3B model doesn’t fully stress the ND GB200 v6 VM. 8B is compact enough to fit on a single virtual machine while still presenting a demanding workload that fully utilizes the ND GB200 v6 VM’s four GPUs. This approach is ideal for conducting controlled, fine-grained validation and troubleshooting on a single VM as an initial step, before progressing to multi-node distributed training.\n\n# Performance Parameters Overview\n\nEfficiently training large language models depends on how the model is distributed across your virtual machine. This section      explains     parallelism parameters (tensor, pipeline, context, data) and micro batch size to maximize the Azure virtual machine’s performance and training speed.\n\n## Tensor Parallelism (TP)\n\nTensor parallelism splits individual layers of a model across multiple GPUs, allowing large models to be trained by distributing computations.\n\nSource: [NVIDIA](https://docs.nvidia.com/nemo-framework/user-guide/latest/nemotoolkit/features/parallelisms.html), Accessed 8/5/2025\n\n## Pipeline Parallelism (PP)\n\nPipeline parallelism divides a model into sequential stages assigned to different GPUs.\n\nSource: [NVIDIA](https://docs.nvidia.com/nemo-framework/user-guide/latest/nemotoolkit/features/parallelisms.html), Accessed 8/5/2025\n\n## Context Parallelism (CP)\n\nContext parallelism partitions long input sequences across multiple GPUs, reducing peak activation memory and enabling efficient training of large-context models.\n\n## Data Parallelism (DP)\n\nData parallelism replicates the model across multiple devices, each processing a different subset of the input data and synchronizing gradients after each step, enabling scalable training with minimal communication overhead. This is configured by default.\n\nSource: [NVIDIA](https://docs.nvidia.com/nemo-framework/user-guide/latest/nemotoolkit/features/parallelisms.html), Accessed 8/5/2025\n\n## Micro Batch Size (MBS)\n\nMicro batch size is the size of the smaller batch of data processed per data parallel rank.\n\n# Understanding Telemetry and Parameter Impact\n\nTo fully understand how parallelism parameters affect both model training and cluster efficiency, it’s essential to monitor a range of telemetry and performance metrics. In this analysis, the following key metrics were tracked for each experiment:\n\n## GPU Utilization\n\nGPU utilization measures how effectively GPUs are being used. Higher utilization generally means better hardware efficiency.\n\n## Memory Usage\n\nMemory usage indicates how much GPU memory is consumed. This helps identify potential bottlenecks or opportunities to increase batch size.\n\n## Streaming Multiprocessor (SM) Clock Speed\n\nSM Clock Speed reflects the average operating frequency of the GPU’s SMs during training. Higher SM clock speeds can indicate more intensive computation but may also lead to increased power consumption and thermal load.\n\n## Training Step Time\n\nPretraining training step time is the average time to complete a training step. Shorter step times mean faster training.\n\n## Training Step Loss\n\nThe loss quantifies the discrepancy between predicted outputs and the true outputs. It measures how effectively the model is learning.\n\n# Methodology\n\nWe ran a sweep of all possible configurations from 1 to 16 for micro batch size and 1 to 4 for each parallelism parameter with fp16 with fp8 mixed precision on a single ND GB200 v6 VM. We recommend using bf16 with fp8 mixed precision for accurate pretraining like we’ve done on the fully automated Azure AI benchmarking guide.\n\n# Results\n\nThe following plots illustrate how each parameter influenced the pretraining speed, memory use, GPU Utilization, and SM clock speed.\n\n## MBS\n\nFirst, we analyzed the impact of micro batch size. With constant values for all parallelism parameters, the pretraining time per step (Figure 1) and the clock speed (Figure 4) decreases, as the MBS increases. On the other hand, the memory usage (Figure 2), and GPU utilization (Figure 3) increased with the batch size. Larger batch sizes require more memory and computational effort per step, which drives up these metrics.\n\n| | | | --- | --- | | Figure 1. Average pretraining time per step of the LLAMA3 8B model with      NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of the micro batch size. | Figure 2. Average memory used of the LLAMA3 8B model with      NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of the micro batch size. | | | | | Figure 3. Average GPU Utilization of LLAMA3 8B model with      NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of the micro batch size. | Figure 4. Average SM clock speed of the LLAMA3 8B model with      NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of the micro batch size. |\n\n## Tensor Parallelism\n\nAs Tensor Parallelism (TP) increased, the average memory usage per GPU (Figure 6) decreased, since computations were distributed more broadly. However, higher TP values introduced communication overhead, which led to increased pretraining step time (Figure 5) and reduced GPU utilization (Figure 7). SM clock speed (Figure 8) slightly increased with TP, reflecting the trade-off between memory efficiency and computational speed. Notably, TP=1 achieved the fastest step time, while higher TP values slowed pretraining despite reducing memory usage.\n\n| | | | --- | --- | | Figure 5. Average pretraining time per step of the LLAMA3 8B model with      NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of TP. | Figure 6. Average memory used of the LLAMA3 8B model with      NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of TP. | | | | | Figure 7. Average GPU Utilization of the LLAMA3 8B model with      NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of TP. | Figure 8. Average SM clock speed of the LLAMA3 8B model with      NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of TP. |\n\n## Pipeline Parallelism\n\nNext, we examined Pipeline Parallelism (PP). Increasing PP divided the model into more sequential stages. In our single VM, 4-GPU setup, higher PP values led to increased synchronization overhead and more idle time for GPUs, resulting in longer step times (Figure 9) and lower GPU utilization (Figure 11). Memory usage (Figure 10) decreased as PP increased, while SM clock speed (Figure 12) slightly increased. These results suggest that minimal pipeline parallelism is optimal for this hardware and model size which may not be benefit from pipeline parallelism.\n\n| | | | --- | --- | | Figure 9. Average pretraining time per step of the LLAMA3 8B model with      NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of PP | Figure 10. Average memory used of the LLAMA3 8B model with      NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of PP. | | | | | Figure 11. Average GPU Utilization of the LLAMA3 8B model with      NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of PP. | Figure 12. Average SM clock speed of the LLAMA3 8B model with       NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of PP. |\n\n## Context Parallelism\n\nFinally, we explored Context Parallelism (CP). Varying CP changed how input sequences were partitioned across GPUs. Increasing CP beyond 1 led to longer training step times (Figure 13) and underutilized resources with a steady decline in GPU utilization (Figure 15). Memory usage (Figure 14) and SM clock speed (Figure 16) all decreased with higher CP, but the best training speed was achieved with CP set to 1.\n\n| | | | --- | --- | | Figure 13. Average pretraining time per step of the LLAMA3 8B model with     NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of CP. | Figure 14. Average memory used of the LLAMA3 8B model with      NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of CP. | | | | | Figure 15. Average GPU Utilization of the LLAMA3 8B model with      NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of CP. | Figure 16. Average SM clock speed of the LLAMA3 8B model with      NVIDIA NeMo framework on Azure ND GB200 v6 VM as a function of CP. |\n\n# Conclusion\n\nAs our goal with validation is to stress the virtual machine, the optimal configuration is the one that has the highest memory and GPU utilization and the fastest pretraining steps. In the new pretraining section of our [Azure AI benchmarking guide](https://github.com/Azure/AI-benchmarking-guide/tree/main) we selected MBS = 4, TP = 1, PP = 2, and CP = 1 for automation. We invite you to reproduce our results by following the README.\n\nUpdated Aug 18, 2025\n\nVersion 2.0\n\n[ai infrastructure](/tag/ai%20infrastructure?nodeId=board%3AAzureHighPerformanceComputingBlog)\n\n[benchmarking](/tag/benchmarking?nodeId=board%3AAzureHighPerformanceComputingBlog)\n\n[virtual machines](/tag/virtual%20machines?nodeId=board%3AAzureHighPerformanceComputingBlog)\n\n[!\\[HugoAffaticati&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/m_assets/avatars/default/avatar-1.svg?image-dimensions=50x50)](/users/hugoaffaticati/1467620) [HugoAffaticati](/users/hugoaffaticati/1467620) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined July 26, 2022\n\n[View Profile](/users/hugoaffaticati/1467620)\n\n/category/azure/blog/azurehighperformancecomputingblog [Azure High Performance Computing (HPC) Blog](/category/azure/blog/azurehighperformancecomputingblog) Follow this blog board to get notified when there's new activity",
  "OutputDir": "_community",
  "FeedName": "Microsoft Tech Community",
  "Link": "https://techcommunity.microsoft.com/t5/azure-high-performance-computing/optimizing-large-scale-ai-performance-with-pretraining/ba-p/4445273",
  "FeedLevelAuthor": "rss.livelink.threads-in-node"
}
