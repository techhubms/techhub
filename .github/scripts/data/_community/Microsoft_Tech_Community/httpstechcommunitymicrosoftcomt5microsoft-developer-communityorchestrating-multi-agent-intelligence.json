{
  "Title": "Orchestrating Multi-Agent Intelligence: MCP-Driven Patterns in Agent Framework",
  "Tags": [],
  "ProcessedDate": "2025-10-22 18:04:41",
  "PubDate": "2025-10-22T17:59:16+00:00",
  "Author": "heenaugale",
  "FeedName": "Microsoft Tech Community",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "EnhancedContent": "Building reliable AI systems requires modular, stateful coordination and deterministic workflows that enable agents to collaborate seamlessly. The Microsoft Agent Framework provides these foundations, with memory, tracing, and orchestration built in.\n\nThis implementation demonstrates four multi-agentic patterns — Single Agent, Handoff, Reflection, and Magentic Orchestration — showcasing different interaction models and collaboration strategies. From lightweight domain routing to collaborative planning and self-reflection, these patterns highlight the framework’s flexibility.\n\nAt the core is Model Context Protocol (MCP), connecting agents, tools, and memory through a shared context interface. Persistent session state, conversation thread history, and checkpoint support are handled via Cosmos DB when configured, with an in-memory dictionary as a default fallback. This setup enables dynamic pattern swapping, performance comparison, and traceable multi-agent interactions — all within a unified, modular runtime.\n\n## Business Scenario: Contoso Customer Support Chatbot\n\nContoso’s chatbot handles multi-domain customer inquiries like billing anomalies, promotion eligibility, account locks, and data usage questions. These require combining **structured data** (billing, CRM, security logs, promotions) with **unstructured policy documents** processed via vector embeddings.\n\nUsing **MCP**, the system orchestrates tool calls to fetch real-time structured data and relevant policy content, ensuring **policy-aligned, auditable responses** without exposing raw databases. This enables the assistant to explain anomalies, recommend actions, confirm eligibility, guide account recovery, and surface risk indicators—reducing handle time and improving first-contact resolution while supporting richer multi-agent reasoning.\n\n## Architecture & Core Concepts\n\nThe Contoso chatbot leverages the **Microsoft Agent Framework** to deliver a modular, stateful, and workflow-driven architecture. At its core, the system consists of:\n\n- **Base Agent**: All agent patterns—single agent, reflection, handoff and magentic orchestration—inherit from a common base class, ensuring consistent interfaces for message handling, tool invocation, and state management.\n- **Backend**: A FastAPI backend manages session routing, agent execution, and workflow orchestration.\n- **Frontend**: A React-based UI (or Streamlit alternative) streams responses in real-time and visualizes agent reasoning and tool calls.\n\n### Modular Runtime and Pattern Swapping\n\nOne of the most powerful aspects of this implementation is its **modular runtime design**. Each agentic pattern—Single, Reflection, Handoff, and Magnetic—plugs into a shared execution pipeline defined by the base agent and MCP integration. By simply updating the .env configuration (e.g., agent\\_module=handoff), developers can **swap in and out entire coordination strategies** without touching the backend, frontend, or memory layers. This makes it easy to compare agent styles side by side, benchmark reasoning behaviors, and experiment with orchestration logic—all while maintaining a **consistent, deterministic runtime**. The same MCP connectors, FastAPI backend, and Cosmos/in-memory state management work seamlessly across every pattern, enabling rapid iteration and reliable evaluation.\n\n```\n# Dynamic agent pattern loading\nagent_module_path = os.getenv(\"AGENT_MODULE\") agent_module = __import__(agent_module_path, fromlist=[\"Agent\"]) Agent = getattr(agent_module, \"Agent\") ```\n\n```\n# Common MCP setup across all patterns\nasync def _create_tools(self, headers: Dict[str, str]) -> List[MCPStreamableHTTPTool] | None: if not self.mcp_server_uri: return None return [MCPStreamableHTTPTool( name=\"mcp-streamable\", url=self.mcp_server_uri, headers=headers, timeout=30, request_timeout=30, )] ```\n\n### Memory & State Management\n\nState management is critical for multi-turn conversations and cross-agent workflows. The system supports two out-of-the-box options:\n\n1. **Persistent Storage (Cosmos DB)**\n- Acts as the durable, enterprise-ready backend.\n- Stores serialized conversation threads and workflow checkpoints keyed by tenant and session ID.\n- Ensures data durability and auditability across restarts.\n2. **In-Memory Session Store**\n- Default fallback when Cosmos DB credentials are not configured.\n- Maintains ephemeral state per session for fast prototyping or lightweight use cases.\n\nAll patterns leverage the same **thread-based state abstraction**, enabling:\n\n- **Session isolation**: Each user session maintains its own state and history.\n- **Checkpointing**: Multi-agent workflows can snapshot shared and executor-local state at any point, supporting pause/resume and fault recovery.\n- **Model Context Protocol (MCP)**: Acts as the connector between agents and tools, standardizing how data is fetched and results are returned to agents, whether querying structured databases or unstructured knowledge sources.\n\n### Core Principles\n\nAcross all patterns, the framework emphasizes:\n\n- **Modularity**: Components are interchangeable—agents, tools, and state stores can be swapped without disrupting the system.\n- **Stateful Coordination**: Multi-agent workflows coordinate through shared and local state, enabling complex reasoning without losing context.\n- **Deterministic Workflows**: While agents operate autonomously, the workflow layer ensures predictable, auditable execution of multi-agent tasks.\n- **Unified Execution**: From single-agent Q&A to complex Magentic orchestrations, every agent follows the same execution lifecycle and integrates seamlessly with MCP and the state store.\n\n## Multi-Agent Patterns: Workflow and Coordination\n\nWith the architecture and core concepts established, we can now explore the **agentic patterns** implemented in the Contoso chatbot. Each pattern builds on the base agent and MCP integration but differs in how agents **orchestrate tasks** and **communicate** with one another to handle multi-domain customer queries.\n\nIn the sections that follow, we take a deeper dive into each pattern’s **workflow** and examine the **under-the-hood communication flows** between agents:\n\n1. **Single Agent** – A simple, single-domain agent handling straightforward queries.\n2. **Reflection Agent** – Allows agents to introspect and refine their outputs.\n3. **Handoff Pattern** – Routes conversations intelligently to specialized agents across domains.\n4. **Magentic Orchestration** – Coordinates multiple specialist agents for complex, parallel tasks.\n\nFor each pattern, the focus will be on **how agents communicate and coordinate**, showing the practical orchestration mechanisms in action.\n\n### Single Intelligent Agent\n\nThe **Single Agent Pattern** represents the simplest orchestration style within the framework. Here, a single autonomous agent handles all reasoning, decision-making, and tool interactions directly — without delegation or multi-agent coordination.\n\nWhen a user submits a request, the single agent processes the query using all tools, memory, and data sources available through the **Model Context Protocol (MCP)**. It performs retrieval, reasoning, and response composition in a single, cohesive loop.\n\n**Communication Flow:**\n\n1. **User Input → Agent:** The user submits a question or command.\n2. **Agent → MCP Tools:** The agent invokes one or more tools (e.g., vector retrieval, structured queries, or API calls) to gather relevant context and data.\n3. **Agent → User:** The agent synthesizes the tool outputs, applies reasoning, and generates the final response to the user.\n4. **Session Memory:** Throughout the exchange, the agent stores conversation history and extracted entities in the configured memory store (in-memory or Cosmos DB).\n\n**Key Communication Principles:**\n\n- **Single Responsibility:** One agent performs both reasoning and action, ensuring fast response times and simpler state management.\n- **Direct Tool Invocation:** The agent has direct access to all registered tools through MCP, enabling flexible retrieval and action chaining.\n- **Stateful Execution:** The session memory preserves dialogue context, allowing the agent to maintain continuity across user turns.\n- **Deterministic Behavior:** The workflow is fully predictable — input, reasoning, tool call, and output occur in a linear sequence.\n\n### Reflection pattern\n\nThe **Reflection Pattern** introduces a lightweight, two-agent communication loop designed to improve the quality and reliability of responses through structured self-review. In this setup, a **Primary Agent** first generates an initial response to the user’s query. This draft is then passed to a **Reviewer Agent**, whose role is to critique and refine the response—identifying gaps, inaccuracies, or missed context. Finally, the **Primary Agent** incorporates this feedback and produces a polished final answer for the user.\n\nThis process introduces one round of reflection and improvement without adding excessive latency, balancing quality with responsiveness.\n\n**Communication Flow:**\n\n1. **User Input → Primary Agent:** The user submits a query.\n2. **Primary Agent → Reviewer Agent:** The primary generates an initial draft and passes it to the reviewer.\n3. **Reviewer Agent → Primary Agent:** The reviewer provides feedback or suggested improvements.\n4. **Primary Agent → User:** The primary revises its response and sends the refined version back to the user.\n\n**Key Communication Principles:**\n\n- **Two-Stage Dialogue:** Structured interaction between Primary and Reviewer ensures each output undergoes quality assurance.\n- **Focused Review:** The Reviewer doesn’t recreate answers—it critiques and enhances, reducing redundancy.\n- **Stateful Context:** Both agents operate over the same shared memory, ensuring consistency between draft and revision.\n- **Deterministic Flow:** A single reflection round guarantees predictable latency while still improving answer quality.\n- **Transparent Traceability:** Each step—initial draft, feedback, and final output—is logged, allowing developers to audit reasoning or assess quality improvements over time.\n\n**In practice**, this pattern enables the system to reason about its own output before responding, yielding clearer, more accurate, and policy-aligned answers without requiring multiple independent retries.\n\n### Handoff Pattern\n\nWhen a user request arrives, the system first routes it through an **Intent Classifier** (or triage agent) to determine which domain specialist should handle the conversation. Once identified, control is handed off directly to that **Specialist Agent**, which uses its own tools, domain knowledge, and state context to respond.\n\nThis specialist continues to handle the user interaction **as long as the conversation stays within its domain**. If the user’s intent shifts — for example, moving from *billing* to *security* — the conversation is routed back to the Intent Classifier, which re-assigns it to the correct specialist agent.\n\nThis pattern reduces latency and maintains continuity by minimizing unnecessary routing. Each handoff is tracked through the shared state store, ensuring seamless context carry-over and full traceability of decisions.\n\n**Key Communication Principles:**\n\n- **Dynamic Routing:** The Intent Classifier routes user input to the right specialist domain.\n- **Domain Persistence:** The specialist remains active while the user stays within its domain.\n- **Context Continuity:** Conversation history and entities persist across agents through the shared state store.\n- **Traceable Handoffs:** Every routing decision is logged for observability and auditability.\n- **Low Latency:** Responses are faster since domain-appropriate agents handle queries directly.\n\n**In practice**, this means a user could begin a conversation about billing, continue seamlessly, and only be re-routed when switching topics — without losing any conversational context or history.\n\n### Magentic Pattern\n\nThe **Magentic Pattern** is designed for open-ended, multi-faceted tasks that require multiple agents to collaborate. It introduces a **Manager (Planner) Agent**, which interprets the user’s goal, breaks it into subtasks, and orchestrates multiple **Specialist Agents** to execute those subtasks.\n\nThe Manager creates and maintains a **Task Ledger**, which tracks the status, dependencies, and results of each specialist’s work. As specialists perform their tool calls or reasoning, the Manager monitors their progress, gathers intermediate outputs, and can dynamically re-plan, dispatch additional tasks, or adjust the overall workflow.\n\nWhen all subtasks are complete, the Manager synthesizes the combined results into a coherent final response for the user.\n\n**Key Communication Principles:**\n\n- **Centralized Orchestration:** The Manager coordinates all agent interactions and workflow logic.\n- **Parallel and Sequential Execution:** Specialists can work simultaneously or in sequence based on task dependencies.\n- **Task Ledger:** Acts as a transparent record of all task assignments, updates, and completions.\n- **Dynamic Re-planning:** The Manager can modify or extend workflows in real time based on intermediate findings.\n- **Shared Memory:** All agents access the same state store for consistent context and result sharing.\n- **Unified Output:** The Manager consolidates results into one response, ensuring coherence across multi-agent reasoning.\n\n**In practice**, Magentic orchestration enables complex reasoning where the system might combine insights from multiple agents — e.g., billing, product, and security — and present a unified recommendation or resolution to the user.\n\n## Choosing the Right Agent for Your Use Case\n\nSelecting the appropriate agent pattern hinges on the complexity of the task and the level of coordination required. As use cases evolve from straightforward queries to intricate, multi-step processes, the need for specialized orchestration increases. Below is a decision matrix to guide your choice:\n\n| Feature / Requirement | Single Agent | Reflection Agent | Handoff Pattern | Magentic Orchestration | | --- | --- | --- | --- | --- | | Handles simple, domain-bound tasks | ✔ | ✔ | ✖ | ✖ | | Supports review / quality assurance | ✖ | ✔ | ✖ | ✔ | | Multi-domain routing | ✖ | ✖ | ✔ | ✔ | | Open-ended / complex workflows | ✖ | ✖ | ✖ | ✔ | | Parallel agent collaboration | ✖ | ✖ | ✖ | ✔ | | Direct tool access | ✔ | ✔ | ✔ | ✔ | | Low latency / fast response | ✔ | ✔ | ✔ | ✖ | | Easy to implement / low orchestration | ✔ | ✔ | ✖ | ✖ |\n\n## Dive Deeper: Explore, Build, and Innovate\n\nWe've explored various agent patterns — from Single Agent to Magentic Orchestration — each tailored to different use cases and complexities. To see these patterns in action, we invite you to explore our [Github repo](https://github.com/microsoft/OpenAIWorkshop/tree/int-agentic/agentic_ai/agents/agent_framework). Clone the repo, experiment with the examples, and adapt them to your own scenarios.\n\nAdditionally, beyond the patterns discussed here, the [repository](https://github.com/microsoft/OpenAIWorkshop/tree/main/agentic_ai/workflow/fraud_detection) also features a **Human-in-the-Loop (HITL) workflow** designed for fraud detection. This workflow integrates human oversight into AI decision-making, ensuring higher accuracy and reliability. For an in-depth look at this approach, we recommend reading our detailed blog post: [Building Human-in-the-loop AI Workflows with Microsoft Agent Framework | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/azure-ai-foundry-blog/building-human-in-the-loop-ai-workflows-with-microsoft-agent-framework/4460342)\n\nEngage with these resources, and start building intelligent, reliable, and scalable AI systems today!\n\n```\n\n```\n\nUpdated Oct 22, 2025\n\nVersion 1.0\n\n[agents](/tag/agents?nodeId=board%3AAzureDevCommunityBlog)\n\n[ai](/tag/ai?nodeId=board%3AAzureDevCommunityBlog)\n\n[genai](/tag/genai?nodeId=board%3AAzureDevCommunityBlog)\n\n[llm](/tag/llm?nodeId=board%3AAzureDevCommunityBlog)\n\n[mcp](/tag/mcp?nodeId=board%3AAzureDevCommunityBlog)\n\n[!\\[heenaugale&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/m_assets/avatars/default/avatar-2.svg?image-dimensions=50x50)](/users/heenaugale/2858027) [heenaugale](/users/heenaugale/2858027) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined January 12, 2025\n\n[View Profile](/users/heenaugale/2858027)\n\n/category/azure/blog/azuredevcommunityblog [Microsoft Developer Community Blog](/category/azure/blog/azuredevcommunityblog) Follow this blog board to get notified when there's new activity",
  "OutputDir": "_community",
  "Description": "Building reliable AI systems requires modular, stateful coordination and deterministic workflows that enable agents to collaborate seamlessly. The Microsoft Agent Framework provides these foundations, with memory, tracing, and orchestration built in.\n\nThis implementation demonstrates four multi-agentic patterns — Single Agent, Handoff, Reflection, and Magentic Orchestration — showcasing different interaction models and collaboration strategies. From lightweight domain routing to collaborative planning and self-reflection, these patterns highlight the framework’s flexibility.\n\nAt the core is Model Context Protocol (MCP), connecting agents, tools, and memory through a shared context interface. Persistent session state, conversation thread history, and checkpoint support are handled via Cosmos DB when configured, with an in-memory dictionary as a default fallback. This setup enables dynamic pattern swapping, performance comparison, and traceable multi-agent interactions — all within a unified, modular runtime.\n\n## Business Scenario: Contoso Customer Support Chatbot\n\nContoso’s chatbot handles multi-domain customer inquiries like billing anomalies, promotion eligibility, account locks, and data usage questions. These require combining **structured data** (billing, CRM, security logs, promotions) with **unstructured policy documents** processed via vector embeddings.\n\nUsing **MCP**, the system orchestrates tool calls to fetch real-time structured data and relevant policy content, ensuring **policy-aligned, auditable responses** without exposing raw databases. This enables the assistant to explain anomalies, recommend actions, confirm eligibility, guide account recovery, and surface risk indicators—reducing handle time and improving first-contact resolution while supporting richer multi-agent reasoning.\n\n![]()\n\n## Architecture & Core Concepts\n\nThe Contoso chatbot leverages the **Microsoft Agent Framework** to deliver a modular, stateful, and workflow-driven architecture. At its core, the system consists of:\n\n- **Base Agent**: All agent patterns—single agent, reflection, handoff and magentic orchestration—inherit from a common base class, ensuring consistent interfaces for message handling, tool invocation, and state management.\n- **Backend**: A FastAPI backend manages session routing, agent execution, and workflow orchestration.\n- **Frontend**: A React-based UI (or Streamlit alternative) streams responses in real-time and visualizes agent reasoning and tool calls.\n\n### Modular Runtime and Pattern Swapping\n\nOne of the most powerful aspects of this implementation is its **modular runtime design**. Each agentic pattern—Single, Reflection, Handoff, and Magnetic—plugs into a shared execution pipeline defined by the base agent and MCP integration. By simply updating the .env configuration (e.g., agent\\_module=handoff), developers can **swap in and out entire coordination strategies** without touching the backend, frontend, or memory layers. This makes it easy to compare agent styles side by side, benchmark reasoning behaviors, and experiment with orchestration logic—all while maintaining a **consistent, deterministic runtime**. The same MCP connectors, FastAPI backend, and Cosmos/in-memory state management work seamlessly across every pattern, enabling rapid iteration and reliable evaluation.\n\n- # Dynamic agent pattern loading\nagent\\_module\\_path = os.getenv(\"AGENT\\_MODULE\") agent\\_module = \\_\\_import\\_\\_(agent\\_module\\_path, fromlist=[\"Agent\"]) Agent = getattr(agent\\_module, \"Agent\")\n- # Common MCP setup across all patterns\nasync def \\_create\\_tools(self, headers: Dict[str, str]) -> List[MCPStreamableHTTPTool] | None: if not self.mcp\\_server\\_uri: return None return [MCPStreamableHTTPTool( name=\"mcp-streamable\", url=self.mcp\\_server\\_uri, headers=headers, timeout=30, request\\_timeout=30, )]\n\n### Memory & State Management\n\nState management is critical for multi-turn conversations and cross-agent workflows. The system supports two out-of-the-box options:\n\n1. **Persistent Storage (Cosmos DB)**\n- Acts as the durable, enterprise-ready backend.\n- Stores serialized conversation threads and workflow checkpoints keyed by tenant and session ID.\n- Ensures data durability and auditability across restarts.\n2. **In-Memory Session Store**\n- Default fallback when Cosmos DB credentials are not configured.\n- Maintains ephemeral state per session for fast prototyping or lightweight use cases.\n\nAll patterns leverage the same **thread-based state abstraction**, enabling:\n\n- **Session isolation**: Each user session maintains its own state and history.\n- **Checkpointing**: Multi-agent workflows can snapshot shared and executor-local state at any point, supporting pause/resume and fault recovery.\n- **Model Context Protocol (MCP)**: Acts as the connector between agents and tools, standardizing how data is fetched and results are returned to agents, whether querying structured databases or unstructured knowledge sources.\n\n### Core Principles\n\nAcross all patterns, the framework emphasizes:\n\n- **Modularity**: Components are interchangeable—agents, tools, and state stores can be swapped without disrupting the system.\n- **Stateful Coordination**: Multi-agent workflows coordinate through shared and local state, enabling complex reasoning without losing context.\n- **Deterministic Workflows**: While agents operate autonomously, the workflow layer ensures predictable, auditable execution of multi-agent tasks.\n- **Unified Execution**: From single-agent Q&A to complex Magentic orchestrations, every agent follows the same execution lifecycle and integrates seamlessly with MCP and the state store.\n\n## Multi-Agent Patterns: Workflow and Coordination\n\nWith the architecture and core concepts established, we can now explore the **agentic patterns** implemented in the Contoso chatbot. Each pattern builds on the base agent and MCP integration but differs in how agents **orchestrate tasks** and **communicate** with one another to handle multi-domain customer queries.\n\nIn the sections that follow, we take a deeper dive into each pattern’s **workflow** and examine the **under-the-hood communication flows** between agents:\n\n1. **Single Agent** – A simple, single-domain agent handling straightforward queries.\n2. **Reflection Agent** – Allows agents to introspect and refine their outputs.\n3. **Handoff Pattern** – Routes conversations intelligently to specialized agents across domains.\n4. **Magentic Orchestration** – Coordinates multiple specialist agents for complex, parallel tasks.\n\nFor each pattern, the focus will be on **how agents communicate and coordinate**, showing the practical orchestration mechanisms in action.\n\n### Single Intelligent Agent\n\n![]()\n\nThe **Single Agent Pattern** represents the simplest orchestration style within the framework. Here, a single autonomous agent handles all reasoning, decision-making, and tool interactions directly — without delegation or multi-agent coordination.\n\nWhen a user submits a request, the single agent processes the query using all tools, memory, and data sources available through the **Model Context Protocol (MCP)**. It performs retrieval, reasoning, and response composition in a single, cohesive loop.\n\n**Communication Flow:**\n\n1. **User Input → Agent:** The user submits a question or command.\n2. **Agent → MCP Tools:** The agent invokes one or more tools (e.g., vector retrieval, structured queries, or API calls) to gather relevant context and data.\n3. **Agent → User:** The agent synthesizes the tool outputs, applies reasoning, and generates the final response to the user.\n4. **Session Memory:** Throughout the exchange, the agent stores conversation history and extracted entities in the configured memory store (in-memory or Cosmos DB).\n\n**Key Communication Principles:**\n\n- **Single Responsibility:** One agent performs both reasoning and action, ensuring fast response times and simpler state management.\n- **Direct Tool Invocation:** The agent has direct access to all registered tools through MCP, enabling flexible retrieval and action chaining.\n- **Stateful Execution:** The session memory preserves dialogue context, allowing the agent to maintain continuity across user turns.\n- **Deterministic Behavior:** The workflow is fully predictable — input, reasoning, tool call, and output occur in a linear sequence.\n\n### Reflection pattern\n\n![]()\n\nThe **Reflection Pattern** introduces a lightweight, two-agent communication loop designed to improve the quality and reliability of responses through structured self-review. In this setup, a **Primary Agent** first generates an initial response to the user’s query. This draft is then passed to a **Reviewer Agent**, whose role is to critique and refine the response—identifying gaps, inaccuracies, or missed context. Finally, the **Primary Agent** incorporates this feedback and produces a polished final answer for the user.\n\nThis process introduces one round of reflection and improvement without adding excessive latency, balancing quality with responsiveness.\n\n**Communication Flow:**\n\n1. **User Input → Primary Agent:** The user submits a query.\n2. **Primary Agent → Reviewer Agent:** The primary generates an initial draft and passes it to the reviewer.\n3. **Reviewer Agent → Primary Agent:** The reviewer provides feedback or suggested improvements.\n4. **Primary Agent → User:** The primary revises its response and sends the refined version back to the user.\n\n**Key Communication Principles:**\n\n- **Two-Stage Dialogue:** Structured interaction between Primary and Reviewer ensures each output undergoes quality assurance.\n- **Focused Review:** The Reviewer doesn’t recreate answers—it critiques and enhances, reducing redundancy.\n- **Stateful Context:** Both agents operate over the same shared memory, ensuring consistency between draft and revision.\n- **Deterministic Flow:** A single reflection round guarantees predictable latency while still improving answer quality.\n- **Transparent Traceability:** Each step—initial draft, feedback, and final output—is logged, allowing developers to audit reasoning or assess quality improvements over time.\n\n**In practice**, this pattern enables the system to reason about its own output before responding, yielding clearer, more accurate, and policy-aligned answers without requiring multiple independent retries.\n\n### Handoff Pattern\n\n![]()\n\nWhen a user request arrives, the system first routes it through an **Intent Classifier** (or triage agent) to determine which domain specialist should handle the conversation. Once identified, control is handed off directly to that **Specialist Agent**, which uses its own tools, domain knowledge, and state context to respond.\n\nThis specialist continues to handle the user interaction **as long as the conversation stays within its domain**. If the user’s intent shifts — for example, moving from *billing* to *security* — the conversation is routed back to the Intent Classifier, which re-assigns it to the correct specialist agent.\n\nThis pattern reduces latency and maintains continuity by minimizing unnecessary routing. Each handoff is tracked through the shared state store, ensuring seamless context carry-over and full traceability of decisions.\n\n**Key Communication Principles:**\n\n- **Dynamic Routing:** The Intent Classifier routes user input to the right specialist domain.\n- **Domain Persistence:** The specialist remains active while the user stays within its domain.\n- **Context Continuity:** Conversation history and entities persist across agents through the shared state store.\n- **Traceable Handoffs:** Every routing decision is logged for observability and auditability.\n- **Low Latency:** Responses are faster since domain-appropriate agents handle queries directly.\n\n**In practice**, this means a user could begin a conversation about billing, continue seamlessly, and only be re-routed when switching topics — without losing any conversational context or history.\n\n![]()\n\n### Magentic Pattern\n\n![]()\n\nThe **Magentic Pattern** is designed for open-ended, multi-faceted tasks that require multiple agents to collaborate. It introduces a **Manager (Planner) Agent**, which interprets the user’s goal, breaks it into subtasks, and orchestrates multiple **Specialist Agents** to execute those subtasks.\n\nThe Manager creates and maintains a **Task Ledger**, which tracks the status, dependencies, and results of each specialist’s work. As specialists perform their tool calls or reasoning, the Manager monitors their progress, gathers intermediate outputs, and can dynamically re-plan, dispatch additional tasks, or adjust the overall workflow.\n\nWhen all subtasks are complete, the Manager synthesizes the combined results into a coherent final response for the user.\n\n**Key Communication Principles:**\n\n- **Centralized Orchestration:** The Manager coordinates all agent interactions and workflow logic.\n- **Parallel and Sequential Execution:** Specialists can work simultaneously or in sequence based on task dependencies.\n- **Task Ledger:** Acts as a transparent record of all task assignments, updates, and completions.\n- **Dynamic Re-planning:** The Manager can modify or extend workflows in real time based on intermediate findings.\n- **Shared Memory:** All agents access the same state store for consistent context and result sharing.\n- **Unified Output:** The Manager consolidates results into one response, ensuring coherence across multi-agent reasoning.\n\n**In practice**, Magentic orchestration enables complex reasoning where the system might combine insights from multiple agents — e.g., billing, product, and security — and present a unified recommendation or resolution to the user.\n\n![]()\n\n## Choosing the Right Agent for Your Use Case\n\nSelecting the appropriate agent pattern hinges on the complexity of the task and the level of coordination required. As use cases evolve from straightforward queries to intricate, multi-step processes, the need for specialized orchestration increases. Below is a decision matrix to guide your choice:\n\n| Feature / Requirement | Single Agent | Reflection Agent | Handoff Pattern | Magentic Orchestration | | --- | --- | --- | --- | --- | | Handles simple, domain-bound tasks | ✔ | ✔ | ✖ | ✖ | | Supports review / quality assurance | ✖ | ✔ | ✖ | ✔ | | Multi-domain routing | ✖ | ✖ | ✔ | ✔ | | Open-ended / complex workflows | ✖ | ✖ | ✖ | ✔ | | Parallel agent collaboration | ✖ | ✖ | ✖ | ✔ | | Direct tool access | ✔ | ✔ | ✔ | ✔ | | Low latency / fast response | ✔ | ✔ | ✔ | ✖ | | Easy to implement / low orchestration | ✔ | ✔ | ✖ | ✖ |\n\n## Dive Deeper: Explore, Build, and Innovate\n\nWe've explored various agent patterns — from Single Agent to Magentic Orchestration — each tailored to different use cases and complexities. To see these patterns in action, we invite you to explore our [Github repo](https://github.com/microsoft/OpenAIWorkshop/tree/int-agentic/agentic_ai/agents/agent_framework). Clone the repo, experiment with the examples, and adapt them to your own scenarios.\n\nAdditionally, beyond the patterns discussed here, the [repository](https://github.com/microsoft/OpenAIWorkshop/tree/main/agentic_ai/workflow/fraud_detection) also features a **Human-in-the-Loop (HITL) workflow** designed for fraud detection. This workflow integrates human oversight into AI decision-making, ensuring higher accuracy and reliability. For an in-depth look at this approach, we recommend reading our detailed blog post: [Building Human-in-the-loop AI Workflows with Microsoft Agent Framework | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/azure-ai-foundry-blog/building-human-in-the-loop-ai-workflows-with-microsoft-agent-framework/4460342)\n\nEngage with these resources, and start building intelligent, reliable, and scalable AI systems today!\n\n```\n\n```",
  "Link": "https://techcommunity.microsoft.com/t5/microsoft-developer-community/orchestrating-multi-agent-intelligence-mcp-driven-patterns-in/ba-p/4462150"
}
