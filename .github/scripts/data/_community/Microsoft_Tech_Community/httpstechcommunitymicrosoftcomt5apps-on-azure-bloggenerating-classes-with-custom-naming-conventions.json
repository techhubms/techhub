{
  "FeedName": "Microsoft Tech Community",
  "Author": "daisami",
  "Tags": [],
  "EnhancedContent": "## GitHub Spark and GitHub Copilot are powerful development tools that can significantly boost productivity even when used out of the box. However, in enterprise settings, a common request is for development support that aligns with specific compliances or regulations. While GitHub Copilot allows you to choose models like GPT-4o or others, it does not currently support the use of custom fine-tuned models. Additionally, many users might find it unclear how to integrate Copilot with external services, which can be a source of frustration. To address such needs, one possible approach is to build a custom MCP server and connect it to GitHub Copilot.\n\nGitHub Spark and GitHub Copilot are powerful development tools that can significantly boost productivity even when used out of the box. However, in enterprise settings, a common request is for development support that aligns with specific compliances or regulations. While GitHub Copilot allows you to choose models like GPT-4o or others, it does not currently support the use of custom fine-tuned models. Additionally, many users might find it unclear how to integrate Copilot with external services, which can be a source of frustration. To address such needs, one possible approach is to build a custom MCP server and connect it to GitHub Copilot. For a basic “Hello World” style guide on how to set this up, please refer to the articles below.\n\n- [https://devblogs.microsoft.com/dotnet/build-a-model-context-protocol-mcp-server-in-csharp/](https://devblogs.microsoft.com/dotnet/build-a-model-context-protocol-mcp-server-in-csharp/)\n- [https://learn.microsoft.com/en-us/dotnet/ai/quickstarts/build-mcp-server](https://learn.microsoft.com/en-us/dotnet/ai/quickstarts/build-mcp-server)\n\nBy building an MCP server as an ASP.NET Core application and integrating it with GitHub Copilot, you can introduce custom rules and functionality tailored to your organization’s needs. The architecture for this post would look like the following:\n\nWhile the MCP server can technically be hosted anywhere as long as HTTP communication is possible, for enterprise use cases, it’s often recommended to deploy it within a **private endpoint** inside a **closed Virtual Network**. In production environments, this setup can be securely accessed from client machines via **ExpressRoute**, ensuring both compliance and network isolation.\n\n## Building an MCP Server Using ASP.NET Core\n\nStart by creating a new ASP.NET Core Web API project in Visual Studio. Then, install the required libraries via NuGet. Note: Make sure to enable the option to include **preview versions**—otherwise, some of the necessary packages may not appear in the list.\n\n- ModelContextProtocol\n- ModelContextProtocol.AspNetCore\n\nNext, update the Program.cs file as shown below to enable the MCP server functionality. We’ll create the NamingConventionManagerTool class later, but as you can see, it’s being registered via **Dependency Injection** during application startup. This allows it to be integrated as part of the MCP server’s capabilities.\n\n``` using MCPServerLab01.Tools;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.WebHost.ConfigureKestrel(servreOptions => { servreOptions.ListenAnyIP(8888); // you can change any port to adopt your environment });\n\nbuilder.Logging.AddConsole(consoleLogOptions => { consoleLogOptions.LogToStandardErrorThreshold = LogLevel.Trace; }); builder.Services.AddMcpServer() .WithHttpTransport() .WithTools<NamingConventionManagerTool>();\n\nvar app = builder.Build();\n\napp.MapMcp();\n\napp.Run(); ```\n\nNext, create the NamingConventionManagerTool.cs file. By decorating the class with the [McpServerToolType] and [McpServerTool] attributes, you can expose it as a feature accessible via the MCP server. In this example, we’ll add a tool that assigns class names based on business logic IDs—a common pattern in system integration projects. The class will include the following methods:\n\n- GetNamingRules: Provides an overview of the naming conventions to follow.\n- GenerateClassNamingConvention: Generates a class name based on a given business logic ID.\n- DetermineBusinessCategory: Extracts the business logic ID from a given class name.\n\nAs noted in the prompt, we’ll assume this is part of a fictional project called **Normalian Project**.\n\n``` using ModelContextProtocol.Server; using System.ComponentModel; using System.Text.Json.Serialization;\n\nnamespace MCPServerLab01.Tools;\n\n[McpServerToolType] [Description()] public class NamingConventionManagerTool { // Counter for sequential management // This is just a trial, so here is a static variable. For production, consider saving to a DB or other persistent storage. static int _counter = 0;\n\n[McpServerTool, Description(\"\"\" Provides Normalian Project rules that must be followed when adding or modifying programs. Be sure to refer to these rules as they are mandatory. \"\"\")] public string GetNamingRules() { return \"\"\" In this Normalian project, to facilitate management, class names must follow naming conventions based on business categories. Class names according to business categories are provided by the `GenerateClassNamingConvention` tool. Please define classes using the names provided here. Do not define classes with any other names.\n\nIf you are unsure about the business category from the class name, use the `DetermineBusinessCategory` tool to obtain the business category. \"\"\"; }\n\n[McpServerTool, Description(\"\"\" Retrieves a set of classes and namespaces that should be created for the specified business category in Normalian project. You must create classes using the names suggested here. \"\"\")] public ClassNamingConvention GenerateClassNamingConvention( [Description(\"Business category for the class to be created\")] BusinessCategory businessCategory) { var number = _counter++; var prefix = businessCategory switch { BusinessCategory.NormalianOrder => \"A\", BusinessCategory.NormalianProduct => \"B\", BusinessCategory.NormalianCustomer => \"C\", BusinessCategory.NormalianSupplier => \"D\", BusinessCategory.NormalianEmployee => \"E\", _ => throw new ArgumentException(\"Unknown category.\"), };\n\nvar name = $\"{prefix}{number:D4}\"; return new ClassNamingConvention( ServiceNamespace: \"{YourRootNamespace}.Services\", ServiceClassName: $\"{name}Service\", UsecaseNamespace: \"{YourRootNamespace}.Usecases\", UsecaseClassName: $\"{name}Usecase\", DtoNamespace: \"{YourRootNamespace}.Dtos\", DtoClassName: $\"{name}Dto\"); }\n\n[McpServerTool, Description(\"If you do not know the business category in Normalian project from the class name, check the naming convention to obtain the business category to which the class belongs.\")] public BusinessCategory DetermineBusinessCategory( [Description(\"Class name\")] string className) { ArgumentException.ThrowIfNullOrEmpty(className);\n\nvar prefix = className[0]; return prefix switch { 'A' => BusinessCategory.NormalianOrder, 'B' => BusinessCategory.NormalianProduct, 'C' => BusinessCategory.NormalianCustomer, 'D' => BusinessCategory.NormalianSupplier, 'E' => BusinessCategory.NormalianEmployee, _ => throw new ArgumentException(\"Unknown class name.\"), }; } }\n\n[Description(\"Class name to use in Normalian project\")] public record ClassNamingConvention( [Description(\"Service namespace\")] string ServiceNamespace, [Description(\"Class name to use for the service layer\")] string ServiceClassName, [Description(\"Usecase namespace\")] string UsecaseNamespace, [Description(\"Class name to use for the usecase layer\")] string UsecaseClassName, [Description(\"DTO namespace\")] string DtoNamespace, [Description(\"Class name to use for DTOs\")] string DtoClassName);\n\n[JsonConverter(typeof(JsonStringEnumConverter))] public enum BusinessCategory { NormalianOrder, NormalianProduct, NormalianCustomer, NormalianSupplier, NormalianEmployee, } ```\n\nNext, run the project in Visual Studio to launch the MCP server as an ASP.NET Core application. Once the application starts, take note of the HTTP endpoint displayed in the console or output window as follows —this will be used to interact with the MCP server.\n\n## Connecting GitHub Copilot Agent to the MCP Server\n\nNext, connect the GitHub Copilot Agent to the MCP server. You can easily connect the GitHub Copilot Agent by simply specifying the MCP server's endpoint. To add the server, select Agent mode and click the wrench icon as shown below.\n\nFrom **Add MCP Server**, select HTTP and specify http://localhost:&lt;&lt;PORT&gt;&gt;/sse endpoint. Give it an appropriate name, then choose where to save the MCP server settings—either **User Settings** or **Workspace Settings**. If you will use it just for yourself, **User Settings** should be fine. However, selecting **Workspace Settings** is useful when you want to share the configuration with your team. Since this is just a trial and we only want to use it within this workspace, we chose **Workspace Settings**. This will create a .vscode/mcp.json file with the following content:\n\n``` { \"servers\": { \"mine-mcp-server\": { \"type\": \"sse\", \"url\": \"http://localhost:8888/sse\" } }, \"inputs\": [] } ```\n\nYou'll see a **Start** icon on top of the JSON file—click it to launch the MCP server. Once started, the MCP server will run as shown below. You can also start it from the GitHub Copilot Chat window.\n\nAfter launching, if you click the wrench icon in the Chat window, you'll see a list of tools available on the connected MCP server.\n\n## Using the Created Features via GitHub Copilot Agent\n\nNow, let’s try it out. Open the folder of your .NET console app project in VS Code, and make a request to the Agent like the one shown below.\n\nIt’s doing a great job trying to check the rules. Next, it continues by trying to figure out the class name and other details needed for implementation.\n\nThen, following the naming conventions, it looks up the appropriate namespace and even starts creating folders. Once the folder is created, the class is properly generated with the specified class name.\n\nEven when you ask about the business category, it uses the tool correctly to look it up. Impressive!\n\n## Conclusion\n\nIn this article, we introduced how to build your own MCP server and use it via the GitHub Copilot Agent. By implementing an MCP server and adding tools tailored to your business needs, you can gain a certain level of control over the Agent’s behavior and build your own ecosystem. For this trial, we used a local machine to test the behavior, but for production use, you'll need to consider deploying the MCP server to Azure, adding authentication features, and other enhancements.\n\nUpdated Aug 19, 2025\n\nVersion 1.0\n\n[.net core](/tag/.net%20core?nodeId=board%3AAppsonAzureBlog)\n\n[azure app service](/tag/azure%20app%20service?nodeId=board%3AAppsonAzureBlog)\n\n[web apps](/tag/web%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[daisami&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS00Nzk2OTItMjM1NDE4aUUyRDFCMDFGQ0EzRDgwMkE?image-dimensions=50x50)](/users/daisami/479692) [daisami](/users/daisami/479692) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined December 06, 2019\n\n[View Profile](/users/daisami/479692)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "OutputDir": "_community",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Title": "Generating Classes with Custom Naming Conventions Using GitHub Copilot and a Custom MCP Server",
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/generating-classes-with-custom-naming-conventions-using-github/ba-p/4444837",
  "PubDate": "2025-08-19T16:26:20+00:00",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Description": "GitHub Spark and GitHub Copilot are powerful development tools that can significantly boost productivity even when used out of the box. However, in enterprise settings, a common request is for development support that aligns with specific compliances or regulations. While GitHub Copilot allows you to choose models like GPT-4o or others, it does not currently support the use of custom fine-tuned models. Additionally, many users might find it unclear how to integrate Copilot with external services, which can be a source of frustration. To address such needs, one possible approach is to build a custom MCP server and connect it to GitHub Copilot. For a basic “Hello World” style guide on how to set this up, please refer to the articles below.\n\n- [https://devblogs.microsoft.com/dotnet/build-a-model-context-protocol-mcp-server-in-csharp/](https://devblogs.microsoft.com/dotnet/build-a-model-context-protocol-mcp-server-in-csharp/)\n- [https://learn.microsoft.com/en-us/dotnet/ai/quickstarts/build-mcp-server](https://learn.microsoft.com/en-us/dotnet/ai/quickstarts/build-mcp-server)\n\nBy building an MCP server as an ASP.NET Core application and integrating it with GitHub Copilot, you can introduce custom rules and functionality tailored to your organization’s needs. The architecture for this post would look like the following:\n\n![]()\n\nWhile the MCP server can technically be hosted anywhere as long as HTTP communication is possible, for enterprise use cases, it’s often recommended to deploy it within a **private endpoint** inside a **closed Virtual Network**. In production environments, this setup can be securely accessed from client machines via **ExpressRoute**, ensuring both compliance and network isolation.\n\n## Building an MCP Server Using ASP.NET Core\n\nStart by creating a new ASP.NET Core Web API project in Visual Studio. Then, install the required libraries via NuGet. Note: Make sure to enable the option to include **preview versions**—otherwise, some of the necessary packages may not appear in the list.\n\n- ModelContextProtocol\n- ModelContextProtocol.AspNetCore\n\nNext, update the Program.cs file as shown below to enable the MCP server functionality. We’ll create the NamingConventionManagerTool class later, but as you can see, it’s being registered via **Dependency Injection** during application startup. This allows it to be integrated as part of the MCP server’s capabilities.\n\n- using MCPServerLab01.Tools;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.WebHost.ConfigureKestrel(servreOptions => { servreOptions.ListenAnyIP(8888); // you can change any port to adopt your environment });\n\nbuilder.Logging.AddConsole(consoleLogOptions => { consoleLogOptions.LogToStandardErrorThreshold = LogLevel.Trace; }); builder.Services.AddMcpServer() .WithHttpTransport() .WithTools();\n\nvar app = builder.Build();\n\napp.MapMcp();\n\napp.Run();\n\nNext, create the NamingConventionManagerTool.cs file. By decorating the class with the [McpServerToolType] and [McpServerTool] attributes, you can expose it as a feature accessible via the MCP server. In this example, we’ll add a tool that assigns class names based on business logic IDs—a common pattern in system integration projects. The class will include the following methods:\n\n- GetNamingRules: Provides an overview of the naming conventions to follow.\n- GenerateClassNamingConvention: Generates a class name based on a given business logic ID.\n- DetermineBusinessCategory: Extracts the business logic ID from a given class name.\n\nAs noted in the prompt, we’ll assume this is part of a fictional project called **Normalian Project**.\n- using ModelContextProtocol.Server;\nusing System.ComponentModel; using System.Text.Json.Serialization;\n\nnamespace MCPServerLab01.Tools;\n\n[McpServerToolType] [Description()] public class NamingConventionManagerTool { // Counter for sequential management // This is just a trial, so here is a static variable. For production, consider saving to a DB or other persistent storage. static int \\_counter = 0;\n\n[McpServerTool, Description(\"\"\" Provides Normalian Project rules that must be followed when adding or modifying programs. Be sure to refer to these rules as they are mandatory. \"\"\")] public string GetNamingRules() { return \"\"\" In this Normalian project, to facilitate management, class names must follow naming conventions based on business categories. Class names according to business categories are provided by the `GenerateClassNamingConvention` tool. Please define classes using the names provided here. Do not define classes with any other names.\n\nIf you are unsure about the business category from the class name, use the `DetermineBusinessCategory` tool to obtain the business category. \"\"\"; }\n\n[McpServerTool, Description(\"\"\" Retrieves a set of classes and namespaces that should be created for the specified business category in Normalian project. You must create classes using the names suggested here. \"\"\")] public ClassNamingConvention GenerateClassNamingConvention( [Description(\"Business category for the class to be created\")] BusinessCategory businessCategory) { var number = \\_counter++; var prefix = businessCategory switch { BusinessCategory.NormalianOrder => \"A\", BusinessCategory.NormalianProduct => \"B\", BusinessCategory.NormalianCustomer => \"C\", BusinessCategory.NormalianSupplier => \"D\", BusinessCategory.NormalianEmployee => \"E\", \\_ => throw new ArgumentException(\"Unknown category.\"), };\n\nvar name = $\"{prefix}{number:D4}\"; return new ClassNamingConvention( ServiceNamespace: \"{YourRootNamespace}.Services\", ServiceClassName: $\"{name}Service\", UsecaseNamespace: \"{YourRootNamespace}.Usecases\", UsecaseClassName: $\"{name}Usecase\", DtoNamespace: \"{YourRootNamespace}.Dtos\", DtoClassName: $\"{name}Dto\"); }\n\n[McpServerTool, Description(\"If you do not know the business category in Normalian project from the class name, check the naming convention to obtain the business category to which the class belongs.\")] public BusinessCategory DetermineBusinessCategory( [Description(\"Class name\")] string className) { ArgumentException.ThrowIfNullOrEmpty(className);\n\nvar prefix = className[0]; return prefix switch { 'A' => BusinessCategory.NormalianOrder, 'B' => BusinessCategory.NormalianProduct, 'C' => BusinessCategory.NormalianCustomer, 'D' => BusinessCategory.NormalianSupplier, 'E' => BusinessCategory.NormalianEmployee, \\_ => throw new ArgumentException(\"Unknown class name.\"), }; } }\n\n[Description(\"Class name to use in Normalian project\")] public record ClassNamingConvention( [Description(\"Service namespace\")] string ServiceNamespace, [Description(\"Class name to use for the service layer\")] string ServiceClassName, [Description(\"Usecase namespace\")] string UsecaseNamespace, [Description(\"Class name to use for the usecase layer\")] string UsecaseClassName, [Description(\"DTO namespace\")] string DtoNamespace, [Description(\"Class name to use for DTOs\")] string DtoClassName);\n\n[JsonConverter(typeof(JsonStringEnumConverter))] public enum BusinessCategory { NormalianOrder, NormalianProduct, NormalianCustomer, NormalianSupplier, NormalianEmployee, }\n\nNext, run the project in Visual Studio to launch the MCP server as an ASP.NET Core application. Once the application starts, take note of the HTTP endpoint displayed in the console or output window as follows —this will be used to interact with the MCP server.\n\n![]()\n\n## Connecting GitHub Copilot Agent to the MCP Server\n\nNext, connect the GitHub Copilot Agent to the MCP server. You can easily connect the GitHub Copilot Agent by simply specifying the MCP server's endpoint. To add the server, select Agent mode and click the wrench icon as shown below.\n\n![]()\n\nFrom **Add MCP Server**, select HTTP and specify http://localhost:>/sse endpoint. Give it an appropriate name, then choose where to save the MCP server settings—either **User Settings** or **Workspace Settings**. If you will use it just for yourself, **User Settings** should be fine. However, selecting **Workspace Settings** is useful when you want to share the configuration with your team. Since this is just a trial and we only want to use it within this workspace, we chose **Workspace Settings**. This will create a .vscode/mcp.json file with the following content:\n- {\n\"servers\": { \"mine-mcp-server\": { \"type\": \"sse\", \"url\": \"http://localhost:8888/sse\" } }, \"inputs\": [] }\n\nYou'll see a **Start** icon on top of the JSON file—click it to launch the MCP server. Once started, the MCP server will run as shown below. You can also start it from the GitHub Copilot Chat window.\n\n![]()\n\nAfter launching, if you click the wrench icon in the Chat window, you'll see a list of tools available on the connected MCP server.\n\n![]()\n\n## Using the Created Features via GitHub Copilot Agent\n\nNow, let’s try it out. Open the folder of your .NET console app project in VS Code, and make a request to the Agent like the one shown below.\n\n![]()\n\nIt’s doing a great job trying to check the rules. Next, it continues by trying to figure out the class name and other details needed for implementation.\n\n![]()\n\nThen, following the naming conventions, it looks up the appropriate namespace and even starts creating folders. Once the folder is created, the class is properly generated with the specified class name.\n\n![]()\n\nEven when you ask about the business category, it uses the tool correctly to look it up. Impressive!\n\n![]()\n\n## Conclusion\n\nIn this article, we introduced how to build your own MCP server and use it via the GitHub Copilot Agent. By implementing an MCP server and adding tools tailored to your business needs, you can gain a certain level of control over the Agent’s behavior and build your own ecosystem. For this trial, we used a local machine to test the behavior, but for production use, you'll need to consider deploying the MCP server to Azure, adding authentication features, and other enhancements.",
  "ProcessedDate": "2025-08-19 17:11:44"
}
