{
  "Tags": [],
  "Title": "Jump Starting Quantum Computing on Azure",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "ProcessedDate": "2025-10-14 00:10:18",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Description": "### Why Quantum, Why Now\n\nQuantum mechanics already powers everyday tech: it explains semiconductors (transistors, LEDs) that drive modern electronics and communications, and it enables MRI through nuclear magnetic resonance. These successes show how quantum theory shapes technology — yet **quantum computing** is different. It brings quantum effects directly into computation itself.\n\nIn this article, we’ll first introduce the minimal math you need for quantum computing — just enough to build intuition. Then we’ll walk through the simplest signature protocol, **quantum teleportation**, and finish by running a working example on **Azure Quantum**.\n\n## Classical vs. Quantum: a quick view\n\n**Intuition.** If a classical bit is a coin lying heads or tails, a **qubit** is like a coin **spinning** in the air until you catch it.\n\n- **Classical bit:** always **0** or **1**.\n- **Qubit:** can be **0**, **1**, or *a blend of* both until measured; measuring “catches” it as 0 or 1.\n\n**How programs are built**\n\n- **Classical stack:** transistors → logic gates (AND/OR/NOT) → flip-flops & registers → instruction sets → high-level languages.\n- **Quantum stack:** physical qubits (ions, superconducting circuits, photons) → quantum gates (H for superposition, **CNOT** for entangling) → circuits & algorithms → SDKs (Qiskit, Q#, Cirq, Braket).\n\n**Key difference**\n\nClassical gates manipulate definite bits. Quantum gates manipulate **probability amplitudes** and **correlations** (entanglement), enabling behaviors no classical circuit can replicate efficiently.\n\n![]()In this article we use the common convention: |0⟩≡[1,0]^T, |1⟩≡[0,1]^T. Some books swap the order; that just relabels 0 and 1 and doesn’t change any results.\n\n## What Is a Qubit?\n\nA **qubit** is a physical system that has two distinguished states we call **|0⟩** and **|1⟩**. These are the “reference” states used for preparation and measurement — just like **0** and **1** for a classical bit. In math, the same states are written as the column vectors [1,0]^T and [0,1]^T. When you measure a qubit, the device reports either 0 or 1 relative to these states. Everything else you’ll see later (superposition and entanglement) is built from these two building blocks.\n\n## Superposition & Entanglement\n\n![]()Example of superposition: **|+⟩** and |−⟩ are the eigenvectors of the Pauli-X operator (σx​, also written Sx​); shown here only as a typical example of superposed qubit states.\n\nExample of Entanglement:\n\nThe order of qubits in a multi-qubit state can depend on the **endianness convention**. In some quantum-computing frameworks, the **leftmost bit is the *least significant qubit***, so |01⟩ means “qubit 0 = 1, qubit 1 = 0.” Other texts (especially in physics) treat the **leftmost symbol as the *first particle***.\n\n#### Superposition\n\nA qubit can be in a combination of |0⟩ and |1⟩ at the same time, *parallel possibilities*.\n\nIntuitively, you can picture a qubit as a tiny arrow on a sphere (the *Bloch sphere*).\n\n- If the arrow points straight down, the qubit is in |0⟩.\n- If it points straight up, it’s in |1⟩.\n- Anywhere else on the sphere means the qubit is in some mix of 0 and 1.\n\nMeasuring the qubit is like “checking” which direction the arrow favors: you’ll get 0 or 1 with probabilities set by its position.\n\n#### Entanglement\n\nEntanglement is a strong correlation between qubits that defies everyday intuition. Measure one, and you learn something instantaneously about the other, even if they’re far apart. It's an incredibly useful resource for algorithms and quantum communication.\n\nThe example of an entangled state is the Bell State, which is shown above. Here |00⟩ and |11⟩ are two of the four basis states of a **two-qubit system** (a 4-dimensional state space).\n\nBell state designates that the probability of being |00⟩ and |11⟩ are 50/50. Measuring both qubits gives:\n\n- **00** with probability **1/2**\n- **11** with probability **1/2**\n- **01** and **10** with probability **0**\n\n## Fundamentals of Quantum Gates and Circuits\n\nJust as classical computers use logic gates such as **AND** or **NAND**, quantum computers also use **quantum gates**. Consider a 2 qubit-system: Operate Hadamard gate to the 1st qubit (creates H|0⟩), then operate CNOT creates an Entanglement state:\n\n- **Hadamard (H):** used to create a **superposition** from a computational basis state |0⟩ or |1⟩\n- **CNOT:** Flips the **target qubit** if the **control qubit** is |1⟩. This gate is essential for creating **entanglement**.\nFor example, if you first apply a Hadamard gate to one qubit in a two-qubit system and then apply a CNOT (with the first qubit as control and the second as target), the two qubits become **entangled**.\n\nImagine you have **two coins** that can be heads (0) or tails (1).\n\n1. You first “spin” the **first coin** (this is what the **Hadamard gate** does). While it’s spinning, it’s both heads and tails at once.\n2. Then you use a special rule — the **CNOT gate** — that says:![]()A Hadamard on the first qubit creates |+⟩; applying CNOT (control = first, target = second) turns |+⟩⊗|0⟩ into the entangled state 1/sqrt2(|00⟩+|11⟩).\n*“If the first coin would land tails (1), flip the second coin; if it would land heads (0), leave the second co* *in alone.”*\n\nBecause the first coin was spinning (0 and 1 at the same time), this rule makes the **two coins become linked**:\n\n- If the first ends up heads, the second is heads.\n- If the first ends up tails, the second is tails.\n\nAfter this step, they are no longer independent. They’re in a single **shared quantum state**:\n\nThat’s what “entangled” means — even if you separate them, measuring one instantly tells you what the other will be, because they’re described by **one joint state**, not two separate ones.\n\n## Quantum Teleportation\n\n#### What it does\n\nConsider **Alice** who sends a qubit's state to **Bob**. To teleport a qubit’s state, Alice and Bob first create an **entangled pair**: start with two |0⟩ qubits, apply a **Hadamard** to the first, then a **CNOT** from the first to the second. Alice then takes the **unknown qubit** she wants to send, applies a **CNOT** from it to her half of the pair, and a **Hadamard** on it. Measuring these two qubits gives Alice two classical bits. She sends those bits to Bob, who uses them to decide whether to apply a **Z** and/or an **X** gate to his qubit. After that, Bob’s qubit ends up in exactly the same state Alice started with.\n\n![]()\n\nIn this scenario, the teleportation protocol you see here moves only a single qubit’s state. To send larger quantum information, the process must be repeated — one entangled pair and two classical bits for each qubit to be teleported.\n\n#### What This is Meant\n\nImagine **Alice** has a single qubit in some unknown quantum state — a fragile, special “arrow on a sphere” that she wants to send to **Bob**, who is far away. She *can’t* just copy the qubit and email the file; quantum states can’t be cloned. She also *can’t* just measure it and tell Bob the result, because a measurement destroys the state and only gives her one bit of information.\n\nSo instead, Alice and Bob start with a clever trick: **beforehand they share an entangled pair of qubits**. Think of this pair as two perfectly correlated “quantum coins,” one with Alice and one with Bob. This shared entanglement is like a secret quantum bridge between them.\n\nWhen Alice wants to send her qubit’s state:\n\n1. **Alice performs a special joint measurement** on her unknown qubit and her half of the entangled pair.\nThis step destroys her original qubit (so the state doesn’t exist twice) but produces two ordinary bits of classical information — just 0s and 1s.\n2. **Alice sends those two classical bits** to Bob over a normal communication channel (email, phone, fiber optic cable — anything works, because these are just regular bits now).\n3. **Bob uses those two bits** to decide which simple quantum operation to perform on his half of the entangled pair.\nAfter he does this, his qubit **becomes an exact copy of the state** **Alice started with** — even though the original qubit was destroyed.\n\n#### Why It Matters\n\n- It shows that **superposition and entanglement** aren’t just weird physics but can be turned into real information-handling protocols.\n- It’s a **key building block for a future “quantum internet”**, where quantum states can be sent across long distances.\n- It underpins **secure quantum communication**, since the original state is never copied and eavesdroppers can’t intercept without being noticed.\n\n## Try it on Azure Quantum\n\nFirst, create an **Azure Quantum workspace** — the free **Quick create** option is fine. Once the workspace is provisioned, open the **Azure portal**, navigate to your workspace, and copy its **Resource ID**.\n\n![]()\n\nIf you’re comfortable with Python, we’ll use **Qiskit** to submit a job. In **VS Code**, install the **Azure Quantum Development Kit (QDK)** extension, then install the required Python packages for your environment. This combination lets you write, run, and submit quantum circuits directly from VS Code with minimal setup.\n\n- python -m pip install --upgrade azure-quantum[qiskit] qsharp ipykernel matplotlib pylatexenc\n\n#### Start a notebook in VS Code\n\nOpen a new Jupyter notebook in **VS Code** and begin your Python setup. In the first cell, **import the packages** and set your **Resource ID** (from the previous step) and the **workspace location**.\n- from azure.quantum import Workspace\nfrom qiskit import QuantumCircuit from qiskit.visualization import plot\\_histogram from azure.quantum.qiskit import AzureQuantumProvider import os from dotenv import load\\_dotenv load\\_dotenv(override=True)\n\nworkspace = Workspace( resource\\_id = os.getenv(\"RESOURCE\\_ID\"), # Add the resourceID of your workspace location = os.getenv(\"LOCATION\") # Add the location of your workspace (for example \"westus\") )\n\nprovider = AzureQuantumProvider(workspace)\n\n2nd cell is to prepare the quantum circuit for Quantum Teleportation. Line1 creates a quantum circuit with 3 qubits and 3 classical bits. In quantum teleportation, we need:\n\n- Qubit 0: The qubit whose state we want to teleport\n- Qubit 1: Alice's part of the entangled pair\n- Qubit 2: Bob's part of the entangled pair\n\nLine 3 sets up the state to Teleport. This applies an X gate (NOT gate) to qubit 0, putting it in the |1⟩ state. This is the quantum state that Alice wants to teleport to Bob. The comment notes this is optional - you could teleport any quantum state, but |1⟩ is chosen as a simple example.\n\nLine4 is just a separator for better readability.\n\nThe combination of Line6 and Line 7 creates an entanglement pair as explained in the previous paragraph. In these statements, \"h(n)\" means Hadamard gate, and \"cx(n)\" indicates CNOT gate.\n\nLine 14; This line performs the measurement of Alice's two qubits (qubit 0 and qubit 1):\n\n- First argument [0, 1]: List of quantum bits to measure (qubit 0 and qubit 1)\n- Second argument [0, 1]: List of classical bits to store the results (classical bit 0 and classical bit 1)\n- circuit = QuantumCircuit(3,3)\n\ncircuit.x(0) circuit.barrier()\n\ncircuit.h(1) circuit.cx(1,2) circuit.barrier()\n\ncircuit.cx(0,1) circuit.h(0) circuit.barrier()\n\ncircuit.measure([0, 1], [0, 1]) circuit.barrier()\n\ncircuit.cx(1, 2) circuit.cz(0, 2) circuit.measure([2], [2]) circuit.draw(output='mpl')\n\nWhen you run the cell, it produces an output of the quantum circuit of Teleportation.\n\n![]()\n\nWhile Qiskit itself provides a simulator, I used the simulator provided by the quantum hardware providers. By running the following cell, you can have a list of backend simulators.\n- print(\"This workspace's targets:\")\nfor backend in provider.backends(): print(\"- \" + backend.name())\n\noutput\n- This workspace's targets:\n- quantinuum.sim.h1-1sc\n- quantinuum.sim.h1-1e\n- rigetti.sim.qvm\n- quantinuum.sim.h1-1sc\n- quantinuum.sim.h1-1e\n- rigetti.sim.qvm\n\nAs the list may vary depending on the region and the plan of the workspace, you need to confirm by yourself. I chose and set \"quantinuum.sim.h1-1e\" to run a job.\n- simulator\\_backend = provider.get\\_backend(\"quantinuum.sim.h1-1e\")\n\nFinally submitting a job using the following cell code.\n- # Submit the circuit to run on Azure Quantum\njob = simulator\\_backend.run(circuit, shots=1024) job\\_id = job.id() print(\"Job id\", job\\_id)\n\n# Get the job results (this method waits for the Job to complete):\nresult = job.result() print(result) counts = {format(n, \"03b\"): 0 for n in range(8)} counts.update(result.get\\_counts(circuit)) print(counts) plot\\_histogram(counts)\n\nThe output should show the graph similar to the following image. If your output showed different pattern, change the backend simulator.\n\n![]()\n\nIn Qiskit endian format,\n\n- **1st digit (leftmost)**: Result of qubit 2 (Bob's qubit)\n- **2nd digit (middle)**: Result of qubit 1 (Alice's entangled qubit)\n- **3rd digit (rightmost)**: Result of qubit 0 (original state qubit)\n\nSince we initially set qubit 0 to |1⟩ state and want to teleport it to qubit 2, we should see these measurement patterns:\n\n- **100**: Qubit 2 = |1⟩ (teleportation successful), Alice measured 00\n- **101**: Qubit 2 = |1⟩ (teleportation successful), Alice measured 01\n- **110**: Qubit 2 = |1⟩ (teleportation successful), Alice measured 10\n- **111**: Qubit 2 = |1⟩ (teleportation successful), Alice measured 11\n\n## Conclusion\n\nQuantum computing turns **superposition** and **entanglement** into working tools. In this post you built intuition for **qubits** and **gates**, created a **Bell state** with **H + CNOT**, and walked through **quantum teleportation**, finishing with a run on **Azure Quantum**. Today’s devices are small and noisy, but capabilities are steadily improving.\n\nWhy watch this field? Algorithms like **Shor’s Algorithm**—which can factor large integers efficiently—strike at the foundation of widely used public-key cryptography (e.g., RSA). While fault-tolerant machines aren’t here yet, the prospect of breaking current encryption is a concrete, high-impact milestone that keeps quantum progress consequential. Add potential gains in optimization and materials discovery, and the direction is clear: as hardware and error-handling advance, practical breakthroughs will follow. Keep an eye on quantum computing—the next meaningful steps may arrive sooner than expected.",
  "EnhancedContent": "## Quantum computers use the weird rules of quantum physics - superposition and entanglement - to process information in new ways. They won’t replace your laptop, but they could supercharge specific tasks like search, optimization, materials discovery, and cryptanalysis. We’re still in early days, with real challenges around errors and scaling hardware, yet progress is steady and exciting.\n\n### Why Quantum, Why Now\n\nQuantum mechanics already powers everyday tech: it explains semiconductors (transistors, LEDs) that drive modern electronics and communications, and it enables MRI through nuclear magnetic resonance. These successes show how quantum theory shapes technology — yet **quantum computing** is different. It brings quantum effects directly into computation itself.\n\nIn this article, we’ll first introduce the minimal math you need for quantum computing — just enough to build intuition. Then we’ll walk through the simplest signature protocol, **quantum teleportation**, and finish by running a working example on **Azure Quantum**.\n\n## Classical vs. Quantum: a quick view\n\n**Intuition.** If a classical bit is a coin lying heads or tails, a **qubit** is like a coin **spinning** in the air until you catch it.\n\n- **Classical bit:** always **0** or **1**.\n- **Qubit:** can be **0**, **1**, or *a blend of* both until measured; measuring “catches” it as 0 or 1.\n\n**How programs are built**\n\n- **Classical stack:** transistors → logic gates (AND/OR/NOT) → flip-flops & registers → instruction sets → high-level languages.\n- **Quantum stack:** physical qubits (ions, superconducting circuits, photons) → quantum gates (H for superposition, **CNOT** for entangling) → circuits & algorithms → SDKs (Qiskit, Q#, Cirq, Braket).\n\n**Key difference**\n\nClassical gates manipulate definite bits. Quantum gates manipulate **probability amplitudes** and **correlations** (entanglement), enabling behaviors no classical circuit can replicate efficiently.\n\nIn this article we use the common convention: |0⟩≡[1,0]^T, |1⟩≡[0,1]^T. Some books swap the order; that just relabels 0 and 1 and doesn’t change any results.\n\n## What Is a Qubit?\n\nA **qubit** is a physical system that has two distinguished states we call **|0⟩** and **|1⟩**. These are the “reference” states used for preparation and measurement — just like **0** and **1** for a classical bit. In math, the same states are written as the column vectors [1,0]^T and [0,1]^T. When you measure a qubit, the device reports either 0 or 1 relative to these states. Everything else you’ll see later (superposition and entanglement) is built from these two building blocks.\n\n## Superposition & Entanglement\n\nExample of superposition: **|+⟩** and |−⟩ are the eigenvectors of the Pauli-X operator (σx​, also written Sx​); shown here only as a typical example of superposed qubit states.\n\nExample of Entanglement:\n\nThe order of qubits in a multi-qubit state can depend on the **endianness convention**. In some quantum-computing frameworks, the **leftmost bit is the *least significant qubit***, so |01⟩ means “qubit 0 = 1, qubit 1 = 0.” Other texts (especially in physics) treat the **leftmost symbol as the *first particle***.\n\n#### Superposition\n\nA qubit can be in a combination of |0⟩ and |1⟩ at the same time, *parallel possibilities*.\n\nIntuitively, you can picture a qubit as a tiny arrow on a sphere (the *Bloch sphere*).\n\n- If the arrow points straight down, the qubit is in |0⟩.\n- If it points straight up, it’s in |1⟩.\n- Anywhere else on the sphere means the qubit is in some mix of 0 and 1.\n\nMeasuring the qubit is like “checking” which direction the arrow favors: you’ll get 0 or 1 with probabilities set by its position.\n\n#### Entanglement\n\nEntanglement is a strong correlation between qubits that defies everyday intuition. Measure one, and you learn something instantaneously about the other, even if they’re far apart. It's an incredibly useful resource for algorithms and quantum communication.\n\nThe example of an entangled state is the Bell State, which is shown above. Here |00⟩ and |11⟩ are two of the four basis states of a **two-qubit system** (a 4-dimensional state space).\n\nBell state designates that the probability of being |00⟩ and |11⟩ are 50/50. Measuring both qubits gives:\n\n- **00** with probability **1/2**\n- **11** with probability **1/2**\n- **01** and **10** with probability **0**\n\n## Fundamentals of Quantum Gates and Circuits\n\nJust as classical computers use logic gates such as **AND** or **NAND**, quantum computers also use **quantum gates**. Consider a 2 qubit-system:  Operate Hadamard gate to the 1st qubit (creates H|0⟩), then operate CNOT creates an Entanglement state:\n\n- **Hadamard (H):** used to create a **superposition** from a computational basis state |0⟩ or |1⟩\n- **CNOT:** Flips the **target qubit** if the **control qubit** is |1⟩. This gate is essential for creating **entanglement**.\nFor example, if you first apply a Hadamard gate to one qubit in a two-qubit system and then apply a CNOT (with the first qubit as control and the second as target), the two qubits become **entangled**.\n\nImagine you have **two coins** that can be heads (0) or tails (1).\n\n1. You first “spin” the **first coin** (this is what the **Hadamard gate** does). While it’s spinning, it’s both heads and tails at once.\n2. Then you use a special rule — the **CNOT gate** — that says:A Hadamard on the first qubit creates |+⟩; applying CNOT (control = first, target = second) turns |+⟩⊗|0⟩ into the entangled state 1/sqrt2(|00⟩+|11⟩).\n*“If the first coin would land tails (1), flip the second coin; if it would land heads (0), leave the second co* *in alone.”*\n\nBecause the first coin was spinning (0 and 1 at the same time), this rule makes the **two coins become linked**:\n\n- If the first ends up heads, the second is heads.\n- If the first ends up tails, the second is tails.\n\nAfter this step, they are no longer independent. They’re in a single **shared quantum state**:\n\nThat’s what “entangled” means — even if you separate them, measuring one instantly tells you what the other will be, because they’re described by **one joint state**, not two separate ones.\n\n## Quantum Teleportation\n\n#### What it does\n\nConsider **Alice** who sends a qubit's state to **Bob**. To teleport a qubit’s state, Alice and Bob first create an **entangled pair**: start with two |0⟩ qubits, apply a **Hadamard** to the first, then a **CNOT** from the first to the second. Alice then takes the **unknown qubit** she wants to send, applies a **CNOT** from it to her half of the pair, and a **Hadamard** on it. Measuring these two qubits gives Alice two classical bits. She sends those bits to Bob, who uses them to decide whether to apply a **Z** and/or an **X** gate to his qubit. After that, Bob’s qubit ends up in exactly the same state Alice started with.\n\nIn this scenario, the teleportation protocol you see here moves only a single qubit’s state. To send larger quantum information, the process must be repeated — one entangled pair and two classical bits for each qubit to be teleported.\n\n#### What This is Meant\n\nImagine **Alice** has a single qubit in some unknown quantum state — a fragile, special “arrow on a sphere” that she wants to send to **Bob**, who is far away. She *can’t* just copy the qubit and email the file; quantum states can’t be cloned. She also *can’t* just measure it and tell Bob the result, because a measurement destroys the state and only gives her one bit of information.\n\nSo instead, Alice and Bob start with a clever trick: **beforehand they share an entangled pair of qubits**. Think of this pair as two perfectly correlated “quantum coins,” one with Alice and one with Bob. This shared entanglement is like a secret quantum bridge between them.\n\nWhen Alice wants to send her qubit’s state:\n\n1. **Alice performs a special joint measurement** on her unknown qubit and her half of the entangled pair.\nThis step destroys her original qubit (so the state doesn’t exist twice) but produces two ordinary bits of classical information — just 0s and 1s.\n2. **Alice sends those two classical bits** to Bob over a normal communication channel (email, phone, fiber optic cable — anything works, because these are just regular bits now).\n3. **Bob uses those two bits** to decide which simple quantum operation to perform on his half of the entangled pair.\nAfter he does this, his qubit **becomes an exact copy of the state** **Alice started with** — even though the original qubit was destroyed.\n\n#### Why It Matters\n\n- It shows that **superposition and entanglement** aren’t just weird physics but can be turned into real information-handling protocols.\n- It’s a **key building block for a future “quantum internet”**, where quantum states can be sent across long distances.\n- It underpins **secure quantum communication**, since the original state is never copied and eavesdroppers can’t intercept without being noticed.\n\n## Try it on Azure Quantum\n\nFirst, create an **Azure Quantum workspace** — the free **Quick create** option is fine. Once the workspace is provisioned, open the **Azure portal**, navigate to your workspace, and copy its **Resource ID**.\n\nIf you’re comfortable with Python, we’ll use **Qiskit** to submit a job. In **VS Code**, install the **Azure Quantum Development Kit (QDK)** extension, then install the required Python packages for your environment. This combination lets you write, run, and submit quantum circuits directly from VS Code with minimal setup.\n\n``` python -m pip install --upgrade azure-quantum[qiskit] qsharp ipykernel matplotlib pylatexenc ```\n\n#### Start a notebook in VS Code\n\nOpen a new Jupyter notebook in **VS Code** and begin your Python setup. In the first cell, **import the packages** and set your **Resource ID** (from the previous step) and the **workspace location**.\n\n``` from azure.quantum import Workspace from qiskit import QuantumCircuit from qiskit.visualization import plot_histogram from azure.quantum.qiskit import AzureQuantumProvider import os from dotenv import load_dotenv load_dotenv(override=True)\n\nworkspace = Workspace( resource_id = os.getenv(\"RESOURCE_ID\"), # Add the resourceID of your workspace location = os.getenv(\"LOCATION\") # Add the location of your workspace (for example \"westus\") )\n\nprovider = AzureQuantumProvider(workspace) ```\n\n2nd cell is to prepare the quantum circuit for Quantum Teleportation. Line1 creates a quantum circuit with 3 qubits and 3 classical bits. In quantum teleportation, we need:\n\n- Qubit 0: The qubit whose state we want to teleport\n- Qubit 1: Alice's part of the entangled pair\n- Qubit 2: Bob's part of the entangled pair\n\nLine 3 sets up the state to Teleport. This applies an X gate (NOT gate) to qubit 0, putting it in the |1⟩ state. This is the quantum state that Alice wants to teleport to Bob. The comment notes this is optional - you could teleport any quantum state, but |1⟩ is chosen as a simple example.\n\nLine4 is just a separator for better readability.\n\nThe combination of Line6 and Line 7 creates an entanglement pair as explained in the previous paragraph. In these statements, \"h(n)\" means Hadamard gate, and \"cx(n)\" indicates CNOT gate.\n\nLine 14; This line performs the measurement of Alice's two qubits (qubit 0 and qubit 1):\n\n- First argument [0, 1]: List of quantum bits to measure (qubit 0 and qubit 1)\n- Second argument [0, 1]: List of classical bits to store the results (classical bit 0 and classical bit 1)\n\n``` circuit = QuantumCircuit(3,3)\n\ncircuit.x(0) circuit.barrier()\n\ncircuit.h(1) circuit.cx(1,2) circuit.barrier()\n\ncircuit.cx(0,1) circuit.h(0) circuit.barrier()\n\ncircuit.measure([0, 1], [0, 1]) circuit.barrier()\n\ncircuit.cx(1, 2) circuit.cz(0, 2) circuit.measure([2], [2]) circuit.draw(output='mpl') ```\n\nWhen you run the cell, it produces an output of the quantum circuit of Teleportation.\n\nWhile Qiskit itself provides a simulator, I used the simulator provided by the quantum hardware providers. By running the following cell, you can have a list of backend simulators.\n\n``` print(\"This workspace's targets:\") for backend in provider.backends(): print(\"- \" + backend.name()) ```\n\noutput\n\n``` This workspace's targets:\n- quantinuum.sim.h1-1sc\n- quantinuum.sim.h1-1e\n- rigetti.sim.qvm\n- quantinuum.sim.h1-1sc\n- quantinuum.sim.h1-1e\n- rigetti.sim.qvm\n```\n\nAs the list may vary depending on the region and the plan of the workspace, you need to confirm by yourself. I chose and set \"quantinuum.sim.h1-1e\" to run a job.\n\n``` simulator_backend = provider.get_backend(\"quantinuum.sim.h1-1e\") ```\n\nFinally submitting a job using the following cell code.\n\n```\n# Submit the circuit to run on Azure Quantum\njob = simulator_backend.run(circuit, shots=1024) job_id = job.id() print(\"Job id\", job_id)\n\n# Get the job results (this method waits for the Job to complete):\nresult = job.result() print(result) counts = {format(n, \"03b\"): 0 for n in range(8)} counts.update(result.get_counts(circuit)) print(counts) plot_histogram(counts) ```\n\nThe output should show the graph similar to the following image. If your output showed different pattern, change the backend simulator.\n\nIn Qiskit endian format,\n\n- **1st digit (leftmost)**: Result of qubit 2 (Bob's qubit)\n- **2nd digit (middle)**: Result of qubit 1 (Alice's entangled qubit)\n- **3rd digit (rightmost)**: Result of qubit 0 (original state qubit)\n\nSince we initially set qubit 0 to |1⟩ state and want to teleport it to qubit 2, we should see these measurement patterns:\n\n- **100**: Qubit 2 = |1⟩ (teleportation successful), Alice measured 00\n- **101**: Qubit 2 = |1⟩ (teleportation successful), Alice measured 01\n- **110**: Qubit 2 = |1⟩ (teleportation successful), Alice measured 10\n- **111**: Qubit 2 = |1⟩ (teleportation successful), Alice measured 11\n\n## Conclusion\n\nQuantum computing turns **superposition** and **entanglement** into working tools. In this post you built intuition for **qubits** and **gates**, created a **Bell state** with **H + CNOT**, and walked through **quantum teleportation**, finishing with a run on **Azure Quantum**. Today’s devices are small and noisy, but capabilities are steadily improving.\n\nWhy watch this field? Algorithms like **Shor’s Algorithm**—which can factor large integers efficiently—strike at the foundation of widely used public-key cryptography (e.g., RSA). While fault-tolerant machines aren’t here yet, the prospect of breaking current encryption is a concrete, high-impact milestone that keeps quantum progress consequential. Add potential gains in optimization and materials discovery, and the direction is clear: as hardware and error-handling advance, practical breakthroughs will follow. Keep an eye on quantum computing—the next meaningful steps may arrive sooner than expected.\n\nUpdated Oct 06, 2025\n\nVersion 1.0\n\n[!\\[notanaha&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/m_assets/avatars/default/avatar-9.svg?image-dimensions=50x50)](/users/notanaha/781716) [notanaha](/users/notanaha/781716) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined September 04, 2020\n\n[View Profile](/users/notanaha/781716)\n\n/category/azure/blog/azurecompute [Azure Compute Blog](/category/azure/blog/azurecompute) Follow this blog board to get notified when there's new activity",
  "Author": "notanaha",
  "Link": "https://techcommunity.microsoft.com/t5/azure-compute-blog/jump-starting-quantum-computing-on-azure/ba-p/4459053",
  "OutputDir": "_community",
  "FeedName": "Microsoft Tech Community",
  "PubDate": "2025-10-13T23:40:03+00:00"
}
