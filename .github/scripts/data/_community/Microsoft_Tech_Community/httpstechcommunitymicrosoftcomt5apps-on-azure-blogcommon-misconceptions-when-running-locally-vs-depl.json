{
  "Description": "# TOC\n\n1. Introduction\n2. Environment Variable\n3. Build Time\n1. Compatible\n2. Memory\n4. Conclusion\n\n## **1. Introduction**\n\nOne of the most common issues during project development is the scenario where *“the application runs perfectly in the local environment but fails after being deployed to Azure.”*\n\nIn most cases, deployment logs will clearly reveal the problem and allow you to fix it quickly. However, there are also more complicated situations where \"due to the nature of the error itself\" relevant logs may be difficult to locate.\n\nThis article introduces several common categories of such problems and explains how to troubleshoot them. We will demonstrate them using Python and popular AI-related packages, as these tend to exhibit compatibility-related behavior.\n\nBefore you begin, it is recommended that you read [Deployment and Build from Azure Linux based Web App | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/appsonazureblog/deployment-and-build-from-azure-linux-based-web-app/4461950) on how Azure Linux-based Web Apps perform deployments so you have a basic understanding of the build process.\n\n## **2. Environment Variable**\n\nSimulating a Local Flask + sklearn Project\n\nFirst, let’s simulate a minimal Flask + sklearn project in any local environment (VS Code in this example).\n\nFor simplicity, the sample code does not actually use any sklearn functions; it only displays plain text.\n\napp.py\n\n- from flask import Flask\napp = Flask(\\_\\_name\\_\\_) @app.route(\"/\") def index(): return \"hello deploy environment variable\" if \\_\\_name\\_\\_ == \"\\_\\_main\\_\\_\": app.run(host=\"0.0.0.0\", port=8000)\n\nWe also preset the environment variables required during Azure deployment, although these will not be used when running locally.\n\n.deployment\n- [config]\nSCM\\_DO\\_BUILD\\_DURING\\_DEPLOYMENT=false\n\nAs you may know, the old package name sklearn has long been deprecated in favor of scikit-learn. However, for the purpose of simulating a compatibility error, we will intentionally specify the outdated package name.\n\nrequirements.txt\n- Flask==3.1.0\ngunicorn==23.0.0 sklearn\n\nAfter running the project locally, you can open a browser and navigate to the target URL to verify the result.\n- python3 -m venv .venv\nsource .venv/bin/activate pip install -r requirements.txt python app.py![]()\n\nOf course, you may encounter the same compatibility issue even in your local environment. Simply running the following command resolves it:\n- export SKLEARN\\_ALLOW\\_DEPRECATED\\_SKLEARN\\_PACKAGE\\_INSTALL=True![]()\n\nWe will revisit this error and its solution shortly. For now, create a Linux Web App running Python 3.12 and configure the following environment variables. We will define Oryx Build as the deployment method.\n- SCM\\_DO\\_BUILD\\_DURING\\_DEPLOYMENT=false\nWEBSITE\\_RUN\\_FROM\\_PACKAGE=false ENABLE\\_ORYX\\_BUILD=true![]()\n\nAfter deploying the code and checking the Deployment Center, you should see an error similar to the following.\n\n![]()\n\nFrom the detailed error message, the cause is clear: sklearn is deprecated and replaced by scikit-learn, so additional compatibility handling is now required by the Python runtime.\n\nThe error message suggests the following solutions:\n\n1. Install the newer scikit-learn package directly.\n2. If your project is deeply coupled to the old sklearn package and cannot be refactored yet, enable compatibility by setting an environment variable to allow installation of the deprecated package.\n\nTypically, this type of “works locally but fails on Azure” behavior happens because the deprecated package was installed in the local environment a long time ago at the start of the project, and everything has been running smoothly since. Package compatibility issues like this are very common across various languages on Linux.\n\nWhen a project becomes tightly coupled to an outdated package, you may not be able to upgrade it immediately. In these cases, compatibility workarounds are often the only practical short-term solution. In our example, we will add the environment variable:\n- SKLEARN\\_ALLOW\\_DEPRECATED\\_SKLEARN\\_PACKAGE\\_INSTALL=True\n\nHowever, here comes the real problem: This variable is needed during the build phase, but the environment variables set in Azure Portal’s *Application Settings* only take effect at runtime. So what should we do?\n\nThe answer is simple, shift the Oryx Build process from build-time to runtime.\n\nFirst, open Azure Portal → Configuration and disable Oryx Build.\n- ENABLE\\_ORYX\\_BUILD=false\n\nNext, modify the project by adding a startup script.\n\nrun.sh\n- #!/bin/bash\nexport SKLEARN\\_ALLOW\\_DEPRECATED\\_SKLEARN\\_PACKAGE\\_INSTALL=True python -m venv .venv source .venv/bin/activate pip install -r requirements.txt python app.py\n\nThe startup script works just like the commands you run locally before executing the application. The difference is that you can inject the necessary compatibility environment variables before running pip install or starting the app.\n\nAfter that, return to Azure Portal and add the following Startup Command under *Stack Settings*. This ensures that your compatibility environment variables and build steps run before the runtime starts.\n- bash run.sh![]()\n\nYour overall project structure will now look like this. Once redeployed, everything should work correctly.\n\n![]()\n\n## **3. Build Time**\n\nBuild-Time Errors Caused by AI-Related Packages\n\nMany build-time failures are caused by AI-related packages, whose installation processes can be extremely time-consuming. You can investigate these issues by reviewing the deployment logs at the following maintenance URL:\n- https://.scm.azurewebsites.net/newui\n\n#### Compatible\n\nLet’s simulate a Flask + numpy project.\n\nThe code is shown below.\n\napp.py\n- from flask import Flask\napp = Flask(\\_\\_name\\_\\_) @app.route(\"/\") def index(): return \"hello deploy compatible\" if \\_\\_name\\_\\_ == \"\\_\\_main\\_\\_\": app.run(host=\"0.0.0.0\", port=8000)\n\nWe reuse the same environment variables from the sklearn example.\n\n.deployment\n- [config]\nSCM\\_DO\\_BUILD\\_DURING\\_DEPLOYMENT=false\n\nThis time, we simulate the incompatibility between numpy==1.21.0 and Python 3.10.\n\nrequirements.txt\n- Flask==3.1.0\ngunicorn==23.0.0 numpy==1.21.0\n\nWe will skip the local execution part and move directly to creating a Linux Web App running Python 3.10. Configure the same environment variables as before, and define the deployment method as runtime build.\n- SCM\\_DO\\_BUILD\\_DURING\\_DEPLOYMENT=false\nWEBSITE\\_RUN\\_FROM\\_PACKAGE=false ENABLE\\_ORYX\\_BUILD=false\n\nAfter deployment, Deployment Center shows a successful publish.\n\n![]()\n\nHowever, the actual website displays an error.\n\n![]()\n\nAt this point, you must check the deployment log files mentioned earlier. You will find two key logs:\n\n1. docker.log\n\n- Displays real-time logs of the platform creating and starting the container.\n- In this case, you will see that the health probe exceeded the default 230-second startup window, causing container startup failure.\n- This tells us the root cause is container startup timeout.\n\nTo determine *why* it timed out, we must inspect the second file.\n\n2. default\\_docker.log\n\n- Contains the internal execution logs of the container.\n- Not generated in real time, usually delayed around 15 minutes.\n- Therefore, if docker.log shows a timeout error, wait at least 15 minutes to allow the logs to be written here.\n\n![]()\n\nIn this example, the internal log shows that numpy was being compiled during pip install, and the compilation step took too long. We now have a concrete diagnosis: numpy 1.21.0 is not compatible with Python 3.10, which forces pip to compile from source.\n\nThe compilation exceeds the platform’s startup time limit (230 seconds) and causes the container to fail.\n\nWe can verify this by checking numpy’s official site:\n\n[numpy · PyPI](https://pypi.org/project/numpy/1.21.0/#files)\n\n![]()\n\nnumpy 1.21.0 only provides wheels for cp37, cp38, cp39 but not cp310 (which is python 3.10). Thus, compilation becomes unavoidable.\n\nPossible Solutions\n\n1. Set the environment variable\n\nWEBSITES\\_CONTAINER\\_START\\_TIME\\_LIMIT\n\nto increase the allowed container startup time.\n2. Downgrade Python to 3.9 or earlier.\n3. Upgrade numpy to 1.21.0+, where suitable wheels for Python 3.10 are available.\n\nIn this example, we choose this option.\n\nAfter upgrading numpy to version 1.25.0 (which supports Python 3.10) from specifying in requirements.txt and redeploying, the issue is resolved.\n\n[numpy · PyPI](https://pypi.org/project/numpy/1.25.0/#files)\n\n![]()\n\nrequirements.txt\n- Flask==3.1.0\ngunicorn==23.0.0 numpy==1.25.0\n\n![]()\n\n#### Memory\n\nThe final example concerns the App Service SKU. AI packages such as Streamlit, PyTorch, and others require significant memory. Any one of these packages may cause the build process to fail due to insufficient memory. The error messages vary widely each time.\n\nIf you repeatedly encounter unexplained build failures, check Deployment Center or default\\_docker.log for **Exit Code 137**, which indicates that the system ran out of memory during the build.\n\n![]()\n\nThe only solution in such cases is to **scale up**.\n\n## **4. Conclusion**\n\nThis article introduced several common troubleshooting techniques for resolving Linux Web App issues caused during the build stage. Most of these problems relate to **package compatibility**, although the symptoms may vary greatly. By understanding the debugging process demonstrated in these examples, you will be better prepared to diagnose and resolve similar issues in future deployments.",
  "EnhancedContent": "## This article introduces several common categories of such problems and explains how to troubleshoot them.\nWe will demonstrate them using Python and popular AI-related packages, as these tend to exhibit compatibility-related behavior.\n\n# TOC\n\n1. Introduction\n2. Environment Variable\n3. Build Time\n1. Compatible\n2. Memory\n4. Conclusion\n\n## **1. Introduction**\n\nOne of the most common issues during project development is the scenario where *“the application runs perfectly in the local environment but fails after being deployed to Azure.”*\n\nIn most cases, deployment logs will clearly reveal the problem and allow you to fix it quickly. However, there are also more complicated situations where \"due to the nature of the error itself\" relevant logs may be difficult to locate.\n\nThis article introduces several common categories of such problems and explains how to troubleshoot them. We will demonstrate them using Python and popular AI-related packages, as these tend to exhibit compatibility-related behavior.\n\nBefore you begin, it is recommended that you read [Deployment and Build from Azure Linux based Web App | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/appsonazureblog/deployment-and-build-from-azure-linux-based-web-app/4461950) on how Azure Linux-based Web Apps perform deployments so you have a basic understanding of the build process.\n\n## **2. Environment Variable**\n\nSimulating a Local Flask + sklearn Project\n\nFirst, let’s simulate a minimal Flask + sklearn project in any local environment (VS Code in this example).\n\nFor simplicity, the sample code does not actually use any sklearn functions; it only displays plain text.\n\napp.py\n\n``` from flask import Flask app = Flask(__name__) @app.route(\"/\") def index(): return \"hello deploy environment variable\" if __name__ == \"__main__\": app.run(host=\"0.0.0.0\", port=8000) ```\n\nWe also preset the environment variables required during Azure deployment, although these will not be used when running locally.\n\n.deployment\n\n``` [config] SCM_DO_BUILD_DURING_DEPLOYMENT=false ```\n\nAs you may know, the old package name sklearn has long been deprecated in favor of scikit-learn. However, for the purpose of simulating a compatibility error, we will intentionally specify the outdated package name.\n\nrequirements.txt\n\n``` Flask==3.1.0 gunicorn==23.0.0 sklearn ```\n\nAfter running the project locally, you can open a browser and navigate to the target URL to verify the result.\n\n``` python3 -m venv .venv source .venv/bin/activate pip install -r requirements.txt python app.py ```\n\nOf course, you may encounter the same compatibility issue even in your local environment. Simply running the following command resolves it:\n\n``` export SKLEARN_ALLOW_DEPRECATED_SKLEARN_PACKAGE_INSTALL=True ```\n\nWe will revisit this error and its solution shortly. For now, create a Linux Web App running Python 3.12 and configure the following environment variables. We will define Oryx Build as the deployment method.\n\n``` SCM_DO_BUILD_DURING_DEPLOYMENT=false WEBSITE_RUN_FROM_PACKAGE=false ENABLE_ORYX_BUILD=true ```\n\nAfter deploying the code and checking the Deployment Center, you should see an error similar to the following.\n\nFrom the detailed error message, the cause is clear: sklearn is deprecated and replaced by scikit-learn, so additional compatibility handling is now required by the Python runtime.\n\nThe error message suggests the following solutions:\n\n1. Install the newer scikit-learn package directly.\n2. If your project is deeply coupled to the old sklearn package and cannot be refactored yet, enable compatibility by setting an environment variable to allow installation of the deprecated package.\n\nTypically, this type of “works locally but fails on Azure” behavior happens because the deprecated package was installed in the local environment a long time ago at the start of the project, and everything has been running smoothly since. Package compatibility issues like this are very common across various languages on Linux.\n\nWhen a project becomes tightly coupled to an outdated package, you may not be able to upgrade it immediately. In these cases, compatibility workarounds are often the only practical short-term solution. In our example, we will add the environment variable:\n\n``` SKLEARN_ALLOW_DEPRECATED_SKLEARN_PACKAGE_INSTALL=True ```\n\nHowever, here comes the real problem: This variable is needed during the build phase, but the environment variables set in Azure Portal’s *Application Settings* only take effect at runtime. So what should we do?\n\nThe answer is simple, shift the Oryx Build process from build-time to runtime.\n\nFirst, open Azure Portal → Configuration and disable Oryx Build.\n\n``` ENABLE_ORYX_BUILD=false ```\n\nNext, modify the project by adding a startup script.\n\nrun.sh\n\n``` #!/bin/bash export SKLEARN_ALLOW_DEPRECATED_SKLEARN_PACKAGE_INSTALL=True python -m venv .venv source .venv/bin/activate pip install -r requirements.txt python app.py ```\n\nThe startup script works just like the commands you run locally before executing the application. The difference is that you can inject the necessary compatibility environment variables before running pip install or starting the app.\n\nAfter that, return to Azure Portal and add the following Startup Command under *Stack Settings*. This ensures that your compatibility environment variables and build steps run before the runtime starts.\n\n``` bash run.sh ```\n\nYour overall project structure will now look like this. Once redeployed, everything should work correctly.\n\n## **3. Build Time**\n\nBuild-Time Errors Caused by AI-Related Packages\n\nMany build-time failures are caused by AI-related packages, whose installation processes can be extremely time-consuming. You can investigate these issues by reviewing the deployment logs at the following maintenance URL:\n\n``` https://<YOUR_APP_NAME>.scm.azurewebsites.net/newui ```\n\n#### Compatible\n\nLet’s simulate a Flask + numpy project.\n\nThe code is shown below.\n\napp.py\n\n``` from flask import Flask app = Flask(__name__) @app.route(\"/\") def index(): return \"hello deploy compatible\" if __name__ == \"__main__\": app.run(host=\"0.0.0.0\", port=8000) ```\n\nWe reuse the same environment variables from the sklearn example.\n\n.deployment\n\n``` [config] SCM_DO_BUILD_DURING_DEPLOYMENT=false\n\n```\n\nThis time, we simulate the incompatibility between numpy==1.21.0 and Python 3.10.\n\nrequirements.txt\n\n``` Flask==3.1.0 gunicorn==23.0.0 numpy==1.21.0 ```\n\nWe will skip the local execution part and move directly to creating a Linux Web App running Python 3.10. Configure the same environment variables as before, and define the deployment method as runtime build.\n\n``` SCM_DO_BUILD_DURING_DEPLOYMENT=false WEBSITE_RUN_FROM_PACKAGE=false ENABLE_ORYX_BUILD=false ```\n\nAfter deployment, Deployment Center shows a successful publish.\n\nHowever, the actual website displays an error.\n\nAt this point, you must check the deployment log files mentioned earlier. You will find two key logs:\n\n1. docker.log\n\n- Displays real-time logs of the platform creating and starting the container.\n- In this case, you will see that the health probe exceeded the default 230-second startup window, causing container startup failure.\n- This tells us the root cause is container startup timeout.\n\nTo determine *why* it timed out, we must inspect the second file.\n\n2. default\\_docker.log\n\n- Contains the internal execution logs of the container.\n- Not generated in real time, usually delayed around 15 minutes.\n- Therefore, if docker.log shows a timeout error, wait at least 15 minutes to allow the logs to be written here.\n\nIn this example, the internal log shows that numpy was being compiled during pip install, and the compilation step took too long. We now have a concrete diagnosis: numpy 1.21.0 is not compatible with Python 3.10, which forces pip to compile from source.\n\nThe compilation exceeds the platform’s startup time limit (230 seconds) and causes the container to fail.\n\nWe can verify this by checking numpy’s official site:\n\n[numpy · PyPI](https://pypi.org/project/numpy/1.21.0/#files)\n\nnumpy 1.21.0 only provides wheels for cp37, cp38, cp39 but not cp310 (which is python 3.10). Thus, compilation becomes unavoidable.\n\nPossible Solutions\n\n1. Set the environment variable\n\nWEBSITES\\_CONTAINER\\_START\\_TIME\\_LIMIT\n\nto increase the allowed container startup time.\n2. Downgrade Python to 3.9 or earlier.\n3. Upgrade numpy to 1.21.0+, where suitable wheels for Python 3.10 are available.\n\nIn this example, we choose this option.\n\nAfter upgrading numpy to version 1.25.0 (which supports Python 3.10) from specifying in requirements.txt and redeploying, the issue is resolved.\n\n[numpy · PyPI](https://pypi.org/project/numpy/1.25.0/#files)\n\nrequirements.txt\n\n``` Flask==3.1.0 gunicorn==23.0.0 numpy==1.25.0 ```\n\n#### Memory\n\nThe final example concerns the App Service SKU. AI packages such as Streamlit, PyTorch, and others require significant memory. Any one of these packages may cause the build process to fail due to insufficient memory. The error messages vary widely each time.\n\nIf you repeatedly encounter unexplained build failures, check Deployment Center or default\\_docker.log for **Exit Code 137**, which indicates that the system ran out of memory during the build.\n\nThe only solution in such cases is to **scale up**.\n\n## **4. Conclusion**\n\nThis article introduced several common troubleshooting techniques for resolving Linux Web App issues caused during the build stage. Most of these problems relate to **package compatibility**, although the symptoms may vary greatly. By understanding the debugging process demonstrated in these examples, you will be better prepared to diagnose and resolve similar issues in future deployments.\n\nUpdated Nov 30, 2025\n\nVersion 2.0\n\n[azure app service](/tag/azure%20app%20service?nodeId=board%3AAppsonAzureBlog)\n\n[azure paas](/tag/azure%20paas?nodeId=board%3AAppsonAzureBlog)\n\n[best practices](/tag/best%20practices?nodeId=board%3AAppsonAzureBlog)\n\n[devops](/tag/devops?nodeId=board%3AAppsonAzureBlog)\n\n[python](/tag/python?nodeId=board%3AAppsonAzureBlog)\n\n[web apps](/tag/web%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[theringe&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0xMzU3ODIyLVIxNkJKdg?image-coordinates=0%2C0%2C800%2C800&amp;image-dimensions=50x50)](/users/theringe/1357822) [theringe](/users/theringe/1357822) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined April 08, 2022\n\n[View Profile](/users/theringe/1357822)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "FeedName": "Microsoft Tech Community",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/common-misconceptions-when-running-locally-vs-deploying-to-azure/ba-p/4473938",
  "Title": "Common Misconceptions When Running Locally vs. Deploying to Azure Linux-based Web Apps",
  "OutputDir": "_community",
  "Author": "theringe",
  "PubDate": "2025-11-30T09:14:23+00:00",
  "ProcessedDate": "2025-11-30 10:05:03",
  "Tags": []
}
