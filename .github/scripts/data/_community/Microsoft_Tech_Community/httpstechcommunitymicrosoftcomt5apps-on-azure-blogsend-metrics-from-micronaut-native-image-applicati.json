{
  "ProcessedDate": "2025-08-15 14:40:33",
  "PubDate": "2025-08-15T04:57:57+00:00",
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/send-metrics-from-micronaut-native-image-applications-to-azure/ba-p/4443763",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Author": "Logico_jp",
  "FeedName": "Microsoft Tech Community",
  "EnhancedContent": "The original post (Japanese) was written on 20 July 2025. [MicronautからAzure Monitorにmetricを送信したい – Logico Inside](https://logico-jp.dev/2025/07/20/send-metrics-from-micronaut-applications-to-azure-monitor/)\n\nThis entry is related to the following one. Please take a look for background information. [Send signals from Micronaut native image applications to Azure Monitor | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/appsonazureblog/send-signals-from-micronaut-native-image-applications-to-azure-monitor/4443735)\n\n### Prerequisites\n\n- Maven: 3.9.10\n- JDK version 21\n- Micronaut: 4.9.0 or later\n\nThe following tutorials were used as a reference.\n\n[Create a Micronaut Application to Collect Metrics and Monitor Them on Azure Monitor Metrics](https://graal.cloud/gdk/gdk-modules/metrics/micronaut-metrics-azure/)\n\n[Collect Metrics with Micronaut](https://guides.micronaut.io/latest/micronaut-metrics-maven-java.html)\n\n### Create an archetype\n\nWe can create an archetype using Micronaut’s CLI (`mn` ) or Micronaut Launch. In this entry, use `application.yml` instead of `application.properties` for application configuration. So, we need to specify the feature “yaml” so that we can include dependencies for using yaml.\n\nMicronaut Launch [https://micronaut.io/launch/](https://micronaut.io/launch/)\n\n``` $ mn create-app \\ --build=maven \\ --jdk=21 \\ --lang=java \\ --test=junit \\ --features=validation,graalvm,micrometer-azure-monitor,http-client,micrometer-annotation,yaml \\ dev.logicojp.micronaut.azuremonitor-metric ```\n\nWhen using Micronaut Launch, click [FEATURES] and select the following features.\n\n- validation\n- graalvm\n- micrometer-azure-monitor\n- http-client\n- micrometer-annotation\n- yaml\n\nAfter all features are selected, click [GENERATE PROJECT] and choose [Download Zip] to download an archetype in Zip file.\n\n### Implementation\n\nIn this section, we’re going to use the GDK sample code that we can find in the tutorial. The code is from the Micronaut Guides, but the database access and other parts have been taken out. We have made the following changes to the code to make it fit our needs.\n\n#### a) Structure of the directory\n\nIn the GDK tutorial, folders called `azure` and `lib` are created, but this structure isn’t used in the standard Micronaut archetype. So, codes in both directories has now been combined.\n\n#### b) Instrumentation Key\n\nAs the tutorial above and the Micronaut Micrometer documentation explain, we need to specify the Instrumentation Key. When we create an archetype using Micronaut CLI or Micronaut Launch, the configuration assuming the use of the Instrumentation Key is included in `application.properties` / `application.yml` .\n\n6.3 Azure Monitor Registry [Micronaut Micrometer](https://micronaut-projects.github.io/micronaut-micrometer/5.12.0/guide/#metricsAndReportersAzureMonitor)\n\nThis configuration will work, but currently, Application Insights does not recommend accessing it using only the Instrumentation Key. So, it is better to modify the connection string to include the Instrumentation Key. To set it up, open the file `application.properties` and enter the following information:\n\n``` micronaut.metrics.export.azuremonitor.connectionString=\"InstrumentationKey=....\" ```\n\nIn the case of `application.yml` , we need to specify the connection string in YAML format.\n\n``` micronaut: metrics: enabled: true export: azuremonitor: enabled: true connectionString: InstrumentationKey=.... ```\n\nWe can also specify the environment variable `MICRONAUT_METRICS_EXPORT_AZUREMONITOR_CONNECTIONSTRING` , but since this environment variable name is too long, it is better to use a shorter one. Here’s an example using `AZURE_MONITOR_CONNECTION_STRING` (which is also long, if you think about it).\n\n``` micronaut.metrics.export.azuremonitor.connectionString=${AZURE_MONITOR_CONNECTION_STRING} ```\n\n``` micronaut: metrics: enabled: true export: azuremonitor: enabled: true connectionString: ${AZURE_MONITOR_CONNECTION_STRING} ```\n\nThe connection string can be specified because Micrometer, which is used internally, already supports it. We can find the AzurMonitorConfig.java file here.\n\nAzureMonitorConfig.java [micrometer/implementations/micrometer-registry-azure-monitor/src/main/java/io/micrometer/azuremonitor/AzureMonitorConfig.java at main · micrometer-metrics/micrometer](https://github.com/micrometer-metrics/micrometer/blob/main/implementations/micrometer-registry-azure-monitor/src/main/java/io/micrometer/azuremonitor/AzureMonitorConfig.java)\n\nThe settings in `application.properties` /`application.yml` are as follows. For more information about the specified meter binders, please look at the following documents.\n\nMeter Binder [Micronaut Micrometer](https://micronaut-projects.github.io/micronaut-micrometer/latest/guide/#_meter_binder)\n\n``` micronaut: application: name: azuremonitor-metric metrics: enabled: true binders: files: enabled: true jdbc: enabled: true jvm: enabled: true logback: enabled: true processor: enabled: true uptime: enabled: true web: enabled: true export: azuremonitor: enabled: true step: PT1M connectionString: ${AZURE_MONITOR_CONNECTION_STRING} ```\n\n#### c) pom.xml\n\nTo use the GraalVM Reachability Metadata Repository, you need to add this dependency. The latest version is 0.11.0 as of 20 July, 2025.\n\n``` <dependency> <groupid>org.graalvm.buildtools</groupid> <artifactid>graalvm-reachability-metadata</artifactid> <version>0.11.0</version> </dependency> ```\n\nAdd the GraalVM Maven plugin and enable the use of GraalVM Reachability Metadata obtained from the above dependency. This plugin lets us set optimization levels using buildArg (in this example, the optimisation level is specified). We can also add it to `native-image.properties` , the `native-image` tool (and the Maven/Gradle plugin) will read it.\n\n``` <plugin> <groupid>org.graalvm.buildtools</groupid> <artifactid>native-maven-plugin</artifactid> <configuration> <metadatarepository> <enabled>true</enabled> </metadatarepository> <buildargs combine.children=\"append\"> <buildarg>-Ob</buildarg> </buildargs> <quickbuild>true</quickbuild> </configuration> </plugin> ```\n\nFor now, let’s build it as a Java application.\n\n``` $ mvn clean package ```\n\n### Check if it works as a Java application\n\nAt first, verify that the application is running without any problems and that metrics are being sent to Application Insights. Then, run the application using the Tracing Agent to generate the necessary configuration files.\n\n```\n# (1) Collect configuration files such as reflect-config.json\n$JAVA_HOME/bin/java \\ -agentlib:native-image-agent=config-output-dir=src/main/resources/META-INF/{groupId}/{artifactId}/ \\ -jar ./target/{artifactId}-{version}.jar\n# (2)-a Generate a trace file\n$JAVA_HOME/bin/java \\ -agentlib:native-image-agent=trace-output=/path/to/trace-file.json \\ -jar ./target/{artifactId}-{version}.jar\n# (2)-b Generate a reachability metadata file from the collected trace file\nnative-image-configure generate \\ --trace-input=/path/to/trace-file.json \\ --output-dir=/path/to/config-dir/ ```\n\n[Configure Native Image with the Tracing Agent](https://www.graalvm.org/latest/reference-manual/native-image/guides/configure-with-tracing-agent/)\n\n[Collect Metadata with the Tracing Agent](https://www.graalvm.org/latest/reference-manual/native-image/metadata/AutomaticMetadataCollection/)\n\nThe following files are stored in the specific directory.\n\n- `jni-config.json`\n- `reflect-config.json`\n- `proxy-config.json`\n- `resource-config.json`\n- `reachability-metadata.json`\n\nThese files can be located at `src/main/resources/META-INF/native-image` . The `native-image` tool picks up configuration files located in the directory `src/main/resources/META-INF/native-image` . However, it is recommended that we place the files in subdirectories divided by `groupId` and `artifactId` , as shown below.\n\n``` src/main/resources/META-INF/native-image/{groupId}/{artifactId} ```\n\n### native-image.properties\n\nWhen creating a native image, we call the following command.\n\n``` mvn package -Dpackaging=native-image ```\n\nWe should specify the timing of class initialization (build time or runtime), the command line options for the `native-image` tool (the same command line options work in Maven/Gradle plugin), and the JVM arguments in the `native-image.properties` file. Indeed, these settings can be specified in `pom.xml` , but it is recommended that they be externalized.\n\n#### a) Location of configuration files:\n\nAs described in the documentation, we can specify the location of configuration property files. If we build using the recommended method (placing the files in the directory `src/main/resources/META-INF/native-image/{groupId}/{artifactId}` ), we can specify the directory location using ${.}.\n\n- `-H:DynamicProxyConfigurationResources`\n- `-H:JNIConfigurationResources`\n- `-H:ReflectionConfigurationResources`\n- `-H:ResourceConfigurationResources`\n- `-H:SerializationConfigurationResources`\n\n[Native Image Build Configuration](https://www.graalvm.org/latest/reference-manual/native-image/overview/BuildConfiguration/#embed-a-configuration-file)\n\n#### b) HTTP/HTTPS protocols support:\n\nWe need to use `--enable-https` /`--enable-http` when using the HTTP(S) protocol in your application.\n\n[URL Protocols in Native Image](https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/URLProtocols/)\n\n#### c) When classes are loaded and initialized:\n\nIn the case of AOT compilation, classes are usually loaded at compile time and stored in the image heap (at build time). However, some classes might be specified to be loaded when the program is running. In these cases, it is necessary to explicitly specify initialization at runtime (and vice versa, of course). There are two types of build arguments.\n\n```\n# Explicitly specify initialisation at runtime\n--initialize-at-run-time=...\n# Explicitly specify initialisation at build time\n--initialize-at-build-time=... ```\n\nTo enable tracing of class initialization, use the following arguments.\n\n```\n# Enable tracing of class initialization\n--trace-class-initialization=... # Deprecated in GraalVM 21.3 --trace-object-instantiation=... # Current option ```\n\n[Specify Class Initialization Explicitly](https://www.graalvm.org/latest/reference-manual/native-image/guides/specify-class-initialization/)\n\n[Class Initialization in Native Image](https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/ClassInitialization/)\n\n#### d) Prevent fallback builds:\n\nIf the application cannot be optimized during the Native Image build, the native-image tool will create a fallback file, which needs JVM. To prevent fallback builds, we need to specify the option `--no-fallback. For other build options, please look at the following document. `\n\n`\n\n`\n\n[Command-line Options](https://www.graalvm.org/latest/reference-manual/native-image/overview/Options/#build-options)\n\n`\n\n`\n\n### Build a Native Image application\n\n`\n\n`\n\nBuilding a native image application takes a long time (though it has got quicker over time). If building it for testing purpose, we strongly recommend enabling Quick Build and setting the optimization level to `-Ob` option (although this will still take time). See below for more information.\n\n`\n\n`\n\n[Maven plugin for GraalVM Native Image](https://graalvm.github.io/native-build-tools/latest/maven-plugin.html#native-image-options) [Gradle plugin for GraalVM Native Image](https://graalvm.github.io/native-build-tools/latest/gradle-plugin.html#native-image-options)\n\n`\n\n`\n\n[Optimizations and Performance](https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/#optimization-levels)\n\n`\n\n`\n\n### Test as a native image application\n\n`\n\n`\n\nWhen you start the native image application, we might see the following message: This message means that GC notifications are not available because `GarbageCollectorMXBean` of JVM does not provide any notifications.\n\n`\n\n`\n\n``` GC notifications will not be available because no GarbageCollectorMXBean of the JVM provides any. GCs=[young generation scavenger, complete scavenger] ```\n\n`\n\n`\n\nLet’s check if the application works.\n\n`\n\n`\n\n#### 1) GET /books and GET /books/{isbn}\n\n`\n\n`\n\nThis is a normal REST API. Call both of them a few times.\n\n`\n\n`\n\n#### 2) GET /metrics\n\n`\n\n`\n\nWe can check the list of available metrics.\n\n`\n\n`\n\n``` { \"names\": [ \"books.find\", \"books.index\", \"executor\", \"executor.active\", \"executor.completed\", \"executor.pool.core\", \"executor.pool.max\", \"executor.pool.size\", \"executor.queue.remaining\", \"executor.queued\", \"http.server.requests\", \"jvm.classes.loaded\", \"jvm.classes.unloaded\", \"jvm.memory.committed\", \"jvm.memory.max\", \"jvm.memory.used\", \"jvm.threads.daemon\", \"jvm.threads.live\", \"jvm.threads.peak\", \"jvm.threads.started\", \"jvm.threads.states\", \"logback.events\", \"microserviceBooksNumber.checks\", \"microserviceBooksNumber.latest\", \"microserviceBooksNumber.time\", \"process.cpu.usage\", \"process.files.max\", \"process.files.open\", \"process.start.time\", \"process.uptime\", \"system.cpu.count\", \"system.cpu.usage\", \"system.load.average.1m\" ] } ```\n\n`\n\n`\n\nAt first, the following three metrics are custom ones added in the class `MicroserviceBooksNumberService` .\n\n`\n\n`\n\n- `microserviceBooksNumber.checks`\n- `microserviceBooksNumber.time`\n- `microserviceBooksNumber.latest`\n\nAnd, the following two metrics are custom ones collected in the class `BooksController` , which collect information such as the time taken and the number of calls. Each metric can be viewed at `GET /metrics/{metric name}` .\n\n`\n\n`\n\n- `books.find`\n- `books.index`\n\n`\n\n`\n\nThe following is an example of `microserviceBooksNumber.*` .\n\n`\n\n`\n\n``` // miroserviceBooksNumber.checks { \"name\": \"microserviceBooksNumber.checks\", \"measurements\": [ { \"statistic\": \"COUNT\", \"value\": 12 } ] } // microserviceBooksNumber.time { \"name\": \"microserviceBooksNumber.time\", \"measurements\": [ { \"statistic\": \"COUNT\", \"value\": 12 }, { \"statistic\": \"TOTAL_TIME\", \"value\": 0.212468 }, { \"statistic\": \"MAX\", \"value\": 0.032744 } ], \"baseUnit\": \"seconds\" } //microserviceBooksNumber.latest { \"name\": \"microserviceBooksNumber.latest\", \"measurements\": [ { \"statistic\": \"VALUE\", \"value\": 2 } ] } ```\n\n`\n\n`\n\nHere is an example of the metric `books.*. `\n\n`\n\n`\n\n``` // books.index { \"name\": \"books.index\", \"measurements\": [ { \"statistic\": \"COUNT\", \"value\": 6 }, { \"statistic\": \"TOTAL_TIME\", \"value\": 3.08425 }, { \"statistic\": \"MAX\", \"value\": 3.02097 } ], \"availableTags\": [ { \"tag\": \"exception\", \"values\": [ \"none\" ] } ], \"baseUnit\": \"seconds\" } // books.find { \"name\": \"books.find\", \"measurements\": [ { \"statistic\": \"COUNT\", \"value\": 7 } ], \"availableTags\": [ { \"tag\": \"result\", \"values\": [ \"success\" ] }, { \"tag\": \"exception\", \"values\": [ \"none\" ] } ] } ```\n\n`\n\n`\n\n### Metrics from Azure Monitor (application insights)\n\n`\n\n`\n\nHere is the grid view of custom metrics in Application Insights (`microserviceBooks.time` is the average value).\n\n`\n\n`\n\n`\n\n`\n\nTo confirm that the values match those in Application Insights, check the metric `http.server.requests` , for example. We should see three items on the graph and the value is equal to the number of API responses (3).\n\n`\n\n`\n\n`\n\n`\n\nUpdated Aug 15, 2025\n\nVersion 3.0\n\n[azure container apps](/tag/azure%20container%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[java](/tag/java?nodeId=board%3AAppsonAzureBlog)\n\n[web apps](/tag/web%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[Logico_jp&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0yOTkyMzctNTQ3ODkyaTBFMzYwMUVGM0FBQkZBN0Y?image-dimensions=50x50)](/users/logico_jp/299237) [Logico_jp](/users/logico_jp/299237) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined March 12, 2019\n\n[View Profile](/users/logico_jp/299237)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "Title": "Send metrics from Micronaut native image applications to Azure Monitor",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "OutputDir": "_community",
  "Description": "The original post (Japanese) was written on 20 July 2025. [MicronautからAzure Monitorにmetricを送信したい – Logico Inside](https://logico-jp.dev/2025/07/20/send-metrics-from-micronaut-applications-to-azure-monitor/)\n\nThis entry is related to the following one. Please take a look for background information. [Send signals from Micronaut native image applications to Azure Monitor | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/appsonazureblog/send-signals-from-micronaut-native-image-applications-to-azure-monitor/4443735)\n\n### Prerequisites\n\n- Maven: 3.9.10\n- JDK version 21\n- Micronaut: 4.9.0 or later\n\nThe following tutorials were used as a reference.\n\n[Create a Micronaut Application to Collect Metrics and Monitor Them on Azure Monitor Metrics](https://graal.cloud/gdk/gdk-modules/metrics/micronaut-metrics-azure/)\n\n[Collect Metrics with Micronaut](https://guides.micronaut.io/latest/micronaut-metrics-maven-java.html)\n\n### Create an archetype\n\nWe can create an archetype using Micronaut’s CLI (`mn` ) or Micronaut Launch. In this entry, use `application.yml` instead of `application.properties` for application configuration. So, we need to specify the feature “yaml” so that we can include dependencies for using yaml.\n\nMicronaut Launch [https://micronaut.io/launch/](https://micronaut.io/launch/)\n\n- $ mn create-app \\\n--build=maven \\ --jdk=21 \\ --lang=java \\ --test=junit \\ --features=validation,graalvm,micrometer-azure-monitor,http-client,micrometer-annotation,yaml \\ dev.logicojp.micronaut.azuremonitor-metric\n\nWhen using Micronaut Launch, click [FEATURES] and select the following features.\n\n- validation\n- graalvm\n- micrometer-azure-monitor\n- http-client\n- micrometer-annotation\n- yaml\n\nAfter all features are selected, click [GENERATE PROJECT] and choose [Download Zip] to download an archetype in Zip file.\n\n![]()\n\n### Implementation\n\nIn this section, we’re going to use the GDK sample code that we can find in the tutorial. The code is from the Micronaut Guides, but the database access and other parts have been taken out. We have made the following changes to the code to make it fit our needs.\n\n#### a) Structure of the directory\n\nIn the GDK tutorial, folders called `azure` and `lib` are created, but this structure isn’t used in the standard Micronaut archetype. So, codes in both directories has now been combined.\n\n#### b) Instrumentation Key\n\nAs the tutorial above and the Micronaut Micrometer documentation explain, we need to specify the Instrumentation Key. When we create an archetype using Micronaut CLI or Micronaut Launch, the configuration assuming the use of the Instrumentation Key is included in `application.properties` / `application.yml` .\n\n6.3 Azure Monitor Registry [Micronaut Micrometer](https://micronaut-projects.github.io/micronaut-micrometer/5.12.0/guide/#metricsAndReportersAzureMonitor)\n\nThis configuration will work, but currently, Application Insights does not recommend accessing it using only the Instrumentation Key. So, it is better to modify the connection string to include the Instrumentation Key. To set it up, open the file `application.properties` and enter the following information:\n- micronaut.metrics.export.azuremonitor.connectionString=\"InstrumentationKey=....\"\n\nIn the case of `application.yml` , we need to specify the connection string in YAML format.\n- micronaut:\nmetrics: enabled: true export: azuremonitor: enabled: true connectionString: InstrumentationKey=....\n\nWe can also specify the environment variable `MICRONAUT_METRICS_EXPORT_AZUREMONITOR_CONNECTIONSTRING` , but since this environment variable name is too long, it is better to use a shorter one. Here’s an example using `AZURE_MONITOR_CONNECTION_STRING` (which is also long, if you think about it).\n- micronaut.metrics.export.azuremonitor.connectionString=${AZURE\\_MONITOR\\_CONNECTION\\_STRING}\n- micronaut:\nmetrics: enabled: true export: azuremonitor: enabled: true connectionString: ${AZURE\\_MONITOR\\_CONNECTION\\_STRING}\n\nThe connection string can be specified because Micrometer, which is used internally, already supports it. We can find the AzurMonitorConfig.java file here.\n\nAzureMonitorConfig.java [micrometer/implementations/micrometer-registry-azure-monitor/src/main/java/io/micrometer/azuremonitor/AzureMonitorConfig.java at main · micrometer-metrics/micrometer](https://github.com/micrometer-metrics/micrometer/blob/main/implementations/micrometer-registry-azure-monitor/src/main/java/io/micrometer/azuremonitor/AzureMonitorConfig.java)\n\nThe settings in `application.properties` /`application.yml` are as follows. For more information about the specified meter binders, please look at the following documents.\n\nMeter Binder [Micronaut Micrometer](https://micronaut-projects.github.io/micronaut-micrometer/latest/guide/#_meter_binder)\n- micronaut:\napplication: name: azuremonitor-metric metrics: enabled: true binders: files: enabled: true jdbc: enabled: true jvm: enabled: true logback: enabled: true processor: enabled: true uptime: enabled: true web: enabled: true export: azuremonitor: enabled: true step: PT1M connectionString: ${AZURE\\_MONITOR\\_CONNECTION\\_STRING}\n\n#### c) pom.xml\n\nTo use the GraalVM Reachability Metadata Repository, you need to add this dependency. The latest version is 0.11.0 as of 20 July, 2025.\n- org.graalvm.buildtools\ngraalvm-reachability-metadata 0.11.0\n\nAdd the GraalVM Maven plugin and enable the use of GraalVM Reachability Metadata obtained from the above dependency. This plugin lets us set optimization levels using buildArg (in this example, the optimisation level is specified). We can also add it to `native-image.properties` , the `native-image` tool (and the Maven/Gradle plugin) will read it.\n- org.graalvm.buildtools\nnative-maven-plugin\n\ntrue\n\n-Ob\n\ntrue\n\nFor now, let’s build it as a Java application.\n- $ mvn clean package\n\n### Check if it works as a Java application\n\nAt first, verify that the application is running without any problems and that metrics are being sent to Application Insights. Then, run the application using the Tracing Agent to generate the necessary configuration files.\n- # (1) Collect configuration files such as reflect-config.json\n$JAVA\\_HOME/bin/java \\ -agentlib:native-image-agent=config-output-dir=src/main/resources/META-INF/{groupId}/{artifactId}/ \\ -jar ./target/{artifactId}-{version}.jar\n# (2)-a Generate a trace file\n$JAVA\\_HOME/bin/java \\ -agentlib:native-image-agent=trace-output=/path/to/trace-file.json \\ -jar ./target/{artifactId}-{version}.jar\n# (2)-b Generate a reachability metadata file from the collected trace file\nnative-image-configure generate \\ --trace-input=/path/to/trace-file.json \\ --output-dir=/path/to/config-dir/\n\n[Configure Native Image with the Tracing Agent](https://www.graalvm.org/latest/reference-manual/native-image/guides/configure-with-tracing-agent/)\n\n[Collect Metadata with the Tracing Agent](https://www.graalvm.org/latest/reference-manual/native-image/metadata/AutomaticMetadataCollection/)\n\nThe following files are stored in the specific directory.\n\n- `jni-config.json`\n- `reflect-config.json`\n- `proxy-config.json`\n- `resource-config.json`\n- `reachability-metadata.json`\n\nThese files can be located at `src/main/resources/META-INF/native-image` . The `native-image` tool picks up configuration files located in the directory `src/main/resources/META-INF/native-image` . However, it is recommended that we place the files in subdirectories divided by `groupId` and `artifactId` , as shown below.\n- src/main/resources/META-INF/native-image/{groupId}/{artifactId}\n\n### native-image.properties\n\nWhen creating a native image, we call the following command.\n- mvn package -Dpackaging=native-image\n\nWe should specify the timing of class initialization (build time or runtime), the command line options for the `native-image` tool (the same command line options work in Maven/Gradle plugin), and the JVM arguments in the `native-image.properties` file. Indeed, these settings can be specified in `pom.xml` , but it is recommended that they be externalized.\n\n#### a) Location of configuration files:\n\nAs described in the documentation, we can specify the location of configuration property files. If we build using the recommended method (placing the files in the directory `src/main/resources/META-INF/native-image/{groupId}/{artifactId}` ), we can specify the directory location using ${.}.\n\n- `-H:DynamicProxyConfigurationResources`\n- `-H:JNIConfigurationResources`\n- `-H:ReflectionConfigurationResources`\n- `-H:ResourceConfigurationResources`\n- `-H:SerializationConfigurationResources`\n\n[Native Image Build Configuration](https://www.graalvm.org/latest/reference-manual/native-image/overview/BuildConfiguration/#embed-a-configuration-file)\n\n#### b) HTTP/HTTPS protocols support:\n\nWe need to use `--enable-https` /`--enable-http` when using the HTTP(S) protocol in your application.\n\n[URL Protocols in Native Image](https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/URLProtocols/)\n\n#### c) When classes are loaded and initialized:\n\nIn the case of AOT compilation, classes are usually loaded at compile time and stored in the image heap (at build time). However, some classes might be specified to be loaded when the program is running. In these cases, it is necessary to explicitly specify initialization at runtime (and vice versa, of course). There are two types of build arguments.\n- # Explicitly specify initialisation at runtime\n--initialize-at-run-time=...\n# Explicitly specify initialisation at build time\n--initialize-at-build-time=...\n\nTo enable tracing of class initialization, use the following arguments.\n- # Enable tracing of class initialization\n--trace-class-initialization=... # Deprecated in GraalVM 21.3 --trace-object-instantiation=... # Current option\n\n[Specify Class Initialization Explicitly](https://www.graalvm.org/latest/reference-manual/native-image/guides/specify-class-initialization/)\n\n[Class Initialization in Native Image](https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/ClassInitialization/)\n\n#### d) Prevent fallback builds:\n\nIf the application cannot be optimized during the Native Image build, the native-image tool will create a fallback file, which needs JVM. To prevent fallback builds, we need to specify the option `--no-fallback. For other build options, please look at the following document. `\n\n`\n\n`\n\n[Command-line Options](https://www.graalvm.org/latest/reference-manual/native-image/overview/Options/#build-options)\n\n`\n\n`\n\n### Build a Native Image application\n\n`\n\n`\n\nBuilding a native image application takes a long time (though it has got quicker over time). If building it for testing purpose, we strongly recommend enabling Quick Build and setting the optimization level to `-Ob` option (although this will still take time). See below for more information.\n\n`\n\n`\n\n[Maven plugin for GraalVM Native Image](https://graalvm.github.io/native-build-tools/latest/maven-plugin.html#native-image-options) [Gradle plugin for GraalVM Native Image](https://graalvm.github.io/native-build-tools/latest/gradle-plugin.html#native-image-options)\n\n`\n\n`\n\n[Optimizations and Performance](https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/#optimization-levels)\n\n`\n\n`\n\n### Test as a native image application\n\n`\n\n`\n\nWhen you start the native image application, we might see the following message: This message means that GC notifications are not available because `GarbageCollectorMXBean` of JVM does not provide any notifications.\n\n`\n\n`\n- GC notifications will not be available because no GarbageCollectorMXBean of the JVM provides any. GCs=[young generation scavenger, complete scavenger]\n\n`\n\n`\n\nLet’s check if the application works.\n\n`\n\n`\n\n#### 1) GET /books and GET /books/{isbn}\n\n`\n\n`\n\nThis is a normal REST API. Call both of them a few times.\n\n`\n\n`\n\n#### 2) GET /metrics\n\n`\n\n`\n\nWe can check the list of available metrics.\n\n`\n\n`\n- {\n\"names\": [ \"books.find\", \"books.index\", \"executor\", \"executor.active\", \"executor.completed\", \"executor.pool.core\", \"executor.pool.max\", \"executor.pool.size\", \"executor.queue.remaining\", \"executor.queued\", \"http.server.requests\", \"jvm.classes.loaded\", \"jvm.classes.unloaded\", \"jvm.memory.committed\", \"jvm.memory.max\", \"jvm.memory.used\", \"jvm.threads.daemon\", \"jvm.threads.live\", \"jvm.threads.peak\", \"jvm.threads.started\", \"jvm.threads.states\", \"logback.events\", \"microserviceBooksNumber.checks\", \"microserviceBooksNumber.latest\", \"microserviceBooksNumber.time\", \"process.cpu.usage\", \"process.files.max\", \"process.files.open\", \"process.start.time\", \"process.uptime\", \"system.cpu.count\", \"system.cpu.usage\", \"system.load.average.1m\" ] }\n\n`\n\n`\n\nAt first, the following three metrics are custom ones added in the class `MicroserviceBooksNumberService` .\n\n`\n\n`\n\n- `microserviceBooksNumber.checks`\n- `microserviceBooksNumber.time`\n- `microserviceBooksNumber.latest`\n\nAnd, the following two metrics are custom ones collected in the class `BooksController` , which collect information such as the time taken and the number of calls. Each metric can be viewed at `GET /metrics/{metric name}` .\n\n`\n\n`\n\n- `books.find`\n- `books.index`\n\n`\n\n`\n\nThe following is an example of `microserviceBooksNumber.*` .\n\n`\n\n`\n- // miroserviceBooksNumber.checks\n{ \"name\": \"microserviceBooksNumber.checks\", \"measurements\": [ { \"statistic\": \"COUNT\", \"value\": 12 } ] } // microserviceBooksNumber.time { \"name\": \"microserviceBooksNumber.time\", \"measurements\": [ { \"statistic\": \"COUNT\", \"value\": 12 }, { \"statistic\": \"TOTAL\\_TIME\", \"value\": 0.212468 }, { \"statistic\": \"MAX\", \"value\": 0.032744 } ], \"baseUnit\": \"seconds\" } //microserviceBooksNumber.latest { \"name\": \"microserviceBooksNumber.latest\", \"measurements\": [ { \"statistic\": \"VALUE\", \"value\": 2 } ] }\n\n`\n\n`\n\nHere is an example of the metric `books.*. `\n\n`\n\n`\n- // books.index\n{ \"name\": \"books.index\", \"measurements\": [ { \"statistic\": \"COUNT\", \"value\": 6 }, { \"statistic\": \"TOTAL\\_TIME\", \"value\": 3.08425 }, { \"statistic\": \"MAX\", \"value\": 3.02097 } ], \"availableTags\": [ { \"tag\": \"exception\", \"values\": [ \"none\" ] } ], \"baseUnit\": \"seconds\" } // books.find { \"name\": \"books.find\", \"measurements\": [ { \"statistic\": \"COUNT\", \"value\": 7 } ], \"availableTags\": [ { \"tag\": \"result\", \"values\": [ \"success\" ] }, { \"tag\": \"exception\", \"values\": [ \"none\" ] } ] }\n\n`\n\n`\n\n### Metrics from Azure Monitor (application insights)\n\n`\n\n`\n\nHere is the grid view of custom metrics in Application Insights (`microserviceBooks.time` is the average value).\n\n`\n\n`\n\n![]()\n\n`\n\n`\n\nTo confirm that the values match those in Application Insights, check the metric `http.server.requests` , for example. We should see three items on the graph and the value is equal to the number of API responses (3).\n\n`\n\n`\n\n![]()\n\n`\n\n`",
  "Tags": []
}
