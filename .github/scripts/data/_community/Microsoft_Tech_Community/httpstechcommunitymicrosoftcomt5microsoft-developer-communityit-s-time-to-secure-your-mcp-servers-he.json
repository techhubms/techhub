{
  "Tags": [],
  "EnhancedContent": "The Model Context Protocol (MCP) provides a powerful, standardized way for LLMs to interact with external tools. But as soon as you move from a local demo to a real-world application, a critical question arises: **How do you secure it?**\n\nExposing an MCP server without security is like leaving the front door of your house wide open. Anyone could walk in and use your tools, access your data, or cause havoc.\n\nThis guide will walk you through securing a Node.js MCP server from the ground up using **JSON Web Tokens (JWT)**. We'll cover authentication (who are you?) and authorization (what are you allowed to do?), with practical code samples based on this project that can be found at [Azure-Samples/mcp-container-ts](https://github.com/Azure-Samples/mcp-container-ts).\n\n## The Goal: From Unprotected to Fully Secured\n\nOur goal is to take a basic MCP server and add a robust security layer that:\n\n1. **Authenticates** every request to ensure it comes from a known user.\n2. **Authorizes** the user, granting them specific permissions based on their role (e.g., admin vs. readonly).\n3. **Protects** individual tools, so only authorized users can access them.\n\n## Why JWT is Perfect for MCP Security\n\nJWT is the industry standard for securing APIs, and it's an ideal fit for MCP servers for a few key reasons:\n\n- **Stateless:** Each JWT contains all the information needed to verify a user. The server doesn't need to store session information, which makes it highly scalable—perfect for handling many concurrent requests from AI agents.\n- **Self-Contained:** A JWT can carry user details, their role, and specific permissions directly within its payload.\n- **Tamper-Proof:** JWTs are digitally signed. If a token is modified in any way, the signature becomes invalid, and the server will reject it.\n- **Portable:** A single JWT can be used to access multiple secured services, which is common in microservice architectures.\n\n## Visualizing the Security Flow\n\nFor visual learners, this sequence diagram illustrates the complete authentication and authorization flow:\n\nComplete authentication and authorization flow\n\n## A Note on MCP Specification Compliance!\n\nIt's important to note that this guide provides a practical, real-world implementation for securing an MCP server, but it does **not** fully implement the [official MCP authorization specification](https://modelcontextprotocol.io/specification/2025-06-18/basic/authorization).\n\nThis implementation focuses on a robust, stateless, and widely understood pattern using traditional JWTs and role-based access control (RBAC), which is sufficient for many use cases. However, for full compliance with the MCP specification, you would need to implement additional features. In a future post, we may explore how to extend our JWT implementation to fully align with the MCP specification.\n\nWe recommend staring the [GitHub repository](https://github.com/Azure-Samples/mcp-container-ts) to stay updated and receive notifications about future improvements.\n\n## Step 1: Defining Roles and Permissions\n\nBefore writing any code, we must define our security rules. What roles exist? What can each role do? This is the foundation of our authorization system.\n\nIn our src/auth/authorization.ts file, we define UserRole and Permission enums. This makes our code clear, readable, and less prone to typos.\n\n``` // src/auth/authorization.ts\n\nexport enum UserRole { ADMIN = \"admin\", USER = \"user\", READONLY = \"readonly\", }\n\nexport enum Permission { CREATE_TODOS = \"create:todos\", READ_TODOS = \"read:todos\", UPDATE_TODOS = \"update:todos\", DELETE_TODOS = \"delete:todos\", LIST_TOOLS = \"list:tools\", }\n\n// This interface defines the structure of our authenticated user export interface AuthenticatedUser { id: string; role: UserRole; permissions: Permission[]; }\n\n// A simple map to assign default permissions to each role const rolePermissions: Record<UserRole, Permission[]> = { [UserRole.ADMIN]: Object.values(Permission), // Admin gets all permissions [UserRole.USER]: [ Permission.CREATE_TODOS, Permission.READ_TODOS, Permission.UPDATE_TODOS, Permission.LIST_TOOLS, ], [UserRole.READONLY]: [Permission.READ_TODOS, Permission.LIST_TOOLS], }; ```\n\n## Step 2: Creating a JWT Service\n\nNext, we need a centralized service to handle all JWT-related logic: creating new tokens for testing and, most importantly, verifying incoming tokens. This keeps our security logic clean and in one place.\n\nHere is the complete src/auth/jwt.ts file. It uses the jsonwebtoken library to do the heavy lifting.\n\n``` // src/auth/jwt.ts\n\nimport * as jwt from \"jsonwebtoken\"; import { AuthenticatedUser, getPermissionsForRole, UserRole, } from \"./authorization.js\";\n\n// These values should come from environment variables for security const JWT_SECRET = process.env.JWT_SECRET!; const JWT_AUDIENCE = process.env.JWT_AUDIENCE!; const JWT_ISSUER = process.env.JWT_ISSUER!; const JWT_EXPIRY = process.env.JWT_EXPIRY || \"2h\";\n\nif (!JWT_SECRET || !JWT_AUDIENCE || !JWT_ISSUER) { throw new Error(\"JWT environment variables are not set!\"); }\n\n/**\n* Generates a new JWT for a given user payload.\n* Useful for testing or generating tokens on demand.\n*/ export function generateToken( user: Partial<AuthenticatedUser> & { id: string } ): string { const payload = { id: user.id, role: user.role || UserRole.USER, permissions: user.permissions || getPermissionsForRole(user.role || UserRole.USER), };\n\nreturn jwt.sign(payload, JWT_SECRET, { algorithm: \"HS256\", expiresIn: JWT_EXPIRY, audience: JWT_AUDIENCE, issuer: JWT_ISSUER, }); }\n\n/**\n* Verifies an incoming JWT and returns the authenticated user payload if valid.\n*/ export function verifyToken(token: string): AuthenticatedUser { try { const decoded = jwt.verify(token, JWT_SECRET, { algorithms: [\"HS256\"], audience: JWT_AUDIENCE, issuer: JWT_ISSUER, }) as jwt.JwtPayload;\n\n// Ensure the decoded token has the fields we expect if (typeof decoded.id !== \"string\" || typeof decoded.role !== \"string\") { throw new Error(\"Token payload is missing required fields.\"); }\n\nreturn { id: decoded.id, role: decoded.role as UserRole, permissions: decoded.permissions || [], }; } catch (error) { // Log the specific error for debugging, but return a generic message console.error(\"JWT verification failed:\", error.message); if (error instanceof jwt.TokenExpiredError) { throw new Error(\"Token has expired.\"); } if (error instanceof jwt.JsonWebTokenError) { throw new Error(\"Invalid token.\"); } throw new Error(\"Could not verify token.\"); } } ```\n\n## Step 3: Building the Authentication Middleware\n\nA \"middleware\" is a function that runs *before* your main request handler. It's the perfect place to put our security check. This middleware will inspect every incoming request, look for a JWT in the Authorization header, and verify it.\n\nIf the token is valid, it attaches the user's information to the request object for later use. If not, it immediately sends a 401 Unauthorized error and stops the request from proceeding further.\n\nTo make this type-safe, we'll also extend Express's Request interface to include our user object.\n\n``` // src/server-middlewares.ts\n\nimport { Request, Response, NextFunction } from \"express\"; import { verifyToken, AuthenticatedUser } from \"./auth/jwt.js\";\n\n// Extend the global Express Request interface to add our custom 'user' property declare global { namespace Express { interface Request { user?: AuthenticatedUser; } } }\n\nexport function authenticateJWT( req: Request, res: Response, next: NextFunction ): void { const authHeader = req.headers.authorization;\n\nif (!authHeader || !authHeader.startsWith(\"Bearer \")) { res.status(401).json({ error: \"Authentication required\", message: \"Authorization header with 'Bearer' scheme must be provided.\", }); return; }\n\nconst token = authHeader.substring(7); // Remove \"Bearer \"\n\ntry { const userPayload = verifyToken(token); req.user = userPayload; // Attach user payload to the request next(); // Proceed to the next middleware or request handler } catch (error) { res.status(401).json({ error: \"Invalid token\", message: error.message, }); } } ```\n\n## Step 4: Protecting the MCP Server\n\nNow we have all the pieces. Let's put them together to protect our server.\n\nFirst, we apply our **authenticateJWT** middleware to the main MCP endpoint in src/index.ts. This ensures **every** request to **/mcp** must have a valid JWT.\n\n``` // src/index.ts // ... other imports import { authenticateJWT } from \"./server-middlewares.js\";\n\n// ... const MCP_ENDPOINT = \"/mcp\"; const app = express();\n\n// Apply security middleware ONLY to the MCP endpoint app.use(MCP_ENDPOINT, authenticateJWT); // ... rest of the file ```\n\nNext, we'll enforce our fine-grained permissions. Let's secure the ListTools handler in src/server.ts. We'll modify it to check if the authenticated user has the Permission.LIST\\_TOOLS permission before returning the list of tools.\n\n``` // src/server.ts // ... other imports import { hasPermission, Permission } from \"./auth/authorization.js\";\n\n// ... inside the StreamableHTTPServer class\n\nprivate setupServerRequestHandlers() { this.server.setRequestHandler(ListToolsRequestSchema, async (request) => { // The user is attached to the request by our middleware const user = this.currentUser;\n\n// 1. Check for an authenticated user if (!user) { return this.createRPCErrorResponse(\"Authentication required.\"); }\n\n// 2. Check if the user has the specific permission to list tools if (!hasPermission(user, Permission.LIST_TOOLS)) { return this.createRPCErrorResponse( \"Insufficient permissions to list tools.\" ); }\n\n// 3. If checks pass, filter tools based on user's permissions const allowedTools = TodoTools.filter((tool) => { const requiredPermissions = this.getToolRequiredPermissions(tool.name); // The user must have at least one of the permissions required for the tool return requiredPermissions.some((p) => hasPermission(user, p)); });\n\nreturn { jsonrpc: \"2.0\", tools: allowedTools, }; });\n\n// ... other request handlers } ```\n\nWith this change, a user with a readonly role can list tools, but a user without the LIST\\_TOOLS permission would be denied access.\n\n## Conclusion and Next Steps\n\nCongratulations! You've successfully implemented a robust authentication and authorization layer for your MCP server. By following these steps, you have:\n\n- Defined clear roles and permissions.\n- Created a centralized service for handling JWTs.\n- Built a middleware to protect all incoming requests.\n- Enforced granular permissions at the tool level.\n\nYour MCP server is no longer an open door—it's a secure service. From here, you can expand on these concepts by adding more roles, more permissions, and even more complex business logic to your authorization system.\n\nStar our [GitHub repository](https://github.com/Azure-Samples/mcp-container-ts) to stay updated and receive notifications about future improvements.\n\nUpdated Sep 22, 2025\n\nVersion 1.0\n\n[ai](/tag/ai?nodeId=board%3AAzureDevCommunityBlog)\n\n[mcp](/tag/mcp?nodeId=board%3AAzureDevCommunityBlog)\n\n[!\\[wassimchegham&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS05NTQ3NTQtSXBGdUR6?image-coordinates=0%2C0%2C580%2C580&amp;image-dimensions=50x50)](/users/wassimchegham/954754) [wassimchegham](/users/wassimchegham/954754) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined February 04, 2021\n\n[View Profile](/users/wassimchegham/954754)\n\n/category/azure/blog/azuredevcommunityblog [Microsoft Developer Community Blog](/category/azure/blog/azuredevcommunityblog) Follow this blog board to get notified when there's new activity",
  "PubDate": "2025-09-25T07:00:00+00:00",
  "Link": "https://techcommunity.microsoft.com/t5/microsoft-developer-community/it-s-time-to-secure-your-mcp-servers-here-s-how/ba-p/4434308",
  "OutputDir": "_community",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Title": "It's time to secure your MCP servers. Here's how.",
  "Description": "The Model Context Protocol (MCP) provides a powerful, standardized way for LLMs to interact with external tools. But as soon as you move from a local demo to a real-world application, a critical question arises: **How do you secure it?**\n\nExposing an MCP server without security is like leaving the front door of your house wide open. Anyone could walk in and use your tools, access your data, or cause havoc.\n\nThis guide will walk you through securing a Node.js MCP server from the ground up using **JSON Web Tokens (JWT)**. We'll cover authentication (who are you?) and authorization (what are you allowed to do?), with practical code samples based on this project that can be found at [Azure-Samples/mcp-container-ts](https://github.com/Azure-Samples/mcp-container-ts).\n\n## The Goal: From Unprotected to Fully Secured\n\nOur goal is to take a basic MCP server and add a robust security layer that:\n\n1. **Authenticates** every request to ensure it comes from a known user.\n2. **Authorizes** the user, granting them specific permissions based on their role (e.g., admin vs. readonly).\n3. **Protects** individual tools, so only authorized users can access them.\n\n## Why JWT is Perfect for MCP Security\n\nJWT is the industry standard for securing APIs, and it's an ideal fit for MCP servers for a few key reasons:\n\n- **Stateless:** Each JWT contains all the information needed to verify a user. The server doesn't need to store session information, which makes it highly scalable—perfect for handling many concurrent requests from AI agents.\n- **Self-Contained:** A JWT can carry user details, their role, and specific permissions directly within its payload.\n- **Tamper-Proof:** JWTs are digitally signed. If a token is modified in any way, the signature becomes invalid, and the server will reject it.\n- **Portable:** A single JWT can be used to access multiple secured services, which is common in microservice architectures.\n\n## Visualizing the Security Flow\n\nFor visual learners, this sequence diagram illustrates the complete authentication and authorization flow:\n\n![]()Complete authentication and authorization flow\n\n## A Note on MCP Specification Compliance!\n\nIt's important to note that this guide provides a practical, real-world implementation for securing an MCP server, but it does **not** fully implement the [official MCP authorization specification](https://modelcontextprotocol.io/specification/2025-06-18/basic/authorization).\n\nThis implementation focuses on a robust, stateless, and widely understood pattern using traditional JWTs and role-based access control (RBAC), which is sufficient for many use cases. However, for full compliance with the MCP specification, you would need to implement additional features. In a future post, we may explore how to extend our JWT implementation to fully align with the MCP specification.\n\nWe recommend staring the [GitHub repository](https://github.com/Azure-Samples/mcp-container-ts) to stay updated and receive notifications about future improvements.\n\n## Step 1: Defining Roles and Permissions\n\nBefore writing any code, we must define our security rules. What roles exist? What can each role do? This is the foundation of our authorization system.\n\nIn our src/auth/authorization.ts file, we define UserRole and Permission enums. This makes our code clear, readable, and less prone to typos.\n\n- // src/auth/authorization.ts\n\nexport enum UserRole { ADMIN = \"admin\", USER = \"user\", READONLY = \"readonly\", }\n\nexport enum Permission { CREATE\\_TODOS = \"create:todos\", READ\\_TODOS = \"read:todos\", UPDATE\\_TODOS = \"update:todos\", DELETE\\_TODOS = \"delete:todos\", LIST\\_TOOLS = \"list:tools\", }\n\n// This interface defines the structure of our authenticated user export interface AuthenticatedUser { id: string; role: UserRole; permissions: Permission[]; }\n\n// A simple map to assign default permissions to each role const rolePermissions: Record = { [UserRole.ADMIN]: Object.values(Permission), // Admin gets all permissions [UserRole.USER]: [ Permission.CREATE\\_TODOS, Permission.READ\\_TODOS, Permission.UPDATE\\_TODOS, Permission.LIST\\_TOOLS, ], [UserRole.READONLY]: [Permission.READ\\_TODOS, Permission.LIST\\_TOOLS], };\n\n## Step 2: Creating a JWT Service\n\nNext, we need a centralized service to handle all JWT-related logic: creating new tokens for testing and, most importantly, verifying incoming tokens. This keeps our security logic clean and in one place.\n\nHere is the complete src/auth/jwt.ts file. It uses the jsonwebtoken library to do the heavy lifting.\n- // src/auth/jwt.ts\n\nimport \\* as jwt from \"jsonwebtoken\"; import { AuthenticatedUser, getPermissionsForRole, UserRole, } from \"./authorization.js\";\n\n// These values should come from environment variables for security const JWT\\_SECRET = process.env.JWT\\_SECRET!; const JWT\\_AUDIENCE = process.env.JWT\\_AUDIENCE!; const JWT\\_ISSUER = process.env.JWT\\_ISSUER!; const JWT\\_EXPIRY = process.env.JWT\\_EXPIRY || \"2h\";\n\nif (!JWT\\_SECRET || !JWT\\_AUDIENCE || !JWT\\_ISSUER) { throw new Error(\"JWT environment variables are not set!\"); }\n\n/\\*\\* \\* Generates a new JWT for a given user payload. \\* Useful for testing or generating tokens on demand. \\*/ export function generateToken( user: Partial & { id: string } ): string { const payload = { id: user.id, role: user.role || UserRole.USER, permissions: user.permissions || getPermissionsForRole(user.role || UserRole.USER), };\n\nreturn jwt.sign(payload, JWT\\_SECRET, { algorithm: \"HS256\", expiresIn: JWT\\_EXPIRY, audience: JWT\\_AUDIENCE, issuer: JWT\\_ISSUER, }); }\n\n/\\*\\* \\* Verifies an incoming JWT and returns the authenticated user payload if valid. \\*/ export function verifyToken(token: string): AuthenticatedUser { try { const decoded = jwt.verify(token, JWT\\_SECRET, { algorithms: [\"HS256\"], audience: JWT\\_AUDIENCE, issuer: JWT\\_ISSUER, }) as jwt.JwtPayload;\n\n// Ensure the decoded token has the fields we expect if (typeof decoded.id !== \"string\" || typeof decoded.role !== \"string\") { throw new Error(\"Token payload is missing required fields.\"); }\n\nreturn { id: decoded.id, role: decoded.role as UserRole, permissions: decoded.permissions || [], }; } catch (error) { // Log the specific error for debugging, but return a generic message console.error(\"JWT verification failed:\", error.message); if (error instanceof jwt.TokenExpiredError) { throw new Error(\"Token has expired.\"); } if (error instanceof jwt.JsonWebTokenError) { throw new Error(\"Invalid token.\"); } throw new Error(\"Could not verify token.\"); } }\n\n## Step 3: Building the Authentication Middleware\n\nA \"middleware\" is a function that runs *before* your main request handler. It's the perfect place to put our security check. This middleware will inspect every incoming request, look for a JWT in the Authorization header, and verify it.\n\nIf the token is valid, it attaches the user's information to the request object for later use. If not, it immediately sends a 401 Unauthorized error and stops the request from proceeding further.\n\nTo make this type-safe, we'll also extend Express's Request interface to include our user object.\n- // src/server-middlewares.ts\n\nimport { Request, Response, NextFunction } from \"express\"; import { verifyToken, AuthenticatedUser } from \"./auth/jwt.js\";\n\n// Extend the global Express Request interface to add our custom 'user' property declare global { namespace Express { interface Request { user?: AuthenticatedUser; } } }\n\nexport function authenticateJWT( req: Request, res: Response, next: NextFunction ): void { const authHeader = req.headers.authorization;\n\nif (!authHeader || !authHeader.startsWith(\"Bearer \")) { res.status(401).json({ error: \"Authentication required\", message: \"Authorization header with 'Bearer' scheme must be provided.\", }); return; }\n\nconst token = authHeader.substring(7); // Remove \"Bearer \"\n\ntry { const userPayload = verifyToken(token); req.user = userPayload; // Attach user payload to the request next(); // Proceed to the next middleware or request handler } catch (error) { res.status(401).json({ error: \"Invalid token\", message: error.message, }); } }\n\n## Step 4: Protecting the MCP Server\n\nNow we have all the pieces. Let's put them together to protect our server.\n\nFirst, we apply our **authenticateJWT** middleware to the main MCP endpoint in src/index.ts. This ensures **every** request to **/mcp** must have a valid JWT.\n- // src/index.ts\n// ... other imports import { authenticateJWT } from \"./server-middlewares.js\";\n\n// ... const MCP\\_ENDPOINT = \"/mcp\"; const app = express();\n\n// Apply security middleware ONLY to the MCP endpoint app.use(MCP\\_ENDPOINT, authenticateJWT); // ... rest of the file\n\nNext, we'll enforce our fine-grained permissions. Let's secure the ListTools handler in src/server.ts. We'll modify it to check if the authenticated user has the Permission.LIST\\_TOOLS permission before returning the list of tools.\n- // src/server.ts\n// ... other imports import { hasPermission, Permission } from \"./auth/authorization.js\";\n\n// ... inside the StreamableHTTPServer class\n\nprivate setupServerRequestHandlers() { this.server.setRequestHandler(ListToolsRequestSchema, async (request) => { // The user is attached to the request by our middleware const user = this.currentUser;\n\n// 1. Check for an authenticated user if (!user) { return this.createRPCErrorResponse(\"Authentication required.\"); }\n\n// 2. Check if the user has the specific permission to list tools if (!hasPermission(user, Permission.LIST\\_TOOLS)) { return this.createRPCErrorResponse( \"Insufficient permissions to list tools.\" ); }\n\n// 3. If checks pass, filter tools based on user's permissions const allowedTools = TodoTools.filter((tool) => { const requiredPermissions = this.getToolRequiredPermissions(tool.name); // The user must have at least one of the permissions required for the tool return requiredPermissions.some((p) => hasPermission(user, p)); });\n\nreturn { jsonrpc: \"2.0\", tools: allowedTools, }; });\n\n// ... other request handlers }\n\nWith this change, a user with a readonly role can list tools, but a user without the LIST\\_TOOLS permission would be denied access.\n\n## Conclusion and Next Steps\n\nCongratulations! You've successfully implemented a robust authentication and authorization layer for your MCP server. By following these steps, you have:\n\n- Defined clear roles and permissions.\n- Created a centralized service for handling JWTs.\n- Built a middleware to protect all incoming requests.\n- Enforced granular permissions at the tool level.\n\nYour MCP server is no longer an open door—it's a secure service. From here, you can expand on these concepts by adding more roles, more permissions, and even more complex business logic to your authorization system.\n\nStar our [GitHub repository](https://github.com/Azure-Samples/mcp-container-ts) to stay updated and receive notifications about future improvements.",
  "Author": "wassimchegham",
  "ProcessedDate": "2025-09-25 07:13:37",
  "FeedName": "Microsoft Tech Community",
  "FeedLevelAuthor": "rss.livelink.threads-in-node"
}
