{
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/deployment-and-build-from-azure-linux-based-web-app/ba-p/4461950",
  "Title": "Deployment and Build from Azure Linux based Web App",
  "EnhancedContent": "## In this tutorial, I’ll use a simple Python app to demonstrate four different Deployment/Build approaches. Each method has its own use cases and limitations. You can even combine them, for example, using your laptop as the deployment tool while still using Oryx as the build engine. The same concepts apply to other runtimes such as Node.js, PHP, and beyond.\n\n# **TOC**\n\n1. Introduction\n2. Deployment  Sources\n- From Laptop\n- From CI/CD tools\n3. Build Source\n- From Oryx Build\n- From Runtime\n- From Deployment  Sources\n4. Walkthrough\n- Laptop + Oryx\n- Laptop + Runtime\n- Laptop\n- CI/CD concept\n5. Conclusion\n\n## **1. Introduction**\n\nDeployment on Azure Linux Web Apps can be done through several different methods. When a deployment issue occurs, the first step is usually to identify which method was used. The core of these methods revolves around the concept of Build, the process of preparing and loading the third-party dependencies required to run an application. For example, a Python app defines its build process as pip install packages, a Node.js app uses npm install modules, and PHP or Java apps rely on libraries.\n\nIn this tutorial, I’ll use a simple Python app to demonstrate four different Deployment/Build approaches. Each method has its own use cases and limitations. You can even combine them, for example, using your laptop as the deployment tool while still using Oryx as the build engine. The same concepts apply to other runtimes such as Node.js, PHP, and beyond.\n\n## **2. Deployment  Sources**\n\n#### From Laptop\n\n**Scenarios:**\n\n- Setting up a proof of concept\n- Developing in a local environment\n\n**Advantages:**\n\n- Fast development cycle\n- Minimal configuration required\n\n**Limitations:**\n\n- Difficult for the local test environment to interact with cloud resources\n- OS differences between local and cloud environments may cause integration issues\n\n#### From CI/CD tools\n\n**Scenarios:**\n\n- Projects with established development and deployment workflows\n- Codebases requiring version control and automation\n\n**Advantages:**\n\n- Developers can focus purely on coding\n- Automatic deployment upon branch commits\n\n**Limitations:**\n\n- Build and runtime environments may still differ slightly at the OS level\n\n## **3. Build Source**\n\n#### From Oryx Build\n\n**Scenarios:**\n\n- Offloading resource-intensive build tasks from your local or CI/CD environment directly to the Azure Web App platform, reducing local computing overhead.\n\n**Advantages:**\n\n- Minimal extra configuration\n- Multi-language support\n\n**Limitations:**\n\n- Build performance is limited by the App Service SKU and may face performance bottlenecks\n- The build environment may differ from the runtime environment, so apps sensitive to minor package versions should take caution\n\n#### From Runtime\n\n**Scenarios:**\n\n- When you want the benefits and pricing of a PaaS solution but need control similar to an IaaS setup\n\n**Advantages:**\n\n- Build occurs in the runtime environment itself\n- Allows greater flexibility for low-level system operations\n\n**Limitations:**\n\n- Certain system-level settings (e.g., NTP time sync) remain inaccessible\n\n#### From Deployment  Sources\n\n**Scenarios:**\n\n- Pre-package all dependencies and deploy them together, eliminating the need for a separate build step.\n\n**Advantages:**\n\n- Supports proprietary or closed-source company packages\n\n**Limitations:**\n\n- Incompatibility may arise if the development and runtime environments differ significantly in OS or package support\n\n| Type | Method | Scenario | Advantage | Limitation | | --- | --- | --- | --- | --- | | **Deployment** | From Laptop | POC / Dev | Fast setup | Poor cloud link | | **Deployment** | From CI/CD | Auto pipeline | Focus on code | OS mismatch | | **Build** | From Oryx | Platform build | Simple, multi-lang | Performance cap | | **Build** | From Runtime | High control | Flexible ops | Limited access | | **Build** | From **Deployment** | Pre-built deploy | Use private pkg | Env mismatch |\n\n## **4. Walkthrough**\n\n#### Laptop + Oryx\n\n**Add Environment Variables**\n\n- **SCM\\_DO\\_BUILD\\_DURING\\_DEPLOYMENT=false**\n(Purpose: prevents the deployment environment from packaging during publish; this must also be set in the deployment environment itself.)\n- **WEBSITE\\_RUN\\_FROM\\_PACKAGE=false**\n(Purpose: tells Azure Web App not to run the app from a prepackaged file.)\n- **ENABLE\\_ORYX\\_BUILD=true**\n(Purpose: allows the Azure Web App platform to handle the build process automatically after a deployment event.)\n\n**Add startup command**\n\n``` bash /home/site/wwwroot/run.sh ```\n\n(The run.sh file corresponds to the script in your project code.)\n\n**Check sample code**\n\nrequirements.txt — defines Python packages (similar to package.json in Node.js).\n\n``` Flask==3.0.3 gunicorn==23.0.0 ```\n\napp.py — main Python application code.\n\n``` from flask import Flask app = Flask(__name__) @app.route(\"/\") def home(): return \"Deploy from Laptop + Oryx\" if __name__ == \"__main__\": import os app.run(host=\"0.0.0.0\", port=8000) ```\n\nrun.sh — script used to start the application.\n\n``` #!/bin/bash gunicorn --bind=0.0.0.0:8000 app:app ```\n\n.deployment — VS Code deployment configuration file.\n\n``` [config] SCM_DO_BUILD_DURING_DEPLOYMENT=false ```\n\n**Deployment**\n\nOnce both the deployment and build processes complete successfully, you should see the expected result.\n\n#### Laptop + Runtime\n\n**Add Environment Variables** (Screenshots omitted since the process is similar to previous steps)\n\n- **SCM\\_DO\\_BUILD\\_DURING\\_DEPLOYMENT=false**\nPurpose: Prevents the deployment environment from packaging during the publishing process. This setting must also be added in the deployment environment itself.\n- **WEBSITE\\_RUN\\_FROM\\_PACKAGE=false**\nPurpose: Instructs Azure Web App not to run the application from a prepackaged file.\n- **ENABLE\\_ORYX\\_BUILD=false**\nPurpose: Ensures that Azure Web App does not perform any build after deployment; all build tasks will instead be handled during the startup script execution.\n\n**Add Startup Command** (Screenshots omitted since the process is similar to previous steps)\n\n``` bash /home/site/wwwroot/run.sh ```\n\n(The run.sh file corresponds to the script of the same name in your project code.)\n\n**Check Sample Code** (Screenshots omitted since the process is similar to previous steps)\n\n**requirements.txt**: Defines Python packages (similar to package.json in Node.js).\n\n``` Flask==3.0.3 gunicorn==23.0.0 ```\n\n**app.py**: The main Python application code.\n\n``` from flask import Flask\n\napp = Flask(__name__)\n\n@app.route(\"/\") def home(): return \"Deploy from Laptop + Runtime\"\n\nif __name__ == \"__main__\": import os app.run(host=\"0.0.0.0\", port=8000)\n\n```\n\n**run.sh**: Startup script. In addition to launching the app, it also creates a virtual environment and installs dependencies, all build-related tasks happen here.\n\n``` #!/bin/bash python -m venv venv source venv/bin/activate pip install -r requirements.txt gunicorn --bind=0.0.0.0:8000 app:app ```\n\n**.deployment**: VS Code deployment configuration file.\n\n``` [config] SCM_DO_BUILD_DURING_DEPLOYMENT=false ```\n\n**Deployment** (Screenshots omitted since the process is similar to previous steps)\n\nOnce both deployment and build are completed, you should see the expected output.\n\n#### Laptop\n\n**Add Environment Variables** (Screenshots omitted as the process is similar to previous steps)\n\n- **SCM\\_DO\\_BUILD\\_DURING\\_DEPLOYMENT=false**\nPurpose: Prevents the deployment environment from packaging during publish. This must also be set in the deployment environment itself.\n- **WEBSITE\\_RUN\\_FROM\\_PACKAGE=false**\nPurpose: Instructs Azure Web App not to run the app from a prepackaged file.\n- **ENABLE\\_ORYX\\_BUILD=false**\nPurpose: Prevents Azure Web App from building after deployment. All build tasks will instead execute during the startup script.\n\n**Add Startup Command** (Screenshots omitted as the process is similar to previous steps)\n\n``` bash /home/site/wwwroot/run.sh ```\n\n(The run.sh corresponds to the same-named file in your project code.)\n\n**Check Sample Code** (Screenshots omitted as the process is similar to previous steps)\n\n**requirements.txt**: Defines Python packages (like package.json in Node.js).\n\n``` Flask==3.0.3 gunicorn==23.0.0 ```\n\n**app.py**: The main Python application.\n\n``` from flask import Flask\n\napp = Flask(__name__)\n\n@app.route(\"/\") def home(): return \"Deploy from Laptop\"\n\nif __name__ == \"__main__\": import os app.run(host=\"0.0.0.0\", port=8000)\n\n```\n\n**run.sh**: The startup script. In addition to launching the app, it activates an existing virtual environment. **The creation of that environment and installation of dependencies will occur in the next section.**\n\n``` #!/bin/bash source venv/bin/activate gunicorn --bind=0.0.0.0:8000 app:app ```\n\n**.deployment**: VS Code deployment configuration file.\n\n``` [config] SCM_DO_BUILD_DURING_DEPLOYMENT=false ```\n\n**Deployment** Before deployment, you must perform a local build process. Run commands locally (depending on the language, usually for installing dependencies).\n\n``` python -m venv venv source venv/bin/activate pip install -r requirements.txt ```\n\nAfter completing the local build, deploy your app.\n\nOnce deployment finishes, you should see the expected result.\n\n#### CI/CD concept\n\nFor example, when using **Azure DevOps (ADO)** as your CI/CD tool, its behavior conceptually mirrors deploying directly from a laptop, but with enhanced automation, governance, and reproducibility. Essentially, ADO pipelines translate your manual local deployment steps into codified, repeatable workflows defined in a **YAML pipeline file**, executed by Microsoft-hosted or self-hosted agents.\n\nA typical azure-pipelines.yml defines the stages (e.g., *build*, *deploy*) and their corresponding jobs and steps. Each stage runs on a specified VM image (e.g., ubuntu-latest) and executes commands, the same npm install, pip install which you would normally run on your laptop.\n\nThe **ADO pipeline** acts as your automated laptop, every build command, environment variable, and deployment step you’d normally execute locally is just formalized in YAML. Whether you build inline, use Oryx, or deploy pre-built artifacts, the underlying concept remains identical: compile, package, and deliver code to Azure. The distinction lies in *who performs it*.\n\n## **5. Conclusion**\n\nDifferent deployment and build methods lead to different debugging and troubleshooting approaches. Therefore, understanding the selected deployment method and its corresponding troubleshooting process is an essential skill for every developer and DevOps engineer.\n\nUpdated Oct 16, 2025\n\nVersion 1.0\n\n[azure app service](/tag/azure%20app%20service?nodeId=board%3AAppsonAzureBlog)\n\n[azure paas](/tag/azure%20paas?nodeId=board%3AAppsonAzureBlog)\n\n[best practices](/tag/best%20practices?nodeId=board%3AAppsonAzureBlog)\n\n[devops](/tag/devops?nodeId=board%3AAppsonAzureBlog)\n\n[python](/tag/python?nodeId=board%3AAppsonAzureBlog)\n\n[web apps](/tag/web%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[theringe&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0xMzU3ODIyLVIxNkJKdg?image-coordinates=0%2C0%2C800%2C800&amp;image-dimensions=50x50)](/users/theringe/1357822) [theringe](/users/theringe/1357822) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined April 08, 2022\n\n[View Profile](/users/theringe/1357822)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "Tags": [],
  "FeedName": "Microsoft Tech Community",
  "PubDate": "2025-10-16T12:39:45+00:00",
  "Author": "theringe",
  "Description": "# **TOC**\n\n1. Introduction\n2. Deployment Sources\n- From Laptop\n- From CI/CD tools\n3. Build Source\n- From Oryx Build\n- From Runtime\n- From Deployment Sources\n4. Walkthrough\n- Laptop + Oryx\n- Laptop + Runtime\n- Laptop\n- CI/CD concept\n5. Conclusion\n\n## **1. Introduction**\n\nDeployment on Azure Linux Web Apps can be done through several different methods. When a deployment issue occurs, the first step is usually to identify which method was used. The core of these methods revolves around the concept of Build, the process of preparing and loading the third-party dependencies required to run an application. For example, a Python app defines its build process as pip install packages, a Node.js app uses npm install modules, and PHP or Java apps rely on libraries.\n\nIn this tutorial, I’ll use a simple Python app to demonstrate four different Deployment/Build approaches. Each method has its own use cases and limitations. You can even combine them, for example, using your laptop as the deployment tool while still using Oryx as the build engine. The same concepts apply to other runtimes such as Node.js, PHP, and beyond.\n\n## **2. Deployment Sources**\n\n#### From Laptop\n\n**Scenarios:**\n\n- Setting up a proof of concept\n- Developing in a local environment\n\n**Advantages:**\n\n- Fast development cycle\n- Minimal configuration required\n\n**Limitations:**\n\n- Difficult for the local test environment to interact with cloud resources\n- OS differences between local and cloud environments may cause integration issues\n\n#### From CI/CD tools\n\n**Scenarios:**\n\n- Projects with established development and deployment workflows\n- Codebases requiring version control and automation\n\n**Advantages:**\n\n- Developers can focus purely on coding\n- Automatic deployment upon branch commits\n\n**Limitations:**\n\n- Build and runtime environments may still differ slightly at the OS level\n\n## **3. Build Source**\n\n#### From Oryx Build\n\n**Scenarios:**\n\n- Offloading resource-intensive build tasks from your local or CI/CD environment directly to the Azure Web App platform, reducing local computing overhead.\n\n**Advantages:**\n\n- Minimal extra configuration\n- Multi-language support\n\n**Limitations:**\n\n- Build performance is limited by the App Service SKU and may face performance bottlenecks\n- The build environment may differ from the runtime environment, so apps sensitive to minor package versions should take caution\n\n#### From Runtime\n\n**Scenarios:**\n\n- When you want the benefits and pricing of a PaaS solution but need control similar to an IaaS setup\n\n**Advantages:**\n\n- Build occurs in the runtime environment itself\n- Allows greater flexibility for low-level system operations\n\n**Limitations:**\n\n- Certain system-level settings (e.g., NTP time sync) remain inaccessible\n\n#### From Deployment Sources\n\n**Scenarios:**\n\n- Pre-package all dependencies and deploy them together, eliminating the need for a separate build step.\n\n**Advantages:**\n\n- Supports proprietary or closed-source company packages\n\n**Limitations:**\n\n- Incompatibility may arise if the development and runtime environments differ significantly in OS or package support\n\n| Type | Method | Scenario | Advantage | Limitation | | --- | --- | --- | --- | --- | | **Deployment** | From Laptop | POC / Dev | Fast setup | Poor cloud link | | **Deployment** | From CI/CD | Auto pipeline | Focus on code | OS mismatch | | **Build** | From Oryx | Platform build | Simple, multi-lang | Performance cap | | **Build** | From Runtime | High control | Flexible ops | Limited access | | **Build** | From **Deployment** | Pre-built deploy | Use private pkg | Env mismatch |\n\n## **4. Walkthrough**\n\n#### Laptop + Oryx\n\n**Add Environment Variables**\n\n- **SCM\\_DO\\_BUILD\\_DURING\\_DEPLOYMENT=false**\n(Purpose: prevents the deployment environment from packaging during publish; this must also be set in the deployment environment itself.)\n- **WEBSITE\\_RUN\\_FROM\\_PACKAGE=false**\n(Purpose: tells Azure Web App not to run the app from a prepackaged file.)\n- **ENABLE\\_ORYX\\_BUILD=true**\n(Purpose: allows the Azure Web App platform to handle the build process automatically after a deployment event.)\n\n![]()\n\n**Add startup command**\n\n- bash /home/site/wwwroot/run.sh\n\n(The run.sh file corresponds to the script in your project code.)\n\n![]()\n\n**Check sample code**\n\n![]()\n\nrequirements.txt — defines Python packages (similar to package.json in Node.js).\n- Flask==3.0.3\ngunicorn==23.0.0\n\napp.py — main Python application code.\n- from flask import Flask\napp = Flask(\\_\\_name\\_\\_) @app.route(\"/\") def home(): return \"Deploy from Laptop + Oryx\" if \\_\\_name\\_\\_ == \"\\_\\_main\\_\\_\": import os app.run(host=\"0.0.0.0\", port=8000)\n\nrun.sh — script used to start the application.\n- #!/bin/bash\ngunicorn --bind=0.0.0.0:8000 app:app\n\n.deployment — VS Code deployment configuration file.\n- [config]\nSCM\\_DO\\_BUILD\\_DURING\\_DEPLOYMENT=false\n\n**Deployment**\n\n![]()\n\nOnce both the deployment and build processes complete successfully, you should see the expected result.\n\n![]()\n\n#### Laptop + Runtime\n\n**Add Environment Variables** (Screenshots omitted since the process is similar to previous steps)\n\n- **SCM\\_DO\\_BUILD\\_DURING\\_DEPLOYMENT=false**\nPurpose: Prevents the deployment environment from packaging during the publishing process. This setting must also be added in the deployment environment itself.\n- **WEBSITE\\_RUN\\_FROM\\_PACKAGE=false**\nPurpose: Instructs Azure Web App not to run the application from a prepackaged file.\n- **ENABLE\\_ORYX\\_BUILD=false**\nPurpose: Ensures that Azure Web App does not perform any build after deployment; all build tasks will instead be handled during the startup script execution.\n\n**Add Startup Command** (Screenshots omitted since the process is similar to previous steps)\n- bash /home/site/wwwroot/run.sh\n\n(The run.sh file corresponds to the script of the same name in your project code.)\n\n**Check Sample Code** (Screenshots omitted since the process is similar to previous steps)\n\n**requirements.txt**: Defines Python packages (similar to package.json in Node.js).\n- Flask==3.0.3\ngunicorn==23.0.0\n\n**app.py**: The main Python application code.\n- from flask import Flask\n\napp = Flask(\\_\\_name\\_\\_)\n\n@app.route(\"/\") def home(): return \"Deploy from Laptop + Runtime\"\n\nif \\_\\_name\\_\\_ == \"\\_\\_main\\_\\_\": import os app.run(host=\"0.0.0.0\", port=8000)\n\n**run.sh**: Startup script. In addition to launching the app, it also creates a virtual environment and installs dependencies, all build-related tasks happen here.\n- #!/bin/bash\npython -m venv venv source venv/bin/activate pip install -r requirements.txt gunicorn --bind=0.0.0.0:8000 app:app\n\n**.deployment**: VS Code deployment configuration file.\n- [config]\nSCM\\_DO\\_BUILD\\_DURING\\_DEPLOYMENT=false\n\n**Deployment** (Screenshots omitted since the process is similar to previous steps)\n\nOnce both deployment and build are completed, you should see the expected output.\n\n![]()\n\n#### Laptop\n\n**Add Environment Variables** (Screenshots omitted as the process is similar to previous steps)\n\n- **SCM\\_DO\\_BUILD\\_DURING\\_DEPLOYMENT=false**\nPurpose: Prevents the deployment environment from packaging during publish. This must also be set in the deployment environment itself.\n- **WEBSITE\\_RUN\\_FROM\\_PACKAGE=false**\nPurpose: Instructs Azure Web App not to run the app from a prepackaged file.\n- **ENABLE\\_ORYX\\_BUILD=false**\nPurpose: Prevents Azure Web App from building after deployment. All build tasks will instead execute during the startup script.\n\n**Add Startup Command** (Screenshots omitted as the process is similar to previous steps)\n- bash /home/site/wwwroot/run.sh\n\n(The run.sh corresponds to the same-named file in your project code.)\n\n**Check Sample Code** (Screenshots omitted as the process is similar to previous steps)\n\n**requirements.txt**: Defines Python packages (like package.json in Node.js).\n- Flask==3.0.3\ngunicorn==23.0.0\n\n**app.py**: The main Python application.\n- from flask import Flask\n\napp = Flask(\\_\\_name\\_\\_)\n\n@app.route(\"/\") def home(): return \"Deploy from Laptop\"\n\nif \\_\\_name\\_\\_ == \"\\_\\_main\\_\\_\": import os app.run(host=\"0.0.0.0\", port=8000)\n\n**run.sh**: The startup script. In addition to launching the app, it activates an existing virtual environment. **The creation of that environment and installation of dependencies will occur in the next section.**\n- #!/bin/bash\nsource venv/bin/activate gunicorn --bind=0.0.0.0:8000 app:app\n\n**.deployment**: VS Code deployment configuration file.\n- [config]\nSCM\\_DO\\_BUILD\\_DURING\\_DEPLOYMENT=false\n\n**Deployment** Before deployment, you must perform a local build process. Run commands locally (depending on the language, usually for installing dependencies).\n\n![]()\n- python -m venv venv\nsource venv/bin/activate pip install -r requirements.txt\n\nAfter completing the local build, deploy your app.\n\nOnce deployment finishes, you should see the expected result.\n\n![]()\n\n#### CI/CD concept\n\nFor example, when using **Azure DevOps (ADO)** as your CI/CD tool, its behavior conceptually mirrors deploying directly from a laptop, but with enhanced automation, governance, and reproducibility. Essentially, ADO pipelines translate your manual local deployment steps into codified, repeatable workflows defined in a **YAML pipeline file**, executed by Microsoft-hosted or self-hosted agents.\n\nA typical azure-pipelines.yml defines the stages (e.g., *build*, *deploy*) and their corresponding jobs and steps. Each stage runs on a specified VM image (e.g., ubuntu-latest) and executes commands, the same npm install, pip install which you would normally run on your laptop.\n\nThe **ADO pipeline** acts as your automated laptop, every build command, environment variable, and deployment step you’d normally execute locally is just formalized in YAML. Whether you build inline, use Oryx, or deploy pre-built artifacts, the underlying concept remains identical: compile, package, and deliver code to Azure. The distinction lies in *who performs it*.\n\n## **5. Conclusion**\n\nDifferent deployment and build methods lead to different debugging and troubleshooting approaches. Therefore, understanding the selected deployment method and its corresponding troubleshooting process is an essential skill for every developer and DevOps engineer.",
  "OutputDir": "_community",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "ProcessedDate": "2025-10-16 13:12:20"
}
