{
  "FeedName": "Microsoft Tech Community",
  "ProcessedDate": "2025-10-04 23:09:15",
  "EnhancedContent": "## Authored by Mike Azure, Drasi Maintainer\n\n[Drasi](https://drasi.io/) , the open-source Rust data change processing platform, simplifies the creation of change-driven systems through continuous queries, reactions, and clearly defined change semantics. Continuous queries enable developers to specify precisely what data changes matter, track these changes in real-time, and react immediately as changes occur. Unlike traditional database queries, which provide static snapshots of data, continuous queries constantly maintain an up-to-date view of query results, automatically notifying reactions of precise additions, updates, and deletions to the result set as they happen.to the result set as they happen.\n\nTo date, Drasi has supported only [openCypher](https://drasi.io/reference/query-language/cypher/) for writing continuous queries; openCypher is a powerful declarative graph query language. Recently, Drasi has added support for [Graph Query Language (GQL)](https://drasi.io/reference/query-language/gql/), the new international ISO standard for querying property graphs. In this article, we describe what GQL means for writing continuous queries and describe how we implemented GQL Support.\n\n#### **A Standardized Future for Graph Queries**\n\nGQL is the first officially standardized database language since SQL in 1987. Published by [ISO/IEC in April 2024](https://www.iso.org/standard/76120.html), it defines a global specification for querying property graphs. Unlike the relational model that structures data into tables, the property graph model structures data inside of the database as a graph. With GQL support, Drasi enables users to benefit from a query language that we expect to be widely adopted across the database industry, ensuring compatibility with future standards in graph querying.\n\nDrasi continues to support openCypher, allowing users to select the query language that best fits their requirements and existing knowledge. With the introduction of GQL, Drasi users can now write continuous queries using the new international standard.\n\n#### **Example GQL Continuous Query: Counting Unique Messages**\n\nEvent-driven architectures traditionally involve overhead for parsing event payloads, filtering irrelevant data, and managing contextual state to identify precise data transitions. Drasi eliminates much of this complexity through continuous queries, which maintain accurate real-time views of data and generate change notifications.\n\nImagine a simple database with a message table containing the text of each message. Suppose you want to know, in real-time, how many times the same message has been sent. Traditionally, addressing these types of scenarios involves polling databases at set intervals, using middleware to detect state changes, and developing custom logic to handle reactions. It could also mean setting up change data capture (CDC) to feed a message broker and process events through a stream processing system. These methods can quickly become complex and difficult, especially when handling numerous or more sophisticated scenarios.\n\nDrasi simplifies this process by employing a change-driven architecture. Rather than relying on polling or other methods, Drasi uses continuous queries that actively monitor data for specific conditions. The moment a specified condition is met or changes, Drasi proactively sends notifications, ensuring real-time responsiveness.\n\nThe following example shows the continuous query in GQL that counts the frequency of each unique message:\n\n``` MATCH    (m:Message)LET Message = m.Message RETURN   Message,   count(Message) AS Frequency ```\n\nYou can explore this example in the Drasi [Getting Started tutorial](https://drasi.io/getting-started).\n\n#### **Key Features** **of the GQL Language**\n\nOpenCypher had a significant influence on GQL and there are many things in common between the two languages; however, there are also some important differences.\n\nA new statement introduced in GQL is NEXT, which enables linear composition of multiple statements. It forms a pipeline where each subsequent statement receives the working table resulting from the previous statement.\n\nOne application for NEXT is the ability to filter results after an aggregation. For example, to find colors associated with more than five vehicles, the following query can be used:\n\n``` MATCH (v:Vehicle)RETURN v.color AS color, count(v) AS vehicle_countNEXT FILTER vehicle_count > 5RETURN color, vehicle_count ```\n\nEquivalent openCypher:\n\n``` MATCH (v:Vehicle)WITH v.color AS color, count(v) AS vehicle_countWHERE vehicle_count > 5RETURN color, vehicle_count ```\n\nGQL introduces additional clauses and statements: LET, YIELD, and FILTER.\n\nThe LET statement allows users to define new variables or computed fields for every row in the current working table. Each LET expression can reference existing columns in scope, and the resulting variables are added as new columns.\n\nExample:\n\n``` MATCH (v:Vehicle)LET makeAndModel = v.make + '  ' + v.modelRETURN makeAndModel, v.year ```\n\nEquivalent openCypher:\n\n``` MATCH (v:Vehicle)WITH v, v.make + '  ' + v.model AS makeAndModelRETURN makeAndModel, v.year ```\n\nThe YIELD clause projects and optionally renames columns from the working table, limiting the set of columns available in scope. Only specified columns remain in scope after YIELD.\n\nExample:\n\nMATCH (v:Vehicle)-[e:LOCATED\\_IN]-&gt;(z:Zone) YIELD v.color AS vehicleColor, z.type AS location RETURN vehicleColor, location\n\nFILTER is a standalone statement that removes rows from the current working table based on a specified condition. While GQL still supports a WHERE clause for filtering during the MATCH phase, the FILTER statement provides additional flexibility by allowing results to be filtered after previous steps. It does not create a new table; instead, it updates the working table. Unlike openCypher’s WHERE clause, which is tied to a MATCH or WITH, GQL's FILTER can be applied independently at various points in the query pipeline.\n\nExample:\n\nMATCH (n:Person) FILTER n.age &gt; 30 RETURN n.name, n.age\n\nGQL also provides control in how aggregations are grouped. The GROUP BY clause can be used to explicitly define the grouping keys, ensuring results are aggregated exactly as intended.\n\nMATCH (v:Vehicle)-[:LOCATED\\_IN]-&gt;(z:Zone) RETURN z.type AS zone\\_type, v.color AS vehicle\\_color, count(v) AS vehicle\\_count GROUP BY zone\\_type, vehicle\\_color\n\nIf the GROUP BY clause is omitted, GQL defaults to an implicit grouping behavior, having all non-aggregated columns in the RETURN clause automatically used as the grouping keys.\n\nWhile many of the core concepts, like pattern matching, projections, and filtering, will feel familiar to openCypher users, GQL’s statements are distinct in their usage. Supporting these differences in Drasi required design changes, described in the following section, that led to multiple query languages within the platform.\n\n#### **Refactoring Drasi for Multi-Language Query Support**\n\nInstead of migrating Drasi from openCypher to GQL, we saw this as an opportunity to address multi-language support in the system. Drasi's initial architecture was designed exclusively for openCypher. In this model, the query parser generated an Abstract Syntax Tree (AST) for openCypher. The execution engine was designed to process this AST format, executing the query it represented to produce the resulting dataset. Built‑in functions (such as toUpper() for string case conversion) followed openCypher naming and were implemented within the same module as the engine. This created an architectural challenge for supporting additional query languages, such as GQL.\n\nTo enable multi-language support, the system was refactored to separate the parsing, execution, and function management. A key insight was that the existing AST structure, originally created for openCypher, was flexible enough to be used for GQL. Although GQL and openCypher are different languages, their core operations, matching patterns, filtering data, and projecting results, could be represented by this AST.\n\nThe diagram shows the dependencies within this new architecture, highlighting the separation and interaction between the components. The language-specific function modules for openCypher and GQL provide the functions to the execution engine. The language-specific parsers for openCypher and GQL produce an AST, and the execution engine operates on this AST. The engine only needs to understand this AST format, making it language-agnostic.\n\nThe AST structure is based on a sequence of `QueryPart` objects. Each `QueryPart` represents a distinct stage of the query, containing clauses for matching, filtering, and returning data. The execution engine processes these `QueryPart`s sequentially.\n\n``` pub struct QueryPart {    pub match_clauses: Vec<MatchClause>,    pub where_clauses: Vec<Expression>,    pub return_clause: ProjectionClause,} ```\n\nThe process begins when a query is submitted in either GQL or openCypher. The query is first directed to its corresponding language-specific parser, which handles the lexical analysis and transforms the raw query string into the standardized AST. When data changes occur in the graph, the execution engine uses the MATCH clauses from the first QueryPart to find affected graph patterns and captures the matched data. This matched data then flows through each QueryPart in sequence. The WHERE portion of the AST filters out data that does not meet the specified conditions. The RETURN portion transforms the data by selecting specific fields, computing new values, or performing aggregations. Each QueryPart's output becomes the next one's input, creating a pipeline that incrementally produces query results as the underlying graph changes.\n\nTo support functions from multiple languages in this AST, we introduced a function registry to abstract a function's name from its implementation. Function names can differ (e.g., toUpper() in openCypher versus Upper() in GQL). For any given query, language-specific modules populate this registry, mapping each function name to its corresponding behavior. Functions with shared logic can be implemented once in the engine and registered under multiple names in specific function crates, preventing code duplication. Meanwhile, language-exclusive functions can be registered and implemented separately within their respective modules. When processing an AST, the engine uses the registry attached to that query to resolve and execute the correct function. The separate function modules allow developers to introduce their own function registry, supporting custom implementations or names.\n\n#### **Conclusion**\n\nBy adding support for GQL, [Drasi](https://drasi.io/) now offers developers a choice between openCypher and the new GQL standard. This capability ensures that teams can use the syntax that best fits their skills and project requirements. In addition, the architectural changes set the foundation for additional query languages.\n\nYou can check out the code on our [GitHub organization,](https://github.com/drasi-project) dig into the technical details on our [documentation site](https://drasi.io/), and join our developer community on [Discord](http://aka.ms/drasidiscord).\n\nUpdated Oct 03, 2025\n\nVersion 3.0\n\n[monitoring](/tag/monitoring?nodeId=board%3ALinuxandOpenSourceBlog)\n\n[!\\[CollinBrian&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/m_assets/avatars/default/avatar-5.svg?image-dimensions=50x50)](/users/collinbrian/1113044) [CollinBrian](/users/collinbrian/1113044) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined July 26, 2021\n\n[View Profile](/users/collinbrian/1113044)\n\n/category/azure/blog/linuxandopensourceblog [Linux and Open Source Blog](/category/azure/blog/linuxandopensourceblog) Follow this blog board to get notified when there's new activity",
  "Link": "https://techcommunity.microsoft.com/t5/linux-and-open-source-blog/drasi-is-fluent-in-gql-integrating-the-new-graph-query-standard/ba-p/4458888",
  "Title": "Drasi is Fluent in GQL: Integrating the New Graph Query Standard",
  "Author": "CollinBrian",
  "OutputDir": "_community",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure",
  "Tags": [],
  "Description": "[Drasi](https://drasi.io/) , the open-source Rust data change processing platform, simplifies the creation of change-driven systems through continuous queries, reactions, and clearly defined change semantics. Continuous queries enable developers to specify precisely what data changes matter, track these changes in real-time, and react immediately as changes occur. Unlike traditional database queries, which provide static snapshots of data, continuous queries constantly maintain an up-to-date view of query results, automatically notifying reactions of precise additions, updates, and deletions to the result set as they happen.to the result set as they happen.\n\nTo date, Drasi has supported only [openCypher](https://drasi.io/reference/query-language/cypher/) for writing continuous queries; openCypher is a powerful declarative graph query language. Recently, Drasi has added support for [Graph Query Language (GQL)](https://drasi.io/reference/query-language/gql/), the new international ISO standard for querying property graphs. In this article, we describe what GQL means for writing continuous queries and describe how we implemented GQL Support.\n\n#### **A Standardized Future for Graph Queries**\n\nGQL is the first officially standardized database language since SQL in 1987. Published by [ISO/IEC in April 2024](https://www.iso.org/standard/76120.html), it defines a global specification for querying property graphs. Unlike the relational model that structures data into tables, the property graph model structures data inside of the database as a graph. With GQL support, Drasi enables users to benefit from a query language that we expect to be widely adopted across the database industry, ensuring compatibility with future standards in graph querying.\n\nDrasi continues to support openCypher, allowing users to select the query language that best fits their requirements and existing knowledge. With the introduction of GQL, Drasi users can now write continuous queries using the new international standard.\n\n#### **Example GQL Continuous Query: Counting Unique Messages**\n\nEvent-driven architectures traditionally involve overhead for parsing event payloads, filtering irrelevant data, and managing contextual state to identify precise data transitions. Drasi eliminates much of this complexity through continuous queries, which maintain accurate real-time views of data and generate change notifications.\n\nImagine a simple database with a message table containing the text of each message. Suppose you want to know, in real-time, how many times the same message has been sent. Traditionally, addressing these types of scenarios involves polling databases at set intervals, using middleware to detect state changes, and developing custom logic to handle reactions. It could also mean setting up change data capture (CDC) to feed a message broker and process events through a stream processing system. These methods can quickly become complex and difficult, especially when handling numerous or more sophisticated scenarios.\n\nDrasi simplifies this process by employing a change-driven architecture. Rather than relying on polling or other methods, Drasi uses continuous queries that actively monitor data for specific conditions. The moment a specified condition is met or changes, Drasi proactively sends notifications, ensuring real-time responsiveness.\n\nThe following example shows the continuous query in GQL that counts the frequency of each unique message:\n\n``` MATCH  (m:Message)LET Message = m.Message RETURN Message, count(Message) AS Frequency ```\n\nYou can explore this example in the Drasi [Getting Started tutorial](https://drasi.io/getting-started).\n\n#### **Key Features** **of the GQL Language**\n\nOpenCypher had a significant influence on GQL and there are many things in common between the two languages; however, there are also some important differences.\n\nA new statement introduced in GQL is NEXT, which enables linear composition of multiple statements. It forms a pipeline where each subsequent statement receives the working table resulting from the previous statement.\n\nOne application for NEXT is the ability to filter results after an aggregation. For example, to find colors associated with more than five vehicles, the following query can be used:\n\n``` MATCH (v:Vehicle)RETURN v.color AS color, count(v) AS vehicle_countNEXT FILTER vehicle_count > 5RETURN color, vehicle_count ```\n\nEquivalent openCypher:\n\n``` MATCH (v:Vehicle)WITH v.color AS color, count(v) AS vehicle_countWHERE vehicle_count > 5RETURN color, vehicle_count ```\n\nGQL introduces additional clauses and statements: LET, YIELD, and FILTER.\n\nThe LET statement allows users to define new variables or computed fields for every row in the current working table. Each LET expression can reference existing columns in scope, and the resulting variables are added as new columns.\n\nExample:\n\n``` MATCH (v:Vehicle)LET makeAndModel = v.make + ' ' + v.modelRETURN makeAndModel, v.year ```\n\nEquivalent openCypher:\n\n``` MATCH (v:Vehicle)WITH v, v.make + ' ' + v.model AS makeAndModelRETURN makeAndModel, v.year ```\n\nThe YIELD clause projects and optionally renames columns from the working table, limiting the set of columns available in scope. Only specified columns remain in scope after YIELD.\n\nExample:\n\nMATCH (v:Vehicle)-[e:LOCATED\\_IN]->(z:Zone) YIELD v.color AS vehicleColor, z.type AS location RETURN vehicleColor, location\n\nFILTER is a standalone statement that removes rows from the current working table based on a specified condition. While GQL still supports a WHERE clause for filtering during the MATCH phase, the FILTER statement provides additional flexibility by allowing results to be filtered after previous steps. It does not create a new table; instead, it updates the working table. Unlike openCypher’s WHERE clause, which is tied to a MATCH or WITH, GQL's FILTER can be applied independently at various points in the query pipeline.\n\nExample:\n\nMATCH (n:Person) FILTER n.age > 30 RETURN n.name, n.age\n\nGQL also provides control in how aggregations are grouped. The GROUP BY clause can be used to explicitly define the grouping keys, ensuring results are aggregated exactly as intended.\n\nMATCH (v:Vehicle)-[:LOCATED\\_IN]->(z:Zone) RETURN z.type AS zone\\_type, v.color AS vehicle\\_color, count(v) AS vehicle\\_count GROUP BY zone\\_type, vehicle\\_color\n\nIf the GROUP BY clause is omitted, GQL defaults to an implicit grouping behavior, having all non-aggregated columns in the RETURN clause automatically used as the grouping keys.\n\nWhile many of the core concepts, like pattern matching, projections, and filtering, will feel familiar to openCypher users, GQL’s statements are distinct in their usage. Supporting these differences in Drasi required design changes, described in the following section, that led to multiple query languages within the platform.\n\n#### **Refactoring Drasi for Multi-Language Query Support**\n\nInstead of migrating Drasi from openCypher to GQL, we saw this as an opportunity to address multi-language support in the system. Drasi's initial architecture was designed exclusively for openCypher. In this model, the query parser generated an Abstract Syntax Tree (AST) for openCypher. The execution engine was designed to process this AST format, executing the query it represented to produce the resulting dataset. Built‑in functions (such as toUpper() for string case conversion) followed openCypher naming and were implemented within the same module as the engine. This created an architectural challenge for supporting additional query languages, such as GQL.\n\nTo enable multi-language support, the system was refactored to separate the parsing, execution, and function management. A key insight was that the existing AST structure, originally created for openCypher, was flexible enough to be used for GQL. Although GQL and openCypher are different languages, their core operations, matching patterns, filtering data, and projecting results, could be represented by this AST.\n\n![]()\n\nThe diagram shows the dependencies within this new architecture, highlighting the separation and interaction between the components. The language-specific function modules for openCypher and GQL provide the functions to the execution engine. The language-specific parsers for openCypher and GQL produce an AST, and the execution engine operates on this AST. The engine only needs to understand this AST format, making it language-agnostic.\n\nThe AST structure is based on a sequence of `QueryPart` objects. Each `QueryPart` represents a distinct stage of the query, containing clauses for matching, filtering, and returning data. The execution engine processes these `QueryPart`s sequentially.\n\n``` pub struct QueryPart { pub match_clauses: Vec, pub where_clauses: Vec, pub return_clause: ProjectionClause,} ```\n\nThe process begins when a query is submitted in either GQL or openCypher. The query is first directed to its corresponding language-specific parser, which handles the lexical analysis and transforms the raw query string into the standardized AST. When data changes occur in the graph, the execution engine uses the MATCH clauses from the first QueryPart to find affected graph patterns and captures the matched data. This matched data then flows through each QueryPart in sequence. The WHERE portion of the AST filters out data that does not meet the specified conditions. The RETURN portion transforms the data by selecting specific fields, computing new values, or performing aggregations. Each QueryPart's output becomes the next one's input, creating a pipeline that incrementally produces query results as the underlying graph changes.\n\nTo support functions from multiple languages in this AST, we introduced a function registry to abstract a function's name from its implementation. Function names can differ (e.g., toUpper() in openCypher versus Upper() in GQL). For any given query, language-specific modules populate this registry, mapping each function name to its corresponding behavior. Functions with shared logic can be implemented once in the engine and registered under multiple names in specific function crates, preventing code duplication. Meanwhile, language-exclusive functions can be registered and implemented separately within their respective modules. When processing an AST, the engine uses the registry attached to that query to resolve and execute the correct function. The separate function modules allow developers to introduce their own function registry, supporting custom implementations or names.\n\n#### **Conclusion**\n\nBy adding support for GQL, [Drasi](https://drasi.io/) now offers developers a choice between openCypher and the new GQL standard. This capability ensures that teams can use the syntax that best fits their skills and project requirements. In addition, the architectural changes set the foundation for additional query languages.\n\nYou can check out the code on our [GitHub organization,](https://github.com/drasi-project) dig into the technical details on our [documentation site](https://drasi.io/), and join our developer community on [Discord](http://aka.ms/drasidiscord).",
  "PubDate": "2025-10-03T19:28:14+00:00",
  "FeedLevelAuthor": "rss.livelink.threads-in-node"
}
