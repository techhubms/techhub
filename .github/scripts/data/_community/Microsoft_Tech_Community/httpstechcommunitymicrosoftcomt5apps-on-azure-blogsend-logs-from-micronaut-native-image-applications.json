{
  "FeedName": "Microsoft Tech Community",
  "Title": "Send logs from Micronaut native image applications to Azure Monitor",
  "Link": "https://techcommunity.microsoft.com/t5/apps-on-azure-blog/send-logs-from-micronaut-native-image-applications-to-azure/ba-p/4443867",
  "Author": "Logico_jp",
  "EnhancedContent": "The original post (Japanese) was written on 29 July 2025.\n\n[MicronautからAzure Monitorにlogを送信したい – Logico Inside](https://logico-jp.dev/2025/07/29/send-logs-from-micronaut-applications-to-azure-monitor/)\n\nThis entry is related to the following one. Please take a look for background information.\n\n[Send signals from Micronaut native image applications to Azure Monitor | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/appsonazureblog/send-signals-from-micronaut-native-image-applications-to-azure-monitor/4443735)\n\n### Where can we post logs?\n\nLog destination differs depending upon managed services such as App Service, Container Apps, etc. We can also send logs to specified destination which is different destination from the default one. In the case of Azure Container Apps, for instance, we have several options to send logs.\n\n| **Type** | **Destination** | **How to** | | --- | --- | --- | | Write console output to a log | `ContainerAppConsoleLogs_CL`<br><br><br><br><br>If diagnostic settings are configured, destination table may differ from the above. | The output destination can be changed in the diagnostic settings. This is handled by Container Apps, so no user action is required. | | Use DCE (Data Collection Endpoint) to write logs to custom table in Log Analytics Workspace | Custom tables in Log Analytics Workspace. | Follow these tutorials listed below.<br><br><br><br><br>[Publish Application Logs to Azure Monitor Logs](https://graal.cloud/gdk/gdk-modules/logging/micronaut-azure-logging/)<br><br><br><br><br>[Publish Micronaut application logs to Microsoft Azure Monitor Logs](https://guides.micronaut.io/latest/micronaut-azure-logging-maven-java.html) | | Using the Log Appender | `traces`<br> table in Application Insights | When writing logs to thetraces table in Application Insights, Log Appender configuration is required. |\n\n[Log storage and monitoring options in Azure Container Apps](https://learn.microsoft.com/azure/container-apps/log-options)\n\nFrom now on, we elaborate the 3rd way — write logs to the traces table in Application Insights.\n\n### Prerequisites\n\n- Maven: 3.9.10\n- JDK: 21\n- Micronaut: 4.9.0 or later\n\nRegarding logs, the logs posted with the following 4 log libraries are automatically collected. In this entry, we use Logback.\n\n- Log4j2\n- Logback\n- JBoss Logging\n- java.util.logging\n\n### Create Azure resource (Application Insights)\n\nCreate a resource group and configure Application Insights. Refer to the following documentation for details.\n\n[Create and configure Application Insights resources - Azure Monitor](https://learn.microsoft.com/en-us/azure/azure-monitor/app/create-workspace-resource?tabs=portal)\n\nThat’s it for the Azure setup.\n\n### Create an archetype\n\nWe can create an archetype using Micronaut’s CLI (`mn` ) or Micronaut Launch. In this entry, use `application.yml` instead of `application.properties` for application configuration. So, we need to specify the feature “yaml” so that we can include dependencies for using yaml.\n\n[Micronaut Launch](https://micronaut.io/launch/)\n\n``` mn create-app \\ --build=maven \\ --jdk=21 \\ --lang=java \\ --test=junit \\ --features=graalvm,azure-tracing,yaml \\ dev.logicojp.micronaut.azuremonitor-log ```\n\nWhen using Micronaut Launch, click [FEATURES] and select the following features.\n\n- graalvm\n- azure-tracing\n- yaml\n\nAfter all features are selected, click [GENERATE PROJECT] and choose [Download Zip] to download an archetype in Zip file.\n\n### Add dependencies and plugins to pom.xml\n\nIn order to output logs to Application Insights, the following dependencies must be added.\n\n``` <dependency> <groupid>io.opentelemetry.instrumentation</groupid> <artifactid>opentelemetry-logback-appender-1.0</artifactid> </dependency> <dependency> <groupid>com.microsoft.azure</groupid> <artifactid>applicationinsights-logging-logback</artifactid> </dependency> <dependency> <groupid>io.micronaut.tracing</groupid> <artifactid>micronaut-tracing-opentelemetry-http</artifactid> </dependency> ```\n\nIn this entry, we are using Logback for log output, so we are using opentelemetry-logback-appender-1.0. However, should you be using a different library, it will be necessary to specify the appropriate an appender for that library.\n\nThe dependency `com.azure:azure-monitor-opentelemetry-autoconfigure` is being included transitively since `io.micronaut.tracing:azure-tracing` depends upon the dependency. If Azure tracing has not yet been added, the following dependencies must be added explicitly.\n\n``` <dependency> <groupid>com.azure</groupid> <artifactid>azure-monitor-opentelemetry-autoconfigure</artifactid> </dependency> ```\n\nAdditionally, we need to add this dependency to use the GraalVM Reachability Metadata Repository. The latest version is 0.11.0 as of 29 July, 2025.\n\n``` <dependency> <groupid>org.graalvm.buildtools</groupid> <artifactid>graalvm-reachability-metadata</artifactid> <version>0.11.0</version> <classifier>repository</classifier> <type>zip</type> </dependency> ```\n\nAdd the GraalVM Maven plugin and enable the use of GraalVM Reachability Metadata obtained from the above dependency. This plugin lets us set optimization levels using `buildArg` (in this example, the optimisation level is specified). We can also add it to `native-image.properties` , the `native-image` tool (and the Maven/Gradle plugin) will read it.\n\n``` <plugin> <groupid>org.graalvm.buildtools</groupid> <artifactid>native-maven-plugin</artifactid> <configuration> <metadatarepository> <enabled>true</enabled> </metadatarepository> <buildargs combine.children=\"append\"> <buildarg>-Ob</buildarg> </buildargs> <quickbuild>true</quickbuild> </configuration> </plugin> ```\n\n### Application configuration\n\nIn order to proceed, it is necessary to include both Application Insights-specific settings and Azure-tracing settings. To ensure optimal performance when using Azure tracing, please refer to the settings outlined below.\n\n[Send traces from Micronaut native image applications to Azure Monitor | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/appsonazureblog/send-traces-from-micronaut-native-image-applications-to-azure-monitor/4443791)\n\nFor Application Insights-specific settings, please refer to the documentation provided.\n\n[Configuration options - Azure Monitor Application Insights for Java - Azure Monitor](https://learn.microsoft.com/en-us/azure/azure-monitor/app/java-standalone-config)\n\nAccording to the documentation, when specifying a connection string, the configuration should be as follows.\n\n> >\n> *You can also set the connection string by using the environment variable `APPLICATIONINSIGHTS_CONNECTION_STRING`. It then takes precedence over the connection string specified in the JSON configuration.*\n> > >\n> Or you can set the connection string by using the Java system property `applicationinsights.connection.string`\n> . It also takes precedence over the connection string specified in the JSON configuration.\n> >\n\nInitially, it may appear that there is no alternative but to use environment variables or Java system properties. However, in the case of Micronaut (and similarly for Spring Boot and Quarkus), the connection string can be configured using the relationship between application settings and environment variables. This allows for defining it in `application.properties` or `application.yml` .\n\nFor instance, in the case of the connection string mentioned above, if we specify it using an environment variable, we would use `APPLICATIONINSIGHTS_CONNECTION_STRING` . In Micronaut, we can specify it as shown in lines 5–7 of the following `application.yml` example (the key matches the one used when setting it as a system property).\n\nThe configuration of application.yml, including Application Insights-specific settings, is as follows:\n\n``` applicationinsights: connection: string: ${AZURE_MONITOR_CONNECTION_STRING} sampling: percentage: 100 instrumentation: logging: level: \"INFO\" preview: captureLogbackMarker: true captureControllerSpans: true azure: tracing: connection-string: ${AZURE_MONITOR_CONNECTION_STRING} ```\n\n### Codes\n\n#### a) To enable Application Insights\n\nWe need to explicitly create an `OpenTelemetry` object to send logs. Please note that while Azure-tracing enables Application Insights, the `OpenTelemetry` object generated during this process is not publicly accessible and cannot be retrieved from outside.\n\n``` AutoConfiguredOpenTelemetrySdkBuilder sdkBuilder = AutoConfiguredOpenTelemetrySdk.builder(); OpenTelemetry openTelemetry = sdkBuilder.build().getOpenTelemetrySdk(); AzureMonitorAutoConfigure.customize(sdkBuilder, \"connectionString\"); ```\n\n#### b) Log Appender\n\nWhen we create the archetype, `src/main/resources/logback.xml` should be generated. In this file, add an Appender to associate with the `io.opentelemetry.instrumentation.logback.appender.v1_0.OpenTelemetryAppender class object. `\n\n``` <configuration> <appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"> <!-- encoders are assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --> <encoder> <pattern>%cyan(%d{HH:mm:ss.SSS}) %gray([%thread]) %highlight(%-5level) %magenta(%logger{36}) - %msg%n </pattern> </encoder> </appender> <appender name=\"OpenTelemetry\" class=\"io.opentelemetry.instrumentation.logback.appender.v1_0.OpenTelemetryAppender\"> <captureexperimentalattributes>true</captureexperimentalattributes> <capturecodeattributes>true</capturecodeattributes> <capturemarkerattribute>true</capturemarkerattribute> <capturekeyvaluepairattributes>true</capturekeyvaluepairattributes> <capturemdcattributes>*</capturemdcattributes> </appender> <root level=\"info\"> <appender-ref ref=\"STDOUT\"> <appender-ref ref=\"OpenTelemetry\"> </appender-ref></appender-ref></root> </configuration> ```\n\nThen, associate the `OpenTelemetry` object we created earlier with Log Appender so that logs can be sent using OpenTelemetry.\n\n``` OpenTelemetryAppender.install(openTelemetry); ```\n\n#### c) Other implementation\n\nThe objective of this article is to verify the Trace and Trace log. To that end, we will develop a rudimentary REST API, akin to a “Hello World” application. However, we will utilize the logger feature to generate multiple logs. In a real-world application, we would likely refine this process to avoid generating excessive logs.\n\nFor example, `HelloController.java` is shown below.\n\n``` package dev.logicojp.micronaut;\n\nimport io.micronaut.http.HttpStatus; import io.micronaut.http.MediaType; import io.micronaut.http.annotation.*; import io.micronaut.http.exceptions.HttpStatusException; import io.micronaut.scheduling.TaskExecutors; import io.micronaut.scheduling.annotation.ExecuteOn; import io.opentelemetry.api.OpenTelemetry; import io.opentelemetry.instrumentation.logback.appender.v1_0.OpenTelemetryAppender; import org.slf4j.Logger; import org.slf4j.LoggerFactory;\n\n@Controller(\"/api/hello\") @ExecuteOn(TaskExecutors.IO) public class HelloController {\n\nprivate static final Logger logger = LoggerFactory.getLogger(HelloController.class);\n\npublic HelloController(OpenTelemetry _openTelemetry){ OpenTelemetryAppender.install(_openTelemetry); logger.info(\"OpenTelemetry is configured and ready to use.\"); }\n\n@Get @Produces(MediaType.APPLICATION_JSON) public GreetingResponse hello(@QueryValue(value = \"name\", defaultValue = \"World\") String name) { logger.info(\"Hello endpoint was called with query parameter: {}\", name); // Simulate some processing HelloService helloService = new HelloService(); GreetingResponse greetingResponse = helloService.greet(name); logger.info(\"Processing complete, returning response\"); return greetingResponse; }\n\n@Post @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) @Status(HttpStatus.ACCEPTED) public void setGreetingPrefix(@Body GreetingPrefix greetingPrefix) { String prefix = greetingPrefix.prefix(); if (prefix == null || prefix.isBlank()) { logger.error(\"Received request to set an empty or null greeting prefix.\"); throw new HttpStatusException(HttpStatus.BAD_REQUEST, \"Prefix cannot be null or empty\"); } HelloService helloService = new HelloService(); helloService.setGreetingPrefix(prefix); logger.info(\"Greeting prefix set to: {}\", prefix); } } ```\n\nFor now, let’s build it as a Java application.\n\n``` mvn clean package ```\n\n### Test as a Java application\n\nPlease verify that the application is running without any issues …\n\n- that traces are being sent to Application Insights\n- that logs are being sent to the `traces`\ntable\n- that they can be confirmed on the Trace screen.\n\nIf the call is GET /api/hello?name=Logico\\_jp, the `traces` table will look like this:\n\nIn the Trace application, it should resemble this structure, in conjunction with the Request.\n\nThen, run the application using the Tracing Agent to generate the necessary configuration files.\n\n```\n# (1) Collect configuration files such as reflect-config.json\n$JAVA_HOME/bin/java \\ -agentlib:native-image-agent=config-output-dir=src/main/resources/META-INF/{groupId}/{artifactId}/ \\ -jar ./target/{artifactId}-{version}.jar\n# (2)-a Generate a trace file\n$JAVA_HOME/bin/java \\ -agentlib:native-image-agent=trace-output=/path/to/trace-file.json \\ -jar ./target/{artifactId}-{version}.jar\n# (2)-b Generate a reachability metadata file from the collected trace file\nnative-image-configure generate \\ --trace-input=/path/to/trace-file.json \\ --output-dir=/path/to/config-dir/ ```\n\n[Configure Native Image with the Tracing Agent](https://www.graalvm.org/latest/reference-manual/native-image/guides/configure-with-tracing-agent/)\n\n[Collect Metadata with the Tracing Agent](https://www.graalvm.org/latest/reference-manual/native-image/metadata/AutomaticMetadataCollection/)\n\nMake the following files in the specified folder.\n\n- `jni-config.json`\n- `reflect-config.json`\n- `proxy-config.json`\n- `resource-config.json`\n- `reachability-metadata.json`\n\nThese files can be located at `src/main/resources/META-INF/native-image` . The `native-image` tool picks up configuration files located in the directory `src/main/resources/META-INF/native-image` . However, it is recommended that we place the files in subdirectories divided by `groupId` and `artifactId` , as shown below.\n\n`src/main/resources/META-INF/native-image/{groupId}/{artifactId}`\n\n### native-image.properties\n\nWhen creating a native image, we call the following command.\n\n``` mvn package -Dpackaging=native-image ```\n\nWe should specify the timing of class initialization (build time or runtime), the command line options for the `native-image` tool (the same command line options work in Maven/Gradle plugin), and the JVM arguments in the `native-image.properties` file. Indeed, these settings can be specified in `pom.xml` , but it is recommended that they be externalized.\n\nThis is also explained in the metric entry, so some details will be left out. If needed, please check the metric entry.\n\n[Send metrics from Micronaut native image applications to Azure Monitor | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/appsonazureblog/send-metrics-from-micronaut-native-image-applications-to-azure-monitor/4443763)\n\n### Build a Native Image application\n\nBuilding a native image application takes a long time (though it has got quicker over time). If building it for testing purpose, we strongly recommend enabling Quick Build and setting the optimization level to `-Ob` option (although this will still take time). See below for more information.\n\n[Maven plugin for GraalVM Native Image](https://graalvm.github.io/native-build-tools/latest/maven-plugin.html#native-image-options) [Gradle plugin for GraalVM Native Image](https://graalvm.github.io/native-build-tools/latest/gradle-plugin.html#native-image-options)\n\n[Optimizations and Performance](https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/#optimization-levels)\n\n### Test as a native image application\n\nVerify that this application works the same as a normal Java application. For example, call GET /api/hello?name=xxxx, GET /api/hello?name=, GET /api/hello , and POST /api/hello.\n\n### Check if traces and logs are visible in Azure Monitor (application insights)\n\nWhen reviewing the traces table in Application Insights, it becomes evident that four records were added at 3:14 p.m.\n\nWhen checking traces…\n\nAs can be seen in the `traces` table, the logs have indeed been added to the trace. Naturally, the occurrence times remain consistent.\n\n### Summary\n\nI have outlined the process of writing to the traces table in Application Insights. However, it should be noted that some code is necessary to configure the Log Appender. Consequently, zero code instrumentation cannot be achieved strictly. However, the actual configuration is relatively minor, so implementation is not difficult.\n\nUpdated Aug 15, 2025\n\nVersion 4.0\n\n[azure container apps](/tag/azure%20container%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[java](/tag/java?nodeId=board%3AAppsonAzureBlog)\n\n[web apps](/tag/web%20apps?nodeId=board%3AAppsonAzureBlog)\n\n[!\\[Logico_jp&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0yOTkyMzctNTQ3ODkyaTBFMzYwMUVGM0FBQkZBN0Y?image-dimensions=50x50)](/users/logico_jp/299237) [Logico_jp](/users/logico_jp/299237) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined March 12, 2019\n\n[View Profile](/users/logico_jp/299237)\n\n/category/azure/blog/appsonazureblog [Apps on Azure Blog](/category/azure/blog/appsonazureblog) Follow this blog board to get notified when there's new activity",
  "OutputDir": "_community",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Description": "The original post (Japanese) was written on 29 July 2025.\n\n[MicronautからAzure Monitorにlogを送信したい – Logico Inside](https://logico-jp.dev/2025/07/29/send-logs-from-micronaut-applications-to-azure-monitor/)\n\nThis entry is related to the following one. Please take a look for background information.\n\n[Send signals from Micronaut native image applications to Azure Monitor | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/appsonazureblog/send-signals-from-micronaut-native-image-applications-to-azure-monitor/4443735)\n\n### Where can we post logs?\n\nLog destination differs depending upon managed services such as App Service, Container Apps, etc. We can also send logs to specified destination which is different destination from the default one. In the case of Azure Container Apps, for instance, we have several options to send logs.\n\n| **Type** | **Destination** | **How to** | | --- | --- | --- | | Write console output to a log | `ContainerAppConsoleLogs_CL`<br><br><br><br><br>If diagnostic settings are configured, destination table may differ from the above. | The output destination can be changed in the diagnostic settings. This is handled by Container Apps, so no user action is required. | | Use DCE (Data Collection Endpoint) to write logs to custom table in Log Analytics Workspace | Custom tables in Log Analytics Workspace. | Follow these tutorials listed below.<br><br><br><br><br>[Publish Application Logs to Azure Monitor Logs](https://graal.cloud/gdk/gdk-modules/logging/micronaut-azure-logging/)<br><br><br><br><br>[Publish Micronaut application logs to Microsoft Azure Monitor Logs](https://guides.micronaut.io/latest/micronaut-azure-logging-maven-java.html) | | Using the Log Appender | `traces`<br> table in Application Insights | When writing logs to thetraces table in Application Insights, Log Appender configuration is required. |\n\n[Log storage and monitoring options in Azure Container Apps](https://learn.microsoft.com/azure/container-apps/log-options)\n\nFrom now on, we elaborate the 3rd way — write logs to the traces table in Application Insights.\n\n### Prerequisites\n\n- Maven: 3.9.10\n- JDK: 21\n- Micronaut: 4.9.0 or later\n\nRegarding logs, the logs posted with the following 4 log libraries are automatically collected. In this entry, we use Logback.\n\n- Log4j2\n- Logback\n- JBoss Logging\n- java.util.logging\n\n### Create Azure resource (Application Insights)\n\nCreate a resource group and configure Application Insights. Refer to the following documentation for details.\n\n[Create and configure Application Insights resources - Azure Monitor](https://learn.microsoft.com/en-us/azure/azure-monitor/app/create-workspace-resource?tabs=portal)\n\nThat’s it for the Azure setup.\n\n### Create an archetype\n\nWe can create an archetype using Micronaut’s CLI (`mn` ) or Micronaut Launch. In this entry, use `application.yml` instead of `application.properties` for application configuration. So, we need to specify the feature “yaml” so that we can include dependencies for using yaml.\n\n[Micronaut Launch](https://micronaut.io/launch/)\n\n- mn create-app \\\n--build=maven \\ --jdk=21 \\ --lang=java \\ --test=junit \\ --features=graalvm,azure-tracing,yaml \\ dev.logicojp.micronaut.azuremonitor-log\n\nWhen using Micronaut Launch, click [FEATURES] and select the following features.\n\n- graalvm\n- azure-tracing\n- yaml\n\nAfter all features are selected, click [GENERATE PROJECT] and choose [Download Zip] to download an archetype in Zip file.\n\n### Add dependencies and plugins to pom.xml\n\nIn order to output logs to Application Insights, the following dependencies must be added.\n- io.opentelemetry.instrumentation\nopentelemetry-logback-appender-1.0 com.microsoft.azure applicationinsights-logging-logback io.micronaut.tracing micronaut-tracing-opentelemetry-http\n\nIn this entry, we are using Logback for log output, so we are using opentelemetry-logback-appender-1.0. However, should you be using a different library, it will be necessary to specify the appropriate an appender for that library.\n\nThe dependency `com.azure:azure-monitor-opentelemetry-autoconfigure` is being included transitively since `io.micronaut.tracing:azure-tracing` depends upon the dependency. If Azure tracing has not yet been added, the following dependencies must be added explicitly.\n- com.azure\nazure-monitor-opentelemetry-autoconfigure\n\nAdditionally, we need to add this dependency to use the GraalVM Reachability Metadata Repository. The latest version is 0.11.0 as of 29 July, 2025.\n- org.graalvm.buildtools\ngraalvm-reachability-metadata 0.11.0 repository zip\n\nAdd the GraalVM Maven plugin and enable the use of GraalVM Reachability Metadata obtained from the above dependency. This plugin lets us set optimization levels using `buildArg` (in this example, the optimisation level is specified). We can also add it to `native-image.properties` , the `native-image` tool (and the Maven/Gradle plugin) will read it.\n- org.graalvm.buildtools\nnative-maven-plugin\n\ntrue\n\n-Ob\n\ntrue\n\n### Application configuration\n\nIn order to proceed, it is necessary to include both Application Insights-specific settings and Azure-tracing settings. To ensure optimal performance when using Azure tracing, please refer to the settings outlined below.\n\n[Send traces from Micronaut native image applications to Azure Monitor | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/appsonazureblog/send-traces-from-micronaut-native-image-applications-to-azure-monitor/4443791)\n\nFor Application Insights-specific settings, please refer to the documentation provided.\n\n[Configuration options - Azure Monitor Application Insights for Java - Azure Monitor](https://learn.microsoft.com/en-us/azure/azure-monitor/app/java-standalone-config)\n\nAccording to the documentation, when specifying a connection string, the configuration should be as follows.\n\n> >\n> *You can also set the connection string by using the environment variable `APPLICATIONINSIGHTS_CONNECTION_STRING`. It then takes precedence over the connection string specified in the JSON configuration.*\n> > >\n> Or you can set the connection string by using the Java system property `applicationinsights.connection.string`\n> . It also takes precedence over the connection string specified in the JSON configuration.\n> >\n\nInitially, it may appear that there is no alternative but to use environment variables or Java system properties. However, in the case of Micronaut (and similarly for Spring Boot and Quarkus), the connection string can be configured using the relationship between application settings and environment variables. This allows for defining it in `application.properties` or `application.yml` .\n\nFor instance, in the case of the connection string mentioned above, if we specify it using an environment variable, we would use `APPLICATIONINSIGHTS_CONNECTION_STRING` . In Micronaut, we can specify it as shown in lines 5–7 of the following `application.yml` example (the key matches the one used when setting it as a system property).\n\nThe configuration of application.yml, including Application Insights-specific settings, is as follows:\n- applicationinsights:\nconnection: string: ${AZURE\\_MONITOR\\_CONNECTION\\_STRING} sampling: percentage: 100 instrumentation: logging: level: \"INFO\" preview: captureLogbackMarker: true captureControllerSpans: true azure: tracing: connection-string: ${AZURE\\_MONITOR\\_CONNECTION\\_STRING}\n\n### Codes\n\n#### a) To enable Application Insights\n\nWe need to explicitly create an `OpenTelemetry` object to send logs. Please note that while Azure-tracing enables Application Insights, the `OpenTelemetry` object generated during this process is not publicly accessible and cannot be retrieved from outside.\n- AutoConfiguredOpenTelemetrySdkBuilder sdkBuilder = AutoConfiguredOpenTelemetrySdk.builder();\nOpenTelemetry openTelemetry = sdkBuilder.build().getOpenTelemetrySdk(); AzureMonitorAutoConfigure.customize(sdkBuilder, \"connectionString\");\n\n#### b) Log Appender\n\nWhen we create the archetype, `src/main/resources/logback.xml` should be generated. In this file, add an Appender to associate with the `io.opentelemetry.instrumentation.logback.appender.v1_0.OpenTelemetryAppender class object. `\n- %cyan(%d{HH:mm:ss.SSS}) %gray([%thread]) %highlight(%-5level)\n%magenta(%logger{36}) - %msg%n\n\ntrue true true true \\*\n\nThen, associate the `OpenTelemetry` object we created earlier with Log Appender so that logs can be sent using OpenTelemetry.\n- OpenTelemetryAppender.install(openTelemetry);\n\n#### c) Other implementation\n\nThe objective of this article is to verify the Trace and Trace log. To that end, we will develop a rudimentary REST API, akin to a “Hello World” application. However, we will utilize the logger feature to generate multiple logs. In a real-world application, we would likely refine this process to avoid generating excessive logs.\n\nFor example, `HelloController.java` is shown below.\n- package dev.logicojp.micronaut;\n\nimport io.micronaut.http.HttpStatus; import io.micronaut.http.MediaType; import io.micronaut.http.annotation.\\*; import io.micronaut.http.exceptions.HttpStatusException; import io.micronaut.scheduling.TaskExecutors; import io.micronaut.scheduling.annotation.ExecuteOn; import io.opentelemetry.api.OpenTelemetry; import io.opentelemetry.instrumentation.logback.appender.v1\\_0.OpenTelemetryAppender; import org.slf4j.Logger; import org.slf4j.LoggerFactory;\n\n@Controller(\"/api/hello\") @ExecuteOn(TaskExecutors.IO) public class HelloController {\n\nprivate static final Logger logger = LoggerFactory.getLogger(HelloController.class);\n\npublic HelloController(OpenTelemetry \\_openTelemetry){ OpenTelemetryAppender.install(\\_openTelemetry); logger.info(\"OpenTelemetry is configured and ready to use.\"); }\n\n@Get @Produces(MediaType.APPLICATION\\_JSON) public GreetingResponse hello(@QueryValue(value = \"name\", defaultValue = \"World\") String name) { logger.info(\"Hello endpoint was called with query parameter: {}\", name); // Simulate some processing HelloService helloService = new HelloService(); GreetingResponse greetingResponse = helloService.greet(name); logger.info(\"Processing complete, returning response\"); return greetingResponse; }\n\n@Post @Consumes(MediaType.APPLICATION\\_JSON) @Produces(MediaType.APPLICATION\\_JSON) @Status(HttpStatus.ACCEPTED) public void setGreetingPrefix(@Body GreetingPrefix greetingPrefix) { String prefix = greetingPrefix.prefix(); if (prefix == null || prefix.isBlank()) { logger.error(\"Received request to set an empty or null greeting prefix.\"); throw new HttpStatusException(HttpStatus.BAD\\_REQUEST, \"Prefix cannot be null or empty\"); } HelloService helloService = new HelloService(); helloService.setGreetingPrefix(prefix); logger.info(\"Greeting prefix set to: {}\", prefix); } }\n\nFor now, let’s build it as a Java application.\n- mvn clean package\n\n### Test as a Java application\n\nPlease verify that the application is running without any issues …\n\n- that traces are being sent to Application Insights\n- that logs are being sent to the `traces`\ntable\n- that they can be confirmed on the Trace screen.\n\nIf the call is GET /api/hello?name=Logico\\_jp, the `traces` table will look like this:\n\n![]()\n\nIn the Trace application, it should resemble this structure, in conjunction with the Request.\n\n![]()\n\nThen, run the application using the Tracing Agent to generate the necessary configuration files.\n- # (1) Collect configuration files such as reflect-config.json\n$JAVA\\_HOME/bin/java \\ -agentlib:native-image-agent=config-output-dir=src/main/resources/META-INF/{groupId}/{artifactId}/ \\ -jar ./target/{artifactId}-{version}.jar\n# (2)-a Generate a trace file\n$JAVA\\_HOME/bin/java \\ -agentlib:native-image-agent=trace-output=/path/to/trace-file.json \\ -jar ./target/{artifactId}-{version}.jar\n# (2)-b Generate a reachability metadata file from the collected trace file\nnative-image-configure generate \\ --trace-input=/path/to/trace-file.json \\ --output-dir=/path/to/config-dir/\n\n[Configure Native Image with the Tracing Agent](https://www.graalvm.org/latest/reference-manual/native-image/guides/configure-with-tracing-agent/)\n\n[Collect Metadata with the Tracing Agent](https://www.graalvm.org/latest/reference-manual/native-image/metadata/AutomaticMetadataCollection/)\n\nMake the following files in the specified folder.\n\n- `jni-config.json`\n- `reflect-config.json`\n- `proxy-config.json`\n- `resource-config.json`\n- `reachability-metadata.json`\n\nThese files can be located at `src/main/resources/META-INF/native-image` . The `native-image` tool picks up configuration files located in the directory `src/main/resources/META-INF/native-image` . However, it is recommended that we place the files in subdirectories divided by `groupId` and `artifactId` , as shown below.\n\n`src/main/resources/META-INF/native-image/{groupId}/{artifactId}`\n\n### native-image.properties\n\nWhen creating a native image, we call the following command.\n- mvn package -Dpackaging=native-image\n\nWe should specify the timing of class initialization (build time or runtime), the command line options for the `native-image` tool (the same command line options work in Maven/Gradle plugin), and the JVM arguments in the `native-image.properties` file. Indeed, these settings can be specified in `pom.xml` , but it is recommended that they be externalized.\n\nThis is also explained in the metric entry, so some details will be left out. If needed, please check the metric entry.\n\n[Send metrics from Micronaut native image applications to Azure Monitor | Microsoft Community Hub](https://techcommunity.microsoft.com/blog/appsonazureblog/send-metrics-from-micronaut-native-image-applications-to-azure-monitor/4443763)\n\n### Build a Native Image application\n\nBuilding a native image application takes a long time (though it has got quicker over time). If building it for testing purpose, we strongly recommend enabling Quick Build and setting the optimization level to `-Ob` option (although this will still take time). See below for more information.\n\n[Maven plugin for GraalVM Native Image](https://graalvm.github.io/native-build-tools/latest/maven-plugin.html#native-image-options) [Gradle plugin for GraalVM Native Image](https://graalvm.github.io/native-build-tools/latest/gradle-plugin.html#native-image-options)\n\n[Optimizations and Performance](https://www.graalvm.org/latest/reference-manual/native-image/optimizations-and-performance/#optimization-levels)\n\n### Test as a native image application\n\nVerify that this application works the same as a normal Java application. For example, call GET /api/hello?name=xxxx, GET /api/hello?name=, GET /api/hello , and POST /api/hello.\n\n### Check if traces and logs are visible in Azure Monitor (application insights)\n\nWhen reviewing the traces table in Application Insights, it becomes evident that four records were added at 3:14 p.m.\n\n![]()\n\nWhen checking traces…\n\n![]()![]()\n\nAs can be seen in the `traces` table, the logs have indeed been added to the trace. Naturally, the occurrence times remain consistent.\n\n### Summary\n\nI have outlined the process of writing to the traces table in Application Insights. However, it should be noted that some code is necessary to configure the Log Appender. Consequently, zero code instrumentation cannot be achieved strictly. However, the actual configuration is relatively minor, so implementation is not difficult.",
  "ProcessedDate": "2025-08-15 05:09:32",
  "Tags": [],
  "PubDate": "2025-08-15T04:55:41+00:00",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Community"
}
