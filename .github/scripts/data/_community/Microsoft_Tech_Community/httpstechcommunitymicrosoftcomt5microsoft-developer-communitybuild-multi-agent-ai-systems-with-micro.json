{
  "EnhancedContent": "*Like many of you I have been on a journey to build AI systems where **multiple agents** (AI models with tools and autonomy) collaborate to solve complex tasks. In this post, I want to share the engineering challenges we faced, the architecture we designed with Azure AI Foundry, and the lessons learned along the way.* Our goal is to empower AI engineers and developers to leverage multi-agent systems for real-world applications, with the benefit of Microsoft’s tools, research insights, and enterprise-grade platform.\n\n## Why Multi‑Agent Systems? The Need for AI Teamwork\n\nBuilding a single AI agent to perform a task is often straightforward. However, **many real-world processes are too complex for one agent alone**. Tasks like in-depth research, enterprise workflow automation, or multi-step customer service involve context switching and specialized knowledge that overwhelm a lone chatbot. Multi-agent systems address this by distributing work across specialized agents while maintaining coordination. This approach brings several advantages:\n\n- **Scalability:** Workloads can be split among agents, enabling horizontal scaling as tasks or data increase. More agents can handle more subtasks in parallel, avoiding bottlenecks.\n- **Specialisation:** Each agent can be fine-tuned for a specific role or domain (e.g. *research*, *summarisation*, *data extraction*), which improves performance and maintainability. No single model has to be a master of all trades.\n- **Flexibility:** Modular agents can be reused in different workflows or recombined to create new capabilities. It’s easy to extend the system by adding or swapping an agent without redesigning everything.\n- **Robustness:** If one agent fails or underperforms, others can pick up the slack. Decoupling tasks means the overall system can tolerate faults better than a monolithic agent.\n\nThis mirrors how human teams work: we achieve more by **dividing and conquering** complex problems. In fact, internal experiments and industry reports have shown that groups of AI agents can significantly outperform a single powerful model on complex, open-ended tasks. For example, [Anthropic](https://www.anthropic.com/engineering/multi-agent-research-system) found a multi-agent system (Claude agents working together) **answered 90% more queries correctly** than a single-agent approach in one evaluation. The ability to **operate in parallel** is key – our experience likewise showed that multiple agents exploring different aspects of a problem can cover far more ground, albeit with increased resource usage.\n\n**Challenge:** A downside of multi-agent setups is they consume more resources (more model calls, more tokens) than single-agent runs. In Anthropic’s research, multi-agent systems used ~15× the tokens of a single chat session. We’ve observed similarly that letting agents think and interact in depth pays off in better results, but at a cost. Ensuring the **task’s value justifies the cost** is important when choosing a multi-agent solution.\n\n## Designing the Architecture: Orchestration via a Lead Agent\n\nTo harness these benefits, we designed a **multi-agent architecture** built around an orchestrator-worker pattern – very similar to Anthropic’s “lead agent and subagents” approach. In Azure AI Foundry (our enterprise AI platform), this takes shape as **Connected Agents**: a mechanism where a **main agent** can spawn and coordinate **child agents** to handle sub-tasks. The main agent is the brain of the operation, responsible for understanding the user’s request, breaking it into parts, and delegating those parts to the appropriate specialist agents.\n\nEach agent in the system is defined with three core components:\n\n- **Instructions (prompt/policy):** defining the agent’s goal, role, and constraints (its “game plan”).\n- **Model:** an LLM that powers the agent’s reasoning and dialogue (e.g. GPT-4 or other models available in Foundry).\n- **Tools:** external capabilities the agent can invoke to get information or take actions (e.g. web search, databases, APIs).\n\nBy composing agents with different instructions and tools, we create a team where **each agent has a clear role**. The main agent’s role is orchestration; the sub-agents focus on specific tasks. This **separation of concerns** makes the system easier to understand and debug, and prevents any single context window from becoming overloaded.\n\n**How it works (overview):** When a user query comes in, the **lead agent** analyzes the request and devises a plan. It may decide that multiple pieces of information or steps are needed. The lead agent then **spins up subordinate agents in parallel** to gather or compute those pieces[\\]](https://www.anthropic.com/engineering/multi-agent-research-system). Each sub-agent operates with its own context window and tools, exploring one aspect of the task. They report their findings back to the lead agent, which integrates the results and decides if more exploration is required. The loop continues until the lead agent is satisfied that it can produce a final answer, at which point it consolidates everything and returns the result to the user.\n\nThis orchestrator/sub-agent pattern is powerful because it lets complex tasks be solved through **natural language delegation** rather than hard-coded logic. Notably, the main agent doesn’t need an if/else tree written by us to decide which sub-agent handles what; **it uses the language model’s reasoning to route tasks**. In Azure AI Foundry’s Connected Agents, the primary agent simply says (in effect) “*You, Agent A, do X; You, Agent B, do Y*,” and the platform handles the rest—no custom orchestration code needed. This drastically simplified our development: we focus on crafting the right prompts and agent designs, and let the AI figure out the coordination.\n\n### Example: Sales Assistant with Specialist Agents\n\nTo make this concrete, imagine a **Sales Preparation Assistant** that helps a sales team research a client before a meeting. Instead of trying to cram all knowledge and skills into one model, we give the assistant a team of four sub-agents, each an expert in a different area. The main agent (“Sales Assistant”) will ask each specialist for input and then compile a briefing.\n\n| Agent Role | Purpose & Task | Example Tools/Models Used | | --- | --- | --- | | **Market Research Agent** | Gathers industry trends and news related to the client’s sector. | Bing Web Search, internal news API | | **Competitive Analysis Agent** | Finds information on the client’s competitors and market position. | Web Search, Company DB | | **Customer Insights Agent** | Summarises the client’s history and interactions (from CRM data). | Azure Cognitive Search on CRM, GPT-4 | | **Financial Analysis Agent** | Reviews the client’s financial data and recent performance. | Finance database query tool, Excel APIs | | **Main Sales Assistant** | Orchestrator that delegates to the above agents, then synthesises a final report for the sales team. | GPT-4 (with instructions to compile and format results) |\n\nIn this scenario, the **Main Sales Assistant** agent would ask each sub-agent to report on their specialty (market news, competition, CRM insights, finances). Rather than one AI trying to do it all (and possibly missing nuances), we have **focused mini-AIs** each doing a thorough job in parallel. This approach was shown to reduce the overall time required and improve the quality of the final output. In early trials, such multi-agent setups often succeed where single agents fall short – for instance, finding all relevant facts across disparate sources and **preparing a comprehensive briefing more quickly**. Development is easier too: if tomorrow we need to add a *“Regulatory Compliance Agent”* for a new client requirement, we can plug it in without retraining or heavily modifying the others.\n\n**Orchestration under the hood:** Azure AI Foundry’s Agent Service provides the runtime that makes all this work reliably. It manages the **message passing** between the main agent and sub-agents, ensures each tool invocation is executed (with retries on failure), and keeps a structured log of the entire multi-agent conversation (we call it a **thread**). This means developers don’t have to manually implement how agents call each other or share data; the platform handles those mechanics. Foundry also supports true agent-to-agent messaging if agents need to talk directly, but often a hierarchical pattern (through the main agent) suffices for task delegation.\n\n## Tools, Knowledge, and the Model Context Protocol (MCP)\n\nFor agents to be effective, especially in enterprise scenarios, they must integrate with external knowledge sources and services – no single LLM knows everything or can perform all actions. Microsoft’s approach emphasizes a rich **tool integration layer**. In our system, tools range from web search and databases to APIs for taking real actions (sending emails, executing workflows, etc.) Equipping agents with the right tools extends their capabilities dramatically: an agent can retrieve up-to-date info, pull data behind corporate firewalls, or trigger business processes.\n\nOne key innovation is the **Model-Context Protocol (MCP)**, which Foundry uses to manage tools. MCP provides a structured way for agents to **discover and use tools dynamically** at runtime. Traditionally, if you wanted your AI agent to use a new tool, you might have to hard-code that tool’s API and update the agent’s code or prompt. With MCP, tools are defined on a **central tool server** (with descriptions and endpoints), and agents can query this server to see what tools are available. The agent’s SDK then generates the necessary code “stubs” to call the tool on the fly. This means:\n\n- **Easier maintenance:** You can add, update, or remove tools in one place (the MCP registry) without changing the agent’s code. When the Finance database API updates, just update its MCP entry; all agents automatically get the new version next time they run.\n- **Dynamic adaptability:** Agents can choose tools based on context. For example, a research agent might discover that a new MarketAnalysisAPI tool is available and start using it for a finance query, whereas previously it only had a generic web search.\n- **Separation of concerns:** Those building AI agents can rely on domain experts to maintain the tool definitions, while they focus on the agent logic. Agents treat tools in a uniform way, as functions they can call.\n\nIn practice, **tool selection became a critical part of our agent design**. A lesson we learned is that *giving agents access to the right tool, with a clear description, can make or break their performance*. If a tool’s description is vague or overlapping with another, the agent might choose the wrong approach and wander down a blind alley. For instance, we saw cases where an agent would stubbornly query an internal knowledge base for information that actually only existed on the web, simply because the tool prompt made the web search sound less relevant. We addressed this by carefully curating tool descriptions and even building an internal **tool-testing agent** that automatically tries out tools and suggests better descriptions for them. Ensuring each tool had a **distinct purpose and clear usage guidance** dramatically improved our agents’ success rate in choosing the optimal tool for a given job.\n\nFinally, **multi-modal support** is worth noting. Some tasks involve not just text, but images or other media. Our multi-agent architecture, especially with Azure AI Foundry, can incorporate vision-capable models as agents or tools. For example, an “Image Analysis Agent” could be part of a team, or an agent might call a vision API tool. The Telco customer service demo (using Foundry + OpenAI Agent SDK) featured an agent that could handle image uploads (like an ID document) by invoking an image-processing function. The orchestration framework doesn’t fundamentally change with multi-modality, it simply treats the vision model as another specialist agent or tool in the conversation. The ability to plug in different AI skills (text, vision, search, etc.) under a unified agent system is a **big advantage** of Microsoft’s approach: the agent team becomes *cross-functional*, each member with their own modality or expertise, collectively solving richer tasks than any single foundation model could.\n\n## Reliability, Safety, and Enterprise-Grade Engineering\n\nWhile the basic idea of agents chatting and calling tools is elegant, **productionizing** this system for enterprise use brought serious engineering challenges. We needed our multi-agent system to be **reliable, controllable, and secure**. Here are the key areas we focused on and how we addressed them:\n\n### Observability and Debugging\n\nMulti-agent chains can be complex and non-deterministic each run might involve different paths as agents make choices. Early on, we realized that treating the system as a black box was untenable. Developers and operators must be able to **observe what each agent is “thinking” and doing**, or else diagnosing issues would be impossible. Azure AI Foundry’s Agent Service was built with **full conversation traceability** in mind. Every message between agents (and to the user), every tool invocation and result, is captured in a structured **thread log**. We integrated this with Azure Application Insights telemetry, so one can monitor performance, latencies, errors, and even token consumption of agents in real time.\n\nThis tracing proved invaluable. For example, when a complex workflow wasn’t producing the expected outcome, we could replay the entire agent conversation step by step to see where things went awry. In one instance, we found that two sub-agents were given slightly overlapping responsibilities, causing them to waste time retrieving nearly identical information. The logs and message transcripts made this immediately clear, guiding us to tighten the role definitions. Moreover, because the system logs are structured (not just free-form text), we could build automatic analysis tools like checking how often an agent hits a retry or how many cycles a conversation goes through before completion – to spot anomalies. This kind of **observability** was something the open-source community also highlighted as crucial; in fact, **Sematic Kernel**,  **AutoGen** frameworks introduce metrics tracking and message tracing for exactly this reason.\n\nWe also developed **visual debugging tools**. One example is the **AutoGen Studio** (a low-code interface from Microsoft Research) which allows developers to visually inspect agent interactions in real time, pause agents, or adjust their behavior on the fly. This interactive approach accelerates the prompt-engineering loop: one can watch agents argue or collaborate live, and intervene if needed. Such capabilities turned out to be vital for understanding emergent behaviors in multi-agent setups.\n\n### Coordination Complexity and State Management\n\nAs more agents come into play, keeping them coordinated and preserving shared context is hard. Early versions of agents would sometimes spawn excessive numbers of agents or get stuck in loops. For instance, one of our prototypes (before we applied strict limits) ended up in a degenerate state where two agents kept handing control back and forth without making progress. This taught us to implement **guardrails and smarter orchestration policies**.\n\nIn Azure AI Foundry, beyond the simple connected-agent pattern, we introduced a more structured orchestration capability called **Multi-Agent Workflows**. This lets developers explicitly define **states, transitions, and triggers** in a workflow that involves multiple agents. It’s like flowcharting the high-level process that the agents should follow, including how they pass data around. We use this for long-running or highly critical processes where you want extra determinism for example, an onboarding workflow might have clearly defined phases (Verification → Provisioning → Notification) each handled by different agents, and you want to ensure the process doesn’t derail. The workflow engine enforces that the system moves to the next state only when all agents in the current state have completed and certain conditions (triggers) are met. It also provides persistence: if the process needs to wait (say, for an external event or simply because it’s a lengthy task), the state is saved and can be resumed later without losing context.\n\nThese workflow features were a response to reliability needs, they give fine-grained control and error recovery in multi-agent systems that operate over extended periods. In practice, we learned to use the simpler **Connected Agents** approach for quick, on-the-fly delegations (it’s amazingly capable with minimal setup), and reserve **Workflow Orchestration** for scenarios where we must guarantee a robust sequence over minutes, hours, or days. By having both options, we can strike a balance between **flexibility** and **control** as needed.\n\n### Trust, Safety, and Governance\n\nWhen you let AI agents act autonomously (especially if they can use tools that modify data or interact with the real world), **safety** is paramount. From day one, our design included enterprise-grade safety measures:\n\n- **Content Filtering and Policy Enforcement:** All AI outputs go through content filters to catch disallowed content or potential prompt injection attacks. The Foundry Agent Service has integrated guardrails so that even if an agent tries something risky (e.g., a tool returns a sensitive info that should not be shown), policies can prevent misuse or leakage. For example, we configured financial analysis agents with rules not to output certain PII or to stop if they detect a regulatory compliance issue, handing off to a human instead.\n- **Identity and Access Control:** Agents operate with identities managed via Microsoft Entra ID (Azure AD). This means every action an agent takes can be attributed and audited. Role-Based Access Control (RBAC) is enforced: an agent only has access to the data and APIs its role permits. If an agent’s credentials are compromised or misused, Azure’s standard auditing can alert us. Essentially, agents are first-class service principals in our cloud stack.\n- **Network Isolation and Compliance:** For enterprise deployments, Azure AI Foundry allows agents to run in isolated networks (so they can’t arbitrarily call external services unless allowed) and to use customer-managed storage and search indices. This addresses the **data governance** aspect, we can ensure an agent looking up internal documents only sees what it’s supposed to, and all data stays within compliant boundaries.\n- **Auditability:** As mentioned earlier, every decision an agent makes (every tool it calls, every answer it gives) is recorded. This is crucial for **trust,** if a multi-agent system is making business decisions, we need to be able to explain and justify those decisions later. By retaining the full reasoning trace and sources, we make the system’s work **transparent and auditable**. In fact, our “Deep Research” agents output not just answers but also a log of how they arrived at that answer, including citations to source material for each claim. This level of detail is a must-have in regulated industries or any high-stakes use case.\n\nOverall, **baking in trust and safety by design** was a non-negotiable requirement. It does introduce some overhead – e.g., being strict about content filtering can sometimes stop an agent from a creative solution until we refine its prompt or the filter thresholds, but it’s worth it for the confidence it gives to deploy these agents at scale.\n\n### Performance and Cost Considerations\n\nWe touched on the resource cost of multi-agent systems. Another challenge was ensuring the system runs efficiently. Without care, adding agents can linearly increase cost and latency. We mitigated this in a few ways:\n\n- **Parallelism:** We make agents run concurrently wherever possible. Our lead agents typically fire off multiple sub-agents at once rather than sequentially waiting for one then starting the next. Also, our agents themselves can issue *parallel tool calls*. In fact, we enabled some of our retrieval agents to batch multiple search queries and send them all at the same time. Anthropic reported that this kind of parallelism cut their research task times by up to **90%**, and we’ve observed similar dramatic speed-ups. By doing in 1 minute what a single agent might take 10 minutes to do step-by-step, we make the approach far more practical. Of course, the flip side is hitting many APIs and LLM endpoints concurrently can spike usage costs; we carefully monitor usage and recommend multi-agent mode only when needed for the problem complexity.\n- **Scaling rules and agent limits:** One lesson learned was to prevent “agent sprawl.” We devised guidelines (and encoded some in prompts) about how many sub-agents to use for a given task complexity. For simple fact queries, the main agent is encouraged to handle it alone or with at most one helper; for moderately complex tasks, maybe spin up 2–3; only truly complex projects get a dozen specialists. This avoids the situation where an overzealous orchestrator might launch an army of agents and overkill the problem. These limits were informed by experimentation and echo the principle of **scaling effort to the problem size**.\n- **Model selection:** Multi-agent systems don’t always need the largest model for every agent. We often use a **mix of model sizes** to optimize cost. For instance, a straightforward data extraction agent might be powered by a cheaper GPT-3.5, while the synthesis agent uses GPT-4 for the final answer quality. Foundry makes it easy to deploy a range of model endpoints (including open-source Llama-based models) and each agent can pick the one best suited. We learned that using an expensive model for a simple sub-task is wasteful; a smaller model with the right tools can do the job just as well. This mix-and-match approach helped keep our compute costs in check without sacrificing outcome quality.\n\n## Lessons Learned and Best Practices\n\nBuilding these multi-agent systems was an iterative learning process. Here are some of the **key lessons and best practices** that emerged, which we believe will be useful to anyone developing their own:\n\nLet’s expand on a couple of these points:\n\n1. **Prompt engineering for multi-agent is different:** We quickly discovered that writing prompts for a **team of agents** is an order of magnitude more complex than for a single chatbot. Not only do you have to get each agent’s behavior right, you must shape how they interact. One principle that served us well was: **“Think like your agents.”** When debugging, we’d often step through the conversation from each agent’s perspective, almost role-playing as them, to see why they might be doing something silly. If an agent was repeating another’s results, maybe our instructions were too vague and they didn’t realise that sub-task was already covered. The fix would be to clarify the division of labour in the lead agent’s prompt or introduce an ordering (e.g., Agent B only runs after Agent A’s info is in, etc.). Another principle: **teach the orchestrator to delegate effectively**. The main agent’s prompt now includes explicit guidance on how to break down tasks and how to phrase sub-agent assignments with plenty of detail. We learned that if the lead just says “Research topic X” to two different agents, they might both do the same thing. Now, the lead agent provides distinct **objectives and context** to each sub-agent (e.g., focus one on recent news, another on historical data, etc.). This reduced redundancy and missed coverage dramatically.\n2. **Let the AI help improve itself:** One delightful surprise was that large models can be quite good at analyzing and refining their own strategies when asked. We sometimes gave an agent a chance to **critique its output or plan,** essentially a self-reflection step. In other cases we had a “judge” agent evaluate the final answers against criteria (accuracy, completeness, etc.) These evaluations not only gave us a score for benchmarking changes, but the judge’s feedback (being an LLM) often highlighted exactly where an agent went off track or missed something. In a sense, we used one AI to tell us how to make another AI better. This kind of meta-prompting and self-correction became a powerful tool in our development cycle, allowing **faster iteration** without full human-in-the-loop at every turn.\n3. **Know when to simplify:** Not every problem needs a fleet of agents. A big lesson was to **use the simplest approach that works**. If a single agent with a smart prompt can handle a task reliably, that’s fine! We reserved multi-agent mode for when there was clear added value  e.g., problems requiring parallel exploration, different expertise, or lengthy reasoning that benefits from splitting into parts. This discipline kept our systems leaner and easier to maintain. It also helped us explain the value to stakeholders: we could justify the complexity by pointing to concrete gains (like a task that went from 2 hours by a single high-end model to 10 minutes by a team of agents with better results).\n\n## Conclusion and Next Steps\n\nMulti-agent AI systems have moved from intriguing research demos to practical, production-ready solutions. Our journey involved close collaboration between teams such as those who built open-source frameworks like AutoGen to experiment with multi-agent interactions) and the **Azure AI product teams** (who turned these concepts into the robust Azure AI Foundry Agent Service). Along the way, we learned how to orchestrate LLMs at scale, how to keep them in check, and how to squeeze the most value out of agent collaboration.\n\nToday, Azure AI Foundry’s Agents platform provides a **unified environment to develop, test, and deploy multi-agent systems,** complete with the orchestration, observability, and safety features to make them enterprise-ready. The public preview of features like **Connected Agents** and **Deep Research** (which is essentially an advanced research agent that uses the web + analysis in a multi-step process) is already enabling customers to build “AI teams” that tackle complex workflows. This is just the beginning. We’re continuing to improve the platform with feedback from developers: upcoming releases will further tighten integration with the broader Azure ecosystem (for example, more seamless use of Azure Cognitive Search, Excel as a tool, etc.), expand the library of **pre-built agent templates** in the Agent Catalog (so you can start with a solid example for common scenarios), and introduce more advanced coordination patterns inspired by real-world use cases.\n\nIf you’re an AI engineer or developer eager to explore multi-agent systems, **now is a great time to dive in**. Here are some resources to get you started:\n\n- **[Microsoft AI Agents for Beginners](https://aka.ms/ai-agents-beginners)** - Learn all about AI Agents with this FREE curricula\n- [**Azure AI Foundry Documentation**](https://ai.azure.com/doc/) – Learn more about the Agent Service and how to configure agents, tools, and workflows.\n- [**Microsoft Learn Modules**](https://learn.microsoft.com) –  step-by-step tutorial to build a connected multi-agent solution (for example, a ticket triage system) using Azure AI Foundry Agent Service. This will walk you through setting up agents and using the SDK.\n- **Microsoft [MCP for Beginners](https://aka.ms/mcp-for-beginners): Integrating MCP Tools** – Another tutorial focused on the Model Context Protocol, showing how to enable dynamic tool discovery for your agents.\n- [**Azure AI Foundry Agent Catalog**](https://ai.azure.com) – Browse a growing collection of **open-sourced agent examples** contributed by Microsoft and partners, covering scenarios from content compliance to manufacturing optimization. These samples are great starting points to see how multi-agent code is structured in real projects.\n\nMulti-agent systems represent a significant shift in how we conceptualise AI solutions: from single brilliant assistants to **teams of specialised agents working in concert**. The engineering journey hasn’t been easy  we navigated challenges in coordination, built new tooling for control, and refined prompts endlessly. But the end result is a new class of AI applications that are more **powerful, resilient, and tunable**. We hope the insights shared here help you in your own journey to build with AI agents. We’re excited to see what you will create with these technologies. As we continue to push the frontier of agentic AI (both in research and in Azure), one thing is clear: **many minds – human or AI – are often better than one**. Happy building!\n\n**Userful References**\n\n[Introducing Multi-Agent Orchestration in Foundry Agent Service – Build ...](https://techcommunity.microsoft.com/blog/azure-ai-foundry-blog/building-a-digital-workforce-with-multi-agents-in-azure-ai-foundry-agent-service/4414671)\n\n[Building a multimodal, multi-agent system using Azure AI Agent Service ...](https://techcommunity.microsoft.com/blog/azure-ai-foundry-blog/building-a-multimodal-multi-agent-system-using-azure-ai-agent-service-and-openai/4396267)\n\n[How we built our multi-agent research system \\ Anthropic](https://www.anthropic.com/engineering/multi-agent-research-system)\n\n[What is Azure AI Foundry Agent Service? - Azure AI Foundry](https://learn.microsoft.com/en-us/azure/ai-foundry/agents/overview)\n\n[Multi-Agent Systems and MCP Tools Integration with Azure AI Foundry ...](https://techcommunity.microsoft.com/blog/educatordeveloperblog/multi-agent-systems-and-mcp-tools-integration-with-azure-ai-foundry/4431823)\n\n[Introducing Deep Research in Azure AI Foundry Agent Service](https://azure.microsoft.com/en-us/blog/introducing-deep-research-in-azure-ai-foundry-agent-service/)\n\n[AutoGen v0.4: Advancing the development of agentic AI systems](https://www.microsoft.com/en-us/research/blog/autogen-v0-4-reimagining-the-foundation-of-agentic-ai-for-scale-extensibility-and-robustness/)\n\nUpdated Sep 16, 2025\n\nVersion 1.0\n\n[agents](/tag/agents?nodeId=board%3AAzureDevCommunityBlog)\n\n[ai](/tag/ai?nodeId=board%3AAzureDevCommunityBlog)\n\n[ai foundry](/tag/ai%20foundry?nodeId=board%3AAzureDevCommunityBlog)\n\n[azure ai foundry](/tag/azure%20ai%20foundry?nodeId=board%3AAzureDevCommunityBlog)\n\n[best practices](/tag/best%20practices?nodeId=board%3AAzureDevCommunityBlog)\n\n[codestories](/tag/codestories?nodeId=board%3AAzureDevCommunityBlog)\n\n[developer](/tag/developer?nodeId=board%3AAzureDevCommunityBlog)\n\n[llm](/tag/llm?nodeId=board%3AAzureDevCommunityBlog)\n\n[!\\[Lee_Stott&#x27;s avatar\\](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/dS0yMTA1NDYtODM5MjVpMDI2ODNGQTMwMzAwNDFGQQ?image-dimensions=50x50)](/users/lee_stott/210546) [Lee_Stott](/users/lee_stott/210546) ![Icon for Microsoft rank](https://techcommunity.microsoft.com/t5/s/gxcuf89792/images/cmstNC05WEo0blc?image-dimensions=100x16&amp;constrain-image=true)Microsoft\n\nJoined September 25, 2018\n\n[View Profile](/users/lee_stott/210546)\n\n/category/azure/blog/azuredevcommunityblog [Microsoft Developer Community Blog](/category/azure/blog/azuredevcommunityblog) Follow this blog board to get notified when there's new activity",
  "FeedLevelAuthor": "rss.livelink.threads-in-node",
  "Author": "Lee_Stott",
  "FeedName": "Microsoft Tech Community",
  "Link": "https://techcommunity.microsoft.com/t5/microsoft-developer-community/build-multi-agent-ai-systems-with-microsoft/ba-p/4454510",
  "Description": "*Like many of you I have been on a journey to build AI systems where **multiple agents** (AI models with tools and autonomy) collaborate to solve complex tasks. In this post, I want to share the engineering challenges we faced, the architecture we designed with Azure AI Foundry, and the lessons learned along the way.* Our goal is to empower AI engineers and developers to leverage multi-agent systems for real-world applications, with the benefit of Microsoft’s tools, research insights, and enterprise-grade platform.\n\n## Why Multi‑Agent Systems? The Need for AI Teamwork\n\nBuilding a single AI agent to perform a task is often straightforward. However, **many real-world processes are too complex for one agent alone**. Tasks like in-depth research, enterprise workflow automation, or multi-step customer service involve context switching and specialized knowledge that overwhelm a lone chatbot. Multi-agent systems address this by distributing work across specialized agents while maintaining coordination. This approach brings several advantages:\n\n- **Scalability:** Workloads can be split among agents, enabling horizontal scaling as tasks or data increase. More agents can handle more subtasks in parallel, avoiding bottlenecks.\n- **Specialisation:** Each agent can be fine-tuned for a specific role or domain (e.g. *research*, *summarisation*, *data extraction*), which improves performance and maintainability. No single model has to be a master of all trades.\n- **Flexibility:** Modular agents can be reused in different workflows or recombined to create new capabilities. It’s easy to extend the system by adding or swapping an agent without redesigning everything.\n- **Robustness:** If one agent fails or underperforms, others can pick up the slack. Decoupling tasks means the overall system can tolerate faults better than a monolithic agent.\n\nThis mirrors how human teams work: we achieve more by **dividing and conquering** complex problems. In fact, internal experiments and industry reports have shown that groups of AI agents can significantly outperform a single powerful model on complex, open-ended tasks. For example, [Anthropic](https://www.anthropic.com/engineering/multi-agent-research-system) found a multi-agent system (Claude agents working together) **answered 90% more queries correctly** than a single-agent approach in one evaluation. The ability to **operate in parallel** is key – our experience likewise showed that multiple agents exploring different aspects of a problem can cover far more ground, albeit with increased resource usage.\n\n**Challenge:** A downside of multi-agent setups is they consume more resources (more model calls, more tokens) than single-agent runs. In Anthropic’s research, multi-agent systems used ~15× the tokens of a single chat session. We’ve observed similarly that letting agents think and interact in depth pays off in better results, but at a cost. Ensuring the **task’s value justifies the cost** is important when choosing a multi-agent solution.\n\n## Designing the Architecture: Orchestration via a Lead Agent\n\nTo harness these benefits, we designed a **multi-agent architecture** built around an orchestrator-worker pattern – very similar to Anthropic’s “lead agent and subagents” approach. In Azure AI Foundry (our enterprise AI platform), this takes shape as **Connected Agents**: a mechanism where a **main agent** can spawn and coordinate **child agents** to handle sub-tasks. The main agent is the brain of the operation, responsible for understanding the user’s request, breaking it into parts, and delegating those parts to the appropriate specialist agents.\n\nEach agent in the system is defined with three core components:\n\n- **Instructions (prompt/policy):** defining the agent’s goal, role, and constraints (its “game plan”).\n- **Model:** an LLM that powers the agent’s reasoning and dialogue (e.g. GPT-4 or other models available in Foundry).\n- **Tools:** external capabilities the agent can invoke to get information or take actions (e.g. web search, databases, APIs).\n\nBy composing agents with different instructions and tools, we create a team where **each agent has a clear role**. The main agent’s role is orchestration; the sub-agents focus on specific tasks. This **separation of concerns** makes the system easier to understand and debug, and prevents any single context window from becoming overloaded.\n\n**How it works (overview):** When a user query comes in, the **lead agent** analyzes the request and devises a plan. It may decide that multiple pieces of information or steps are needed. The lead agent then **spins up subordinate agents in parallel** to gather or compute those pieces[\\]](https://www.anthropic.com/engineering/multi-agent-research-system). Each sub-agent operates with its own context window and tools, exploring one aspect of the task. They report their findings back to the lead agent, which integrates the results and decides if more exploration is required. The loop continues until the lead agent is satisfied that it can produce a final answer, at which point it consolidates everything and returns the result to the user.\n\n![]()\n\nThis orchestrator/sub-agent pattern is powerful because it lets complex tasks be solved through **natural language delegation** rather than hard-coded logic. Notably, the main agent doesn’t need an if/else tree written by us to decide which sub-agent handles what; **it uses the language model’s reasoning to route tasks**. In Azure AI Foundry’s Connected Agents, the primary agent simply says (in effect) “*You, Agent A, do X; You, Agent B, do Y*,” and the platform handles the rest—no custom orchestration code needed. This drastically simplified our development: we focus on crafting the right prompts and agent designs, and let the AI figure out the coordination.\n\n### Example: Sales Assistant with Specialist Agents\n\nTo make this concrete, imagine a **Sales Preparation Assistant** that helps a sales team research a client before a meeting. Instead of trying to cram all knowledge and skills into one model, we give the assistant a team of four sub-agents, each an expert in a different area. The main agent (“Sales Assistant”) will ask each specialist for input and then compile a briefing.\n\n| Agent Role | Purpose & Task | Example Tools/Models Used | | --- | --- | --- | | **Market Research Agent** | Gathers industry trends and news related to the client’s sector. | Bing Web Search, internal news API | | **Competitive Analysis Agent** | Finds information on the client’s competitors and market position. | Web Search, Company DB | | **Customer Insights Agent** | Summarises the client’s history and interactions (from CRM data). | Azure Cognitive Search on CRM, GPT-4 | | **Financial Analysis Agent** | Reviews the client’s financial data and recent performance. | Finance database query tool, Excel APIs | | **Main Sales Assistant** | Orchestrator that delegates to the above agents, then synthesises a final report for the sales team. | GPT-4 (with instructions to compile and format results) |\n\nIn this scenario, the **Main Sales Assistant** agent would ask each sub-agent to report on their specialty (market news, competition, CRM insights, finances). Rather than one AI trying to do it all (and possibly missing nuances), we have **focused mini-AIs** each doing a thorough job in parallel. This approach was shown to reduce the overall time required and improve the quality of the final output. In early trials, such multi-agent setups often succeed where single agents fall short – for instance, finding all relevant facts across disparate sources and **preparing a comprehensive briefing more quickly**. Development is easier too: if tomorrow we need to add a *“Regulatory Compliance Agent”* for a new client requirement, we can plug it in without retraining or heavily modifying the others.\n\n**Orchestration under the hood:** Azure AI Foundry’s Agent Service provides the runtime that makes all this work reliably. It manages the **message passing** between the main agent and sub-agents, ensures each tool invocation is executed (with retries on failure), and keeps a structured log of the entire multi-agent conversation (we call it a **thread**). This means developers don’t have to manually implement how agents call each other or share data; the platform handles those mechanics. Foundry also supports true agent-to-agent messaging if agents need to talk directly, but often a hierarchical pattern (through the main agent) suffices for task delegation.\n\n## Tools, Knowledge, and the Model Context Protocol (MCP)\n\nFor agents to be effective, especially in enterprise scenarios, they must integrate with external knowledge sources and services – no single LLM knows everything or can perform all actions. Microsoft’s approach emphasizes a rich **tool integration layer**. In our system, tools range from web search and databases to APIs for taking real actions (sending emails, executing workflows, etc.) Equipping agents with the right tools extends their capabilities dramatically: an agent can retrieve up-to-date info, pull data behind corporate firewalls, or trigger business processes.\n\nOne key innovation is the **Model-Context Protocol (MCP)**, which Foundry uses to manage tools. MCP provides a structured way for agents to **discover and use tools dynamically** at runtime. Traditionally, if you wanted your AI agent to use a new tool, you might have to hard-code that tool’s API and update the agent’s code or prompt. With MCP, tools are defined on a **central tool server** (with descriptions and endpoints), and agents can query this server to see what tools are available. The agent’s SDK then generates the necessary code “stubs” to call the tool on the fly. This means:\n\n- **Easier maintenance:** You can add, update, or remove tools in one place (the MCP registry) without changing the agent’s code. When the Finance database API updates, just update its MCP entry; all agents automatically get the new version next time they run.\n- **Dynamic adaptability:** Agents can choose tools based on context. For example, a research agent might discover that a new MarketAnalysisAPI tool is available and start using it for a finance query, whereas previously it only had a generic web search.\n- **Separation of concerns:** Those building AI agents can rely on domain experts to maintain the tool definitions, while they focus on the agent logic. Agents treat tools in a uniform way, as functions they can call.\n\nIn practice, **tool selection became a critical part of our agent design**. A lesson we learned is that *giving agents access to the right tool, with a clear description, can make or break their performance*. If a tool’s description is vague or overlapping with another, the agent might choose the wrong approach and wander down a blind alley. For instance, we saw cases where an agent would stubbornly query an internal knowledge base for information that actually only existed on the web, simply because the tool prompt made the web search sound less relevant. We addressed this by carefully curating tool descriptions and even building an internal **tool-testing agent** that automatically tries out tools and suggests better descriptions for them. Ensuring each tool had a **distinct purpose and clear usage guidance** dramatically improved our agents’ success rate in choosing the optimal tool for a given job.\n\nFinally, **multi-modal support** is worth noting. Some tasks involve not just text, but images or other media. Our multi-agent architecture, especially with Azure AI Foundry, can incorporate vision-capable models as agents or tools. For example, an “Image Analysis Agent” could be part of a team, or an agent might call a vision API tool. The Telco customer service demo (using Foundry + OpenAI Agent SDK) featured an agent that could handle image uploads (like an ID document) by invoking an image-processing function. The orchestration framework doesn’t fundamentally change with multi-modality, it simply treats the vision model as another specialist agent or tool in the conversation. The ability to plug in different AI skills (text, vision, search, etc.) under a unified agent system is a **big advantage** of Microsoft’s approach: the agent team becomes *cross-functional*, each member with their own modality or expertise, collectively solving richer tasks than any single foundation model could.\n\n## Reliability, Safety, and Enterprise-Grade Engineering\n\nWhile the basic idea of agents chatting and calling tools is elegant, **productionizing** this system for enterprise use brought serious engineering challenges. We needed our multi-agent system to be **reliable, controllable, and secure**. Here are the key areas we focused on and how we addressed them:\n\n### Observability and Debugging\n\nMulti-agent chains can be complex and non-deterministic each run might involve different paths as agents make choices. Early on, we realized that treating the system as a black box was untenable. Developers and operators must be able to **observe what each agent is “thinking” and doing**, or else diagnosing issues would be impossible. Azure AI Foundry’s Agent Service was built with **full conversation traceability** in mind. Every message between agents (and to the user), every tool invocation and result, is captured in a structured **thread log**. We integrated this with Azure Application Insights telemetry, so one can monitor performance, latencies, errors, and even token consumption of agents in real time.\n\nThis tracing proved invaluable. For example, when a complex workflow wasn’t producing the expected outcome, we could replay the entire agent conversation step by step to see where things went awry. In one instance, we found that two sub-agents were given slightly overlapping responsibilities, causing them to waste time retrieving nearly identical information. The logs and message transcripts made this immediately clear, guiding us to tighten the role definitions. Moreover, because the system logs are structured (not just free-form text), we could build automatic analysis tools like checking how often an agent hits a retry or how many cycles a conversation goes through before completion – to spot anomalies. This kind of **observability** was something the open-source community also highlighted as crucial; in fact, **Sematic Kernel**, **AutoGen** frameworks introduce metrics tracking and message tracing for exactly this reason.\n\nWe also developed **visual debugging tools**. One example is the **AutoGen Studio** (a low-code interface from Microsoft Research) which allows developers to visually inspect agent interactions in real time, pause agents, or adjust their behavior on the fly. This interactive approach accelerates the prompt-engineering loop: one can watch agents argue or collaborate live, and intervene if needed. Such capabilities turned out to be vital for understanding emergent behaviors in multi-agent setups.\n\n### Coordination Complexity and State Management\n\nAs more agents come into play, keeping them coordinated and preserving shared context is hard. Early versions of agents would sometimes spawn excessive numbers of agents or get stuck in loops. For instance, one of our prototypes (before we applied strict limits) ended up in a degenerate state where two agents kept handing control back and forth without making progress. This taught us to implement **guardrails and smarter orchestration policies**.\n\nIn Azure AI Foundry, beyond the simple connected-agent pattern, we introduced a more structured orchestration capability called **Multi-Agent Workflows**. This lets developers explicitly define **states, transitions, and triggers** in a workflow that involves multiple agents. It’s like flowcharting the high-level process that the agents should follow, including how they pass data around. We use this for long-running or highly critical processes where you want extra determinism for example, an onboarding workflow might have clearly defined phases (Verification → Provisioning → Notification) each handled by different agents, and you want to ensure the process doesn’t derail. The workflow engine enforces that the system moves to the next state only when all agents in the current state have completed and certain conditions (triggers) are met. It also provides persistence: if the process needs to wait (say, for an external event or simply because it’s a lengthy task), the state is saved and can be resumed later without losing context.\n\nThese workflow features were a response to reliability needs, they give fine-grained control and error recovery in multi-agent systems that operate over extended periods. In practice, we learned to use the simpler **Connected Agents** approach for quick, on-the-fly delegations (it’s amazingly capable with minimal setup), and reserve **Workflow Orchestration** for scenarios where we must guarantee a robust sequence over minutes, hours, or days. By having both options, we can strike a balance between **flexibility** and **control** as needed.\n\n### Trust, Safety, and Governance\n\nWhen you let AI agents act autonomously (especially if they can use tools that modify data or interact with the real world), **safety** is paramount. From day one, our design included enterprise-grade safety measures:\n\n- **Content Filtering and Policy Enforcement:** All AI outputs go through content filters to catch disallowed content or potential prompt injection attacks. The Foundry Agent Service has integrated guardrails so that even if an agent tries something risky (e.g., a tool returns a sensitive info that should not be shown), policies can prevent misuse or leakage. For example, we configured financial analysis agents with rules not to output certain PII or to stop if they detect a regulatory compliance issue, handing off to a human instead.\n- **Identity and Access Control:** Agents operate with identities managed via Microsoft Entra ID (Azure AD). This means every action an agent takes can be attributed and audited. Role-Based Access Control (RBAC) is enforced: an agent only has access to the data and APIs its role permits. If an agent’s credentials are compromised or misused, Azure’s standard auditing can alert us. Essentially, agents are first-class service principals in our cloud stack.\n- **Network Isolation and Compliance:** For enterprise deployments, Azure AI Foundry allows agents to run in isolated networks (so they can’t arbitrarily call external services unless allowed) and to use customer-managed storage and search indices. This addresses the **data governance** aspect, we can ensure an agent looking up internal documents only sees what it’s supposed to, and all data stays within compliant boundaries.\n- **Auditability:** As mentioned earlier, every decision an agent makes (every tool it calls, every answer it gives) is recorded. This is crucial for **trust,** if a multi-agent system is making business decisions, we need to be able to explain and justify those decisions later. By retaining the full reasoning trace and sources, we make the system’s work **transparent and auditable**. In fact, our “Deep Research” agents output not just answers but also a log of how they arrived at that answer, including citations to source material for each claim. This level of detail is a must-have in regulated industries or any high-stakes use case.\n\nOverall, **baking in trust and safety by design** was a non-negotiable requirement. It does introduce some overhead – e.g., being strict about content filtering can sometimes stop an agent from a creative solution until we refine its prompt or the filter thresholds, but it’s worth it for the confidence it gives to deploy these agents at scale.\n\n### Performance and Cost Considerations\n\nWe touched on the resource cost of multi-agent systems. Another challenge was ensuring the system runs efficiently. Without care, adding agents can linearly increase cost and latency. We mitigated this in a few ways:\n\n- **Parallelism:** We make agents run concurrently wherever possible. Our lead agents typically fire off multiple sub-agents at once rather than sequentially waiting for one then starting the next. Also, our agents themselves can issue *parallel tool calls*. In fact, we enabled some of our retrieval agents to batch multiple search queries and send them all at the same time. Anthropic reported that this kind of parallelism cut their research task times by up to **90%**, and we’ve observed similar dramatic speed-ups. By doing in 1 minute what a single agent might take 10 minutes to do step-by-step, we make the approach far more practical. Of course, the flip side is hitting many APIs and LLM endpoints concurrently can spike usage costs; we carefully monitor usage and recommend multi-agent mode only when needed for the problem complexity.\n- **Scaling rules and agent limits:** One lesson learned was to prevent “agent sprawl.” We devised guidelines (and encoded some in prompts) about how many sub-agents to use for a given task complexity. For simple fact queries, the main agent is encouraged to handle it alone or with at most one helper; for moderately complex tasks, maybe spin up 2–3; only truly complex projects get a dozen specialists. This avoids the situation where an overzealous orchestrator might launch an army of agents and overkill the problem. These limits were informed by experimentation and echo the principle of **scaling effort to the problem size**.\n- **Model selection:** Multi-agent systems don’t always need the largest model for every agent. We often use a **mix of model sizes** to optimize cost. For instance, a straightforward data extraction agent might be powered by a cheaper GPT-3.5, while the synthesis agent uses GPT-4 for the final answer quality. Foundry makes it easy to deploy a range of model endpoints (including open-source Llama-based models) and each agent can pick the one best suited. We learned that using an expensive model for a simple sub-task is wasteful; a smaller model with the right tools can do the job just as well. This mix-and-match approach helped keep our compute costs in check without sacrificing outcome quality.\n\n## Lessons Learned and Best Practices\n\nBuilding these multi-agent systems was an iterative learning process. Here are some of the **key lessons and best practices** that emerged, which we believe will be useful to anyone developing their own:\n\n![]()\n\nLet’s expand on a couple of these points:\n\n1. **Prompt engineering for multi-agent is different:** We quickly discovered that writing prompts for a **team of agents** is an order of magnitude more complex than for a single chatbot. Not only do you have to get each agent’s behavior right, you must shape how they interact. One principle that served us well was: **“Think like your agents.”** When debugging, we’d often step through the conversation from each agent’s perspective, almost role-playing as them, to see why they might be doing something silly. If an agent was repeating another’s results, maybe our instructions were too vague and they didn’t realise that sub-task was already covered. The fix would be to clarify the division of labour in the lead agent’s prompt or introduce an ordering (e.g., Agent B only runs after Agent A’s info is in, etc.). Another principle: **teach the orchestrator to delegate effectively**. The main agent’s prompt now includes explicit guidance on how to break down tasks and how to phrase sub-agent assignments with plenty of detail. We learned that if the lead just says “Research topic X” to two different agents, they might both do the same thing. Now, the lead agent provides distinct **objectives and context** to each sub-agent (e.g., focus one on recent news, another on historical data, etc.). This reduced redundancy and missed coverage dramatically.\n2. **Let the AI help improve itself:** One delightful surprise was that large models can be quite good at analyzing and refining their own strategies when asked. We sometimes gave an agent a chance to **critique its output or plan,** essentially a self-reflection step. In other cases we had a “judge” agent evaluate the final answers against criteria (accuracy, completeness, etc.) These evaluations not only gave us a score for benchmarking changes, but the judge’s feedback (being an LLM) often highlighted exactly where an agent went off track or missed something. In a sense, we used one AI to tell us how to make another AI better. This kind of meta-prompting and self-correction became a powerful tool in our development cycle, allowing **faster iteration** without full human-in-the-loop at every turn.\n3. **Know when to simplify:** Not every problem needs a fleet of agents. A big lesson was to **use the simplest approach that works**. If a single agent with a smart prompt can handle a task reliably, that’s fine! We reserved multi-agent mode for when there was clear added value e.g., problems requiring parallel exploration, different expertise, or lengthy reasoning that benefits from splitting into parts. This discipline kept our systems leaner and easier to maintain. It also helped us explain the value to stakeholders: we could justify the complexity by pointing to concrete gains (like a task that went from 2 hours by a single high-end model to 10 minutes by a team of agents with better results).\n\n## Conclusion and Next Steps\n\nMulti-agent AI systems have moved from intriguing research demos to practical, production-ready solutions. Our journey involved close collaboration between teams such as those who built open-source frameworks like AutoGen to experiment with multi-agent interactions) and the **Azure AI product teams** (who turned these concepts into the robust Azure AI Foundry Agent Service). Along the way, we learned how to orchestrate LLMs at scale, how to keep them in check, and how to squeeze the most value out of agent collaboration.\n\nToday, Azure AI Foundry’s Agents platform provides a **unified environment to develop, test, and deploy multi-agent systems,** complete with the orchestration, observability, and safety features to make them enterprise-ready. The public preview of features like **Connected Agents** and **Deep Research** (which is essentially an advanced research agent that uses the web + analysis in a multi-step process) is already enabling customers to build “AI teams” that tackle complex workflows. This is just the beginning. We’re continuing to improve the platform with feedback from developers: upcoming releases will further tighten integration with the broader Azure ecosystem (for example, more seamless use of Azure Cognitive Search, Excel as a tool, etc.), expand the library of **pre-built agent templates** in the Agent Catalog (so you can start with a solid example for common scenarios), and introduce more advanced coordination patterns inspired by real-world use cases.\n\nIf you’re an AI engineer or developer eager to explore multi-agent systems, **now is a great time to dive in**. Here are some resources to get you started:\n\n- **[Microsoft AI Agents for Beginners](https://aka.ms/ai-agents-beginners)** - Learn all about AI Agents with this FREE curricula\n- [**Azure AI Foundry Documentation**](https://ai.azure.com/doc/) – Learn more about the Agent Service and how to configure agents, tools, and workflows.\n- [**Microsoft Learn Modules**](https://learn.microsoft.com) – step-by-step tutorial to build a connected multi-agent solution (for example, a ticket triage system) using Azure AI Foundry Agent Service. This will walk you through setting up agents and using the SDK.\n- **Microsoft [MCP for Beginners](https://aka.ms/mcp-for-beginners): Integrating MCP Tools** – Another tutorial focused on the Model Context Protocol, showing how to enable dynamic tool discovery for your agents.\n- [**Azure AI Foundry Agent Catalog**](https://ai.azure.com) – Browse a growing collection of **open-sourced agent examples** contributed by Microsoft and partners, covering scenarios from content compliance to manufacturing optimization. These samples are great starting points to see how multi-agent code is structured in real projects.\n\nMulti-agent systems represent a significant shift in how we conceptualise AI solutions: from single brilliant assistants to **teams of specialised agents working in concert**. The engineering journey hasn’t been easy we navigated challenges in coordination, built new tooling for control, and refined prompts endlessly. But the end result is a new class of AI applications that are more **powerful, resilient, and tunable**. We hope the insights shared here help you in your own journey to build with AI agents. We’re excited to see what you will create with these technologies. As we continue to push the frontier of agentic AI (both in research and in Azure), one thing is clear: **many minds – human or AI – are often better than one**. Happy building!\n\n**Userful References**\n\n[Introducing Multi-Agent Orchestration in Foundry Agent Service – Build ...](https://techcommunity.microsoft.com/blog/azure-ai-foundry-blog/building-a-digital-workforce-with-multi-agents-in-azure-ai-foundry-agent-service/4414671)\n\n[Building a multimodal, multi-agent system using Azure AI Agent Service ...](https://techcommunity.microsoft.com/blog/azure-ai-foundry-blog/building-a-multimodal-multi-agent-system-using-azure-ai-agent-service-and-openai/4396267)\n\n[How we built our multi-agent research system \\ Anthropic](https://www.anthropic.com/engineering/multi-agent-research-system)\n\n[What is Azure AI Foundry Agent Service? - Azure AI Foundry](https://learn.microsoft.com/en-us/azure/ai-foundry/agents/overview)\n\n[Multi-Agent Systems and MCP Tools Integration with Azure AI Foundry ...](https://techcommunity.microsoft.com/blog/educatordeveloperblog/multi-agent-systems-and-mcp-tools-integration-with-azure-ai-foundry/4431823)\n\n[Introducing Deep Research in Azure AI Foundry Agent Service](https://azure.microsoft.com/en-us/blog/introducing-deep-research-in-azure-ai-foundry-agent-service/)\n\n[AutoGen v0.4: Advancing the development of agentic AI systems](https://www.microsoft.com/en-us/research/blog/autogen-v0-4-reimagining-the-foundation-of-agentic-ai-for-scale-extensibility-and-robustness/)",
  "OutputDir": "_community",
  "PubDate": "2025-09-18T07:00:00+00:00",
  "Tags": [],
  "ProcessedDate": "2025-09-18 07:12:42",
  "Title": "Build Multi‑Agent AI Systems with Microsoft",
  "FeedUrl": "https://techcommunity.microsoft.com/t5/s/gxcuf89792/rss/Category?category.id=Azure"
}
