{
  "FeedUrl": "https://www.reddit.com/r/csharp/.rss",
  "Link": "https://www.reddit.com/r/csharp/comments/1mkrlcc/what_is_the_lowest_effort_highest_impact_helper/",
  "Tags": [
    "csharp"
  ],
  "OutputDir": "_community",
  "FeedName": "Reddit CSharp",
  "ProcessedDate": "2025-08-08 15:50:33",
  "Title": "What is the lowest effort, highest impact helper method you've ever written?",
  "FeedLevelAuthor": "C#",
  "EnhancedContent": "I just realized how much easier my code flows both when writing and when reading after I made the following helpers to make string.Join follow the LINQ chaining style when I'm already manipulating lists of text with LINQ:\n\n``` public static class IEnumerableExtensions { public static string StringJoin<T>(this IEnumerable<T> source, string separator) => string.Join(separator, source.Select(item => item?.ToString()));\n\npublic static string StringJoin<T>(this IEnumerable<T> source, char separator) => string.Join(separator, source.Select(item => item?.ToString())); } ```\n\nSo instead of\n\n``` string.Join(\", \", myItems.Select(item => $\"{item.Id} ({item.Name})\")) ```\n\nI get to write\n\n``` myItems.Select(item => $\"{item.Id} ({item.Name})\").StringJoin(\", \") ```\n\nWhich I find much easier to follow since it doesn't mix the \"the first piece of code happens last\" classic method call from-the-inside-out style with the LINQ pipeline \"first piece of code happens first\" style chain-calls. I don't mind either style, but it turns out I very much mind mixing them in the same expression\n\nIt makes me wonder why I didn't make this extension years ago and what other easy wins I might be missing out on.\n\nSo I ask you all: What's your lowest effort, highest impact helper code?\n\nI've written a lot of SQL in my years as a developer, so `foo IN(1, 2, 3)` is a more intuitive way to express the concept to me than `foo == 1 || foo == 2 || foo == 3` or even `new int[] {1,2,3}.Contains(foo)` . Having `foo` being first just makes more sense, so I have a handy `IsIn()` extension method so I can write `foo.IsIn(1, 2, 3)` :\n\n``` public static bool IsIn<T>(this T obj, params T[] values) { foreach (T val in values) { if (val.Equals(obj)) return true; } return false; }\n\npublic static bool IsIn<T>(this T obj, IComparer comparer, params T[] values) { foreach (T val in values) { if (comparer.Compare(obj, val) == 0) return true; } return false; } ```\n\nInstead of comparing `foo` thrice, you could also do `foo is 1 or 2 or 3`\n\nAfter using F#, it's hard for me to live without [`choose`](https://fsharp.github.io/fsharp-core-docs/reference/fsharp-collections-listmodule.html#choose):\n\n``` public static IEnumerable<U> Choose<T, U>(this IEnumerable<T> source, Func<T, U?> selector) where U : struct { foreach (var elem in source) { var projection = selector(elem); if (projection.HasValue) { yield return projection.Value; } } }\n\npublic static IEnumerable<U> Choose<T, U>(this IEnumerable<T> source, Func<T, U?> selector) { foreach (var elem in source) { var projection = selector(elem); if (projection != null) { yield return projection; } } } ```\n\nYou can think of it as\n\n``` .Select(projection) .Where(r => r != null) ```\n\nIf you have an identity function, you can now express filtering nulls out as:\n\n``` .Choose(Id) ```\n\nYou can just use .OfType&lt;U&gt;() with nullable reference types enabled.\n\nSet of helper methods like this one:\n\n``` public static async Task<(T0, T1, T2)> WhenAll<T0, T1, T2>(Task<T0> t0, Task<T1> t1, Task<T2> t2) { await Task.WhenAll(t0, t1, t2); return (t0.Result, t1.Result, t2.Result); } ```\n\nwhich wraps results of multiple calls into a nice tuple:\n\n``` var (result1, result2, result3) = await Common.TaskHelper.WhenAll( DuStuff1Async(), DuStuff2Async(), DuStuff3Async()); ```\n\n`Bool IsNotEmpty(this string text) => ! String.IsNullOrWhiteSpace(text);`\n\nTurns\n\n`if (string.IsNullOrWhiteSpace(text) == false)’\n\nInto\n\n`if (text.IsNotEmpty())`\n\nSuper helpful in predicates too:\n\n`…[LINQ chain that ends up in a string].Where(IsNotEmpty)…..`\n\nCalling a method on something that could be null just looks wrong, even if it works because it's actually a static method call. My mental `NullReferenceException` detector will just keep annoying me as I read through code like this.\n\nI suspect a lot of us have written these:\n\n``` public static bool IsNullOrWhiteSpace(this string str) => string.IsNullOrWhiteSpace(str);\n\npublic static bool IsNotNullOrWhiteSpace(this string str) => !IsNullOrWhiteSpace(str);\n\npublic static bool IsNullOrEmpty(this string str) => string.IsNullOrEmpty(str);\n\npublic static bool IsNotNullOrEmpty(this string str) => !IsNullOrEmpty(str); ```\n\n```\n\npublic static bool ContainsOnlyCharactersIn(this string stringToTest, string validCharacters, CaseSensitivity caseSensitivity = CaseSensitivity.CaseSensitive)\n\npublic static string RemoveCharactersNotIn(this string candidate, string validCharacters)\n\npublic static string CamelCaseToSpaced(this string input)\n\npublic static string PrettyName(this Type type) // Supports generic types\n\npublic static bool IsValidEnumValue&lt;TEnum&gt;(iny candidateValue)\n\npublic static DateTime EndOfPreviousMonth(this DateTime candidateDate)\n\npublic static DateTime FirstOfMonth(this DateTime candidateDate)\n\npublic static DateTime FirstOfNextMonth(this DateTime candidateDate)\n\npublic static DateTime EndOfMonth(this DateTime candidateDate)\n\npublic static DateTime StartOfTheMonth12MonthsAgo(this DateTime candidateDate)\n\n```\n\nQuite an old one. I like my dates with a suffix.\n\n``` /// <summary> /// Return a DateTime string with suffix e.g. \"st\", \"nd\", \"rd\", \"th\" /// So a format \"dd-MMM-yyyy\" could return \"16th-Jan-2014\" /// </summary> public static string ToStringWithSuffix(this DateTime dateTime, string format, string suffixPlaceHolder = \"$\") { if(format.LastIndexOf(\"d\", StringComparison.Ordinal) == -1 || format.Count(x => x == 'd') > 2) { return dateTime.ToString(format); }\n\nstring suffix; switch(dateTime.Day) { case 1: case 21: case 31: suffix = \"st\"; break; case 2: case 22: suffix = \"nd\"; break; case 3: case 23: suffix = \"rd\"; break; default: suffix = \"th\"; break; }\n\nvar formatWithSuffix = format.Insert(format.LastIndexOf(\"d\", StringComparison.InvariantCultureIgnoreCase) + 1, suffixPlaceHolder); var date = dateTime.ToString(formatWithSuffix);\n\nreturn date.Replace(suffixPlaceHolder, suffix); } ```",
  "Author": "zigs",
  "PubDate": "2025-08-08T10:28:57+00:00",
  "Description": "I just realized how much easier my code flows both when writing and when reading after I made the following helpers to make string.Join follow the LINQ chaining style when I'm already manipulating lists of text with LINQ:\n\n``` public static class IEnumerableExtensions { public static string StringJoin(this IEnumerable source, string separator) => string.Join(separator, source.Select(item => item?.ToString())); public static string StringJoin(this IEnumerable source, char separator) => string.Join(separator, source.Select(item => item?.ToString())); } ```\n\nSo instead of\n\n``` string.Join(\", \", myItems.Select(item => $\"{item.Id} ({item.Name})\")) ```\n\nI get to write\n\n``` myItems.Select(item => $\"{item.Id} ({item.Name})\").StringJoin(\", \") ```\n\nWhich I find much easier to follow since it doesn't mix the \"the first piece of code happens last\" classic method call from-the-inside-out style with the LINQ pipeline \"first piece of code happens first\" style chain-calls. I don't mind either style, but it turns out I very much mind mixing them in the same expression\n\nIt makes me wonder why I didn't make this extension years ago and what other easy wins I might be missing out on.\n\nSo I ask you all: What's your lowest effort, highest impact helper code?"
}
