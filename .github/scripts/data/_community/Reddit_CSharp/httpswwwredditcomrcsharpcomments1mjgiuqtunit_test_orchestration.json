{
  "FeedUrl": "https://www.reddit.com/r/csharp/.rss",
  "Link": "https://www.reddit.com/r/csharp/comments/1mjgiuq/tunit_test_orchestration/",
  "Tags": [
    "csharp"
  ],
  "OutputDir": "_community",
  "FeedName": "Reddit CSharp",
  "ProcessedDate": "2025-08-08 15:50:34",
  "Title": "TUnit: Test Orchestration",
  "FeedLevelAuthor": "C#",
  "EnhancedContent": "Hey all - Been a while. I'd like to share with you a new feature of TUnit that (I think) helps you write tests where complex setup or system orchestration is necessary.\n\nIf you picture spinning up a WebApp that uses a Docker Network, Redis, a Message Bus, a SQL Database, and perhaps you'd like to spin up extra Docker containers that provide you a UI to inspect these resources too. And you want to do all this in memory so your tests don't need to connect to any actual third parties (i.e. TestContainers).\n\nWell, TUnit now supports nested property injection via data sources. This means that properties created via a data source attribute, can also have properties injected into their instances too, and this can happen so on and so on recursively. Combine this with ClassDataSource(Shared = PerTestSession), and we get smart object re-use for those expensive to initialise items. TUnit intelligently works out which services to initialise first, based on what they've been injected into, and will work its way up the chain to ensure all properties are initialised in a sensible order where one can depend on, and use details from another. This means you have to do less boiler-plate code managing the set up and tear down of your tests, and more time focusing on the test themselves. It also helps keep code following that single responsibility principle. Behaviour of your dependencies remains isolated to their own classes.\n\nHere is an example of how this works: [https://tunit.dev/docs/examples/complex-test-infrastructure](https://tunit.dev/docs/examples/complex-test-infrastructure)\n\nLet me know your thoughts please and any feedback is welcome!\n\nNice. If I have 3 dependecies in test containers, lets say: sql server, redis, rabbitmq, will these start in parallel, and injected when all ready using PerTestSession, or are they sequential?\n\nProperties on a class at the same level will be initialised in parallel as they won't be seen as depending on one another :)\n\nLooks great.\n\nIm so glad that theres a testing framework thats actually tackling harder issues and being very customisable.\n\nHopefuly the other frameworks will try to move fast now theres a front sprinter.\n\nYou're doing super good work Tom :)\n\n[u/thomhurst](/user/thomhurst/) great work, looks awesome. I wanted to try out TUnit in a new project of mine but the ReSharper does not detect TUnit tests. Do I need to configure something within R# to make it work? Running tests via the VS Text Explorer or dotnet tests works.\n\nNot sure about resharper but they're recognised in Rider so I would've thought it'd be similar. Check the options for \"testing platform\". If you find anything, make sure it's enabled.",
  "Author": "thomhurst",
  "PubDate": "2025-08-06T20:59:12+00:00",
  "Description": "Hey all - Been a while. I'd like to share with you a new feature of TUnit that (I think) helps you write tests where complex setup or system orchestration is necessary.\n\nIf you picture spinning up a WebApp that uses a Docker Network, Redis, a Message Bus, a SQL Database, and perhaps you'd like to spin up extra Docker containers that provide you a UI to inspect these resources too. And you want to do all this in memory so your tests don't need to connect to any actual third parties (i.e. TestContainers).\n\nWell, TUnit now supports nested property injection via data sources. This means that properties created via a data source attribute, can also have properties injected into their instances too, and this can happen so on and so on recursively. Combine this with ClassDataSource(Shared = PerTestSession), and we get smart object re-use for those expensive to initialise items. TUnit intelligently works out which services to initialise first, based on what they've been injected into, and will work its way up the chain to ensure all properties are initialised in a sensible order where one can depend on, and use details from another. This means you have to do less boiler-plate code managing the set up and tear down of your tests, and more time focusing on the test themselves. It also helps keep code following that single responsibility principle. Behaviour of your dependencies remains isolated to their own classes.\n\nHere is an example of how this works: [https://tunit.dev/docs/examples/complex-test-infrastructure](https://tunit.dev/docs/examples/complex-test-infrastructure)\n\nLet me know your thoughts please and any feedback is welcome!"
}
