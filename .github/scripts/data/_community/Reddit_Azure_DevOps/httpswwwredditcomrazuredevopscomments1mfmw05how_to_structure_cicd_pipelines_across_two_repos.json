{
  "Title": "How to structure CI/CD pipelines across two repos (Azure DevOps, ACR, AKS, Helm)",
  "FeedName": "Reddit Azure DevOps",
  "OutputDir": "_community",
  "Tags": [
    "azuredevops"
  ],
  "ProcessedDate": "2025-08-05 17:37:33",
  "Description": "Hey everyone, I’m currently setting up CI/CD for a project using the following stack:\n\n- Azure DevOps (Repos + Pipelines)\n- Azure Container Registry (ACR)\n- Azure Kubernetes Service (AKS)\n- Helm charts (stored in ACR as OCI artifacts)\n\nHere’s the structure I currently have:\n\n- **repoA**: contains the service source code. It has a pipeline that builds a Docker image and pushes it to ACR with a tag like `image:date-buildNumber`\n.\n- **repoB**: a mono-repo for all Helm charts. It has pipelines that version and package the charts and push them to ACR as Helm OCI charts.\n\nNow I’m figuring out the best way to handle **release/deployment pipelines**.\n\n# Option 1:\n\nPut the release pipeline in **repoA**, where:\n\n- The pipeline builds the Docker image and pushes to ACR.\n- Then, after a manual approval step, it:\n- Pulls the latest version of the Helm chart from ACR.\n- Runs `helm upgrade`\non AKS, passing in `--set image.tag=xxx` .\n\n# Option 2:\n\nPut the release pipeline in **repoB**, where:\n\n- It handles the `helm upgrade`\nlogic.\n- But then the question is: how does **repoB** know which Docker image tag was just built in **repoA**?\n- How can we build a fully automated CI/CD flow where a developer pushes code to **repoA**, triggering a build and then deployment through staging/prod, while keeping release logic in **repoB**?\n\nRepos are already split like this (repoA for code, repoB for charts), so I'm mainly looking for best practices on **how to wire up release/deployment pipelines** in this setup to avoid future pain.\n\nAnyone dealt with a similar pattern or has thoughts on the cleanest approach?\n\nThanks!",
  "Author": "machosalade",
  "Link": "https://www.reddit.com/r/azuredevops/comments/1mfmw05/how_to_structure_cicd_pipelines_across_two_repos/",
  "PubDate": "2025-08-02T10:03:38+00:00",
  "EnhancedContent": "Hey everyone, I’m currently setting up CI/CD for a project using the following stack:\n\n- Azure DevOps (Repos + Pipelines)\n- Azure Container Registry (ACR)\n- Azure Kubernetes Service (AKS)\n- Helm charts (stored in ACR as OCI artifacts)\n\nHere’s the structure I currently have:\n\n- **repoA**: contains the service source code. It has a pipeline that builds a Docker image and pushes it to ACR with a tag like `image:date-buildNumber`\n.\n- **repoB**: a mono-repo for all Helm charts. It has pipelines that version and package the charts and push them to ACR as Helm OCI charts.\n\nNow I’m figuring out the best way to handle **release/deployment pipelines**.\n\n# Option 1:\n\nPut the release pipeline in **repoA**, where:\n\n- The pipeline builds the Docker image and pushes to ACR.\n- Then, after a manual approval step, it:\n\n- Pulls the latest version of the Helm chart from ACR.\n- Runs `helm upgrade`\non AKS, passing in `--set image.tag=xxx` .\n\n# Option 2:\n\nPut the release pipeline in **repoB**, where:\n\n- It handles the `helm upgrade`\nlogic.\n- But then the question is: how does **repoB** know which Docker image tag was just built in **repoA**?\n- How can we build a fully automated CI/CD flow where a developer pushes code to **repoA**, triggering a build and then deployment through staging/prod, while keeping release logic in **repoB**?\n\nRepos are already split like this (repoA for code, repoB for charts), so I'm mainly looking for best practices on **how to wire up release/deployment pipelines** in this setup to avoid future pain.\n\nAnyone dealt with a similar pattern or has thoughts on the cleanest approach?\n\nThanks!\n\nStill need help?\n\nYes\n\nI'm still a beginner in Azure DevOps, but GitHub Actions has [repositiory_dispatch](https://docs.github.com/en/actions/reference/workflows-and-actions/events-that-trigger-workflows#repository_dispatch)so an action can be triggered by an external source like another GitHub Action workflow.\n\nI know it doesn't directly help, but hopefully it gives an idea or something. Good luck!\n\nA pipeline in Repo B which triggers on pipeline A.\n\nYou can use the buildid variable which triggered this pipeline (or do some magic with artifacts with info in build) and execute correct logic in Repo B.\n\nReally like the seperation of concerns.\n\nTo respect the separation of concern you could checkout the repoB after the docker image push in repoA. In repoA pipeline you will update the values yaml of repoB which triggers if the commit is pushed. Something like this:\n\n```\n# azure-pipelines.yml in repoA\n\ntrigger:\n- main\n\n# 1. Declare the Helm charts repository as a pipeline resource\nresources: repositories:\n- repository: HelmChartsRepo # A friendly name/alias for repoB\ntype: git name: YourProject/repoB # The full name: <ProjectName>/<RepoName> ref: main # The branch to check out\n\npool: vmImage: 'ubuntu-latest'\n\nvariables: imageName: 'my-app' imageTag: '$(Build.BuildNumber)'\n\nsteps:\n- task: Docker@2\ndisplayName: 'Build and Push Docker Image to ACR' inputs: command: 'buildAndPush' repository: '$(imageName)' dockerfile: '**/Dockerfile' containerRegistry: 'YourAcrServiceConnection' tags: '$(imageTag)'\n\n- checkout: self\npersistCredentials: true\n\n- checkout: HelmChartsRepo\npersistCredentials: true\n\n# 3. Update the values file in the checked-out Helm repo\n- bash: |\n# Configure Git identity\ngit config --global user.email \"pipeline@azuredevops.com\" git config --global user.name \"Azure DevOps Pipeline\"\n\n# Navigate to the checked-out repoB directory.\n# Its name matches the repository name ('repoB').\ncd $(Pipeline.Workspace)/repoB\n\necho \"Updating Helm values in $(pwd)\"\n\n# Install yq for robust YAML manipulation\nsudo wget https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -O /usr/bin/yq && sudo chmod +x /usr/bin/yq\n\n# Update the image tag\nyq -i '.image.tag = \"$(imageTag)\"' ./charts/my-app/values.yaml\n\n# Commit and push the change.\n# The credentials from the checkout step are automatically used.\ngit add . git commit -m \"Update image tag for $(imageName) to $(imageTag) [skip ci]\" git push displayName: 'Update and Push Helm Values' ```\n\nPipelines committing changes to repos is a huge anti-pattern. Creating and pushing tags is one thing, but actually making changes? Never.",
  "FeedLevelAuthor": "Azure DevOps",
  "FeedUrl": "https://www.reddit.com/r/azuredevops/.rss"
}
