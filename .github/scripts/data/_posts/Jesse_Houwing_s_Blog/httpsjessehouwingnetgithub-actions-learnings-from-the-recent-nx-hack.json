{
  "FeedName": "Jesse Houwing's Blog",
  "FeedLevelAuthor": "Scrum Bug",
  "ProcessedDate": "2025-09-02 21:09:29",
  "PubDate": "2025-09-02T21:05:46+00:00",
  "EnhancedContent": "You may have seen recent reporting around the compromise of the `nx` project. A malicious version of their package was published to npmjs which subsequently published GitHub tokens, crypto wallets and other sensitive materials of 1000s of users.\n\n[Malicious versions of Nx and some supporting plugins were published\n## Summary Malicious versions of the \\[`nx` package\\](https://www.npmjs.com/package/nx), as well as some supporting plugin packages, were published to npm, containing code that scans the file systâ€¦\n!\\[\\](https://jessehouwing.net/content/images/icon/pinned-octocat-093da3e6fa40.svg)GitHubnrwl !\\[\\](https://jessehouwing.net/content/images/thumbnail/GHSA-cxm3-wv7p-598c)](https://github.com/nrwl/nx/security/advisories/GHSA-cxm3-wv7p-598c?ref=jessehouwing.net) The maintainers of the project have spelled out exactly how the project was compromised. Yet, it doesn't tell exactly what they did to prevent the same issue from happening in the future. Or how *you* can protect yourself from these attack vectors.\n\nI'll walk through the attack chain and will explain what options are available to you to prevent these things from happening.\n\n## Understanding the vulnerable workflow\n\nLet's look at the main cause of this hack. [The introduction of a new GitHub Actions Workflow that had the `pull_request_target` trigger enabled](https://github.com/nrwl/nx/pull/32458/files?ref=jessehouwing.net). This trigger is dangerous, since it signals to GitHub that the workflow is safe and has access to secrets. By default only to secrets referenced in the workflow itself, but that *always* includes the built-in GitHub Actions token.\n\n```yaml on: pull_request_target: types: [opened, edited, synchronize, reopened] ```\n\nThe second stage of the hack was possible due to script injection in that same workflow. This allowed the injection of arbitrary code in the pipeline through the title of the pull request:\n\n```yaml\n- name: Create PR message file\nrun: | mkdir -p /tmp cat > /tmp/pr-message.txt << 'EOF' ${{ github.event.pull_request.title }}\n\n${{ github.event.pull_request.body }} EOF ```\n\nThe pull request's title and body are written to the script prior to execution, so including `EOF` in any of them would be interpreted as arbitrary bash commands. And adding`$(...)` would also lead to code execution prior to writing the contents to `pr-message.txt` .\n\nSince the workflow can how execute arbitrary code, and the GitHub Hosted Runner runs with sudo by default, [it would also be possible to write a memory dump of the runner process to gain access to the Runner's GitHub Token](https://karimrahal.com/2023/01/05/github-actions-leaking-secrets/?ref=jessehouwing.net).\n\nWith this token, it is possible to either write to an unprotected branch on the repo, or to run other workflows. [The `publish.yml` workflow had the ability to be triggered manually](https://github.com/nrwl/nx/blob/400e3003d72acd75522468d58fdc160e76e13a68/.github/workflows/publish.yml?ref=jessehouwing.net#L8-L13) in the `master` branch. This means that it can be triggered against any branch in the project repo and will use the contents of the workflow in that specific branch. Because the npm token is stored as a repository secret, it will be available to all workflows in the repository, regardless of the branch it's created in.\n\nIn this case I would have used the GitHub Token to:\n\n- Create a new branch in the project repository\n- Overwrite the publish.yml in the new branch to send the npm token to a webserver I control\n- Trigger the publish workflow against my branch\n- Delete the branch\n- Optionally delete the workflow run\n\nWithout overwriting the publish.yaml, changes in any of the build scripts executed in the publish job would have had access to the token, since it was added as a job level environment variable.\n\n```yaml publish: if: ${{ github.repository_owner == 'nrwl' }} env: GH_TOKEN: ${{ github.token }} NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }} ```\n\nIn the disclosure the project mentions that they have branch rulesets in place to protect their master branch.\n\n## Understanding the vulnerable (human) process\n\nThis attack couldn't have happened if the workflow above wouldn't have been added, or if it had used the standard `pull_request` trigger instead. If you read the documentation for `pull_request_target` , it calls out that its dangerous.\n\nIt looks like this workflow was generated by AI:\n\n```plaintext ðŸ¤– Generated with Claude Code ```\n\nAnd that none of the humans in the loop were aware of the dangers. Nor was there any tooling in place to scan the workflows and to alert them of the potential problems.\n\nOnce the attacker figured out the attack chain, it would have been possible to execute the attack in seconds, with only minimal observable traces. And because all actions would be performed by the `github-actions[bot]` user, none of the changes would stand out and any commits would even be considered verified if done correctly.\n\nIt's trivially easy to setup a repo in which to test this attack without actually having to interact with the nx repo.\n\nBecause the NPM token was stored as a repository secret, access to it would not require an explicit approval. This is against best practices for GitHub Actions in public repos. For example:\n\n```yaml\n- uses: actions/checkout@v4\n```\n\nIn this case as far as I can tell none of the referenced actions have a known vulnerability, but this leaves the project open to attacks similar to the tj-actions/changed-files hack from a few months back:\n\n[CVE-2025-30066 - How Malicious Commits in tj-actions/changed-files Leaked GitHub Secrets In March 2025, the popular GitHub Action named tj-actions/changed-files faced a major supply chain security incident. This vulnerability, tracked as CVE-2025-30066, allowed malicious actors to expose GitHub secrets by secretly modifying the actionâ€™s code and stealing secrets from build logs. In this post, weâ€™ll break down what !\\[\\](https://jessehouwing.net/content/images/icon/favicon-1.ico)CVE CyberSecurity Database NewsPoster !\\[\\](https://jessehouwing.net/content/images/thumbnail/CVE-2025-30066.png)](https://www.cve.news/cve-2025-30066/?ref=jessehouwing.net)\n## Remediation\n\nLet's break down the remediations that can be put in place (and which ones are default for new organizations):\n\n1. Change the default permissions for GitHub Actions to read-only.\n2. Set workflow permissions at the job level\n3. Require Approval for running fork pull request workflows from contributors\n4. Do not rely on `pull_request_target`\n.\n5. Do not use `workflow_dispatch`\nor `repository _dispatch` triggers in workflows that have access to critical secrets.\n6. Store critical secrets in environment secrets, instead of repository secrets.\n7. Pass secrets only to the steps that need them\n8. Pin all actions to their sha.\n9. Enable GitHub Advanced Security Code Scanning for GitHub Actions and add Branch Ruleset.\n10. Enable Dependabot for GitHub Actions to automatically update action references to the latest version.\n11. Consider 3rd party security hardening tools like StepSecurity's Harden Runner.\n\n### Change the default permissions for GitHub Actions to read-only\n\nWhen GitHub Actions was first released, the default permissions were set to write-all. When GitHub changed the default permission to read-all later, they did not retroactively reset the permission for existing accounts and organizations.\n\nGitHub Enterprise Owners and GitHub Organization Owners can enforce a default permission of read-all through the Settings:\n\n![](https://jessehouwing.net/content/images/2025/09/image.png)Set the default workflow permissions to: Read repository contents and package permissions. This will break all workflows that do not explicitly declare their required permissions in case they need more than read-all.\n\nWhile you're at it, you should also turn off **Allow GitHub Actions to create and approve pull requests**.\n\n### Set workflow permissions at the job level\n\nA workflow can declare its required permissions at the workflow or at the job level. For best security, it's recommended to deny all permissions at the workflow level and explicitly declare permissions for each job specifically:\n\n```yaml\n# Opt out of any default permissions\npermissions: {}\n\njobs: build:\n# explicitly request permissions\npermissions: contents: read\n\ndeploy: permissions: contents: read packages: write ```\n\n### Require approval for running fork pull request workflows from contributors\n\nThis is a controversial one. As it adds quite a bit of overhead to project teams receiving many 3rd party contributions. But it might have been enough for a maintainer to detect the script injection attack that was used to exfiltrate the GitHub Actions token.\n\nGitHub Enterprise Owner, Organization Owners and Repository Admins can set a policy to require approval before running any GitHub Actions workflow.\n\n![](https://jessehouwing.net/content/images/2025/09/image-1.png)Require approval for all external contributors While it might feel tempting to set this policy to any of the lighter settings, there are already known cases where a person appears helpful by fixing a few typos. They'll be considered trusted after that.\n\nSetting this policy will require a maintainer to review the Pull Request and trigger the workflows each time an external contributor pushes new commits.\n\n### Do not rely on `pull_request_target`\n\nThe `pull_request_target` is inherently dangerous. It opens you up to all kinds of additional attack paths and very few people are completely aware of the implications.\n\n**My recommendation is to never rely on the `pull_request_target` trigger.**\n\nIn the enterprises I control we've added a Custom Pattern for Secret Scanning to block all commits that contain `pull_request_target` :\n\n![](https://jessehouwing.net/content/images/2025/09/image-14.png)Define a custom pattern to block pushes And we enabled this pattern for Push protection:\n\n![](https://jessehouwing.net/content/images/2025/09/image-15.png)Enable custom pattern for push protection\n### Do not use `workflow_dispatch`\nor `repository_dispatch` triggers in workflows that have access to critical secrets.\n\nSince `workflow_dispatch` and `repository_dispatch` allow an attacker to control the branch against the workflow will run, it can be used to exfiltrate repository secrets if the attacker has write access to any other branch on the repository.\n\nThe only way to protect secrets from this attack path, is to store them as an environment secret.\n\n### Store critical secrets in environment secrets, instead of repository secrets.\n\nSecrets defined at the repository level are accessible to all workflows. There is no way to limit access to repository level secrets.\n\nIn order to protect a critical secret, such as the NPM token used to publish your package, it should be defined as an Environment Secret.\n\nIn the Environment's policy you can then set a branch policy to limit which branches have access to the secret.\n\n![](https://jessehouwing.net/content/images/2025/09/image-9.png)Set specific branches to limit access to critical secrets. Optionally add **Required Reviewers** to prevent access to the secrets without manual approval:\n\n![](https://jessehouwing.net/content/images/2025/09/image-3.png)Add Required Reviewers to prevent access to the secrets without manual approval Then update the workflow to reference the environment when defining the job:\n\n```yaml jobs: deploy: environment: public steps: uses: actions/deploy@sha with: npm_token: ${{ secrets.NPM_TOKEN }} ```\n\n### Pass secrets only to the steps that need them\n\nIn the nx repository [the `NPM_AUTH_TOKEN` is defined at the job level](https://github.com/nrwl/nx/blob/400e3003d72acd75522468d58fdc160e76e13a68/.github/workflows/publish.yml?ref=jessehouwing.net#L433-L436):\n\n```yaml publish: env:\n# DO NOT USE THIS!\nGH_TOKEN: ${{ github.token }} NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }} steps:\n- ...\n```\n\nThis makes the secrets available to all steps in the workflow. If the attacker can take control of any of the code executed in these steps, they would be able to exfiltrate the secret.\n\nIn this case the job also calls `pnpm build:wasm` which adds a number of additional places to hide exfiltration code.\n\nIt's better to explicitly pass the secrets only to the steps that need them:\n\n``` publish: env:\n# NO SECRETS SET HERE\nsteps:\n- ...\n- ...\n- name: Publish\nenv: VERSION: ${{ needs.resolve-required-data.outputs.version }} DRY_RUN: ${{ needs.resolve-required-data.outputs.dry_run_flag }} PUBLISH_BRANCH: ${{ needs.resolve-required-data.outputs.publish_branch }} NX_VERBOSE_LOGGING: true NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }} run: | echo \"\"\n# Create and check out the publish branch\ngit checkout -b $PUBLISH_BRANCH echo \"\" echo \"Version set to: $VERSION\" echo \"DRY_RUN set to: $DRY_RUN\" echo \"\" pnpm nx-release --local=false $VERSION $DRY_RUN ```\n\n### Pin all Pactions to their sha.\n\nThe attack on nx doesn't seem to have relied on this attack vector, but the recent attack on tj-actions/changed-files has shown again that it's dangerous to rely on only the tag to reference actions of 3rd parties.\n\nGitHub recommends that you always reference actions you do not control using their explicit commit sha.\n\nFor example:\n\n```yaml\n- uses: actions/checkout@v4\n```\n\nShould have used:\n\n```yaml\n- uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5\n```\n\n[There is now a policy which requires all actions to be pinned to their commit sha](https://github.blog/changelog/2025-08-15-github-actions-policy-now-supports-blocking-and-sha-pinning-actions/?ref=jessehouwing.net):\n\n![](https://jessehouwing.net/content/images/2025/09/image-10.png)Require actions to be pinned to a full-length commit SHA **Because this is a new policy, GitHub Administrators must explicitly opt-in to this policy.**\n\nThere are several tools available to perform the pinning on your behalf:\n\n- [gh-pin-actions extension for the GitHub CLI.](https://github.com/amenocal/gh-pin-actions?ref=jessehouwing.net)\n- [RenovateBot - Digest Pinning and Updating](https://docs.renovatebot.com/modules/manager/github-actions/?ref=jessehouwing.net#digest-pinning-and-updating)\n\n### Enable GitHub Advanced Security Code Scanning for GitHub Actions and add Branch Ruleset.\n\nThe script injection vulnerability at the root of this attack would have been detected by GitHub Advanced Security Code Scanning for GitHub Actions.\n\nGitHub Advanced Security is free for all public repos, so there is not really a good reason not to enable it.\n\nBecause support for GitHub Actions was added recently, GitHub Repository Owners must explicitly enable GitHub Actions in the Code Scanning configuration:\n\n![](https://jessehouwing.net/content/images/2025/09/image-11.png) Or add `actions` to the list of supported languages in their workflow:\n\n```yaml jobs: analyze: name: Analyze (${{ matrix.language }}) runs-on: ${{ (matrix.language == 'swift' && 'macos-latest') || 'ubuntu-latest' }} permissions: security-events: write packages: read actions: read contents: read\n\nstrategy: fail-fast: false matrix: include:\n# Make sure Actions is added to the list of langages:\n- language: actions\nbuild-mode: none ```\n\nThis will detect a number of GitHub Actions vulnerabilities, including:\n\n- Script Injection\n- Unsafe checkout\n\nIn order to prevent workflows with these vulnerabilities to enter the repository, add a branch ruleset that requires the Code QL workflow to succeed:\n\n![](https://jessehouwing.net/content/images/2025/09/image-12.png) And require Code Scanning results:\n\n![](https://jessehouwing.net/content/images/2025/09/image-13.png)\n### Enable Dependabot for GitHub Actions to automatically update action references to the latest version.\n\nTo automatically keep your referenced GitHub Actions up to date, especially when you are pinning to the full commit sha, you can enable Dependabot to automatically create a pull request whenever an action is updated.\n\nTo enable Dependabot for GitHub Actions, explicitly add `github-actions` to your `.github/dependabot.yml` :\n\n```yaml version: 2 updates:\n- package-ecosystem: \"github-actions\"\ndirectory: \"/\" # Location of package manifests schedule: interval: \"weekly\"\n\n```\n\nTo reduce maintainer burden, [GitHub Actions can be used to automate updates completely](https://docs.github.com/en/code-security/dependabot/working-with-dependabot/automating-dependabot-with-github-actions?ref=jessehouwing.net).\n\n### Consider 3rd party security hardening tools like StepSecurity's Harden Runner.\n\nAll of the above remediations are built-in features of the GitHub platform.\n\nThere are 3rd party solutions available to further secure GitHub Actions. Of those StepSecurity's Harden Runner is probably the best-known option. You can add harden-runner to any workflow by adding a single step to your workflow jobs:\n\n``` steps:\n- name: Harden Runner\nuses: step-security/harden-runner@c6295a65d1254861815972266d5933fd6e532bdf # v2.11.1 with: egress-policy: audit ```\n\nThe Community version of Harden runner offers the following protections to all of workflows:\n\nhttps://github.com/step-security/harden-runner?ref=jessehouwing.net#community-free\n\n- **CI/CD-Aware Event Correlation:**Â Each outbound network connection, file operation, and process execution is mapped to the exact step, job, and workflow where it occurs.\n- **Automated Baseline Creation:**Â Harden-Runner builds a baseline for each job based on past outbound network connections.\n- **Anomaly Detection:**Â Once the baseline is created, any future outbound calls not in the baseline trigger a detection.\n- **Block Network Egress Traffic with Domain Allowlist:**Â Optionally use the automatically created baseline to control outbound network traffic by specifying allowed domains, preventing unauthorized data exfiltration.\n- **Detect Modification of Source Code:**Â Monitor and alert on unauthorized changes to your source code during the CI/CD pipeline.\n\n## Conclusion\n\nGitHub offers many features to protect your project against attacks that try to abuse GitHub Actions. Unfortunately, many of these features require explicit opt-in or configuration.\n\nThis should not be an excuse to leave your open-source projects open to attack.",
  "Tags": [
    "GitHub",
    "GitHub Actions",
    "Security"
  ],
  "Link": "https://jessehouwing.net/github-actions-learnings-from-the-recent-nx-hack/",
  "FeedUrl": "https://jessehouwing.net/rss/",
  "OutputDir": "_posts",
  "Title": "GitHub Actions learnings from the recent nx hack",
  "Description": "You may have seen recent reporting around the compromise of the nx project. A malicious version of their package was published to npmjs which subsequently published GitHub tokens, crypto wallets and other sensitive materials of 1000s of users.",
  "Author": "Jesse Houwing"
}
