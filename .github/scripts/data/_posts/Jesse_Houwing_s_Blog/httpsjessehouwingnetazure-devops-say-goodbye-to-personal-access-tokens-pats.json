{
  "ProcessedDate": "2025-08-05 09:49:32",
  "FeedUrl": "https://jessehouwing.net/rss/",
  "EnhancedContent": "> Michael, author of some of my favorite Azure DevOps Extensions, reached out on the [Azure DevOps Club slack channel](https://www.azuredevops.club/?ref=jessehouwing.net) for help. He wanted to automatically rotate Personal Access Tokens to integrate with Azure DevOps, which lead to a quest to completely eradicate Personal Access Tokens altogether. After sharing my work to make the Azure DevOps Extension Tasks work without Personal Access Tokens, Michael went to work. I've asked him to share his results in this guest blog, since I feel they're useful for anyone doing automation against Azure DevOps. As you can see he agreed!\n>\n> Jesse Houwing\n\n## PATs, PATs and more PATs - our 5 scenarios we used PATs for\n\nBuilding [Bravo Notes](https://www.bravonotes.com/?ref=jessehouwing.net) here at Agile Extensions we are extensively using the Azure DevOps REST APIs in many ways.\n\nAnd I'm not talking about the API calls the Bravo Notes extension makes at runtime e.g. to load work items, publish wiki pages etc.\n\nWe use the Azure DevOps REST APIs in these **5 scenarios** as well:\n\n1. publish multiple versions of the Bravo Notes extension for development, staging and production via the marketplace APIs (in Azure Pipelines)\n2. retrieve marketplace event data for installs/uninstalls and more on a schedule (in Azure Functions app)\n3. run integration tests for many Bravo Notes components that need Azure DevOps APIs (in Azure Pipelines)\n4. run e2e tests of the main Bravo Notes app outside of Azure DevOps (in Azure Pipelines)\n5. run integration and e2e tests locally\n\nIn the past we used personal access tokens (PATs) for all of those scenarios.\n\nFor years our process was:\n\n- watch for notifications that a PAT was about to expire\n- be annoyed that this manual regular chore was on your plate (AGAIN!)\n- regenerate PAT in Azure DevOps\n- update pipeline variables and secrets with the new PAT\n- feel bad and wonder why there wasn't a more elegant solution\n- be done and push responsibility for improving this to future Michael\n\n## PAT REST APIs to the rescue?\n\nA while I ago a new set of APIs got introduced to manage PATs. That sounded intriguing and a few weeks back I reached out to the community to ask for guidance on how to automatically renew and manage PATs and do away with the manual process entirely.\n\n> >\n> ðŸ¤” Me: Is there a good resource online on how to transition from manually rotating PATs to rotating PATs automatically (a pipeline using PAT REST API, KeyVault)?\n> >\n\nThankfully Jesse pointed me to a better (the right) way:\n\n> >\n> ðŸ’¡ **Don't use PATs** but use an Azure Service principle with workload Federation.\n> >\n\nWhen you are reading this on his blog you probably already know that Jesse is one of those people who uses the internet for what it was build for:\n\n**He shares what he has learned (often the hard way) to make the lives of all of us easier.** In this case in form of [this blog post on how to publish marketplace extensions without using PATs](https://jessehouwing.net/publish-azure-devops-extensions-using-workload-identity-oidc/).\n\nI was convinced already that using PATs was less than ideal.\n\nBut at this point I was still hesitant about whether this approach could help us do away with PATs entirely. After all we had 5 different scenarios.\n\nThere was only one way to find out so we started by tackling the scenario that Jesse wrote about in his blog post.\n\n## Scenario 1: Publish marketplace extensions without a PAT\n\nThe blog post didn't disappoint as it contained all the pieces to help us **publish marketplace extensions without a PAT** - whohoo ðŸ¥³!\n\nBelow are the steps we needed to take. Please refer to Jesse's blog post for all the datails. Our mileage varied a bit as the ARM service connection now uses an \"App registration\" in Azure instead of a \"Service Principal\".\n\nThe process is the still the same in general, though.\n\n1. Create the ARM service connection (the UX changed a bit since Jesse's blog post)\n- Choose \"Azure Resource Manager\" Connection\n- Identity Type: \"App registration (automatic)\"\n- Credential: \"Workload identity federation\"\n- the rest is about the same\n2. Add the App registration/service principal as a user in Azure DevOps\n3. Extract the Azure DevOps Identity Id from the Profile API via a pipeline task\n4. Use that Id to add the App registration as a member to the marketplace publisher\n5. Update our pipeline to use the ARM service connection\n\nNote that we could use the newest version of the marketplace extension tasks (v5) that allows you to publish using the ARM service connection directly.\n\nSo there is no need to fetch an access token and overwrite the marketplace service connection credentials anymore. After changing our pipelines we were able to delete our old \"Visual Studio Marketplace\" service connection.\n\n```yaml\n- task: PublishAzureDevOpsExtension@5\ndisplayName: 'Publish Extension' inputs: connectTo: 'AzureRM' connectedServiceNameAzureRM: 'marketplace-service-connection' fileType: vsix vsixFile: '$(Pipeline.Workspace)/vsix/production.vsix' updateTasksVersion: false\n\n```\n\nAnd that was it. The pipeline worked as before and we could revoke the PAT for publishing extensions to the marketplace.\n\nOf course we didn't want to stop here and tackle the next scenario and remove one more PAT.\n\n## Scenario 2: Call Azure DevOps APIs from a Azure Function app\n\nWe maintain an Azure Function app to query data about install and uninstall events and pull statistics from the marketplace. Authentication works using - what else could it be - a PAT.\n\nIn Azure Functions of course we don't have the magic of service connections that we can utilize in Azure Pipelines.\n\nAfter initially failing to find the code to use for our NodeJS based function app, searching for the magic GUID `499b84ac-1321-427f-aa17-267ca6975798` that represents Azure DevOps led me right to what we needed to acquire an access token inside the Function app.\n\nAfter finding the right way to acquire the access token, we got this solved in 2 simple steps:\n\n1. Add the Azure Function app as a user in Azure DevOps\n2. Use the code below to acquire an access token and authorize Azure DevOps REST API calls\n\n```Typescript const { ManagedIdentityCredential } = require(\"@azure/identity\");\n\nasync function getMarketplaceAccessToken() { const credential = new ManagedIdentityCredential({ // `AZURE_CLIENT_ID` points to the App registration created via the ARM service connection clientId: process.env.AZURE_CLIENT_ID, }); const tokenResponse = await credential.getToken( \"499b84ac-1321-427f-aa17-267ca6975798/.default\", { tenantId: process.env.AZURE_TENANT_ID, } );\n\nreturn tokenResponse.token; }\n\n```\n\nThere was no stopping now - but still 3 PATs to go.\n\n## Scenario 3: Run intergration tests in Azure Pipelines\n\nNext up was our integration testing pipeline tasks that run integration tests using NodeJS and `jest` . Until now a PAT was used from a secret pipeline variable. Another one that we didn't want to renew manually every few months.\n\nAs we already acquired an access token in a pipeline via an ARM service connection in scenario 1, this dind't seem to difficult to pull off.\n\nFollowing the least priviledge principle we didn't want to use the same service principal from scenario 1. This would have given it access to the marketplace AND Azure DevOps resources that were needed for our integration tests.\n\nLuckily you can create as many ARM service connections as you want and so we did. To use the newly created App registration/service principal, the pipeline task from Jesse's blog post to retrieve an access token that we dind't need for scenario 1 now came in handy again:\n\n```yaml\n- task: AzureCLI@2\ndisplayName: 'Acquire token for integration testing' inputs: azureSubscription: 'azure-devops-integration-testing-connection' scriptType: 'pscore' scriptLocation: 'inlineScript' useGlobalConfig: true inlineScript: | $accessToken = az account get-access-token --resource 499b84ac-1321-427f-aa17-267ca6975798 --query \"accessToken\" --output tsv write-host \"##vso[task.setsecret]$accessToken\" write-host \"##vso[task.setvariable variable=SECRET_INGETRATION_TESTING_TOKEN;issecret=true]$accessToken\"\n\n```\n\nNow we could use the the token for subsequent integration test tasks. Yay only 2 PATs to go!\n\n### Scenario 4: Run e2e tests in Azure Pipelines (against external Azure DevOps organization)\n\nWhile this scenario seemed to be exactly the same es scenario 3 at first, we had an issue here that stopped us in our tracks at first.\n\nThe e2e tests called APIs in a separate Azure DevOps org that only existed for testing.\n\n`[OrgA Pipeline] ---- REST API call ----> [OrgB Work item API]`\n\nThe solution was too simple to be true.\n\nWe were just able to add the App registration/service principal as a user in OrgB and give it access to the resources needed for the e2e tests.\n\nAnother PAT down!\n\n### Scenario 5: Running integration and e2e tests locally\n\nThis might be my least favorite solution so far, but it was simple and did the trick for now.\n\nWe use `jest` to run our tests and in our npm scripts we just stuck in a Azure Developer CLI call to log in prior to starting the test script.\n\nIn our code to set up API authentication we now run some special code to acquire the access token, again with the azure identity SDK.\n\nSo\n\n1. Modify testing script to log in - `azd auth login && npx jest --config jest.integration.config.js\"`\n2. Retrieve the access token from the Azure Developer Cli:\n\n```typescript let token = process.env.SECRET_INGETRATION_TESTING_TOKEN; if (!token && !process.env.CI) { const credential = new AzureDeveloperCliCredential({ tenantId: process.env.AZURE_TENANT_ID, }); const tokenResult = await credential.getToken( '499b84ac-1321-427f-aa17-267ca6975798/.default', { tenantId: process.env.AZURE_TENANT_ID, }, ); token = tokenResult.token; }\n\n```\n\n(Would love to hear about a better solution to securly get an access token for running scripts locally in a development environment.)\n\nAll 5 scenarios done! The champaign ðŸ¾ was almost open when I revoked all PATs that were not needed anymore when I discovered that I had forgotten one last PAT.\n\n### Bonus scenario: the last token - the renovate pipline\n\nWe use renovate to update dependencies and automatically create pull requests in yet another pipeline. (You can thank Jesse for his work online here as well).\n\nImmideately I had a bad feeling and I thought that renovate would only accept PATs as it only accepts `RENOVATE_TOKEN` as a means to authenticate. The [docs](https://docs.renovatebot.com/modules/platform/azure/?ref=jessehouwing.net) make it look that way for sure.\n\nLooking at the code (yay open source) I could see that renovate automatically detects whether the token is a PAT or a OAuth token and chooses the Authorization header (`Basic` or `Bearer` ) accordingly.\n\nSo we could just use the same AzureCLI pipeline task as in scenarios 3 to acquire and 4 and be done!\n\nP.S.: Talking to Jesse about that he mentioned that Azure DevOps now accepts OAuth tokens when using the `Basic` authentication scheme as well which is great in my opinion.\n\n## Wrapping up\n\nJust reading all the terms involved:\n\n- ARM service connection\n- Open Id Connect\n- Workload Identity federation\n- service principal\n- App registration\n\nmade the whole process seem daunting to me.\n\nBut in the end we got rid of all our PATs within a couple of hours.\n\nPersonal access tokens are great to quickly test an API call, authenticate a throw-away script where you don't have other means of authentication ready.\n\nHowever for the long term you really don't want to have to create PATs and renew them until the end of time.\n\nThanks again to Jesse and Joost Voskuil for their help.\n\n> >\n> In case you are facing your own challenge with Azure DevOps or GitHub, don't hesitate to join the [Azure DevOps Club](https://www.azuredevops.club/?ref=jessehouwing.net).\n> >",
  "FeedLevelAuthor": "Scrum Bug",
  "OutputDir": "_posts",
  "Tags": [
    "Azure",
    "Azure DevOps",
    "Security"
  ],
  "Author": "Michael Thomsen",
  "FeedName": "Jesse Houwing's Blog",
  "Link": "https://jessehouwing.net/azure-devops-say-goodbye-to-personal-access-tokens-pats/",
  "Description": "We got rid of all Azure DevOps PAT usage and so should you.\n\nðŸ“¢ Big shout out to Jesse! Without his blog post and direct help, I was probably still renewing expired PATs manually.\n\nBut let's start at the beginning.",
  "Title": "Say goodbye to your Personal Access Tokens",
  "PubDate": "2025-03-04T12:30:04+00:00"
}
