{
  "Tags": [
    "WPF"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Rick Strahl's Web Log",
  "ProcessedDate": "2025-08-05 14:25:42",
  "FeedUrl": "https://feeds.feedburner.com/rickstrahl",
  "Title": "Getting the Current TabItem when the Tab is not selected in WPF",
  "Description": "There's no direct support in WPF to find the control that the mouse is hovering over in Items controls like the TabControl, so if you need to bring up context sensitive information like a context menu or tooltip it takes a little extra effort to get the correct item to work with in this case ContextMenuOpening.",
  "Link": "https://weblog.west-wind.com/posts/2024/Nov/08/Getting-the-Current-TabItem-when-the-Tab-is-not-selected-in-WPF",
  "FeedName": "Rick Strahl's Blog",
  "Author": "Rick Strahl",
  "EnhancedContent": "![](/images/HeroImages/RickHero14.jpg) ![](/images/rick175x175.jpg)\n\nhttps://twitter.com/rickstrahl https://feeds.feedburner.com/rickstrahl\n\n[Contact](https://west-wind.com/contact/) Â  â€¢ [Articles](https://west-wind.com/articles.aspx) Â  â€¢ [Products](https://store.west-wind.com) Â  â€¢ [Support](https://support.west-wind.com) Â  â€¢ [Advertise](https://weblog.west-wind.com/advertise)\n\nSponsored by:\n\n[!\\[\\](https://markdownmonster.west-wind.com/Images/MarkdownMonster_Icon_256.png) **Markdown Monster**](https://markdownmonster.west-wind.com?utm_campaign=westwind-weblog-sponsored)\n- The Markdown Editor for Windows\nhttps://markdownmonster.west-wind.com?utm_campaign=westwind-weblog-sponsored\n\n[advertise here](/advertise)\n\nShare on:\n\nhttps://twitter.com/intent/tweet?url=https://weblog.west-wind.com/posts/2024/Nov/08/Getting-the-Current-TabItem-when-the-Tab-is-not-selected-in-WPF&amp;text=Getting%20the%20Current%20TabItem%20when%20the%20Tab%20is%20not%20selected%20in%20WPF&amp;via=RickStrahl https://www.facebook.com/sharer/sharer.php?u=https://weblog.west-wind.com/posts/2024/Nov/08/Getting-the-Current-TabItem-when-the-Tab-is-not-selected-in-WPF&amp;t=Getting%20the%20Current%20TabItem%20when%20the%20Tab%20is%20not%20selected%20in%20WPF http://www.reddit.com/submit?url=https://weblog.west-wind.com/posts/2024/Nov/08/Getting-the-Current-TabItem-when-the-Tab-is-not-selected-in-WPF&amp;title=Getting%20the%20Current%20TabItem%20when%20the%20Tab%20is%20not%20selected%20in%20WPF\n\nNovember 08, 2024 â€¢ from Hood River, Oregon\n\nâ€¢ Â  3 comments\n\n:P\n\nOn this page:\n\n![Banner](https://weblog.west-wind.com/images/2024/Getting-the-Current-TabItem-when-the-Tab-is-not-selected-in-WPF/Banner.jpg)\n\nThis is a quick reminder to self on how to retrieve a TabItem from a WPF TabControl **when the tab is not currently selected** because I run into this quite frequently and the flail around trying to remember how to get non-selected items on any list control including tab controls.\n\n## Hovered Tab vs Selected Tab\n\nThe issue is that WPF doesn't have a direct mechanism to retrieve a TabItem that the cursor is over if it's not actually selected. Hovering is not selecting and so `SelectedItem` and the 'Hovered Item' are two very different thing and WPF is adverse to the latter ðŸ˜„ WPF only lets you retrieve an item directly via the various `Selected...` properties like `SelectedItem` , `SelectedValue` , `SelectedIndex` etc. all of which only work off the item that is selected... which may be different from the item that the mouse is currently hovering over.\n\nThe most common scenarios for retrieving the hovered item are:\n\n- Popping up a context menu\n- Showing a Tooltip\n\nBoth of these are context sensitive operations and that's exactly why they need more than what the `Selected...` properties can provide.\n\nHovered selections are not that common, but when you need it you need it!\n\n### An Example of Hovered Tabs\n\nHere's an example that demonstrates this exact setup in [Markdown Monster](https://markdownmonster.west-wind.com/) for manipulating Sidebar panels on the (icon only) tab control on the left:\n\n![Markdown Monster Sidebar Tab Context Menu](https://raw.githubusercontent.com/RickStrahl/ImageDrop/refs/heads/master/MarkdownMonster/LeftSidebarSplitPanels.gif)\n\n**Figure 1** - A Sidebar of tabs, that allows selection of tabs that are not selected to show an appropriate context menu\n\nThe icon tabs on the left can be accessed with the context menu even when the tab is not active. You can see that the right tab is selected as the context menu shows the tab name and icon along with the context options. I've run into similar scenarios with context menus, and tooltips that need to pop up over non active icons - the idea of being able to select the tab\n\n## ContextMenu Opening Event Handling\n\nTab Controls are a pain in the ass in WPF because they have a very peculiar way of what is considered a tab. For some operations only the header is considered as a tab, but for others the entire tab including it's body/content size is considered.\n\nSo in the above scenario I need to capture the currently hovered tab. I started with just using the selected item:\n\n```csharp private void LeftSidebar_ContextMenuOpening(object sender, ContextMenuEventArgs e) { var src = sender as TabControl var tab = src?.SelectedItem;\n\nif (tab == null) return; }\n\n```\n\nFor many situations this is probably all that you need. If you are working only off selected tabs then this code works totally fine.\n\nIn the case of my Sidebar example though the above would cause a problem: If I hover over the favorite tab when the Folder Browser is actually active, the context menu that pops up shows the Folder Browser as the context item - Not what I want.\n\n### Fix it: OringalSource and Parent Hierarchy\n\nSo, to find a non-active tab item is a bit less obvious. You can start by looking at the original source element that the context menu event is initiated from using `e.OriginalSource` . You then walk up the parent hierarchy to check if you have a `TabItem` (a `MetroTabItem` in my case) in the list of parents.\n\nHere's what this looks like:\n\n```csharp private async void LeftSidebar_ContextMenuOpening(object sender, ContextMenuEventArgs e) { var src = e.OriginalSource as FrameworkElement; if (src == null) return;\n\nvar tab = WindowUtilities.FindAncestor<MetroTabItem>(src); if (tab == null) return;\n\n// now pop up the menu with the TabItem as context var context = new LeftSidebarContextMenu(tab); await context.OpenContextMenu(); e.Handled = true; }\n\n```\n\nThe key here is a small utility function `WindowUtilities.FindAncestor<T>()` which is used to walk up the control hierarchy to see if there's a matching control of the provided generic type - in this case a `MetroTabItem` (a TabItem subclass from [MahApps.Metro](https://mahapps.com/)).\n\nHere's what that method looks like:\n\n```csharp /// <summary> /// Finds a type of element in the parent chain of an element /// </summary> /// <typeparam name=\"T\">Type of Element to find</typeparam> /// <param name=\"currentControl\">control to start from</param> /// <returns></returns> public static T FindAncestor<T>(DependencyObject currentControl) where T : DependencyObject { do { if (currentControl is T) return (T) currentControl;\n\ncurrentControl = VisualTreeHelper.GetParent(currentControl); } while (currentControl != null);\n\nreturn null; }\n\n```\n\n`FindAncestor<T>` is quite useful for many similar operations - you can use a similar approach to find non-selected TreeView or ListView items for example.\n\n## Summary\n\nIt's a simple and pretty old trick, but it's one of those things that I at least always forget and curse when I need to get access to the actual item, and not the selected item. I'm always naively thinking there should be a native way on control to get this, but... no!\n\nThe trick of looking at the original source control and then walking up the tree, looking for specific types of controls is useful here for find the TabItem, but it's also useful for most other Items Controls. For me at least, this is not the thing that I reach for and so this post serves as a reminder and placeholder so I can quickly jog my memory in the future. If you found your way here via search, it probably saved you a few cycles as well...\n\n![](https://markdownmonster.west-wind.com/favicon.png) this post created and published with the [Markdown Monster Editor](https://markdownmonster.west-wind.com)\n\n### Other Posts you might also like\n\n- [Taking the new Chromium WebView2 Control for a Spin in .NET - Part 1](https://weblog.west-wind.com/posts/2021/Jan/14/Taking-the-new-Chromium-WebView2-Control-for-a-Spin-in-NET-Part-1)\n- [Async and Async Void Event Handling in WPF](https://weblog.west-wind.com/posts/2022/Apr/22/Async-and-Async-Void-Event-Handling-in-WPF)\n- [Centering a WPF TreeViewItem in the TreeView ScrollViewer](https://weblog.west-wind.com/posts/2025/Jul/15/Centering-a-WPF-TreeViewItem-in-the-TreeView-ScrollViewer)\n- [Chromium WebView2 Control and .NET to JavaScript Interop - Part 2](https://weblog.west-wind.com/posts/2021/Jan/26/Chromium-WebView2-Control-and-NET-to-JavaScript-Interop-Part-2)\n\nShare on:\n\nhttps://twitter.com/intent/tweet?url=https://weblog.west-wind.com/posts/2024/Nov/08/Getting-the-Current-TabItem-when-the-Tab-is-not-selected-in-WPF&amp;text=Getting%20the%20Current%20TabItem%20when%20the%20Tab%20is%20not%20selected%20in%20WPF&amp;via=RickStrahl\n\nhttps://www.facebook.com/sharer/sharer.php?u=https://weblog.west-wind.com/posts/2024/Nov/08/Getting-the-Current-TabItem-when-the-Tab-is-not-selected-in-WPF&amp;t=Getting%20the%20Current%20TabItem%20when%20the%20Tab%20is%20not%20selected%20in%20WPF http://www.reddit.com/submit?url=https://weblog.west-wind.com/posts/2024/Nov/08/Getting-the-Current-TabItem-when-the-Tab-is-not-selected-in-WPF&amp;title=Getting%20the%20Current%20TabItem%20when%20the%20Tab%20is%20not%20selected%20in%20WPF\n\n![Make Donation](/images/donation.png \"Find this content useful? Consider making a small donation.\")\n\nIs this content useful to you? **Consider making a small donation** to show your support.\n\nPosted in **[WPF](/ShowPosts.aspx?Category=WPF)**\n\n## The Voices of Reason\n\n![](https://www.gravatar.com/avatar.php?gravatar_id=23448e78d187fba56d8bc263081ac5d8&size=100&rating=R)\n\n[Stephen Cleary](https://stephencleary.com/)\n\nNovember 09, 2024\n\n### # re: Getting the Current TabItem when the Tab is not selected in WPF\n\nAh, the old \"navigate the WPF tree\" technique. One thing I've found useful here is to define enumerable primitives for different \"axes\" (visual/logical tree, ancestors/descendants, whatever) and then you can query the WPF tree using LINQ:\n\n```C public static IEnumerable<DependencyObject> SelfAndAncestors(this DependencyObject currentControl) { while (currentControl != null) { yield return currentControl; currentControl = VisualTreeHelper.GetParent(currentControl); } }\n\n```\n\nOnce you have simple helper methods like the above, then you can query it in any way you want:\n\n```C var tab = src.SelfAndAncestors().OfType<MetroTabItem>().FirstOrDefault();\n\n```\n\nThat way you have an \"ancestor axis\" that you can traverse, and the consuming code is more explicit - it's clear that it's looking for the first `MetroTabItem` and returns `null` if none is found (without having to check the XML documentation for `FindAncestor` ).\n\n![](https://www.gravatar.com/avatar.php?gravatar_id=beb7fdd4bcd15e35472a96ab8182f034&size=100&rating=R)\n\n[Rick Strahl](https://west-wind.com)\n\nNovember 09, 2024\n\n### # re: Getting the Current TabItem when the Tab is not selected in WPF\n\n@Steven - oh I like that! Adding to my helper library! Thanks!\n\n![](https://www.gravatar.com/avatar.php?gravatar_id=54ff33cd55c914ed17e76906a464b6c3&size=100&rating=R)\n\nFelix Strauss\n\nNovember 11, 2024\n\n### # re: Getting the Current TabItem when the Tab is not selected in WPF\n\nInteresting topic! I am experimenting with this too. I have two WPF TabControls next to each other (like a split view). My goal is to know which tab is currently active. SelectedItem does not change if the user switches to the tab in the other control. A tab is considered 'active' if a child control (eg. TextBox) has user focus.\n\nMaybe you have an idea how I could solve this problem?",
  "PubDate": "2024-11-09T09:10:44+00:00"
}
