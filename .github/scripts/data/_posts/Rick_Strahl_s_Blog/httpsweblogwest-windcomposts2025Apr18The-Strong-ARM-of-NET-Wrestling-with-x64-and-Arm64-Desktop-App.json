{
  "Tags": [
    ".NET",
    "Windows"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Rick Strahl's Web Log",
  "ProcessedDate": "2025-08-05 14:25:42",
  "FeedUrl": "https://feeds.feedburner.com/rickstrahl",
  "Title": "The Strong ARM of .NET: Wrestling with x64 and Arm64 Desktop App Deployment",
  "Description": ".NET works great for cross-platform development making it easy to build apps that are cross-platform and cross-architecture specifically for x64 and Arm64. However, building a distributable application that can install and run out of box on both of these platforms, that's a bit more effort. In this post I discuss some of the gotchas and how to work around them to distribute apps that run out of the gate on both platforms.",
  "Link": "https://weblog.west-wind.com/posts/2025/Apr/18/The-Strong-ARM-of-NET-Wrestling-with-x64-and-Arm64-Desktop-App-Deployment",
  "FeedName": "Rick Strahl's Blog",
  "Author": "Rick Strahl",
  "EnhancedContent": "![](/images/HeroImages/RickHero11.jpg) ![](/images/rick175x175.jpg)\n\nhttps://twitter.com/rickstrahl https://feeds.feedburner.com/rickstrahl\n\n[Contact](https://west-wind.com/contact/) ¬† ‚Ä¢ [Articles](https://west-wind.com/articles.aspx) ¬† ‚Ä¢ [Products](https://store.west-wind.com) ¬† ‚Ä¢ [Support](https://support.west-wind.com) ¬† ‚Ä¢ [Advertise](https://weblog.west-wind.com/advertise)\n\nSponsored by:\n\n[!\\[\\](https://markdownmonster.west-wind.com/Images/MarkdownMonster_Icon_256.png) **Markdown Monster**](https://markdownmonster.west-wind.com?utm_campaign=westwind-weblog-sponsored)\n- The Markdown Editor for Windows\nhttps://markdownmonster.west-wind.com?utm_campaign=westwind-weblog-sponsored\n\n[advertise here](/advertise)\n\nShare on:\n\nhttps://twitter.com/intent/tweet?url=https://weblog.west-wind.com/posts/2025/Apr/18/The-Strong-ARM-of-NET-Wrestling-with-x64-and-Arm64-Desktop-App-Deployment&amp;text=The%20Strong%20ARM%20of%20.NET:%20Wrestling%20with%20x64%20and%20Arm64%20Desktop%20App%20Deployment&amp;via=RickStrahl https://www.facebook.com/sharer/sharer.php?u=https://weblog.west-wind.com/posts/2025/Apr/18/The-Strong-ARM-of-NET-Wrestling-with-x64-and-Arm64-Desktop-App-Deployment&amp;t=The%20Strong%20ARM%20of%20.NET:%20Wrestling%20with%20x64%20and%20Arm64%20Desktop%20App%20Deployment http://www.reddit.com/submit?url=https://weblog.west-wind.com/posts/2025/Apr/18/The-Strong-ARM-of-NET-Wrestling-with-x64-and-Arm64-Desktop-App-Deployment&amp;title=The%20Strong%20ARM%20of%20.NET:%20Wrestling%20with%20x64%20and%20Arm64%20Desktop%20App%20Deployment\n\nApril 18, 2025 ‚Ä¢ from Maui, Hawaii\n\n‚Ä¢ ¬† 1 comment\n\n:P\n\nOn this page:\n\n[Edit this Post](https://github.com/RickStrahl/BlogPosts/blob/master/2025-04/TheStrongArmOfDotNetWrestlingWithX64andArm64/TheStrongArmOfDotNetWrestlingWithX64andArm64.md)\n\n![The Strong Arm Of The Law Banner](https://weblog.west-wind.com/images/2025/TheStrongArmOfDotNetWrestlingWithX64andArm64/TheStrongArmOfTheLawBanner.jpg) *[ùÖ† The Strong Arm Of the Law - Saxon](https://open.spotify.com/track/4xwKkJTov5AaJqDmZVSzXn?si=5905b0df8acd42ac)*\n\nIf you follow me at all, you've probably heard me talk about some of my travails related to making a .NET Windows Desktop application ‚Äî [Markdown Monster](https://markdownmonster.west-wind.com) ‚Äî run well on ARM-based systems. Since it is a .NET application, it should be very simple: .NET is cross-platform and **cross-architecture**, and ARM64 is among the supported targets for .NET binaries. So it should be straightforward to compile an application and have it work both on Windows x64 and Arm64, right?\n\nWell... it works, but it's not anywhere as simple as I expected it to be to have the app run on both Windows x64 and Arm64 **natively**!\n\nI'm coming at this specifically from the perspective of a Windows Desktop application distributed to many customers of all types with both x64 and Arm64 machines. And let's say that the road to getting this to work smoothly was a bumpy one, due to a bunch of weird and very unexpected behaviors in the runtimes and the compilation process.\n\nIn this post, I'll discuss some of the things I ran into and yhe workarounds I ended up implementing to create a deployable application that works out of the box on both Win-x64 and Win-arm64.\n\n[!\\[\\](/images/sponsors/banner-example.png?v=1.2)](https://markdownmonster.west-wind.com?ut=weblog)\n\n## The Good News: Cross-Compilation is Seamless\n\nThe good news is that in order to compile your application and have it work on ARM, very little is required: as long as you compile your application for `AnyCPU` , the compiled IL runtime code that is generated works on any platform and architecture, assuming you stick to code that works on the target platforms. In this case it's a Windows WPF application running on Windows, and there's technically no difference in API surface between x64 and Arm64. Since .NET compiles into IL byte code that is JIT compiled and executed at runtime, the platform is largely inconsequential. This is true in this scenario with x64 and ARM64 but it often also applies to other platforms like Mac and Linux.\n\nNote that I'm talking about JIT compilation - AOT native compilation is different and doesn't work like this as that generates platform specific native binaries for everything. With AOT completely separate binaries are required for each platform and architecture. In this post I'm not discussing AOT, and discuss standard JIT runtime compiled code. This is what the cross-platform functionality of .NET is all about.\n\nAnd it works surprisingly well without much initial effort... as long as you have the right launcher to start your application!\n\n## The Bad News: Platform Specific Launchers\n\nFor many common .NET application scenarios - specifically Web and Server apps - launchers are not important: If you're building a Web app deployed to a server, you don't need a dedicated launcher and you can use the `dotnet` command to launch an application instead. The `dotnet` command automatically figures out what runtime the compiled application is running under and asking for and loads that specific runtime. You can also explicitly specify a runtime to use.\n\nFor server applications `dotnet` is perfect - you're not distributing the application, and you typically have some sort of script or directive or an AppHost in the case of IIS, that is launching the application in the first place.\n\nHowever, if you build a desktop application you generally want to use a platform specific launcher specific to your application, a binary that can be properly signed and won't trigger a potential Anti-Virus software or Windows' built in Run protection warning, as a generic tool like `dotnet` would. Desktop apps that are installed on client machines typically need an explicit launching binary to work as expected.\n\n### Running with the dotnet Command: It just works!\n\nIf you're not building desktop deployed applications, the easiest way to ensure your app can launch properly on any platform is to use the .NET runtime's built-in `dotnet` command to launch any application without a platform-specific binary loader (i.e. a Windows EXE). Instead, you can use `dotnet <dllName>` :\n\n```ps dotnet `LiveReloadServer.dll`\n\n```\n\n**This works on any platform‚Äîfrom Windows to Mac to Linux, from x64, x86, ARM64, ARM.**\n\nThe `dotnet` launcher determines the current platform and, based on that, runs the appropriate shared runtime. It all works as you would expect it to.\n\n> >\n> ##### Tip: `dotnet`\n> to run Apps Outside of their Published Platform\n> > >\n> If you have a .NET application that is published for a specific platform and is built with .NET, you can potentially get that app to run on another platform assuming the app is compatible with platform.\n> > >\n> For example I have a CLI utility called [LiveReloadServer](https://github.com/RickStrahl/LiveReloadServer) which has a Windows x64 distribution and is distributed for a shared runtime installation. The compiled EXE won't run on Arm64 (currently) or on a Mac or Linux, but I can run `dotnet LiveReloadServer.dll`\n> and **it will then work on these platforms** as long as the application is using a shared runtime.\n> >\n\nLikewise, tools shipped via `dotnet tool` automatically launch the platform-appropriate target and just work on any platform.\n\n> >\n> `dotnet tool`\n> is a great and underappreciated solution for publishing cross-platform .NET applications because it automatically works across platforms and architectures without having to worry about runtime installs or platform specific dependencies.\n> >\n\nThis fact makes `dotnet tool` a great distribution mechanism for small tools and CLI helpers ‚Äî especially for developers.\n\nUnderstand though that there are dependencies for `dotnet tool` and `dotnet <yourApp.dll>` :\n\n- `dotnet tool`\nrequires that the .NET SDK is installed\n- `dotnet <yourApp.dll>`\nrequires only the .NET Shared Runtime\n\n### Built Platform Executables: Not so much!\n\nIf you build a Windows application targeted for `AnyCPU` you are effectively building an application (the DLL) that works on any CPU supported by .NET Runtimes, but the **launcher generated is built for a specific platform and architecture**. If you're building on an x64 system and you don't explicitly specify a `<PlatformTarget></PlatformTarget>` or you use `AnyCPU` (which is the default) the main `EXE` generated uses the current platform default. So if I built on Windows x64 I get x64 Launcher. Building on an arm64 machine I get Arm64 Launcher exe.\n\nThe .NET launcher EXE points at your main application DLL that needs to be launched. From what I can tell it doesn't care about specific versions, it only cares about the filename which has to match your compiled assembly name. The EXE and DLL generally have the same name, but if you rename the EXE, it still has to find the old assembly name DLL.\n\nThe launcher is not .NET code - it's a native binary, and it acts as a .NET AppHost that loads the .NET runtime. Because it's a native EXE it has a regular Windows PE header that identifies which platform it can run on. For x64 that means it can run on x64 and also on ARM. But on ARM it runs as x64 in Emulation mode which works fine but is slower than native Arm64 execution. If you build an Arm64 exe, it'll only run on an Arm64 installation. Trying to run it on x64 results in a hard fail:\n\n![Cant Run On This Platform](https://weblog.west-wind.com/images/2025/TheStrongArmOfDotNetWrestlingWithX64andArm64/CantRunOnThisPlatform.png)\n\n**Figure 1** - An ARM compiled application launcher on an x64 system fails to run.\n\nAn x64 compiled launcher on an arm64 machine works, but the application then runs in x64 emulation mode:\n\n![Runningx64 On Arm64](https://weblog.west-wind.com/images/2025/TheStrongArmOfDotNetWrestlingWithX64andArm64/Runningx64OnArm64.png)\n\n**Figure 2** - Running an x64 app on ARM results in the app running in x64 Emulation mode which is slow.\n\nx64 emulation on ARM works and it's how many application run on ARM. It works and performance is not terrible but it's noticably slower than running in native Arm64 mode. More on that later.\n\nIn both cases on x64 and arm64 running:\n\n```ps dotnet markdownmonster.dll\n\n```\n\nruns the native versions regardless where the launcher was compiled. In other words:\n\n> >\n> Using `dotnet <yourApp.dll>`\n> the application is perfectly compatible for native x64 and arm64 and works fine on either platform, but the launcher EXEs are not!\n> >\n\n## Fixing the Launcher Problem\n\nBottom line: If you want to have an application that works natively both on Windows x64 and Arm64 with an EXE launcher, **you need to have two separate executables**.\n\nFor Markdown Monster I settled on the following approach that I'll discuss here:\n\n- Build the app two times - once for arm64 and once for x64\n- Rename the arm64 exe to `MarkdownMonsterArm64.exe`\n- At install time, check for platform\n- If arm64 swap the main Exe for the Arm64 exe\n\nLet's go through it...\n\n### Building for x64 and arm64 Targets\n\nAt minimum we need two executable launchers: One for the x64 and one for arm64. This can be accomplished by building the project with multiple targets - twice:\n\nHere are the relevant project file directives:\n\n```xml <Project> <PropertyGroup> <PlatformTarget>AnyCPU</PlatformTarget> <!-- <PlatformTarget>arm64</PlatformTarget>--> <Version>3.7.3</Version> ... </PropertyGroup>\n\n<PropertyGroup Condition=\"'$(PlatformTarget)' == 'arm64'\"> <!-- Optional: Use a base version You only need this if you don't compile for ARM every time --> <Version>3.7</Version> </PropertyGroup>\n\n...\n\n<Target Name=\"PostBuildArm\" AfterTargets=\"PostBuildEvent\" Condition=\"'$(PlatformTarget)' == 'arm64'\"> <Message Text=\"Executing PostBuildArm target\" Importance=\"high\" /> <Exec Command=\"copy &quot;$(TargetDir)MarkdownMonster.exe&quot; &quot;$(ProjectDir)MarkdownMonsterArm64.exe&quot;\" /> </Target>\n\n<None Update=\"MarkdownMonsterArm64.exe\"> <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory> </None> </Project>\n\n```\n\nThe idea is that the `PlatformTarget` is changed between `AnyCPU` and `arm64` for the appropriate build. Building this way produces identical output EXCEPT for the launcher EXE which are customized for the specified platform.\n\nThe `<Target>` at the bottom then copies the Arm64 exe to `MarkdownMonsterArm64.exe` . I actually copy this into my **project folder** rather than the build folder and set the file to **Copy if newer** which copies the file into the output directory on build. This may seem odd, but the reason for this is so I don't have to build the arm64 exe every time - I only build when I want to update the version number.\n\n> >\n> Remember the launcher doesn't depend on specific versions of the DLL, so you can build your launcher once and continue to use it with newer versions application. I like to update the launcher with each minor version which doesn't change very frequently. There are probably 20 release builds within a minor version, and I only have to rev the minor version once for all those builds.\n> >\n\nTo build the two exe's you have a couple of options:\n\n1. Build the project twice for each platform with multiple `dotnet build`\ncalls\n2. Build once every minor (or major) version\n\n#### Always Build two Exe's\n\nTo build every time for both targets run dotnet publish/build twice:\n\n```ps\n# as part of build script\ndotnet publish ..\\markdownmonster -o .\\publish -c Release /p:PlatformTarget=arm64 dotnet publish ..\\markdownmonster -o .\\publish -c Release /p:PlatformTarget=AnyCPU\n\n```\n\nMake sure you build `arm64` first, since the last build will produce the final main EXE ie. `MarkdownMonster.exe` . Since the `arm64` only works on Arm64 you'll want to use the `AnyCPU` for the final build to ensure even if you forget to build and swap the Arm launcher the app will still run.\n\nYou want that to be the AnyCPU version so even if the files don't get swapped properly the app will run on all platforms.\n\n#### Only Build For Minor/Major Version Updates\n\nCompiling twice can be slow, so it might prudent to not recompile all the time.\n\nAs mentioned previously, the Launcher is tied to the main DLL only by its assembly name, so there's no need to keep rebuilding the Arm64 launcher - you can reuse the same launcher over many versions. The main reason to recompile the launcher would only be update the version number.\n\nI like to rev the Launcher on minor versions and for this scenario I just manually compile once with the `<PlatformTarget>arm64</PlatformTarget>` set, then set back to `AnyCPU` .\n\nI then copy the EXE into my project directory and set it to `Copy only if newer` so it always gets copied into the output folder.\n\n### Swap the Arm64 Exe During Install\n\nThe output folder after a build then looks like this:\n\n![Launcher Exes In Distribution Folder](https://weblog.west-wind.com/images/2025/TheStrongArmOfDotNetWrestlingWithX64andArm64/LauncherExesInDistributionFolder.png)\n\n**Figure 3** - Distributing an application with both x64 and Arm64 Exes is required to run natively on either platform\n\nYou might be Ok with having these two separate EXEs and running the appropriate one on each platform. Perhaps you can set up your Installer to create the appropriate shortcuts to link to the appropriate EXE.\n\nFor Markdown Monster this isn't the right choice, because people can and often do launch Markdown Monster from the command line. There's also an intermediary launcher that is used for this as well and having to add additional code in there to determine which EXE to run would increase complexity unnecessarily.\n\nSo I chose to swap the EXEs during the Installation process on ARM swapping out the Main EXE with the Arm64 one.\n\n[!\\[\\](/images/sponsors/Mandibles-Display.jpg)](https://amzn.to/41ZVqrT)\n\n### Installer Helper\n\nTo do this I have an [Installer helper that I already use during installation to install the .NET Runtime](https://weblog.west-wind.com/posts/2023/Jun/21/Getting-the-NET-Desktop-Runtime-Installed-with-a-Custom-Runtime-Checker-and-Installer) if it's not present. There's [a GitHub repo](https://github.com/RickStrahl/DotnetDesktopRuntimeInstaller) with a template project that can you can customized or integrated to use as your own install helper.\n\nThe helper is a tiny .NET Framework Console application that is called from the installer with a `-runtimeinstall` command line switch. The helper is a .NET framework app, because its main function is to check if the .NET Core Runtime that the app requires is installed. The .NET Core runtime may not be available yet, hence the `net472` target on the helper.\n\nIn this same Console app I added another operation that can hot-swap the Main EXE for the Arm64 EXE. Here's what that code looks like:\n\n```csharp [DllImport(\"kernel32.dll\", SetLastError = true)] static extern bool IsWow64Process2(IntPtr hProcess, out ushort processMachine, out ushort nativeMachine); const ushort IMAGE_FILE_MACHINE_ARM64 = 0xAA64;\n\ninternal static bool IsArm64 { get { if (IsWow64Process2(Process.GetCurrentProcess().Handle, out ushort procArch, out ushort osArch)) { if (osArch == IMAGE_FILE_MACHINE_ARM64) return true; } return false;\n\n// !!! This doesn't work on .NET 4.x //return RuntimeInformation.OSArchitecture == Architecture.Arm64; } } /// <summary> /// Hotswap the Arm64 executable if running on Arm64. /// </summary> public static void InstallArm64ExeIfRequired() { ConsoleWrite(\"Installing Arm64 Exe...\"); if (!IsArm64) { ConsoleWrite(\"Not running on Arm64.\", color: ConsoleColor.DarkYellow); return; }\n\nvar armExe = Path.Combine(Program.InstallDirectory, \"MarkdownMonsterArm64.exe\"); var mainExe = Path.Combine(Program.InstallDirectory, \"MarkdownMonster.exe\"); var x64ExeRenamed = mainExe.Replace(\".exe\", \"x64.exe\");\n\nif (!File.Exists(armExe)) { ConsoleWrite(\"Arm64 Executable doesn't exist: \" + armExe, color: ConsoleColor.DarkYellow); return; }\n\ntry {\n\nif (!File.Exists(x64ExeRenamed)) File.Copy(mainExe, x64ExeRenamed, true); File.Copy(armExe, mainExe, true);\n\nConsoleWrite(\"Main Exe replaced with Arm64 Exe...\", color: ConsoleColor: ConsoleColor.Green); } catch(Exception ex) { ConsoleWrite(\"Error copying Arm64 Executable: \" + ex.Message, ConsoleColor: ConsoleColor.Red); } }\n\n```\n\nNote that I had to resort to calling a native function to reliably detect the Arm64 OS in a .NET 4.72 executable running on Arm. Neither `RuntimeInformation.OSArchitecture` :\n\n```csharp return RuntimeInformation.OSArchitecture == Architecture.Arm64; // false even on arm64\n\n```\n\nnor the `PROCESSOR_ARCHITECTURE` environment variables are returning the correct state:\n\n![Net Framework And Process Architecture Is Wrong](https://weblog.west-wind.com/images/2025/TheStrongArmOfDotNetWrestlingWithX64andArm64/NetFrameworkAndProcessArchitectureIsWrong.png)\n\n**Figure 4** - The `PROCESSOR_ARCHITECTURE` Environment variable doesn't give you what you would expect: It's **Process specific** not machine specific.\n\nApparently this returns a **Process specific value** and that value is fixed up for .NET Framework executables. IOW, it's not a global OS value which is confusing as hell - especially for the `OsArchitecture` value.\n\nThe native call to `IsWow64Process2()` works reliably however even though it's a little more effort.\n\nSo with the above code in an exe called `mm.exe` that is activated with `-runtimeinstall` parameters I then call this from [Inno Setup](https://jrsoftware.org/isinfo.php) installer script:\n\n```ini [Run] Filename: \"{app}\\mm.exe\"; Parameters: \"-runtimeinstall -silent\"; Description: \"Checking for and installing the .NET Desktop Runtime...\"\n\n```\n\nAnd with that I now - finally - have a clean arm64 install out of the box where x64 gets a `AnyCPU` x64 EXE and ARM gets an arm64 EXE:\n\n![Arm64 Working In Markdown Monster](https://weblog.west-wind.com/images/2025/TheStrongArmOfDotNetWrestlingWithX64andArm64/Arm64WorkingInMarkdownMonster.png)\n\n**Figure 5** - And finally - a working native Arm64 application out of the box!\n\nYay!\n\n## Some general ARM Deployment Notes\n\nHere are a couple of related notes about first deploying and running on Arm64.\n\n### Which mode am I in?\n\nWhat made this especially painful is the fact that for the longest time I actually thought I was running in native arm64 mode, when the app actually was running in Emulation mode.\n\nIt's an easy mistake to make: If you compile to `AnyCPU` , I wrongly assumed that the app would automatically run in native ARM mode. It **certainly does run**, but it doesn't run in natively and instead runs in x64 Emulation.\n\nIt wasn't until quite a bit later when I started to actually display the `ProcessPlatformTarget` that I noticed the problem. And yeah, that was my fault because of a bad assumption that AnyCPU would 'just work' on ARM. It works, but it **doesn't work right**!\n\nThe process to get the app to automatically start up in the native modes on both platforms requiring to separate EXEs isn't exactly straight forward. There are other ways to do what I describe above using MsBuild, but no matter which way you do it, it involves multiple builds and some extra project build configuration steps.\n\n### ARM vs x64 Emulation Performance\n\nWhen I finally managed to properly run the application natively, the performance difference was quite striking compared to running in x64 Emulation. x64 Emulation startup is very laggy. It takes a couple seconds just to get to the logo screen. The app running too feels sluggish - usable but not snappy.\n\nRunning in native Arm64 mode the app pops up immediately on the logo screen. Navigating the UI is immediately responsive and the overall performance is on par to my main i9 laptop on my x64 laptop which is impressive given this is an $800 laptop.\n\nThe moral of the story: It's worth putting in the effort to make sure your app can **run natively on ARM** to get this improved performance. Your ARM users will thank you!\n\n[!\\[\\](/images/Sponsors/NeedsMoreBassTShirt-Display.png)](https://amzn.to/3XmyPE0)\n\n## Summary\n\nIt's sad that getting an app to run seamlessly both on x64 and Arm64 has to be such a painful process.\n\nThis would be so much easier if .NET could produce an executable that could load either an x64 or ARM process. Or even have a `<PlatformTargets></PlatformTargets>` option that let you build for multiple targets more easily generating postFixes like x64/arm64 perhaps that can then be renamed or moved as needed.\n\nI suppose there's no simple way to get this behavior that would be similar to the way that the `dotnet` command can do it. `dotnet` does some fancy process load juggling to make it work transparently like it does, and that's not something that could be done in a single EXE. So for now, it is what is.\n\nIn the end you'll need two EXEs and the best you can do for users is to make this process transparent to users by swapping files depending on the platform. It works and isn't that big of a deal to set up. As is usually the case the biggest hurdle is knowing what needs to be done to get there. I hope this post helps a bit on that front... Now go build something!'\n\n## Resources\n\n- [.NET Desktop Runtime Installer (GitHub)](https://github.com/RickStrahl/DotnetDesktopRuntimeInstaller)\n\n### Other Posts you might also like\n\n- [Adding minimal OWIN Identity Authentication to an Existing ASP.NET MVC Application](https://weblog.west-wind.com/posts/2015/Apr/29/Adding-minimal-OWIN-Identity-Authentication-to-an-Existing-ASPNET-MVC-Application)\n- [Keeping Content Out of the Publish Folder for WebDeploy](https://weblog.west-wind.com/posts/2022/Aug/24/Keeping-Content-Out-of-the-Publish-Folder-for-WebDeploy)\n- [Using SQL Server on Windows ARM](https://weblog.west-wind.com/posts/2024/Oct/24/Using-Sql-Server-on-Windows-ARM)\n- [Map Physical Paths with an HttpContext.MapPath() Extension Method in ASP.NET](https://weblog.west-wind.com/posts/2023/Aug/15/Map-Physical-Paths-with-an-HttpContextMapPath-Extension-Method-in-ASPNET)\n\nShare on:\n\nhttps://twitter.com/intent/tweet?url=https://weblog.west-wind.com/posts/2025/Apr/18/The-Strong-ARM-of-NET-Wrestling-with-x64-and-Arm64-Desktop-App-Deployment&amp;text=The%20Strong%20ARM%20of%20.NET:%20Wrestling%20with%20x64%20and%20Arm64%20Desktop%20App%20Deployment&amp;via=RickStrahl\n\nhttps://www.facebook.com/sharer/sharer.php?u=https://weblog.west-wind.com/posts/2025/Apr/18/The-Strong-ARM-of-NET-Wrestling-with-x64-and-Arm64-Desktop-App-Deployment&amp;t=The%20Strong%20ARM%20of%20.NET:%20Wrestling%20with%20x64%20and%20Arm64%20Desktop%20App%20Deployment http://www.reddit.com/submit?url=https://weblog.west-wind.com/posts/2025/Apr/18/The-Strong-ARM-of-NET-Wrestling-with-x64-and-Arm64-Desktop-App-Deployment&amp;title=The%20Strong%20ARM%20of%20.NET:%20Wrestling%20with%20x64%20and%20Arm64%20Desktop%20App%20Deployment\n\n![Make Donation](/images/donation.png \"Find this content useful? Consider making a small donation.\")\n\nIs this content useful to you? **Consider making a small donation** to show your support.\n\nPosted in **[.NET](/ShowPosts.aspx?Category=.NET)¬†¬†[Windows](/ShowPosts.aspx?Category=Windows)**\n\n## The Voices of Reason\n\n![](https://www.gravatar.com/avatar.php?gravatar_id=b8425cb4c097cc3c0a67ad7a695f3194&size=100&rating=R)\n\nVladimir Novotny\n\nApril 25, 2025\n\n### # re: The Strong ARM of .NET: Wrestling with x64 and Arm64 Desktop App Deployment\n\nAwsome, awsome, awsome!",
  "PubDate": "2025-04-19T08:35:43+00:00"
}
