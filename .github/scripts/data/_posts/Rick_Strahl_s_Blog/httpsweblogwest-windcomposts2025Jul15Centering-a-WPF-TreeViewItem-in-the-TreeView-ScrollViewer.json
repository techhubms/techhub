{
  "Tags": [
    "WPF"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Rick Strahl's Web Log",
  "ProcessedDate": "2025-08-05 14:25:41",
  "FeedUrl": "https://feeds.feedburner.com/rickstrahl",
  "Title": "Centering a WPF TreeViewItem in the TreeView ScrollViewer",
  "Description": "![Digital Tree Banner.jgp](https://weblog.west-wind.com/images/2025/Centering-a-WPF-TreeViewItem-in-the-TreeView-ScrollViewer/DigitalTreeBanner.jgp.png)\n\nThe TreeView control in WPF is a pain of a control with so many obvious features that should be but are not automatically handled. One of the problems is trying to select an item and keeping it visible and centered in the active Viewport. You would think that would be automatic or at least there would be an easy way to bring an item into a prominently visible view, but you'd be wrong!\n\nIn my use case I need to programmatically filter or rather unfilter a bunch of nodes in a TreeView and I want to make sure that the item focused stays visible when the tree is reorganized. Well... the default behavior doesn't do this unfortunately.\n\nThere is a `TreeViewItem.BringIntoView()` method and it seems like that should do the trick. Unfortunately it does a really crappy job at it, bringing the `TreeViewItem` into the view at the edges - top or bottom, rather than where you would likely want to see it which is closer to or smack in the center of the control.\n\nI've dealt with this one too many times in my apps on a one-off basis I finally created a small helper method that does this **right** and that's what this post is about.\n\n[!\\[\\](/images/sponsors/banner-example.png?v=1.2)](https://markdownmonster.west-wind.com?ut=weblog)\n\n## What's the Problem with BringIntoView\n\nUsing just `BringIntoView()` the default behavior looks like this in this example where I 'unfilter' a search list to re-display the whole list, which should then keep the selected item in the viewport:\n\n![Bad Centering Tree View](https://raw.githubusercontent.com/RickStrahl/ImageDrop/refs/heads/master/BlogPosts/2025/BadCenteringTreeView.gif)\n\n**Figure 1** - BringIntoView() brings the TreeViewItem into view, but does so at the edges: Very top or bottom where it doesn't feature prominently.\n\nNote that the selected item ends up at the very bottom of the TreeView. It's easy to miss there and let's be frank - functionally it looks like shit in that position. In a pinch this works, but it's not exactly good UI.\n\nIn this UI scenario I'm using a search filter to filter the list of topics in a documentation project. In this case the match is a somewhat deeply nested header item which filters down to just a couple of items, and when I undo the filter I want that item to show up in the TreeView, preferably centered, so it's easy to see. As it is the item stays visible, but it's at very bottom - buried alive!\n\n## Fixing TreeViewItem Centering\n\nLet's start with the base application code needed to make this happen. This code is needed regardless of the item placement within the view so we'll need that in both the original bad and fixed good implementations. In the example this code gets fired off the X clear button handler of SearchBox:\n\n```csharp public void MakeTopicVisible(DocTopic topic) // bound data item { if (topic == null) return;\n\nvar tvi = WindowUtilities.GetNestedTreeviewItem(topic, TreeTopicBrowser); if (tvi == null) return;\n\n// expand all parents var tvParent = tvi; while (tvParent?.Parent is TreeViewItem parentTvi) { tvParent.IsExpanded = true; if (tvParent.DataContext is DocTopic dt) dt.IsExpanded = true; tvParent = parentTvi; }\n\ntvi.IsSelected = true; tvi.Focus(); tvi.BringIntoView(); }\n\n```\n\nAs is typical for UI operations on a TreeView you need to first map the Model value that you have access to (most likely via `TreeView.SelectedItem` ) and convert that into a `TreeviewItem` . I use a helper function called `GetNestedTreeViewItem()` (see below) which walks the TreeView hierarchy and looks at the DataContext items for a match.\n\nOnce I have the TreeViewItem I then have to expand all parent items to ensure the item will actually be visible.\n\nFinally, once that's all done, the item is selected, focused and hopefully brought into the View. But as shown in the Screen Capture above, if the item is not already visible it'll be pulled into the active Viewport, but likely at the very bottom or top of the view port.\n\nThat's a lot of work for a simple thing that **should be built into the bloody base control** since this is something one does all the time with a `TreeView` !\n\nThe main problem at hand here is that `BringIntoView()` really does an inadequate job of what it's designated job - it gets the TreeViewItem into view, but not where you typically want it. `element.scrollIntoView()` in JavaScript.\n\n### Ooooohhmmmmm... Centering the Tree\n\nAlright so how does this get fixed? Manually, my friend. Manually, by explicitly moving the `ScrollViewer` so the the TreeViewItem is centered.\n\nHere's the code that does the trick:\n\n```csharp /// /// Centers a TreeViewItem inside of the scrollviewer unlike ScrollIntoView /// which scrolls the item just into the top or bottom if not already /// in the view /// /// TreeView to scroll /// TreeView Item to scroll to public static void CenterTreeViewItemInScrollViewer(TreeView treeView, TreeViewItem item) { if (item == null) return;\n\n// Ensure item is visible in layout item.IsSelected = true; item.BringIntoView();\n\ntreeView.Dispatcher.InvokeAsync(() => { var scrollViewer = FindVisualChild(treeView); if (scrollViewer == null) return;\n\n// Find the header content presenter var header = FindVisualChild(item); if (header == null) return;\n\n// Get header position relative to ScrollViewer var transform = header.TransformToAncestor(scrollViewer); var position = transform.Transform(new System.Windows.Point(0, 0));\n\ndouble headerHeight = header.ActualHeight; double viewportHeight = scrollViewer.ViewportHeight * scrollViewer.ScrollableHeight / scrollViewer.ExtentHeight;\n\ndouble targetOffset = scrollViewer.VerticalOffset + position.Y - (viewportHeight / 2) + (headerHeight / 2); scrollViewer.ScrollToVerticalOffset(targetOffset); }, DispatcherPriority.Loaded); }\n\n```\n\nThis code measures the size of the TreeViewItem's **Content** and then adjusts the Viewport by the height or width to try and bring the item into the center of the Viewport - shifting the offset from its current location.\n\nNote that this code specifically looks at the **Content** object (the `ContentPresenter` ) rather than the entire TreeViewItem using `FindVisualChild()` (code below). Why? Because a TreeViewItem contains all of its children and you don't want to center an expanded `TreeViewItem` with all of its items which would show the selected item in the wrong place at best and not at all at worst.\n\nSo rather than the `TreeViewItem` the code looks for the `ContentPresenter` which then lets me correctly center the actual item in the Viewport rather than the whole block.\n\nI can now fix my calling code to use this function instead of `BringIntoView()` :\n\n```csharp tvi.IsSelected = true; tvi.Focus();\n\nWindowUtilities.CenterTreeViewItemInScrollViewer(TreeTopicBrowser, tvi);\n\n```\n\nHere's what the desired behavior looks like:\n\n![Proper Centering Tree View](https://raw.githubusercontent.com/RickStrahl/ImageDrop/refs/heads/master/BlogPosts/2025/ProperCenteringTreeView.gif)\n\nEt Voila!\n\nThis is what `BringIntoView()` should be doing in the first place, but this helper does the trick if you want the TreeViewItem centered. If you don't care about the centering, you can still just `BringIntoView()` or if you need it at some other location you can tweak the method above to put it where you want it. Centering seems like the right thing to do most of the time.\n\nSome refinements for alternate behavior might allow checking if the item is already visible or at least slightly off the top and bottom and not scrolling the viewer in that case to avoid jumping around the UI. Positioning might be another option - top, center, bottom, where top and bottom would be closer to the top or bottom without directly butting up against the top or bottom. Not something I need, but if you need some extra credit homework - there you go...\n\n### Support methods\n\nFor completeness sake here are the two helper functions referenced in the code snippets above:\n\n**FindVisualChild**\n\nFinds a child control by its control type.\n\n```csharp public static T FindVisualChild(DependencyObject currentControl) where T : DependencyObject { if (currentControl != null) { for (int i = 0; i (child); if (childItem != null) return childItem; } }\n\nreturn null; }\n\n```\n\n**GetNestedTreeViewItem**\n\nLooks up a Treeview item by its model value.\n\n```csharp public static TreeViewItem GetNestedTreeviewItem(object item, ItemsControl parent) { // look at this level var tvi = parent.ItemContainerGenerator.ContainerFromItem(item) as TreeViewItem; if (tvi != null) return tvi;\n\n// otherwise, recurse into each generated TreeViewItem foreach (object child in parent.Items) { if (parent.ItemContainerGenerator.ContainerFromItem(child) is TreeViewItem childContainer) { var result = GetNestedTreeviewItem( item, childContainer); if (result != null) return result; } }\n\nreturn null; }\n\n```\n\n## Summary\n\nFile this one away under *Things that should just work, but don't!* So many things that have to do with the TreeView control are not designed in anyway to deal with the hierarchical nature of this control that it's almost comical. The good news is that the tools to do this manually are available and it's relatively straight forward to build reusable helpers that solve that problem.\n\nOf course if you're anything like me, you'll do this manually a 100 times before you wisen up and build something reusable. And that's the point of this post - it'll serve as a reminder to me and quickly find the solution.\n\nOr you can ask an LLM and get an incomplete solution... ask me how I know! 😂 And yeah, that's why I still bother writing helper functions like this, and even write them up in a blog post.\n\n© Rick Strahl, West Wind Technologies, 2005-2025\n\nPosted in **[WPF](/ShowPosts.aspx?Category=WPF)**",
  "Link": "https://weblog.west-wind.com/posts/2025/Jul/15/Centering-a-WPF-TreeViewItem-in-the-TreeView-ScrollViewer",
  "FeedName": "Rick Strahl's Blog",
  "Author": "Rick Strahl",
  "EnhancedContent": "![](/images/HeroImages/RickHero12.jpg) ![](/images/rick175x175.jpg)\n\nhttps://twitter.com/rickstrahl https://feeds.feedburner.com/rickstrahl\n\n[Contact](https://west-wind.com/contact/)   • [Articles](https://west-wind.com/articles.aspx)   • [Products](https://store.west-wind.com)   • [Support](https://support.west-wind.com)   • [Advertise](https://weblog.west-wind.com/advertise)\n\nSponsored by:\n\n[!\\[\\](https://markdownmonster.west-wind.com/Images/MarkdownMonster_Icon_256.png) **Markdown Monster**](https://markdownmonster.west-wind.com?utm_campaign=westwind-weblog-sponsored)\n- The Markdown Editor for Windows\nhttps://markdownmonster.west-wind.com?utm_campaign=westwind-weblog-sponsored\n\n[advertise here](/advertise)\n\nShare on:\n\nhttps://twitter.com/intent/tweet?url=https://weblog.west-wind.com/posts/2025/Jul/15/Centering-a-WPF-TreeViewItem-in-the-TreeView-ScrollViewer&amp;text=Centering%20a%20WPF%20TreeViewItem%20in%20the%20TreeView%20ScrollViewer&amp;via=RickStrahl https://www.facebook.com/sharer/sharer.php?u=https://weblog.west-wind.com/posts/2025/Jul/15/Centering-a-WPF-TreeViewItem-in-the-TreeView-ScrollViewer&amp;t=Centering%20a%20WPF%20TreeViewItem%20in%20the%20TreeView%20ScrollViewer http://www.reddit.com/submit?url=https://weblog.west-wind.com/posts/2025/Jul/15/Centering-a-WPF-TreeViewItem-in-the-TreeView-ScrollViewer&amp;title=Centering%20a%20WPF%20TreeViewItem%20in%20the%20TreeView%20ScrollViewer\n\nJuly 15, 2025 • from Hood River, Oregon\n\n:P\n\nOn this page:\n\n![Digital Tree Banner.jgp](https://weblog.west-wind.com/images/2025/Centering-a-WPF-TreeViewItem-in-the-TreeView-ScrollViewer/DigitalTreeBanner.jgp.png)\n\nThe TreeView control in WPF is a pain of a control with so many obvious features that should be but are not automatically handled. One of the problems is trying to select an item and keeping it visible and centered in the active Viewport. You would think that would be automatic or at least there would be an easy way to bring an item into a prominently visible view, but you'd be wrong!\n\nIn my use case I need to programmatically filter or rather unfilter a bunch of nodes in a TreeView and I want to make sure that the item focused stays visible when the tree is reorganized. Well... the default behavior doesn't do this unfortunately.\n\nThere is a `TreeViewItem.BringIntoView()` method and it seems like that should do the trick. Unfortunately it does a really crappy job at it, bringing the `TreeViewItem` into the view at the edges - top or bottom, rather than where you would likely want to see it which is closer to or smack in the center of the control.\n\nI've dealt with this one too many times in my apps on a one-off basis I finally created a small helper method that does this **right** and that's what this post is about.\n\n[!\\[\\](/images/sponsors/banner-example.png?v=1.2)](https://markdownmonster.west-wind.com?ut=weblog)\n\n## What's the Problem with BringIntoView\n\nUsing just `BringIntoView()` the default behavior looks like this in this example where I 'unfilter' a search list to re-display the whole list, which should then keep the selected item in the viewport:\n\n![Bad Centering Tree View](https://raw.githubusercontent.com/RickStrahl/ImageDrop/refs/heads/master/BlogPosts/2025/BadCenteringTreeView.gif)\n\n**Figure 1** - BringIntoView() brings the TreeViewItem into view, but does so at the edges: Very top or bottom where it doesn't feature prominently.\n\nNote that the selected item ends up at the very bottom of the TreeView. It's easy to miss there and let's be frank - functionally it looks like shit in that position. In a pinch this works, but it's not exactly good UI.\n\nIn this UI scenario I'm using a search filter to filter the list of topics in a documentation project. In this case the match is a somewhat deeply nested header item which filters down to just a couple of items, and when I undo the filter I want that item to show up in the TreeView, preferably centered, so it's easy to see. As it is the item stays visible, but it's at very bottom - buried alive!\n\n## Fixing TreeViewItem Centering\n\nLet's start with the base application code needed to make this happen. This code is needed regardless of the item placement within the view so we'll need that in both the original bad and fixed good implementations. In the example this code gets fired off the X clear button handler of SearchBox:\n\n```csharp public void MakeTopicVisible(DocTopic topic) // bound data item { if (topic == null) return;\n\nvar tvi = WindowUtilities.GetNestedTreeviewItem(topic, TreeTopicBrowser); if (tvi == null) return;\n\n// expand all parents var tvParent = tvi; while (tvParent?.Parent is TreeViewItem parentTvi) { tvParent.IsExpanded = true; if (tvParent.DataContext is DocTopic dt) dt.IsExpanded = true; tvParent = parentTvi; }\n\ntvi.IsSelected = true; tvi.Focus(); tvi.BringIntoView(); }\n\n```\n\nAs is typical for UI operations on a TreeView you need to first map the Model value that you have access to (most likely via `TreeView.SelectedItem` ) and convert that into a `TreeviewItem` . I use a helper function called `GetNestedTreeViewItem()` (see below) which walks the TreeView hierarchy and looks at the DataContext items for a match.\n\nOnce I have the TreeViewItem I then have to expand all parent items to ensure the item will actually be visible.\n\nFinally, once that's all done, the item is selected, focused and hopefully brought into the View. But as shown in the Screen Capture above, if the item is not already visible it'll be pulled into the active Viewport, but likely at the very bottom or top of the view port.\n\nThat's a lot of work for a simple thing that **should be built into the bloody base control** since this is something one does all the time with a `TreeView` !\n\nThe main problem at hand here is that `BringIntoView()` really does an inadequate job of what it's designated job - it gets the TreeViewItem into view, but not where you typically want it. `element.scrollIntoView()` in JavaScript.\n\n### Ooooohhmmmmm... Centering the Tree\n\nAlright so how does this get fixed? Manually, my friend. Manually, by explicitly moving the `ScrollViewer` so the the TreeViewItem is centered.\n\nHere's the code that does the trick:\n\n```csharp /// <summary> /// Centers a TreeViewItem inside of the scrollviewer unlike ScrollIntoView /// which scrolls the item just into the top or bottom if not already /// in the view /// </summary> /// <param name=\"treeView\">TreeView to scroll</param> /// <param name=\"treeViewItem\">TreeView Item to scroll to</param> public static void CenterTreeViewItemInScrollViewer(TreeView treeView, TreeViewItem item) { if (item == null) return;\n\n// Ensure item is visible in layout item.IsSelected = true; item.BringIntoView();\n\ntreeView.Dispatcher.InvokeAsync(() => { var scrollViewer = FindVisualChild<ScrollViewer>(treeView); if (scrollViewer == null) return;\n\n// Find the header content presenter var header = FindVisualChild<ContentPresenter>(item); if (header == null) return;\n\n// Get header position relative to ScrollViewer var transform = header.TransformToAncestor(scrollViewer); var position = transform.Transform(new System.Windows.Point(0, 0));\n\ndouble headerHeight = header.ActualHeight; double viewportHeight = scrollViewer.ViewportHeight * scrollViewer.ScrollableHeight / scrollViewer.ExtentHeight;\n\ndouble targetOffset = scrollViewer.VerticalOffset + position.Y - (viewportHeight / 2) + (headerHeight / 2); scrollViewer.ScrollToVerticalOffset(targetOffset); }, DispatcherPriority.Loaded); }\n\n```\n\nThis code measures the size of the TreeViewItem's **Content** and then adjusts the Viewport by the height or width to try and bring the item into the center of the Viewport - shifting the offset from its current location.\n\nNote that this code specifically looks at the **Content** object (the `ContentPresenter` ) rather than the entire TreeViewItem using `FindVisualChild<ScrollViewer>()` (code below). Why? Because a TreeViewItem contains all of its children and you don't want to center an expanded `TreeViewItem` with all of its items which would show the selected item in the wrong place at best and not at all at worst.\n\nSo rather than the `TreeViewItem` the code looks for the `ContentPresenter` which then lets me correctly center the actual item in the Viewport rather than the whole block.\n\nI can now fix my calling code to use this function instead of `BringIntoView()` :\n\n```csharp tvi.IsSelected = true; tvi.Focus();\n\nWindowUtilities.CenterTreeViewItemInScrollViewer(TreeTopicBrowser, tvi);\n\n```\n\nHere's what the desired behavior looks like:\n\n![Proper Centering Tree View](https://raw.githubusercontent.com/RickStrahl/ImageDrop/refs/heads/master/BlogPosts/2025/ProperCenteringTreeView.gif)\n\nEt Voila!\n\nThis is what `BringIntoView()` should be doing in the first place, but this helper does the trick if you want the TreeViewItem centered. If you don't care about the centering, you can still just `BringIntoView()` or if you need it at some other location you can tweak the method above to put it where you want it. Centering seems like the right thing to do most of the time.\n\nSome refinements for alternate behavior might allow checking if the item is already visible or at least slightly off the top and bottom and not scrolling the viewer in that case to avoid jumping around the UI. Positioning might be another option - top, center, bottom, where top and bottom would be closer to the top or bottom without directly butting up against the top or bottom. Not something I need, but if you need some extra credit homework - there you go...\n\n### Support methods\n\nFor completeness sake here are the two helper functions referenced in the code snippets above:\n\n**FindVisualChild**\n\nFinds a child control by its control type.\n\n```csharp public static T FindVisualChild<T>(DependencyObject currentControl) where T : DependencyObject { if (currentControl != null) { for (int i = 0; i < VisualTreeHelper.GetChildrenCount(currentControl); i++) { var child = VisualTreeHelper.GetChild(currentControl, i); if (child is T) { return (T) child; }\n\nT childItem = FindVisualChild<T>(child); if (childItem != null) return childItem; } }\n\nreturn null; }\n\n```\n\n**GetNestedTreeViewItem**\n\nLooks up a Treeview item by its model value.\n\n```csharp public static TreeViewItem GetNestedTreeviewItem(object item, ItemsControl parent) { // look at this level var tvi = parent.ItemContainerGenerator.ContainerFromItem(item) as TreeViewItem; if (tvi != null) return tvi;\n\n// otherwise, recurse into each generated TreeViewItem foreach (object child in parent.Items) { if (parent.ItemContainerGenerator.ContainerFromItem(child) is TreeViewItem childContainer) { var result = GetNestedTreeviewItem( item, childContainer); if (result != null) return result; } }\n\nreturn null; }\n\n```\n\n[!\\[\\](/images/Sponsors/NeedsMoreBassTShirt-Display.png)](https://amzn.to/3XmyPE0)\n\n## Summary\n\nFile this one away under *Things that should just work, but don't!* So many things that have to do with the TreeView control are not designed in anyway to deal with the hierarchical nature of this control that it's almost comical. The good news is that the tools to do this manually are available and it's relatively straight forward to build reusable helpers that solve that problem.\n\nOf course if you're anything like me, you'll do this manually a 100 times before you wisen up and build something reusable. And that's the point of this post - it'll serve as a reminder to me and quickly find the solution.\n\nOr you can ask an LLM and get an incomplete solution... ask me how I know! 😂 And yeah, that's why I still bother writing helper functions like this, and even write them up in a blog post.\n\n### Other Posts you might also like\n\n- [Taking the new Chromium WebView2 Control for a Spin in .NET - Part 1](https://weblog.west-wind.com/posts/2021/Jan/14/Taking-the-new-Chromium-WebView2-Control-for-a-Spin-in-NET-Part-1)\n- [Async and Async Void Event Handling in WPF](https://weblog.west-wind.com/posts/2022/Apr/22/Async-and-Async-Void-Event-Handling-in-WPF)\n- [Chromium WebView2 Control and .NET to JavaScript Interop - Part 2](https://weblog.west-wind.com/posts/2021/Jan/26/Chromium-WebView2-Control-and-NET-to-JavaScript-Interop-Part-2)\n- [Working around the WPF ImageSource Blues](https://weblog.west-wind.com/posts/2024/Jan/03/Working-around-the-WPF-ImageSource-Blues)\n\nShare on:\n\nhttps://twitter.com/intent/tweet?url=https://weblog.west-wind.com/posts/2025/Jul/15/Centering-a-WPF-TreeViewItem-in-the-TreeView-ScrollViewer&amp;text=Centering%20a%20WPF%20TreeViewItem%20in%20the%20TreeView%20ScrollViewer&amp;via=RickStrahl\n\nhttps://www.facebook.com/sharer/sharer.php?u=https://weblog.west-wind.com/posts/2025/Jul/15/Centering-a-WPF-TreeViewItem-in-the-TreeView-ScrollViewer&amp;t=Centering%20a%20WPF%20TreeViewItem%20in%20the%20TreeView%20ScrollViewer http://www.reddit.com/submit?url=https://weblog.west-wind.com/posts/2025/Jul/15/Centering-a-WPF-TreeViewItem-in-the-TreeView-ScrollViewer&amp;title=Centering%20a%20WPF%20TreeViewItem%20in%20the%20TreeView%20ScrollViewer\n\n![Make Donation](/images/donation.png \"Find this content useful? Consider making a small donation.\")\n\nIs this content useful to you? **Consider making a small donation** to show your support.\n\nPosted in **[WPF](/ShowPosts.aspx?Category=WPF)**",
  "PubDate": "2025-07-16T04:23:03+00:00"
}
