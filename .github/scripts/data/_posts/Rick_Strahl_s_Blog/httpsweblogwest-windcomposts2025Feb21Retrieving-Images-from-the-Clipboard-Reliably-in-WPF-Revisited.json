{
  "Tags": [
    "Windows",
    "WPF"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Rick Strahl's Web Log",
  "ProcessedDate": "2025-08-05 14:25:42",
  "FeedUrl": "https://feeds.feedburner.com/rickstrahl",
  "Title": "Retrieving Images from the Clipboard Reliably in WPF Revisited",
  "Description": "The WPF Clipboard is notoriously bad for retrieving image data, mainly because of the funky behavior of the ImageSource control into which clipboard data is loaded. WPF cuts a lot of corners when retrieving images and there are many scenarios where Clipboard.GetImage() either crashes or doesn't render the supposedly successfully retrieved image. In this post I review some of the challenges and how you can work around the retrieving an ImageSource with an intermediary load of a bitmap in between to provide reliable image retrieval from the clipboard in WPF.",
  "Link": "https://weblog.west-wind.com/posts/2025/Feb/21/Retrieving-Images-from-the-Clipboard-Reliably-in-WPF-Revisited",
  "FeedName": "Rick Strahl's Blog",
  "Author": "Rick Strahl",
  "EnhancedContent": "![](/images/HeroImages/RickHero9.jpg) ![](/images/rick175x175.jpg)\n\nhttps://twitter.com/rickstrahl https://feeds.feedburner.com/rickstrahl\n\n[Contact](https://west-wind.com/contact/) Â  â€¢ [Articles](https://west-wind.com/articles.aspx) Â  â€¢ [Products](https://store.west-wind.com) Â  â€¢ [Support](https://support.west-wind.com) Â  â€¢ [Advertise](https://weblog.west-wind.com/advertise)\n\nSponsored by:\n\n[!\\[\\](https://websurge.west-wind.com/images/WebSurgeLogo.png) **West Wind WebSurge**](https://websurge.west-wind.com?utm_campaign=westwind-weblog-sponsored)\n- Rest Client and Http Load Testing for Windows\nhttps://websurge.west-wind.com?utm_campaign=westwind-weblog-sponsored\n\n[advertise here](/advertise)\n\nShare on:\n\nhttps://twitter.com/intent/tweet?url=https://weblog.west-wind.com/posts/2025/Feb/21/Retrieving-Images-from-the-Clipboard-Reliably-in-WPF-Revisited&amp;text=Retrieving%20Images%20from%20the%20Clipboard%20Reliably%20in%20WPF%20Revisited&amp;via=RickStrahl https://www.facebook.com/sharer/sharer.php?u=https://weblog.west-wind.com/posts/2025/Feb/21/Retrieving-Images-from-the-Clipboard-Reliably-in-WPF-Revisited&amp;t=Retrieving%20Images%20from%20the%20Clipboard%20Reliably%20in%20WPF%20Revisited http://www.reddit.com/submit?url=https://weblog.west-wind.com/posts/2025/Feb/21/Retrieving-Images-from-the-Clipboard-Reliably-in-WPF-Revisited&amp;title=Retrieving%20Images%20from%20the%20Clipboard%20Reliably%20in%20WPF%20Revisited\n\nFebruary 21, 2025 â€¢ from Maui, Hawaii\n\n:P\n\nOn this page:\n\n[Edit this Post](https://github.com/RickStrahl/BlogPosts/blob/master/2025-02/Clipboard-Data-and-Wpf-ImageSource-Conversions-Revisited/ClipboardDataAndWpfImagesourceConversions.md)\n\n![Banner Image](https://weblog.west-wind.com/images/2025/Clipboard-Data-and-Wpf-ImageSource-Conversions-Revisited/BannerImage.jpg)\n\nI've written previously about [image formatting issues with the clipboard data in WPF](https://weblog.west-wind.com/posts/2020/Sep/16/Wrestling-with-Clipboard-Images-in-WPF) and for the most part what I discussed in that post has been working just fine.\n\nRecently however I started noticing some issues with some of my clipboard pasting code in [Markdown Monster](https://markdownmonster.west-wind.com/) producing what appears to be corrupted images when displaying in an ImageSource control. The following is an image captured from [Techsmith's SnagIt](https://www.techsmith.com/snagit/) and then opened in Markdown Monster's Image dialog:\n\n![Bonked Image from Clipboard](https://weblog.west-wind.com/images/2025/Clipboard-Data-and-Wpf-ImageSource-Conversions-Revisited/BonkedImage.jpg)\n\n**Figure 1** - Something's not quite right here: Shades of a badly tuned broadcast TV in the 70's ðŸ˜„\n\nThe image is sort of there, but it's obviously missing color, it's offset by a bunch with part of it missing, mis-sized and... well, it looks like an old, mis-tuned broadcast service TV image. It's an interesting effect, but not what that image should look like.\n\nWhat's happening in this code is that the image is copied to the clipboard from SnagIt and then picked up by the form when it loads from the clipboard and loaded into an `Image` control via an `ImageSource` bitmap.\n\n[!\\[\\](/images/sponsors/banner-example.png?v=1.2)](https://markdownmonster.west-wind.com?ut=weblog)\n\n## That Nasty WPF ImageSource Control\n\nIt should be simple: `Clipboard.GetImage()` should just return you an ImageSource and that should be the end of it. Unfortunately, more times than not, that doesn't 'just' work. Anything a little off in the image and `System.Windows.Clipboard.GetImage()` fails. Either it outright crashes or worse - it returns a result, but the resulting ImageSource doesn't actually render in the image control, which means your code has no way to really know that the image failed.\n\nTurns out `Windows.Forms.Clipboard.GetImage()` works much more reliably, but it can't do transparency in `.png` images, which may be important.\n\nSo, in order to be able to handle all the use cases, I have been using a `ClipboardHelper` class with wrapper functions that look at the clipboard and explicitly extract the bitmap data first, and then create a new `ImageSource` from that bitmap data. That seems to be much more reliable and it support opacity. The first article goes into a lot of detail about how this works and also talks a bit about all the crazy clipboard formats you can run into and have to deal with if you're interested.\n\nFor this post, I'll show the complete, updated code for getting an `ImageSource` or `Bitmap` from the clipboard at the end of the post.\n\n### Image Formatting: Bitness\n\nI've been using this helper class for a long time and it's been working for me for some time, except for the problem shown in **Figure 1** that only occurs occasionally, but is coming up more and more recently. After a bit of sleuthing in the code I was able to track this down to the conversion code that's converting the clipboard bitmap image data into an ImageSource to display in the WPF Image control. The bitmap itself appears to be fine as I checked the actual byte data and wrote it out to file. The file image looked perfectly fine.\n\nSo the issue is Bitmap to ImageSource conversion - which has always been the messy part of this entire process.\n\nThere are a number of ways to do this conversion:\n\n- Dumping the image into a byte stream and assigning loading the image source from that\n- Dumping to file and loading the image source from that\n- Using low-level locking of the actual image data and loading the image source from that\n\nI'd been using the latter, because the in-place memory usage and unsafe code combination are wicked fast compared to any other approaches - like 3-4 faster, plus it doesn't require copying the bitmap buffer of a potentially large image into a second block of memory.\n\nThe original code was [retrieved from Stack Overflow](https://stackoverflow.com/a/30729291) and I used it as is because to be honest I only had a vague idea what that code was actually doing. At the time I noticed some of the hardcoded values and thought about that being a problem but in a bit of testing I didn't see any issues with images from a variety of sources.\n\nHere's the original SO code:\n\n```csharp public static BitmapSource BitmapToBitmapSource(Bitmap bmp) { var bitmapData = bmp.LockBits( new Rectangle(0, 0, bmp.Width, bmp.Height), ImageLockMode.ReadOnly, bmp.PixelFormat);\n\nvar bitmapSource = BitmapSource.Create( bitmapData.Width, bitmapData.Height, bmp.HorizontalResolution, bmp.VerticalResolution, PixelFormats.Bgr24, null, bitmapData.Scan0, bitmapData.Stride * bitmapData.Height, bitmapData.Stride);\n\nbmp.UnlockBits(bitmapData);\n\nreturn bitmapSource; }\n\n```\n\nYou'll notice in there that the `PixelFormats.Bgr24` is hard coded. This will work most of the time but if the image is stored in 32 bit format you get - variable results. Oddly it works some of the time even with 32 bit images, but some images consistently failed with the image behavior shown in **Figure 1**. The reason I've been seeing more of the errors likely is due to more software using the higher 32 bit depth.\n\nTo get around this hard coded pixelformat, we can add a conversion routine that translates pixel formats between the System.Drawing and System.Windows values. The code shows both directions but only the first is from System.Drawing to System.Windows is actually used:\n\n```csharp public static System.Windows.Media.PixelFormat ConvertPixelFormat(System.Drawing.Imaging.PixelFormat systemDrawingFormat) { switch (systemDrawingFormat) { case PixelFormat.Format32bppArgb: return PixelFormats.Bgra32; case PixelFormat.Format32bppRgb: return PixelFormats.Bgr32; case PixelFormat.Format24bppRgb: return PixelFormats.Bgr24; case PixelFormat.Format16bppRgb565: return PixelFormats.Bgr565; case PixelFormat.Format16bppArgb1555: return PixelFormats.Bgr555; case PixelFormat.Format8bppIndexed: return PixelFormats.Gray8; case PixelFormat.Format1bppIndexed: return PixelFormats.BlackWhite; case PixelFormat.Format16bppGrayScale: return PixelFormats.Gray16; default: return PixelFormats.Bgr24; } }\n\npublic static System.Drawing.Imaging.PixelFormat ConvertPixelFormat(System.Windows.Media.PixelFormat wpfFormat) { if (wpfFormat == PixelFormats.Bgra32) return PixelFormat.Format32bppArgb; if (wpfFormat == PixelFormats.Bgr32) return PixelFormat.Format32bppRgb; if (wpfFormat == PixelFormats.Bgr24) return PixelFormat.Format24bppRgb; if (wpfFormat == PixelFormats.Bgr565) return PixelFormat.Format16bppRgb565; if (wpfFormat == PixelFormats.Bgr555) return PixelFormat.Format16bppArgb1555; if (wpfFormat == PixelFormats.Gray8) return PixelFormat.Format8bppIndexed; if (wpfFormat == PixelFormats.Gray16) return PixelFormat.Format16bppGrayScale; if (wpfFormat == PixelFormats.BlackWhite) return PixelFormat.Format1bppIndexed;\n\nreturn PixelFormat.Format24bppRgb; }\n\n```\n\nAnd with that we can now fix the image `Bitmap` to `ImageSource` conversion:\n\n```csharp public static BitmapSource BitmapToBitmapSource(Bitmap bmp) { var bitmapData = bmp.LockBits( new Rectangle(0, 0, bmp.Width, bmp.Height), ImageLockMode.ReadOnly, bmp.PixelFormat);\n\nvar pf = ConvertPixelFormat(bmp.PixelFormat);\n\nvar bitmapSource = BitmapSource.Create( bitmapData.Width, bitmapData.Height, bmp.HorizontalResolution, bmp.VerticalResolution, pf, null, bitmapData.Scan0, bitmapData.Stride * bitmapData.Height, bitmapData.Stride);\n\nbmp.UnlockBits(bitmapData);\n\nreturn bitmapSource; }\n\n```\n\nThe image display now works correctly for anything I'm throwing at it. Here's the image rendering correctly in the Image dialog in Markdown Monster:\n\n![Un Bonked Image](https://weblog.west-wind.com/images/2025/Clipboard-Data-and-Wpf-ImageSource-Conversions-Revisited/UnBonkedImage.jpg)\n\n**Figure 2** - Properly captured image after fixing the Pixelmode conversion.\n\nNote that this method requires unsafe code (for the `LockBits` call) so this may or may not be usable everywhere. If you need a version that works with safe code only you can use the following which uses an intermediary Memory stream:\n\n```csharp public static BitmapSource BitmapToBitmapSourceSafe(Bitmap bmp) { using var ms = new MemoryStream();\n\nbmp.Save(ms, ImageFormat.Png); ms.Position = 0;\n\nvar bitmap = new BitmapImage(); bitmap.BeginInit(); bitmap.CacheOption = BitmapCacheOption.OnLoad; // Load image immediately bitmap.StreamSource = ms; bitmap.EndInit(); bitmap.Freeze(); // Make the BitmapImage cross-thread accessible\n\nreturn bitmap; }\n\n```\n\n### Performance\n\nThis code is reliable but it's **considerably slower** (2-4 times slower depending on how many images you load) and also loads another copy of the image data for each image.\n\nNote that there are a number of other ways to do this: Dumping to disk, traversing the Bitmap buffer with .NET safe code (which apparently is also fairly slow).\n\nI'm using this method in Markdown Monster in a number of places and for single images displayed the slower processing and memory usage is not a problem. However, I also use if for an image list that displays a history of AI Image generated which contains potentially hundreds of images that are loaded asynchronously and the performance difference there is enormous:\n\n![Lots Of Images In An Image List](https://weblog.west-wind.com/images/2025/Clipboard-Data-and-Wpf-ImageSource-Conversions-Revisited/LotsOfImagesInAnImageList.jpg) **Figure 3** - In a large list of images load performance matters - so the faster algorithm using unsafe code ends up being 3-4 times faster.\n\nThe image slider on the bottom contains a large number of images that are loaded asynchronously in the background, but even though they are loading in the background the initial hit of the UI activating is as much as 4 times slower with the MemoryStream code than using the LockBits code.\n\n### Putting it all Together: Getting an Image or ImageSource off the Clipboard\n\nI went into great detail about clipboard image retrieval [in the previous post](https://weblog.west-wind.com/posts/2020/Sep/16/Wrestling-with-Clipboard-Images-in-WPF) and some of the issues you need to deal with. I'm not going to rehash all of it here, but if you're interested there's tons of detail of why this can be such a pain in the ass.\n\nThe short version is: The Windows.Forms Clipboard works great, but it can't do transparency. The native WPF clipboard is super flakey with some image types.\n\nThe wrappers I show here make it very easy to retrieve Clipboard data safely and quickly and as reliably as possible. At this point I've thrown a huge number of different image types at the updated code and I've not had any failures other than a few out memory errors with very large images.\n\nThere are two functions:\n\n- GetImage()\n- GetImageSource()\n\nas well as the previously shown methods:\n\n- BitmapToBitmapSource()\n- ConvertPixelFormat()\n\nThe whole thing to retrieve an ImageSource and a Bitmap Image first, looks like this:\n\n```csharp // ClipboardHelper.GetImageSource() public static ImageSource GetImageSource() { if (!Clipboard.ContainsImage()) return null;\n\n// no try to get a Bitmap and then convert to BitmapSource using (var bmp = GetImage()) { if (bmp == null) return null;\n\nreturn WindowUtilities.BitmapToBitmapSource(bmp); } }\n\n// ClipboardHelper.GetImage() public static Bitmap GetImage() { try { var dataObject = Clipboard.GetDataObject();\n\nvar formats = dataObject.GetFormats(true); if (formats == null || formats.Length == 0) return null;\n\n#if DEBUG // show all formats of the image pasted foreach (var f in formats) Debug.WriteLine(\" - \" + f.ToString()); #endif\n\n// Use this first as this gives you transparency! if (formats.Contains(\"PNG\")) { using MemoryStream ms = (MemoryStream)dataObject.GetData(\"PNG\"); ms.Position = 0; return (Bitmap)new Bitmap(ms); } if (formats.Contains(\"System.Drawing.Bitmap\")) { return (Bitmap)dataObject.GetData(\"System.Drawing.Bitmap\"); } if (formats.Contains(DataFormats.Bitmap)) { return (Bitmap)dataObject.GetData(DataFormats.Bitmap); }\n\n// just use GetImage() - // retry multiple times to work around Windows timing BitmapSource src = null; for (int i = 0; i < 5; i++) { try { // This is notoriously unreliable so retry multiple time if it fails src = Clipboard.GetImage(); break; // success } catch { Thread.Sleep(10); // retry } }\n\nif (src == null) { try { Debug.WriteLine(\"Clipboard Fall through - use WinForms\"); return System.Windows.Forms.Clipboard.GetImage() as Bitmap; } catch { return null; } }\n\nreturn WindowUtilities.BitmapSourceToBitmap(src); } catch { return null; } }\n\n```\n\nThe code looks for a few known formats that can be directly converted from the raw clipboard data and those are immediately returned. Note that some formats are already in Bitmap format while others like `PNG` are a binary stream that has to be loaded and assigned to a Bitmap.\n\nThe first check is for PNG because we want to try and capture the transparency of the raw PNG image. Note that for PNG we read the stream and create a bitmap from it.\n\nNext, both `Bitmap` or `System.Drawing.Bitmap` formats are actually stored in the raw .NET Bitmap format and directly cast to that type. That would seem to be the easiest path, but these images unfortunately don't support opacity and that's why `PNG` is processed first.\n\nYou're likely to see Bitmap formats from .NET applications or applications that have some .NET support, but non-.NET applications likely won't have these clipboard formats set and likely provide raw image data.\n\nIn those cases, the code falls back to the default WPF Clipboard behavior and call `Clipboard.GetImage()` . If that call fails it will delay briefly and try again a few times. There's a well known timing bug in the Windows Clipboard API that can cause the clipboard to not be ready to retrieve data right as you request it, and retrying often can get the image. In fact, the Windows.Forms.Clipboard functionality does that automatically and internally, but for WPF it needs to be explicitly coded.\n\nIf the WPF `GetImage()` fails after several tries, the code then falls back to Windows Forms `GetImage()` operation. Which is very likely to pick up anything else regardless of format.\n\nPrior to the Windows Forms fallback I was running into frequent clipboard pasting failures with images, and the fallback catches those cases that WPF can't handle or is too finicky about. While it may miss opacity, at least it will return something (and opacity is rarely an issue).\n\nNote that there might still be scenarios where the WPF GetImage() is called - succeeds, but doesn't produce an ImageSource that renders. This is unfortunate because there appears to be no good way to detect this failure. An ImageSource is returned and it has data, but it just doesn't render.\n\n[!\\[\\](/images/sponsors/BearingDownTheMountain-DisplayAd.jpg)](https://goldenbeartshirts.com)\n\nOverall I find that these days most images are covered by PNG and one of the Bitmap formats, with only a few odd calls ending up in the WPF GetImage() logic.\n\nWith this code in place, I now have proper working images from any source and including transparency:\n\n![Working Image From Clipboard](https://weblog.west-wind.com/images/2025/Clipboard-Data-and-Wpf-ImageSource-Conversions-Revisited/WorkingImageFromClipboard.jpg)\n\n**Figure 4** - Example of a captured 32bit image with transparency.\n\nYay!\n\n## Summary\n\nWPF Image Clipboard operations have been notoriously difficult to work with, but with this circuitous workaround described in this post, that first loads a bitmap and then an ImageSource from that, it's possible to load the vast majority of images reliably. For those that still fail, the fallback to `Windows.Forms.Clipboard` usually captures the rest.\n\nIf you don't need to capture transparent images, you can bypass all this madness and simply use `Windows.Forms.Clipboard.GetImage()` with a `try/catch` block around it. This works almost universally and is by far the easiest. For the rest, the code described here can be easily packaged into an application and shipped inline as part of a ClipboardHelper class.\n\n### Other Posts you might also like\n\n- [Using SQL Server on Windows ARM](https://weblog.west-wind.com/posts/2024/Oct/24/Using-Sql-Server-on-Windows-ARM)\n- [Fighting through Setting up Microsoft Trusted Signing](https://weblog.west-wind.com/posts/2025/Jul/20/Fighting-through-Setting-up-Microsoft-Trusted-Signing)\n- [Web Browser Control & Specifying the IE Version](https://weblog.west-wind.com/posts/2011/May/21/Web-Browser-Control-Specifying-the-IE-Version)\n- [Programmatic Html to PDF Generation using the WebView2 Control with .NET](https://weblog.west-wind.com/posts/2024/Mar/26/Html-to-PDF-Generation-using-the-WebView2-Control)\n\nShare on:\n\nhttps://twitter.com/intent/tweet?url=https://weblog.west-wind.com/posts/2025/Feb/21/Retrieving-Images-from-the-Clipboard-Reliably-in-WPF-Revisited&amp;text=Retrieving%20Images%20from%20the%20Clipboard%20Reliably%20in%20WPF%20Revisited&amp;via=RickStrahl\n\nhttps://www.facebook.com/sharer/sharer.php?u=https://weblog.west-wind.com/posts/2025/Feb/21/Retrieving-Images-from-the-Clipboard-Reliably-in-WPF-Revisited&amp;t=Retrieving%20Images%20from%20the%20Clipboard%20Reliably%20in%20WPF%20Revisited http://www.reddit.com/submit?url=https://weblog.west-wind.com/posts/2025/Feb/21/Retrieving-Images-from-the-Clipboard-Reliably-in-WPF-Revisited&amp;title=Retrieving%20Images%20from%20the%20Clipboard%20Reliably%20in%20WPF%20Revisited\n\n![Make Donation](/images/donation.png \"Find this content useful? Consider making a small donation.\")\n\nIs this content useful to you? **Consider making a small donation** to show your support.\n\nPosted in **[WPF](/ShowPosts.aspx?Category=WPF)Â Â [Windows](/ShowPosts.aspx?Category=Windows)**",
  "PubDate": "2025-02-22T08:09:36+00:00"
}
