{
  "Tags": [
    ".NET",
    "apphost",
    "internals",
    "muxer",
    "runtime"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Steve Gordon – Code with Steve",
  "ProcessedDate": "2025-08-05 14:30:43",
  "FeedUrl": "https://www.stevejgordon.co.uk/feed",
  "Title": "A Brief Introduction to the .NET Muxer (aka dotnet.exe)",
  "Description": "This post marks the start of what I expect will be a long-term effort to explore the inner workings of .NET, expose the “magic” behind the scenes, and explain the mechanisms and underlying components of the .NET execution model. Today, we begin with a brief introduction to the .NET muxer (dotnet.exe). Note: These posts are […]\n\nThe post [A Brief Introduction to the .NET Muxer (aka dotnet.exe)](https://www.stevejgordon.co.uk/a-brief-introduction-to-the-dotnet-muxer) appeared first on [Steve Gordon - Code with Steve](https://www.stevejgordon.co.uk).\n\n[A Brief Introduction to the .NET Muxer (aka dotnet.exe)](https://www.stevejgordon.co.uk/a-brief-introduction-to-the-dotnet-muxer) was first posted on October 25, 2024 at 8:57 am. ©2017 \"[Steve Gordon's Blog](https://www.stevejgordon.co.uk)\". Use of this feed is for personal non-commercial use only. If you are not reading this article in your feed reader, then the site is guilty of copyright infringement. Please contact me at sgordon@hotmail.co.uk",
  "Link": "https://www.stevejgordon.co.uk/a-brief-introduction-to-the-dotnet-muxer",
  "FeedName": "Steve Gordon's Blog",
  "Author": "Steve Gordon",
  "EnhancedContent": "Skip to main content\n\n![Blog post header image with the title &quot;A Brief Introduction to the .NET Muxer (aka dotnet.exe)&quot;](https://www.stevejgordon.co.uk/wp-content/uploads/2024/10/A-Brief-Introduction-to-the-.NET-Muxer-aka-dotnet.exe_-750x410.png) This post marks the start of what I expect will be a long-term effort to explore the inner workings of .NET, expose the “magic” behind the scenes, and explain the mechanisms and underlying components of the .NET execution model. Today, we begin with a brief introduction to the .NET muxer (dotnet.exe).\n\n> >\n> Note: These posts are a deep dive into .NET internals and won’t typically apply to day-to-day development. While they might not have direct coding applications, understanding these concepts can aid in debugging complex issues or optimizing performance. This series primarily serves as a tool to expand my own understanding of .NET at a deeper level.\n> >\n\nYou will have used the .NET muxer regularly without paying it much attention. When using an IDE, it will automate using the muxer, but I expect that nearly all .NET developers who have worked with .NET (Core and 5+) will have also manually interacted with it. You will know it by its more familiar name, dotnet.exe. In some older documentation, you may also see it referred to as CoreHost (or variations thereof).\n\nThe .NET executable (**dotnet.exe**) is the workhorse for much of what we do as .NET developers. The term ‘muxer’ is short for ‘multiplexer’ and refers to a tool that acts as a single entry point to manage multiple versions of the .NET SDK and runtime. It directs commands to the appropriate version for building, running, and managing .NET applications, simplifying version management and usage. dotnet.exe serves as the “.NET command-line interface (CLI) entry point,” routing commands to the appropriate .NET functionality.\n\nWhen you install the .NET runtime and/or the .NET SDK on your PC, a single instance of dotnet.exe is installed. By default, it lives in the root of the .NET installation directory, ‘C:\\Program Files\\dotnet’ on my Windows PC. This is true even when you have multiple side-by-side versions of the runtime/SDK installed. Generally, the version matches the newest SDK or runtime that you have installed. This dotnet executable selects the appropriate SDK or runtime version based on the application’s configuration or the global settings.\n\nThe code for the muxer lives inside the [runtime repository](https://github.com/dotnet/runtime) as part of the native code base. Let’s begin our journey in **corehost.cpp** with the [main entry point](https://github.com/dotnet/runtime/blob/release/9.0-rc2/src/native/corehost/corehost.cpp#L298). This file resides in the .NET runtime repository and is part of the native codebase that interacts with the .NET runtime and app hosts.\n\n> >\n> NOTE: I’m using the .NET 9 RC2 tag as the most current release at the time of writing this post. I recommend following along with the code open in another browser tab. I’ll include some truncated code in this blog post, but I will avoid copying large portions.\n> >\n\nIn the main function, we can observe some preprocessor directives referring to `FEATURE_APPHOST` . In addition to being compiled as the dotnet executable, significant portions of this code are reused to create the ‘**apphost**‘, which allows .NET applications to run as a (potentially standalone) executable, giving them a native executable wrapper. You will likely have seen an executable produced alongside the DLL(s) created at build time by modifying a common base apphost executable. We won’t get into the apphost concept today, but the core logic for locating the correct runtime version is common to both scenarios. I’ll skip over the code intended for the apphost scenario for now.\n\n```\n\ntrace::setup();\n\nif (trace::is_enabled()) { trace::info(_X(\"--- Invoked %s [version: %s] main = {\"), CURHOST_TYPE, get_host_version_description().c_str()); for (int i = 0; i < argc; ++i) { trace::info(_X(\"%s\"), argv[i]); } trace::info(_X(\"}\")); }\n\n...\n\nint exit_code = exe_start(argc, argv);\n\ntrace::flush();\n\n...\n\nreturn exit_code; ```\n\nThe bulk of the logic lives inside exe\\_start. Before calling that, the preceding code from the main method sets up tracing if enabled. Tracing is not enabled by default, but we can set the `COREHOST_TRACE` environment variable to turn it on. When enabled, we will see detailed trace information as dotnet.exe does its work. This can be used for debugging .NET applications or troubleshooting runtime issues. By default, the trace output is sent to stderr, but its destination can be configured by setting `COREHOST_TRACEFILE` to provide a file location instead. We can also use the `COREHOST_TRACE_VERBOSITY` environment variable to control how detailed the tracing is. By default, level 4 is used, which captures the most detailed output, but you can opt to dial this down to smaller values to reduce the verbosity.\n\nFor example, we can enable this in Windows PowerShell for the current terminal session:\n\n```\n\n$Env:COREHOST_TRACE = 1 ```\n\nIf we then run dotnet without any command line arguments, we see the following output (truncated for brevity):\n\n```\n\nTracing enabled @ Wed Oct 23 06:44:22 2024 GMT --- Invoked dotnet [version: 9.0.0-rc.2.24473.5 @Commit: 990ebf52fc408ca45929fd176d2740675a67fab8] main = { C:\\Program Files\\dotnet\\dotnet.exe }\n\nUsage: dotnet [options] Usage: dotnet [path-to-application] … ```\n\nAfter invoking dotnet.exe without any arguments, we see some basic instructions on its use. Before that, the initial tracing output shows that we successfully enabled tracing and invoked the main method.\n\nLet’s continue our journey and turn our focus to the [exe_start function](https://github.com/dotnet/runtime/blob/release/9.0-rc2/src/native/corehost/corehost.cpp#L108). It first [resolves](https://github.com/dotnet/runtime/blob/release/9.0-rc2/src/native/corehost/corehost.cpp#L117) the executable’s (host’s) path, dealing with symlinks if they apply. It then performs a [basic security check](https://github.com/dotnet/runtime/blob/release/9.0-rc2/src/native/corehost/corehost.cpp#L162) to ensure the executable name (without the extension) matches “dotnet”. This security feature is implemented to prevent tampering with the dotnet.exe name and ensure authenticity. Microsoft signs dotnet.exe, so they want to avoid someone renaming the executable (perhaps to bundle it with their application), which would then make the signature a little misleading.\n\nIf we try to rename the exe and run it, we see the following error:\n\n```\n\nTracing enabled @ Wed Oct 23 07:25:33 2024 GMT --- Invoked dotnet [version: 9.0.0-rc.2.24473.5 @Commit: 990ebf52fc408ca45929fd176d2740675a67fab8] main = { C:\\Program Files\\dotnet2.exe } Error: cannot execute dotnet when renamed to dotnet2. ```\n\nThe executable terminates at this point with a core host entry point failure and an exit code of 0x80008084.\n\nNext, **exe\\_start** [checks the number of arguments](https://github.com/dotnet/runtime/blob/release/9.0-rc2/src/native/corehost/corehost.cpp#L174) passed to it. If there is less than one argument, some hardcoded usage guidance is printed to the terminal, instructing the user to provide options, CLI command or a path to a .NET DLL to load and run. In this case, the executable terminates with an invalid argument length exit code (0x80008081).\n\nAt this point, the next phase of the muxer logic begins. That’s where I’ll leave this short intro post. In the [next post](https://www.stevejgordon.co.uk/how-dotnet-muxer-resolves-and-loads-the-hostfxr-library), we’ll work towards the inner details of **host\\_fxr** and learn how the hostfxr.dll is located and loaded.\n\n### Other posts in this series:\n\n- A Brief Introduction to the .NET Muxer (aka dotnet.exe) [This post]\n- [How dotnet.exe resolves and loads the hostfxr library – Exploring the .NET muxer](https://www.stevejgordon.co.uk/how-dotnet-muxer-resolves-and-loads-the-hostfxr-library)\n\nHave you enjoyed this post and found it useful? If so, please consider supporting me:\n\n[!\\[Buy me a coffee\\](https://cdn.buymeacoffee.com/buttons/bmc-new-btn-logo.svg)Buy me a coffee](https://www.buymeacoffee.com/stevejgordon) [!\\[Donate with PayPal\\](https://www.stevejgordon.co.uk/wp-content/uploads/2020/07/PaypalLogo.png)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=WV4JPPV9FS34L&source=url)\n\n![](https://secure.gravatar.com/avatar/863d6186d3bc32b7c9036101c47d5d5b?s=60&#038;d=blank&#038;r=g)\n\n#### [Steve Gordon](https://www.stevejgordon.co.uk/author/stevejgordon)\n\nSteve Gordon is a Pluralsight author, 7x Microsoft MVP, and a .NET engineer at [Elastic](https://www.elastic.co) where he maintains the .NET APM agent and related libraries. Steve is passionate about community and all things .NET related, having worked with ASP.NET for over 21 years.\n\nSteve enjoys sharing his knowledge through his blog, in videos and by presenting talks at user groups and conferences. Steve is excited to participate in the active .NET community and founded .NET South East, a .NET Meetup group based in Brighton. He enjoys contributing to and maintaining OSS projects. You can find Steve on most social media platforms as [@stevejgordon](https://twitter.com/stevejgordon)",
  "PubDate": "2024-10-25T08:57:43+00:00"
}
