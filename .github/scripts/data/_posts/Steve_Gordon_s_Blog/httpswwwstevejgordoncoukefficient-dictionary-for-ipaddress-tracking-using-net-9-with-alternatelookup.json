{
  "Tags": [
    ".NET",
    ".NET 9",
    "AlternateLookup",
    "C#",
    "IAlternateEqualityComparer",
    "low-allocation",
    "performance",
    "ReadOnlySpan",
    "span"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Steve Gordon – Code with Steve",
  "ProcessedDate": "2025-08-05 14:30:43",
  "FeedUrl": "https://www.stevejgordon.co.uk/feed",
  "Title": "An Efficient Dictionary for IPAddress Tracking using .NET 9 with AlternateLookup and IAlternateEqualityComparer",
  "Description": "In this post, I will introduce and demonstrate enhancements to collections in .NET 9 and C# 13 for low-allocation code paths. Specifically, I will demonstrate using a custom IAlternateEqualityComparer and the AlternateLookup on a Dictionary used for efficiently tracking IP address information, keyed on the bytes of IP addresses. My use case, the basis for […]\n\nThe post [An Efficient Dictionary for IPAddress Tracking using .NET 9 with AlternateLookup and IAlternateEqualityComparer](https://www.stevejgordon.co.uk/efficient-dictionary-for-ipaddress-tracking-using-net-9-with-alternatelookup-and-ialternateequalitycomparer) appeared first on [Steve Gordon - Code with Steve](https://www.stevejgordon.co.uk).\n\n[An Efficient Dictionary for IPAddress Tracking using .NET 9 with AlternateLookup and IAlternateEqualityComparer](https://www.stevejgordon.co.uk/efficient-dictionary-for-ipaddress-tracking-using-net-9-with-alternatelookup-and-ialternateequalitycomparer) was first posted on October 2, 2024 at 8:58 am. ©2017 \"[Steve Gordon's Blog](https://www.stevejgordon.co.uk)\". Use of this feed is for personal non-commercial use only. If you are not reading this article in your feed reader, then the site is guilty of copyright infringement. Please contact me at sgordon@hotmail.co.uk",
  "Link": "https://www.stevejgordon.co.uk/efficient-dictionary-for-ipaddress-tracking-using-net-9-with-alternatelookup-and-ialternateequalitycomparer",
  "FeedName": "Steve Gordon's Blog",
  "Author": "Steve Gordon",
  "EnhancedContent": "Skip to main content\n\n![Header image for blog post about creating an efficient Dictionary for IPAddress tracking using .NET 9 with AlternateLookup and IAlternateEqualityComparer](https://www.stevejgordon.co.uk/wp-content/uploads/2024/10/An-Efficient-Dictionary-for-IPAddress-Tracking-using-.NET-9-with-AlternateLookup-and-IAlternateEqualityComparer-750x410.png) In this post, I will introduce and demonstrate enhancements to collections in .NET 9 and C# 13 for low-allocation code paths. Specifically, I will demonstrate using a custom `IAlternateEqualityComparer` and the `AlternateLookup` on a `Dictionary` used for efficiently tracking IP address information, keyed on the bytes of IP addresses.\n\nMy use case, the basis for the techniques shown here, was tracking the number of requests from non-GitHub IP addresses when handling GitHub webhooks. I wanted to use a dictionary to store a small amount of state, keyed by the IP address. One of my goals was to be as performant and memory-efficient as possible; another was to learn about this new feature of collections.\n\nIn this post, I’ll simplify this scenario as much as possible so we can focus on the new C# 13 `AlternateLookup` feature of the Dictionary. I plan to return to this topic with a deeper, more advanced post describing my IP address tracking implementation in greater detail.\n\nWhenever the application handles a request from an IP address which is not a known GitHub IP, we should either add that IP to the dictionary (if it does not exist) or retrieve the state already held in the dictionary for that IP.\n\nWe’ll begin by defining a dictionary to hold our data:\n\n```\n\nvar dictionary = new Dictionary<ReadOnlyMemory<byte>, string>(ReadOnlyMemoryComparer.Default); ```\n\nIn this pared-down example, the value type for this dictionary is a string. It’s a small class in the real scenario, but that detail is unimportant for now. The key is defined as `ReadOnlyMemory<byte>` , which simplifies some of the later code. In practice, this will always be an array of bytes when a new entry is added to the dictionary. A custom comparer has been passed in, and we’ll come to that soon.\n\nWhen we need to check a remote `IPAddress` for a connection, we’ll first check if we have an existing entry for that IP. During this check, I wanted to avoid any unnecessary allocations. Therefore, ideally, we’ll use a `ReadOnlySpan<byte>` to hold the bytes of the IP we want to look up/add. This allows us to avoid intermediate allocations when preparing that data.\n\n```\n\nvar ipAddress = IPAddress.Parse(\"172.100.50.50\"); var size = ipAddress.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork ? 4 : 16;\n\nSpan<byte> key = stackalloc byte[size];\n\nif (!ipAddress.TryWriteBytes(key, out var bytesWritten)) { // Should never happen }\n\nkey = key[..bytesWritten]; ```\n\nIn the above example, we can stack allocate a small byte buffer to hold the bytes representing the IP address we have received. By defining this local variable as a `Span<byte>` we can use `stackalloc` without the unsafe keyword. Using the `TryWriteBytes` method on the `IPAddress` we can populate that buffer with the bytes of the IP address. While we expect the buffer to be correctly sized, we slice the Span using the range operator to the correct length based on the bytes written into the buffer.\n\nAt his point, pre .NET 9, we’d be stuck. We have a `Span<byte>` that we want to look up, but our dictionary uses `ReadOnlyMemory<byte>` for the key. Fortunately, .NET 9 brings a new feature to some of the generic collection types, allowing us to use an alternate type for the key lookup. To use this feature, we’ll first need to define an `IAlternateEqualityComparer<TAlternate,T>` to assist in the comparison.\n\nI’ll provide the complete code for such a comparer and then discuss the details.\n\n```\n\ninternal sealed class ReadOnlyMemoryComparer : IEqualityComparer<ReadOnlyMemory<byte>>, IAlternateEqualityComparer<ReadOnlySpan<byte>, ReadOnlyMemory<byte>> { public static IEqualityComparer<ReadOnlyMemory<byte>> Default { get; } = new ReadOnlyMemoryComparer();\n\npublic ReadOnlyMemory<byte> Create(ReadOnlySpan<byte> alternate) => alternate.ToArray();\n\npublic bool Equals(ReadOnlySpan<byte> alternate, ReadOnlyMemory<byte> other) => alternate.SequenceEqual(other.Span);\n\npublic bool Equals(ReadOnlyMemory<byte> x, ReadOnlyMemory<byte> y) => x.Span.SequenceEqual(y.Span);\n\npublic int GetHashCode(ReadOnlySpan<byte> alternate) { HashCode hc = default; hc.AddBytes(alternate); return hc.ToHashCode(); }\n\npublic int GetHashCode(ReadOnlyMemory<byte> obj) => GetHashCode(obj.Span); } ```\n\nOur class implements both `IEqualityComparer<ReadOnlyMemory<byte>>` and `IAlternateEqualityComparer<ReadOnlySpan<byte>, ReadOnlyMemory<byte>>` . Crucially, we can now pass a Span/ReadOnlySpan as a generic argument when the constraints use the “allows ref struct” keyword combination in the `where` clause.\n\nWe must provide two implementations for `Equals` and `GetHashCode` .\n\nIEqualityComparer.Equals(ReadOnlyMemory&lt;byte&gt; x, ReadOnlyMemory&lt;byte&gt; y) is pretty easy as we can access the `Span` property on both `ReadOnlyMemory<byte>` instances and then use the optimised `SequenceEqual` method to check if the bytes are the same. IAlternateEqualityComparer.Equals(ReadOnlySpan&lt;byte&gt; alternate, ReadOnlyMemory&lt;byte&gt; other) is equally straightforward and pretty self-explanatory.\n\nIAlternateEqualityComparer.GetHashCode(ReadOnlySpan&lt;byte&gt; alternate) uses the `HashCode` type, adding the bytes and returning the hashcode. IEqualityComparer.GetHashCode(ReadOnlyMemory&lt;byte&gt; obj) calls into this method since we can easily access a Span from the `ReadOnlyMemory<byte>` .\n\nThe final method defined on `IAlternateEqualityComparer` that we must implement is the `Create` method. This accepts our alternate type `ReadOnlySpan<byte>` and must return the key type `ReadOnlyMemory<byte>` . This will be used when adding an item to the dictionary to handle the conversion. In the above implementation, we call `ToArray` on the span to create an array. Since this can be implicitly converted to `ReadOnlyMemory<byte>` , this compiles without issue. This is incurring a small heap allocation, but we can’t avoid it as we need an instance to use as the key.\n\nThe implementation above also caches an instance of this comparer, which is accessed via the `Default` property, so we only need to allocate one instance. It’s that default instance that we passed into the constructor for the dictionary.\n\nWe’re now ready to leverage the new features of .NET 9 to employ our new Span-based comparer.\n\n```\n\nvar alternateLookup = dictionary.GetAlternateLookup<ReadOnlySpan<byte>>(); ```\n\nWe can now call `GetAlternateLookup<TAlternate>` on the dictionary to access methods to operate on the dictionary based on a `ReadOnlySpan<byte>` .\n\nRemember that stack-allocated buffer we filled earlier? We can now use it when adding an entry to the dictionary.\n\n```\n\nalternateLookup[buffer] = \"Hello, world!\"; ```\n\nThis will trigger the `IAlternateEqualityComparer.Create` method which converts that `Span<byte>` into an array, making it safe to store.\n\nOf course, we can perform other standard dictionary operations, such as checking whether an IP address is already present.\n\n```\n\nvar exists = alternateLookup.ContainsKey(buffer); //true ```\n\nBy using `AlternateLookup` , we can now look up items in the dictionary with sliced data from existing memory or stack allocated memory for small items. In this particular example, we could have achieved a similar result by using `IPAddress` directly as the key; however, holding onto those objects which have a slightly larger size was something I wanted to see if I could avoid. I expect the comparisons also to be faster when using the `Span<byte>` ; however, reliably benchmarking that proved complicated because of how the `IPAddress` class is implemented internally.\n\n## Conclusion\n\nThis has been a basic introduction to the `AlternateLookup` feature added to .NET 9. Keep this in mind if you’re working with collections and need to avoid intermediate allocations for the key lookup value. The canonical example would be for a string-keyed dictionary, where we can now avoid allocating strings, by parsing a `Span<char>` to perform a check for a matching entry. `StringComparer` already implements the new interface, requiring little effort to leverage.\n\nAs I’ve shown, crafting a custom compare is not too complicated and works well in scenarios where we can use a Span&lt;T&gt; to parse or produce a key value without heap allocating when we want to perform lookups on a collection.\n\nHave you enjoyed this post and found it useful? If so, please consider supporting me:\n\n[!\\[Buy me a coffee\\](https://cdn.buymeacoffee.com/buttons/bmc-new-btn-logo.svg)Buy me a coffee](https://www.buymeacoffee.com/stevejgordon) [!\\[Donate with PayPal\\](https://www.stevejgordon.co.uk/wp-content/uploads/2020/07/PaypalLogo.png)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=WV4JPPV9FS34L&source=url)\n\n![](https://secure.gravatar.com/avatar/863d6186d3bc32b7c9036101c47d5d5b?s=60&#038;d=blank&#038;r=g)\n\n#### [Steve Gordon](https://www.stevejgordon.co.uk/author/stevejgordon)\n\nSteve Gordon is a Pluralsight author, 7x Microsoft MVP, and a .NET engineer at [Elastic](https://www.elastic.co) where he maintains the .NET APM agent and related libraries. Steve is passionate about community and all things .NET related, having worked with ASP.NET for over 21 years.\n\nSteve enjoys sharing his knowledge through his blog, in videos and by presenting talks at user groups and conferences. Steve is excited to participate in the active .NET community and founded .NET South East, a .NET Meetup group based in Brighton. He enjoys contributing to and maintaining OSS projects. You can find Steve on most social media platforms as [@stevejgordon](https://twitter.com/stevejgordon)",
  "PubDate": "2024-10-02T08:58:07+00:00"
}
