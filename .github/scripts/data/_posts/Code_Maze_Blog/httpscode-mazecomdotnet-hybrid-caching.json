{
  "Tags": [
    "ASP.NET Core",
    "Caching",
    "Distributed Caching",
    "Hybrid Caching",
    "InMemory Caching"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Code Maze",
  "ProcessedDate": "2025-08-05 14:18:56",
  "FeedUrl": "https://code-maze.com/feed/",
  "Title": "Hybrid Caching in ASP.NET Core",
  "Description": "In this article, we’ll introduce hybrid caching in .NET, a new cache type that bridges the existing cache mechanisms in .NET: distributed cache and memory cache. We’ll start by briefly explaining a cache and how existing caches in .NET work. After that, we’ll explore hybrid caching and show how it can be used and configured […]\n\nThe post [Hybrid Caching in ASP.NET Core](https://code-maze.com/dotnet-hybrid-caching/) appeared first on [Code Maze](https://code-maze.com).",
  "Link": "https://code-maze.com/dotnet-hybrid-caching/",
  "FeedName": "Code Maze Blog",
  "Author": "Bozo Spoljaric",
  "EnhancedContent": "# Hybrid Caching in ASP.NET Core\n\nPosted by [Bozo Spoljaric](https://code-maze.com/author/bozo-spoljaric/) | Updated Date Jun 26, 2025 | [0](https://code-maze.com/dotnet-hybrid-caching/#comments)\n\n![Hybrid Caching in ASP.NET Core](https://code-maze.com/wp-content/uploads/2021/12/social-aspnetcore.png)\n\n[!\\[Code Maze Book Collection\\](https://code-maze.com/wp-content/uploads/2024/10/courses-template-wide.png)](https://courses.code-maze.com/courses/?source=tbanner&p=dotnet-hybrid-caching/)\n\nReady to take your skills to the next level? Jump into our high-impact courses in web development and software architecture, all with a focus on mastering the .NET/C# framework. Whether you're **building sleek web applications or designing scalable software solutions**, our expert-led training will give you the tools to succeed. Visit our **[COURSES](https://courses.code-maze.com/courses/?source=tbanner&p=dotnet-hybrid-caching/)** page now and kickstart your journey!\n\nIn this article, we’ll introduce hybrid caching in .NET, a new cache type that bridges the existing cache mechanisms in .NET: distributed cache and memory cache. We’ll start by briefly explaining a cache and how existing caches in .NET work. After that, we’ll explore hybrid caching and show how it can be used and configured in .NET applications. Finally, we’ll compare the mentioned types of cache.\n\nTo download the source code for this article, you can visit our [GitHub repository](https://github.com/CodeMazeBlog/CodeMazeGuides/tree/main/aspnetcore-features/HybridCachingDotNet).\n\nLet’s start!\n\n## Caching in .NET\n\n**Caching stores data in memory for faster access than getting data from its source.** .NET implements two types of caching: in-memory and distributed caching.\n\nSupport Code Maze on Patreon to get rid of ads and get the best discounts on our products!\n\n[![Become a patron at Patreon!](https://code-maze.com/wp-content/plugins/patron-plugin-pro/plugin/lib/patron-button-and-widgets-by-codebard/images/become_a_patron_button.png)](https://www.patreon.com/oauth2/become-patron?response_type=code&amp;min_cents=100&amp;client_id=9_akhcsDQMGo-FTlVmNpM_uxSV4fbW3vnrz7CBRV9RxwjMPCLfWgodhrcE0UuHH4&amp;scope=identity%20identity[email]&amp;redirect_uri=https://code-maze.com/patreon-authorization/&amp;state=eyJmaW5hbF9yZWRpcmVjdF91cmkiOiJodHRwczpcL1wvY29kZS1tYXplLmNvbVwvaGF0ZW9hcy1hc3BuZXQtY29yZS13ZWItYXBpXC8ifQ%3D%3D&amp;utm_source=https%3A%2F%2Fcode-maze.com%2Fhateoas-aspnet-core-web-api%2F&amp;utm_medium=patreon_wordpress_plugin&amp;utm_campaign=11086160&amp;utm_term=&amp;utm_content=post_unlock_button)\n\n[In-memory caching](https://code-maze.com/aspnetcore-in-memory-caching/) uses server local memory to store data that we frequently access.\n\nConversely, [distributed caching](https://code-maze.com/aspnetcore-distributed-caching/) stores data using external services and enables multiple servers to use the same data.\n\n## Hybrid Caching in .NET / ASP.NET Core\n\n**Hybrid caching in .NET employs both types of cache storage**. It introduces two-level caching:\n\n- local in-memory caching as its primary storage (L1)\n- distributed caching as its secondary storage (L2)\n\nWith this approach, hybrid caching keeps fast in-memory access and persistence and scalability of data through its secondary, external storage.\n\n### Add and Configure Hybrid Caching in .NET\n\nTo add hybrid caching to our application, we have to install `Microsoft.Extension.Caching.Hybrid` NuGet package:\n\n`dotnet add package Microsoft.Extensions.Caching.Hybrid`\n\n**To add the `HybridCache` service, we can call the `IServiceCollection` extension `AddHybridCache()`:**\n\n`builder.Services.AddHybridCache();`\n\nThis extension comes with overload, which means we can configure different options for the `HybridCache` service:\n\n``` builder.Services.AddHybridCache(options => { options.MaximumPayloadBytes = 1024 * 10 * 10; options.MaximumKeyLength = 256;\n\noptions.DefaultEntryOptions = new HybridCacheEntryOptions { Expiration = TimeSpan.FromMinutes(30), LocalCacheExpiration = TimeSpan.FromMinutes(30) };\n\noptions.ReportTagMetrics = true; options.DisableCompression = true; }); ```\n\nWith the `HybridCacheOptions` class, we can configure:\n\nIs this material useful to you? Consider subscribing and get **ASP.NET Core Web API Best Practices** eBook for [FREE!](https://code-maze.com/free-ebook-aspnetcore-webapi-best-practices/)\n\n- `MaximumPayloadBytes`\n– the maximum size of the cache items in bytes. In this example, we configure it to 10MB. The default value is 1MB. If we try to store an item bigger than this configured value, `HybridCache` logs the error and doesn’t store the item\n- `MaximumKeyLength`\n– the maximum size of the cache item key in the number of characters. The default value is 1024, and we set it to 256\n- `ReportTagMetrics`\n– indicating whether to use tags in metric reporting\n- `DisableCompression`\n– disabling compression for the particular `HybridCache` instance\n- `DefaultEntryOptions`\n– the `HybridCacheOptions` class with two properties: `Expiration` , which determines the duration of the distributed (L2) cache, and `LocalCacheExpiration` , which determines the duration of the local in-memory (L1) cache. If set in `HybridCacheOptions` , these values will be default values but can be overridden for each specific entry\n\n**When we use and configure any distributed cache, `HybridCache` will automatically detect it and use it as the L2 distributed cache.**\n\nDistributed cache requires serialization. `HybridCache` handles `string` and `bytes[]` internally. For everything else, it uses `System.Text.Json` .\n\nAdditionally, `HybridCache` can use other serializers. To configure them, we can chain `AddSerializer<T>()` to add the serializer for a specific type or `AddSerializerFactory()` to add the serializer for multiple types.\n\n## Use Hybrid Caching in ASP.NET Core\n\nThe hybrid cache library exposes a unified API to get, add, or invalidate values in the cache. In our examples, we’ll use the simple `CmCourse` class:\n\n``` public class CmCourse { public int Id { get; set; }\n\npublic required string Name { get; set; }\n\npublic required string Category { get; set; } } ```\n\nNext, we define the `ICmCourseService` that we will use in minimal API calls:\n\n``` public interface ICmCourseService { Task<CmCourse?> GetCourseAsync(int id, CancellationToken cancellationToken = default);\n\nTask PosttCourseAsync(CmCourse course, CancellationToken cancellationToken = default);\n\nTask InvalidateByCourseIdAsync(int id, CancellationToken cancellationToken = default);\n\nTask InvalidateByCategoryAsync(string tag, CancellationToken cancellationToken = default); } ```\n\nThis interface describes reading, creating, and deleting the values from the data source.\n\nThe interface implementation class – `CmCourseService` requires the injection of `HybridCache` service in its constructor. Additionally, inside the `CmCourseService` class, you can find the private `courseList` field, which mocks the data storage for our example:\n\n``` public class CmCourseService(HybridCache cache) : ICmCourseService { public static readonly List<CmCourse> courseList = [ new CmCourse { Id = 1, Name = \"WebAPI\", Category = \"Backend\" }, new CmCourse { Id = 2, Name = \"Microservices\", Category = \"Backend\" }, new CmCourse { Id = 3, Name = \"Blazor\", Category = \"Frontend\" }, ];\n\n... } ```\n\nLet’s explore each of the `HybridCache` methods and their implementation in `CmCourseService` .\n\nIs this material useful to you? Consider subscribing and get **ASP.NET Core Web API Best Practices** eBook for [FREE!](https://code-maze.com/free-ebook-aspnetcore-webapi-best-practices/)\n\n### Read the Entry From the Cache\n\nThe `GetOrCreateAsync()` method will try to read the value for a provided key from the cache:\n\n``` public async Task<CmCourse?> GetCourseAsync(int id, CancellationToken cancellationToken = default) { return await cache.GetOrCreateAsync($\"course-{id}\", async token => { await Task.Delay(1000, token); var course = courseList.FirstOrDefault(course => course.Id == id);\n\nreturn course; }, options: new HybridCacheEntryOptions { Expiration = TimeSpan.FromMinutes(30), LocalCacheExpiration = TimeSpan.FromMinutes(30) }, tags: [\"course\"], cancellationToken: cancellationToken ); } ```\n\n**The `GetOrCreateAsync()` method first tries to read the value for the key `$\"course-{id}\"` from the cache.** If the value is not in the local cache, `HybridCache` tries to get this value from the distributed cache.\n\nThe second parameter is a factory method that executes if the value doesn’t exist, and it retrieves the value from an external source, stores it in the configured caches, and returns it.\n\nThe following parameters are optional. The `options` parameter allows us to override the default values for cache duration. The `tags` parameter defines the tag that `HybridCache` sets to the new entry it adds to the cache, and the last parameter is the cancellation token.\n\nHandling both caches happens in the library itself, and the developer doesn’t need to implement any additional logic. **A very important feature of the `HybridCache` is that other concurrent requests for the same cache entry wait for the first one to finish.** Such an approach prevents the **cache stampede**, the problem that occurs when there is no required entry in the cache and too many requests get the value from the source and try to repopulate the same cache entry.\n\nThe `GetOrCreateAsync()` method has an overload that allows the definition of the state object for the factory method, reducing the overhead from captured variables.\n\n### Write the Entry to the Cache\n\nIn the most use cases, the `GetOrCreateAsync()` method is sufficient. However, the `HybridCache` implements `SetAsync()` method, which stores an entry in the cache without trying to read it first:\n\n``` public async Task PostCourseAsync(CmCourse course, CancellationToken cancellationToken = default) { courseList.Add(course); await cache.SetAsync($\"course-{course.Id}\", course, options: new HybridCacheEntryOptions { Expiration = TimeSpan.FromMinutes(30), LocalCacheExpiration = TimeSpan.FromMinutes(30) }, tags: [$\"cat-{course.Category}\"], cancellationToken: cancellationToken); } ```\n\nThe first and the second parameters are mandatory, and they set the cache key and the cache entry, respectively. The next three parameters are optional and the same as those used for the `GetOrCreateAsync()` method: options, tags, and cancellation token.\n\nIs this material useful to you? Consider subscribing and get **ASP.NET Core Web API Best Practices** eBook for [FREE!](https://code-maze.com/free-ebook-aspnetcore-webapi-best-practices/)\n\nIf the key already exists in the cache, its value will be overwritten.\n\n### Invalidate Cache Entries by Key\n\nThe method `RemoveAsync()` removes the cache entry with the specified key from the cache:\n\n``` public async Task InvalidateByCourseIdAsync(int id, CancellationToken cancellationToken = default) { await cache.RemoveAsync($\"course-{id}\", cancellationToken); } ```\n\nThe argument **`$\"course-{id}\"`** represents the key that will be removed from both L1 and L2 cache.\n\nThe method has an overload, allowing us to pass the collection of the keys to it.\n\n### Invalidate Cache Entries by Tag\n\nAs described in `GetOrCreateAsync()` and `SetAsync()` methods, we can set one or multiple tags for each cache entry. `The RemoveByTagAsync()` method removes all entries with specified tag:\n\n``` public async Task InvalidateByCategoryAsync(string tag, CancellationToken cancellationToken = default) { await cache.RemoveByTagAsync($\"cat-{tag}\", cancellationToken); } ```\n\nSimilar to the `RemoveAsync()` method, the `RemoveByTagAsync()` has an overload accepting the collection of the keys.\n\n## Benefits of Hybrid Caching in .NET\n\n**The `HybridCache` implements a simple, unified API to handle local and distributed caches using the same API call**. The local `IMemoryCache` can be replaced with `HybridCache` without much effort.\n\n**The hybrid caching is designed with async flow in mind.** As a result, the library handles concurrent operations on the cache, and the developers don’t have to implement any additional control or protection. By pausing the subsequent similar request until the first one is finished, the `HybridCache` offers cache stampede protection out of the box. The exact mechanism significantly lowers the requests for external data sources.\n\nThe tag feature enables a fast and convenient way to invalidate multiple entries with a single call. With its configurable serialization, the cache can be easily adapted for usage with, for example, `ProtoBuf` .\n\nBuilt-in metrics and monitoring also greatly help with application observability and fine-tuning.\n\n## Conclusion\n\nOn the whole, HybridCache is a very valuable addition to the .NET ecosystem. It combines the benefits and advantages of two already existing types of caching and simultaneously solves the problem that each of them has. The two-level caching enables fast access to data and horizontal scalability of the cache when the demands on the application grow.\n\nTo conclude, with a two-level approach to caching, HybridCache improves performance, allows scaling, and minimizes costs by optimizing data storage.\n\n[!\\[Code Maze Book Collection\\](https://code-maze.com/wp-content/uploads/2024/10/courses-template-wide.png)](https://courses.code-maze.com/courses/?source=bbanner&p=dotnet-hybrid-caching/)\n\nReady to take your skills to the next level? Jump into our high-impact courses in web development and software architecture, all with a focus on mastering the .NET/C# framework. Whether you're **building sleek web applications or designing scalable software solutions**, our expert-led training will give you the tools to succeed. Visit our **[COURSES](https://courses.code-maze.com/courses/?source=bbanner&p=dotnet-hybrid-caching/)** page now and kickstart your journey!\n\nLiked it? Take a second to support Code Maze on Patreon and get the ad free reading experience!\n\n[![Become a patron at Patreon!](https://code-maze.com/wp-content/plugins/patron-plugin-pro/plugin/lib/patron-button-and-widgets-by-codebard/images/become_a_patron_button.png)](https://www.patreon.com/oauth2/become-patron?response_type=code&min_cents=100&client_id=9_akhcsDQMGo-FTlVmNpM_uxSV4fbW3vnrz7CBRV9RxwjMPCLfWgodhrcE0UuHH4&scope=identity%20identity[email]&redirect_uri=https://code-maze.com/patreon-authorization/&state=eyJmaW5hbF9yZWRpcmVjdF91cmkiOiJodHRwczpcL1wvY29kZS1tYXplLmNvbVwvZG90bmV0LWh5YnJpZC1jYWNoaW5nXC8ifQ%3D%3D&utm_source=https%3A%2F%2Fcode-maze.com%2Fdotnet-hybrid-caching%2F&utm_medium=patreon_wordpress_plugin&utm_campaign=11086160&utm_term=&utm_content=post_unlock_button)\n\nShare:\n\nhttp://www.facebook.com/sharer.php?u=https://code-maze.com/dotnet-hybrid-caching/&#038;t=Hybrid%20Caching%20in%20ASP.NET%20Corehttp://twitter.com/intent/tweet?text=Hybrid%20Caching%20in%20ASP.NET%20Core%20https://code-maze.com/dotnet-hybrid-caching/http://www.linkedin.com/shareArticle?mini=true&#038;url=https://code-maze.com/dotnet-hybrid-caching/&#038;title=Hybrid%20Caching%20in%20ASP.NET%20Core\n\n### Leave a reply [Cancel reply](/dotnet-hybrid-caching/#respond)\n\nYour email address will not be published. Required fields are marked \\*\n\nCOMMENT\n\nName \\*\n\nEmail \\*\n\nWebsite\n\n#### Courses – Code Maze\n\n[!\\[code maze courses side\\](https://code-maze.com/wp-content/uploads/2024/10/code-maze-courses-template-v3.png)](https://courses.code-maze.com/courses/)\n\nWhether you want to master web development or software architecture you should check our [COURSES](https://courses.code-maze.com/courses/) and pick the one that you like.\n\n#### Ad 1\n\n#### Ad 2\n\n#### Ad 3\n\n#### Ad 4",
  "PubDate": "2025-02-10T07:02:05+00:00"
}
