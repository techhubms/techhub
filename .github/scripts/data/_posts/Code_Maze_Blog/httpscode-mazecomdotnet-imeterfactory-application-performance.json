{
  "Tags": [
    ".NET",
    "ASP.NET Core",
    "C#",
    "IMeterFactory",
    "metrics",
    "Performance"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Code Maze",
  "ProcessedDate": "2025-08-05 14:18:56",
  "FeedUrl": "https://code-maze.com/feed/",
  "Title": "Measure Application Performance in .NET Using IMeterFactory",
  "Description": "Performance monitoring is essential for ensuring that our applications run efficiently and reliably. .NET offers a set of tools to help with this, accessible via IMeterFactory. In this article, we’ll learn how to use these tools to check the health of our applications, measure performance, and collect data for optimization. So let’s get going. What […]\n\nThe post [Measure Application Performance in .NET Using IMeterFactory](https://code-maze.com/dotnet-imeterfactory-application-performance/) appeared first on [Code Maze](https://code-maze.com).",
  "Link": "https://code-maze.com/dotnet-imeterfactory-application-performance/",
  "FeedName": "Code Maze Blog",
  "Author": "Muhammed Saleem",
  "EnhancedContent": "# Measure Application Performance in .NET Using IMeterFactory\n\nPosted by [Muhammed Saleem](https://code-maze.com/author/muhammed-saleem/) | Feb 26, 2025 | [0](https://code-maze.com/dotnet-imeterfactory-application-performance/#comments)\n\n![Measure Application Performance in .NET Using IMeterFactory](https://code-maze.com/wp-content/uploads/2021/12/social-dotnet-core.png)\n\n[!\\[Code Maze Book Collection\\](https://code-maze.com/wp-content/uploads/2024/10/courses-template-wide.png)](https://courses.code-maze.com/courses/?source=tbanner&p=dotnet-imeterfactory-application-performance/)\n\nReady to take your skills to the next level? Jump into our high-impact courses in web development and software architecture, all with a focus on mastering the .NET/C# framework. Whether you're **building sleek web applications or designing scalable software solutions**, our expert-led training will give you the tools to succeed. Visit our **[COURSES](https://courses.code-maze.com/courses/?source=tbanner&p=dotnet-imeterfactory-application-performance/)** page now and kickstart your journey!\n\nPerformance monitoring is essential for ensuring that our applications run efficiently and reliably. .NET offers a set of tools to help with this, accessible via **IMeterFactory**. In this article, we’ll learn how to use these tools to check the health of our applications, measure performance, and collect data for optimization.\n\nTo download the source code for this article, you can visit our [GitHub repository](https://github.com/CodeMazeBlog/CodeMazeGuides/tree/main/aspnetcore-features/PerformanceMonitoringWithIMeterFactory).\n\nSo let’s get going.\n\n## What Are .NET Metric Instruments?\n\nIn .NET, we have various instruments available to capture an application’s performance data, such as:\n\nSupport Code Maze on Patreon to get rid of ads and get the best discounts on our products!\n\n[![Become a patron at Patreon!](https://code-maze.com/wp-content/plugins/patron-plugin-pro/plugin/lib/patron-button-and-widgets-by-codebard/images/become_a_patron_button.png)](https://www.patreon.com/oauth2/become-patron?response_type=code&amp;min_cents=100&amp;client_id=9_akhcsDQMGo-FTlVmNpM_uxSV4fbW3vnrz7CBRV9RxwjMPCLfWgodhrcE0UuHH4&amp;scope=identity%20identity[email]&amp;redirect_uri=https://code-maze.com/patreon-authorization/&amp;state=eyJmaW5hbF9yZWRpcmVjdF91cmkiOiJodHRwczpcL1wvY29kZS1tYXplLmNvbVwvaGF0ZW9hcy1hc3BuZXQtY29yZS13ZWItYXBpXC8ifQ%3D%3D&amp;utm_source=https%3A%2F%2Fcode-maze.com%2Fhateoas-aspnet-core-web-api%2F&amp;utm_medium=patreon_wordpress_plugin&amp;utm_campaign=11086160&amp;utm_term=&amp;utm_content=post_unlock_button)\n\n- **Counter&lt;T&gt;**: Tracks increasing counts, such as total requests or clicks****\n- **Gauge&lt;T&gt;**: Measures fluctuating non-cumulative values, like current memory consumption\n- **UpDownCounter&lt;T&gt;**: Captures values that can increase and decrease, such as queue sizes\n- **Histogram&lt;T&gt;**: Visualizes how data is distributed across ranges of values\n\nIn addition to these, there are observable instruments like **ObservableCounter&lt;T&gt;**, **ObservableGauge&lt;T&gt;**, and **ObservableUpDownCounter&lt;T&gt;** that report their values as they are observed.\n\nThese instruments are carefully designed for different monitoring needs, allowing accurate and meaningful performance tracking.\n\n## Configure IMeterFactory in ASP.NET Core Web API\n\nLet’s create an ASP.NET Core Web API project and configure it to use **IMeterFactory.** We need this before we can create and use the metric instruments described above.\n\n**IMeterFactory** is part of the `System.Diagnostics.Metrics` NuGet package, which is included by default in .NET 8+. This means we can directly inject `IMeterFactory` into our classes. Let’s do that now by creating a `MetricsService` class:\n\n``` public class MetricsService { public MetricsService(IMeterFactory meterFactory) { var meter = meterFactory.Create(\"Metrics.Service\"); } } ```\n\nWe define a `MetricsService` class and inject `IMeterFactory` into it to initialize a `Meter` instance. Now, we can use this `Meter` instance to define and capture metrics.\n\n## Define the IMeterFactory Instruments\n\nNext, let’s see how to capture various metrics.\n\nLet’s declare a counter for holding the number of user clicks, a histogram for reporting response times, and a couple of variables for storing requests and memory consumption:\n\n``` public class MetricsService { private readonly Counter<int> _userClicks; private readonly Histogram<double> _responseTime;\n\nprivate int _requests; private double _memoryConsumption;\n\npublic MetricsService(IMeterFactory meterFactory) { var meter = meterFactory.Create(\"Metrics.Service\");\n\n_userClicks = meter.CreateCounter<int>(\"metrics.service.user_clicks\");\n\n_responseTime = meter.CreateHistogram<double>(\"metrics.service.response_time\");\n\nmeter.CreateObservableCounter(\"metrics.service.requests\", () => _requests);\n\nmeter.CreateObservableGauge(\"metrics.service.memory_consumption\", _memoryConsumption); } } ```\n\nFirst, we initialize the counter using the `CreateCounter()` method. Next, we initialize the histogram metric with the `CreateHistogram()` method.\n\nAfter that, we set up an observable counter using the `CreateObservableCounter()` method, which returns the value of `_requests` through a callback function. Similarly, we set up an observable gauge with the `CreateObservableGauge()` method, returning the `_memoryConsumption` value via its own callback function.\n\nSince the only difference between a `Counter` and `UpDownCounter` is that the former can only increase in value, while the latter can increase *and* decrease, we will not look at `UpDownCounter` here.\n\nIs this material useful to you? Consider subscribing and get **ASP.NET Core Web API Best Practices** eBook for [FREE!](https://code-maze.com/free-ebook-aspnetcore-webapi-best-practices/)\n\n## Capture the Metrics\n\nNow, let’s add a few methods for recording these metric values in both an interface and in the class.\n\nFirst, let’s create an `IMetricsService` interface and add a few method contracts:\n\n``` public interface IMetricsService { void RecordUserClick(); void RecordResponseTime(double value); void RecordRequest(); void RecordMemoryConsumption(double value); } ```\n\nThen, let’s implement this new interface in the `MetricsService` class:\n\n``` public class MetricsService : IMetricsService { // private fields and constructor omitted for brevity public void RecordUserClick() { _userClicks.Add(1); }\n\npublic void RecordResponseTime(double value) { _responseTime.Record(value); }\n\npublic void RecordRequest() { Interlocked.Increment(ref _requests); }\n\npublic void RecordMemoryConsumption(double value) { _memoryConsumption = value; } } ```\n\nHere, the `RecordUserClick()` method increments the `_userClicks` counter by one to track the number of user clicks. The `RecordResponseTime()` method records the provided application’s response time using a histogram metric. The `RecordRequest()` method safely increments the `_requests` counter by one in a multi-threaded environment each time we call it, and the `RecordMemoryConsumption()` method updates the `_memoryConsumption` field with the provided value.\n\nAfter that, let’s create a controller class and inject `IMetricsService` into it. In the controller, let’s add a GET method to generate some metrics data and record those using the `MetricsService` methods:\n\n``` [Route(\"api/[controller]\")] [ApiController] public class MetricsController(IMetricsService metricsService) : ControllerBase { [HttpGet] public IActionResult Get() { var random = Random.Shared;\n\nmetricsService.RecordUserClick();\n\nfor (int i = 0; i < 100; i++) { metricsService.RecordResponseTime(random.NextDouble()); }\n\nmetricsService.RecordRequest();\n\nmetricsService.RecordMemoryConsumption(GC.GetAllocatedBytesForCurrentThread() / (1024 * 1024));\n\nreturn Ok(); }\n\n} ```\n\nWe begin by recording a user-click event by calling the `RecordUserClick()` method. Next, we generate random values for response time within a loop and capture those values by calling the `RecordResponseTime()` method. Afterward, we log a request event by calling the `RecordRequest()` method. Finally, we record the current thread’s memory usage in megabytes by calling the `RecordMemoryConsumption()` method.\n\nHere, the controller’s `Get()` method simulates the metrics data collection by invoking various methods from `MetricsService` with random values and returning an `HTTP 200 OK` response.\n\nFinally, let’s register the `MetricsService` in the dependency injection container:\n\nIs this material useful to you? Consider subscribing and get **ASP.NET Core Web API Best Practices** eBook for [FREE!](https://code-maze.com/free-ebook-aspnetcore-webapi-best-practices/)\n\n``` var builder = WebApplication.CreateBuilder(args); ... builder.Services.AddSingleton<IMetricsService, MetricsService>();\n\nvar app = builder.Build(); ... app.Run(); ```\n\nThis registers `MetricsService` as a singleton service for the `IMetricsService` interface throughout the application’s lifetime.\n\nAlso, make sure to add the `Swashbuckle.AspNetCore` NuGet package and configure Swagger UI in the `Program` class:\n\n``` var builder = WebApplication.CreateBuilder(args); ... builder.Services.AddSwaggerGen(); builder.Services.AddSingleton<IMetricsService, MetricsService>();\n\nvar app = builder.Build();\n\nif (app.Environment.IsDevelopment()) { app.UseSwagger(); app.UseSwaggerUI(); } ... app.Run(); ```\n\nThis will enable the Swagger UI and make it easier to visualize and run the API endpoints.\n\n## Visualize the Metrics\n\nLet’s run the API application, which should display the Swagger UI. To view the metrics, we’ll use the [dotnet-counters](https://learn.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-counters) tool.\n\nFirst, we need to install the `dotnet-counters` tool using the `dotnet tool update` command:\n\n`dotnet tool update -g dotnet-counters`\n\nOnce the tool is installed, we get a success message:\n\n```\n> dotnet tool update -g dotnet-counters\n\nYou can invoke the tool using the following command: dotnet-counters Tool 'dotnet-counters' (version '9.0.553101') was successfully installed. ```\n\nWhile the app is still running, let’s use `dotnet-counters` to monitor all the metrics from our application:\n\nIs this material useful to you? Consider subscribing and get **ASP.NET Core Web API Best Practices** eBook for [FREE!](https://code-maze.com/free-ebook-aspnetcore-webapi-best-practices/)\n\n`dotnet-counters monitor -n MetricsAPI --counters Metrics.Service`\n\nHere, we specify the `dotnet-counters` tool to monitor all metrics in the **MetricsAPI** application coming from the **MetricsService** meter. Remember that the meter name is case-sensitive.\n\nThis will bring up the metrics screen, which will be empty as we haven’t yet run the endpoint to generate those:\n\n``` Press p to pause, r to resume, q to quit. Status: Waiting for initial payload...\n\nName Current Value ```\n\nNow, let’s invoke the `\\metrics` endpoint from the Swagger UI to create the metrics and observe the output:\n\n``` Press p to pause, r to resume, q to quit. Status: Running\n\nName Current Value [Metrics.Service] metrics.service.memory_consumption 0.003 metrics.service.requests (Count) 1 metrics.service.response_time Percentile 50 0.567 95 0.938 99 0.988 metrics.service.user_clicks (Count) 1 ```\n\nAs expected, we can see the output with all metrics collected. As we run the endpoint multiple times, notice how the `user_clicks` and `request` values increment by one. On the other hand, `response_time` shows the percentile of a large set of random samples. **Although** **the** **dotnet-counters tool renders Histogram instruments as three percentile statistics (50th, 95th, and 99th), other tools might summarize the distribution differently or offer more configuration options**. Similarly, `memory_consumption` shows a different value every time as it represents a Gauge.\n\n## Add Clarity With Unit and Description\n\nWhen we define instruments, we can specify an optional unit and description. These details do not change any calculations, but they can help us understand the data in the collection tool’s interface. Currently**, the dotnet-counters tool does not show the description text, but it does display the unit if provided**.\n\nLet’s modify the `MetricsService` constructor, to specify the unit as Seconds and add a description while creating the histogram for capturing the response time:\n\n``` _responseTime = meter.CreateHistogram<double>(name: \"metrics.service.response_time\", unit: \"Seconds\", description: \"This metric measures the time taken for the application to respond to user requests.\"); ```\n\nThe option is available on observable instruments as well.\n\nLet’s modify the constructor further, to specify the unit as Megabytes and add a description while creating the observable gauge metric for memory consumption:\n\n``` meter.CreateObservableGauge(name: \"metrics.service.memory_consumption\", () => _memoryConsumption, unit: \"Megabytes\", description: \"This metric measures the amount of memory used by the application.\"); ```\n\nNow, when we run the application, hit the endpoint, and observe the metrics, we can see that the response time shows the Seconds as units, while the memory consumption shows units as Megabytes:\n\n``` Press p to pause, r to resume, q to quit. Status: Running Name Current Value [Metrics.Service] metrics.service.memory_consumption (Megabytes) 0.003 metrics.service.requests (Count) 1 metrics.service.response_time (Seconds) Percentile 50 0.532 95 0.952 99 0.976 metrics.service.user_clicks (Count) 1 ```\n\nLeveraging this, we can add units to metrics to make the data more meaningful.\n\n## Define Multi-Dimensional Metrics\n\nMeasurements can have tags that link them to key-value pairs, which helps organize data for analysis. We can use specific tags for `Counter` and `Histogram` measurements in the overloaded `Add()` and `Record()` methods, which accept one or more `KeyValuePair` arguments. For `ObservableCounter` and `ObservableGauge` , we can add tagged measurements in the callback provided to the constructor.\n\nFor example, to improve the metrics for user clicks by adding details like the user’s region and the feature clicked, we can create a method called `RecordUserClickDetailed()` in `MetricsService` . This method allows us to send these extra details to the overloaded `Counter.Add()` method:\n\n``` public void RecordUserClickDetailed(string region, string feature) { _userClicks.Add(1, new KeyValuePair<string, object?>(\"user.region\", region), new KeyValuePair<string, object?>(\"user.feature\", feature)); } ```\n\nSimilarly, let’s create a multi-dimensional gauge that reports detailed resource consumption, such as CPU, memory, and thread count. First, let’s add these additional fields to our `MetricService` class:\n\n``` private double _cpu; private double _memory; private double _threadCount; ```\n\nNext, let’s create a `GetResourceConsumption()` method that returns `IEnumerable<Measurement<int>>` :\n\n``` private IEnumerable<Measurement<double>> GetResourceConsumption() { return [ new Measurement<double>(_cpu, new KeyValuePair<string,object?> (\"resource_usage\", \"cpu\")), new Measuremcent<double>(_memory, new KeyValuePair<string,object?> (\"resource_usage\", \"memory\")), new Measurement<double>(_threadCount, new KeyValuePair<string,object?> (\"resource_usage\", \"thread_count\")), ]; } ```\n\nNext, in our constructor, we need to update the callback in our observable Gauge creation to call our new `GetResourceConsumption()` method:\n\nIs this material useful to you? Consider subscribing and get **ASP.NET Core Web API Best Practices** eBook for [FREE!](https://code-maze.com/free-ebook-aspnetcore-webapi-best-practices/)\n\n``` public MetricsService(IMeterFactory meterFactory) { // code omitted for brevity\n\nmeter.CreateObservableGauge(name: \"metrics.service.resource_consumption\", () => GetResourceConsumption()); } ```\n\nAdditionally, let’s create a `RecordResourceUsage()` method for capturing the resource usage:\n\n``` public void RecordResourceUsage(double currentCpuUsage, double currentMemoryUsage, double currentThreadCount) { _cpu = currentCpuUsage; _memory = currentMemoryUsage; _threadCount = currentThreadCount; } ```\n\nAlso, let’s create a Utility class and method to calculate the CPU usage:\n\n``` public static class Utilities { public static double GetCpuUsagePercentage() { var process = Process.GetCurrentProcess();\n\nvar startTime = DateTime.UtcNow; var initialCpuTime = process.TotalProcessorTime;\n\nThread.Sleep(1000);\n\nvar endTime = DateTime.UtcNow; var finalCpuTime = process.TotalProcessorTime;\n\nvar totalCpuTimeUsed = (finalCpuTime - initialCpuTime).TotalMilliseconds; var totalTimeElapsed = (endTime - startTime).TotalMilliseconds;\n\nvar cpuUsage = (totalCpuTimeUsed / (Environment.ProcessorCount * totalTimeElapsed)) * 100;\n\nreturn cpuUsage; } } ```\n\nThis method measures the CPU usage of the current process by capturing the CPU time used over a one-second period and calculating the percentage of CPU utilization.\n\nLastly, we need to be sure to update our `IMetricsService` interface with our two new recording methods:\n\n``` void RecordUserClickDetailed(string region, string feature); void RecordResourceUsage(double currentCpuUsage, double currentMemoryUsage, double currentThreadCount); ```\n\nNow, let’s call these methods by adding them to the end of the GET endpoint in the controller, immediately before the final `return Ok()` line:\n\n``` metricsService.RecordUserClickDetailed(\"US\", \"checkout\");\n\nmetricsService.RecordResourceUsage( Utilities.GetCpuUsagePercentage(), GC.GetTotalAllocatedBytes() / (1024 * 1024), Process.GetCurrentProcess().Threads.Count); ```\n\nWhile calling the `RecordUserClickDetailed()` method, we pass the region and feature.\n\nWhen calling the method, we pass the values for CPU usage, total memory, and thread count. We utilize the `GetCpuUsagePercentage()` utility method to obtain CPU usage, while the `GC.GetTotalAllocatedBytes()` method can supply the total memory allocated to the current process and `Process.GetCurrentProcess().Threads.Count` report the number of threads running in that process.\n\nNow, when we run the application again, exercise the endpoint, and observe the metrics, we can see it displays these details as multi-dimensional metrics:\n\nIs this material useful to you? Consider subscribing and get **ASP.NET Core Web API Best Practices** eBook for [FREE!](https://code-maze.com/free-ebook-aspnetcore-webapi-best-practices/)\n\n``` Press p to pause, r to resume, q to quit. Status: Running\n\nName Current Value [Metrics.Service] metrics.service.memory_consumption (Megabytes) 0.016 metrics.service.requests (Count) 1 metrics.service.resource_consumption resource_usage cpu 0.482 memory 6 thread_count 50 metrics.service.response_time (Seconds) Percentile 50 0.419 95 0.958 99 0.983 metrics.service.user_clicks (Count) 1 user.feature user.region checkout US 1 ```\n\nThis is an excellent way to display metrics that have multiple dimensions.\n\n## Test IMeterFactory Metrics Using MetricCollector\n\nWe can test any custom `IMeterFactory` metrics that we add to our application using the **MetricCollector&lt;T&gt;** class. This class simplifies the process of recording measurements from specific instruments and helps us verify their accuracy. Let’s see how to do this.\n\nFirst, we need to add the `Microsoft.Extensions.DependencyInjection` and `Microsoft.Extensions.Diagnostics.Testing` NuGet packages. Next, we need to define a `CreateServiceProvider()` to use in our test methods:\n\n``` private static ServiceProvider CreateServiceProvider() { var serviceCollection = new ServiceCollection(); serviceCollection.AddMetrics(); serviceCollection.AddSingleton<MetricsService>();\n\nreturn serviceCollection.BuildServiceProvider(); } ```\n\nThe `CreateServiceProvider()` method sets up a dependency injection container. It creates a new `ServiceCollection` , adds metric services, and a singleton instance of `MetricsService` , and then builds and returns a service provider that can be used to resolve these services.\n\nLet’s write a test for user click metrics using `MetricCollector<int>` :\n\n``` public void GivenMetricsConfigured_WhenUserClickRecorded_ThenCounterCaptured() { // Arrange using var services = CreateServiceProvider(); var metrics = services.GetRequiredService<MetricsService>(); var meterFactory = services.GetRequiredService<IMeterFactory>(); var collector = new MetricCollector<int>(meterFactory, \"Metrics.Service\", \"metrics.service.user_clicks\");\n\n// Act metrics.RecordUserClick();\n\n// Assert var measurements = collector.GetMeasurementSnapshot(); Assert.Single(measurements); Assert.Equal(1, measurements[0].Value); } ```\n\nThis test verifies that `MetricsService` accurately records a user’s click. It sets up the required services and metrics collector and then calls the `RecordUserClick()` method in `MetricsService` . Afterward, it checks that the metrics collector has captured exactly one user click. Here, the metric collector will collect the specified metrics and return a snapshot of the measurements collected.\n\nSimilarly, let’s write a test for request metrics which uses `ObservableCounter` :\n\n``` public void GivenMetricsConfigured_WhenRequestRecorded_ThenObservableCounterCaptured() { // Arrange using var services = CreateServiceProvider(); var metrics = services.GetRequiredService<MetricsService>(); var meterFactory = services.GetRequiredService<IMeterFactory>(); var collector = new MetricCollector<int>(meterFactory, \"Metrics.Service\", \"metrics.service.requests\");\n\n// Act metrics.RecordRequest();\n\n// Assert collector.RecordObservableInstruments(); var measurements = collector.GetMeasurementSnapshot(); Assert.Single(measurements); Assert.Equal(1, measurements[0].Value); } ```\n\nThis test verifies that the `MetricsService` accurately records a request. It sets up the necessary components, including a `MetricsService` and a `MetricCollector` , to capture metrics. The test then calls the `RecordRequest()` method on the `MetricsService` and checks that the observable counter for requests is incremented by one.\n\nIs this material useful to you? Consider subscribing and get **ASP.NET Core Web API Best Practices** eBook for [FREE!](https://code-maze.com/free-ebook-aspnetcore-webapi-best-practices/)\n\nWhen collecting observable metrics (`ObservableCounter` , `ObservableGauge` , etc), we need to call the `RecordObservableInstruments()` method on the `MetricsCollector` to scan all the observable metrics.\n\nThe `MetricCollector` simplifies the process of writing tests for the various metric collections in our application.\n\n## IMeterFactory Best Practices\n\nLet’s explore best practices for choosing and implementing **IMeterFactory** instruments. **For DI-aware libraries, avoid static variables and opt for dependency injection (DI) instead**.\n\nWhen creating a Meter, it’s important to choose a unique name. As discussed earlier, follow [OpenTelemetry naming guidelines](https://github.com/open-telemetry/semantic-conventions/blob/main/docs/general/metrics.md#general-guidelines) using a lowercase, dotted hierarchical structure and underscores to separate words for naming all constructs. Ensure the instrument name is unique across the system, often incorporating assembly or namespace names.\n\nWe should always choose the appropriate instrument based on need; however, keep in mind that the Observable equivalents may perform better in performance-intensive scenarios, such as when there are more than one million calls per second per thread.\n\nIf we need to understand the distribution’s tail, such as the 90th, 95th, and 99th percentiles, instead of just averages, use a histogram to measure event timings. For measuring cache, queue, and file sizes, opt for an **UpDownCounter** or **ObservableUpDownCounter** based on ease of integration into existing code, either through API calls for increments and decrements or a callback for current values from a maintained variable.\n\n.NET APIs allow any string as a unit, but utilizing [UCUM](https://ucum.org/), the international standard for unit names is advisable. For multi-dimensional metrics, the API accepts any object as the tag value. However, collection tools typically expect numeric types and strings, making it crucial to provide these formats. Additionally, it’s recommended to follow the naming guidelines for tag names.\n\n## Conclusion\n\nIn this article, we discussed how to set up IMeterFactory in an ASP.NET Core Web API to effectively track various metrics. We looked at how to display these metrics using the dotnet-counters tool and shared tips for choosing and using the different metrics. Finally, we wrapped up with a discussion of best practices and testing metric collection in our code.\n\n[!\\[Code Maze Book Collection\\](https://code-maze.com/wp-content/uploads/2024/10/courses-template-wide.png)](https://courses.code-maze.com/courses/?source=bbanner&p=dotnet-imeterfactory-application-performance/)\n\nReady to take your skills to the next level? Jump into our high-impact courses in web development and software architecture, all with a focus on mastering the .NET/C# framework. Whether you're **building sleek web applications or designing scalable software solutions**, our expert-led training will give you the tools to succeed. Visit our **[COURSES](https://courses.code-maze.com/courses/?source=bbanner&p=dotnet-imeterfactory-application-performance/)** page now and kickstart your journey!\n\nLiked it? Take a second to support Code Maze on Patreon and get the ad free reading experience!\n\n[![Become a patron at Patreon!](https://code-maze.com/wp-content/plugins/patron-plugin-pro/plugin/lib/patron-button-and-widgets-by-codebard/images/become_a_patron_button.png)](https://www.patreon.com/oauth2/become-patron?response_type=code&min_cents=100&client_id=9_akhcsDQMGo-FTlVmNpM_uxSV4fbW3vnrz7CBRV9RxwjMPCLfWgodhrcE0UuHH4&scope=identity%20identity[email]&redirect_uri=https://code-maze.com/patreon-authorization/&state=eyJmaW5hbF9yZWRpcmVjdF91cmkiOiJodHRwczpcL1wvY29kZS1tYXplLmNvbVwvZG90bmV0LWltZXRlcmZhY3RvcnktYXBwbGljYXRpb24tcGVyZm9ybWFuY2VcLyJ9&utm_source=https%3A%2F%2Fcode-maze.com%2Fdotnet-imeterfactory-application-performance%2F&utm_medium=patreon_wordpress_plugin&utm_campaign=11086160&utm_term=&utm_content=post_unlock_button)\n\nShare:\n\nhttp://www.facebook.com/sharer.php?u=https://code-maze.com/dotnet-imeterfactory-application-performance/&#038;t=Measure%20Application%20Performance%20in%20.NET%20Using%20IMeterFactoryhttp://twitter.com/intent/tweet?text=Measure%20Application%20Performance%20in%20.NET%20Using%20IMeterFactory%20https://code-maze.com/dotnet-imeterfactory-application-performance/http://www.linkedin.com/shareArticle?mini=true&#038;url=https://code-maze.com/dotnet-imeterfactory-application-performance/&#038;title=Measure%20Application%20Performance%20in%20.NET%20Using%20IMeterFactory\n\n### Leave a reply [Cancel reply](/dotnet-imeterfactory-application-performance/#respond)\n\nYour email address will not be published. Required fields are marked \\*\n\nCOMMENT\n\nName \\*\n\nEmail \\*\n\nWebsite\n\n#### Courses – Code Maze\n\n[!\\[code maze courses side\\](https://code-maze.com/wp-content/uploads/2024/10/code-maze-courses-template-v3.png)](https://courses.code-maze.com/courses/)\n\nWhether you want to master web development or software architecture you should check our [COURSES](https://courses.code-maze.com/courses/) and pick the one that you like.\n\n#### Ad 1\n\n#### Ad 2\n\n#### Ad 3\n\n#### Ad 4",
  "PubDate": "2025-02-26T08:47:52+00:00"
}
