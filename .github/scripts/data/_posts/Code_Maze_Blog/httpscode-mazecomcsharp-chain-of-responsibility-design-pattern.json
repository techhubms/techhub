{
  "Tags": [
    "C#",
    "Chain of Responsibility",
    "csharp",
    "Design Pattern",
    "single responsibility principle"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Code Maze",
  "ProcessedDate": "2025-08-05 14:18:57",
  "FeedUrl": "https://code-maze.com/feed/",
  "Title": "Chain of Responsibility Design Pattern in C#",
  "Description": "In this article, we will talk about the Chain of Responsibility Design Pattern. We are going to see how to implement this pattern in C# and how it can solve certain design problems. Let’s start. What is The Chain of Responsibility Design Pattern? Chain of Responsibility is a behavioral pattern that helps us design a […]\n\nThe post [Chain of Responsibility Design Pattern in C#](https://code-maze.com/csharp-chain-of-responsibility-design-pattern/) appeared first on [Code Maze](https://code-maze.com).",
  "Link": "https://code-maze.com/csharp-chain-of-responsibility-design-pattern/",
  "FeedName": "Code Maze Blog",
  "Author": "Ahsan Ullah",
  "EnhancedContent": "# Chain of Responsibility Design Pattern in C#\n\nPosted by [Ahsan Ullah](https://code-maze.com/author/aullah/) | Dec 9, 2024 | [0](https://code-maze.com/csharp-chain-of-responsibility-design-pattern/#comments)\n\n![Chain of Responsibility Design Pattern in C#](https://code-maze.com/wp-content/uploads/2021/12/social-design-patterns.png)\n\n[!\\[Code Maze Book Collection\\](https://code-maze.com/wp-content/uploads/2024/10/courses-template-wide.png)](https://courses.code-maze.com/courses/?source=tbanner&p=csharp-chain-of-responsibility-design-pattern/)\n\nReady to take your skills to the next level? Jump into our high-impact courses in web development and software architecture, all with a focus on mastering the .NET/C# framework. Whether you're **building sleek web applications or designing scalable software solutions**, our expert-led training will give you the tools to succeed. Visit our **[COURSES](https://courses.code-maze.com/courses/?source=tbanner&p=csharp-chain-of-responsibility-design-pattern/)** page now and kickstart your journey!\n\nIn this article, we will talk about the Chain of Responsibility Design Pattern. We are going to see how to implement this pattern in C# and how it can solve certain design problems.\n\nTo download the source code for this article, you can visit our [GitHub repository](https://github.com/CodeMazeBlog/CodeMazeGuides/tree/main/csharp-design-patterns/ChainOfResponsibilityPattern).\n\nLet’s start.\n\n## What is The Chain of Responsibility Design Pattern?\n\nChain of Responsibility is a behavioral pattern that helps us design a complex component built over independent processing components. **This pattern suggests breaking down logic into smaller, more focused components, each with a distinct responsibility, and chaining them together to accomplish a larger task.** Chain of Responsibility is a powerful technique for fostering the [Single Responsibility Principle](https://code-maze.com/single-responsibility-principle/) and promoting loose coupling.\n\nSupport Code Maze on Patreon to get rid of ads and get the best discounts on our products!\n\n[![Become a patron at Patreon!](https://code-maze.com/wp-content/plugins/patron-plugin-pro/plugin/lib/patron-button-and-widgets-by-codebard/images/become_a_patron_button.png)](https://www.patreon.com/oauth2/become-patron?response_type=code&amp;min_cents=100&amp;client_id=9_akhcsDQMGo-FTlVmNpM_uxSV4fbW3vnrz7CBRV9RxwjMPCLfWgodhrcE0UuHH4&amp;scope=identity%20identity[email]&amp;redirect_uri=https://code-maze.com/patreon-authorization/&amp;state=eyJmaW5hbF9yZWRpcmVjdF91cmkiOiJodHRwczpcL1wvY29kZS1tYXplLmNvbVwvaGF0ZW9hcy1hc3BuZXQtY29yZS13ZWItYXBpXC8ifQ%3D%3D&amp;utm_source=https%3A%2F%2Fcode-maze.com%2Fhateoas-aspnet-core-web-api%2F&amp;utm_medium=patreon_wordpress_plugin&amp;utm_campaign=11086160&amp;utm_term=&amp;utm_content=post_unlock_button)\n\n**ASP.NET Core middleware is a prime example of the chain of responsibility pattern.** **The middleware decouples a request’s sender from its receivers by allowing multiple handlers to handle it independently.**\n\nIn a typical use-case of this pattern, we send a request along a series of handlers:\n\n[![Chain of Responsibility Design Pattern](https://code-maze.com/wp-content/uploads/2024/12/Chain-of-Responsibility-Design-Pattern.png)](https://code-maze.com/wp-content/uploads/2024/12/Chain-of-Responsibility-Design-Pattern.png)\n\nEach handler addresses a specific aspect of the whole task. The client arranges the handlers in a particular sequence to form a chain and sends the request to the first handler, which then passes it along to the subsequent handlers, ultimately producing the final result. The entire mechanism involves two key functions: creating a chain and passing the execution call from one handler to the next.\n\nThe `IHandler` interface defines the basic methods needed to support the chain propagation process. One such method (e.g. `setNext()` ) is responsible for building the chain and should accept and store a reference to the next handler.\n\nUpon receiving a request, a handler executes its logic and then hands over the responsibility to the next handler in the chain. A method like `handle()` can serve this purpose and essentially should be a part of the `IHandler` interface.\n\n## Single-handler vs Multi-handler Workflow\n\nThe chain propagation can follow a single or multi-handler workflow depending on the overall intent.\n\nIn a multi-handler workflow, the handlers represent a sequence of steps, and the request is allowed to be handled by multiple handlers:\n\n[![Chain of Responsibility (Multi-handler Workflow)](https://code-maze.com/wp-content/uploads/2024/12/Chain-of-Responsibility-Design-Pattern-Multi-handler-e1733206348883.png)](https://code-maze.com/wp-content/uploads/2024/12/Chain-of-Responsibility-Design-Pattern-Multi-handler.png)\n\nThe request enters the first step, undergoes the operation performed by that handler, and then moves on to the next step if the previous operation succeeds. The process continues up to the terminal handler.\n\nIs this material useful to you? Consider subscribing and get **ASP.NET Core Web API Best Practices** eBook for [FREE!](https://code-maze.com/free-ebook-aspnetcore-webapi-best-practices/)\n\nA multi-handler approach is handy when we perform a series of operations that may change dynamically based on various business factors. We can incorporate more steps in the process by adding more handlers to the chain without affecting existing ones. Similarly, we can eliminate steps that are not relevant to a particular case by removing the corresponding handler.\n\nIn the case of a single-handler workflow, only one handler in the chain ‘truly’ processes the request:\n\n[![Chain of Responsibility (Single-handler Workflow)](https://code-maze.com/wp-content/uploads/2024/12/Chain-of-Responsibility-Design-Pattern-Single-handler.png)](https://code-maze.com/wp-content/uploads/2024/12/Chain-of-Responsibility-Design-Pattern-Single-handler.png)\n\nIn this scenario, the handlers are simply variations of one another. Each handler passes the request along to the next until it reaches the appropriate handler capable of processing that particular request. The designated handler stops the chain once it handles the request.\n\nIn both cases, the client is aware of all potential handlers that can participate in request processing, but it does not need to know the details of the request or which specific handler(s) will handle it. By doing so, we can effectively separate the sender, the request, and the receiver.\n\n## What Problem Does The Chain of Responsibility Pattern Solve?\n\nTo better understand how the Chain of Responsibility (**CoR**) pattern functions, let’s begin by discussing the problem it addresses.\n\nLet’s consider a rental request processing API for a library:\n\n``` public class RentalAssistService { public RentalResponse ProcessRentRequest(RentalRequest request) { var result = CheckForBookAvailability(request.BookName);\n\nif (result != RentalResponse.BookAvailable) return result;\n\nresult = CheckForMemberAccessibility(request.BookName, request.UserName);\n\nif (result != RentalResponse.AccessibleToUser) return result;\n\nresult = CheckForAvailableBalance(request.UserName);\n\nif (result != RentalResponse.RentalApproved) return result;\n\nreturn IssueBook(request.BookName, request.UserName); } ... } ```\n\nThe API provides a method to process a user’s `RentalRequest` after some due diligence procedure. This process involves four sequential operations: book availability checks, member eligibility checks, checks for sufficient balance, and book issuance procedures:\n\nIs this material useful to you? Consider subscribing and get **ASP.NET Core Web API Best Practices** eBook for [FREE!](https://code-maze.com/free-ebook-aspnetcore-webapi-best-practices/)\n\n``` private RentalResponse CheckForBookAvailability(string bookName) { if (DataStore.FindBook(bookName) is not { } book || book.IssuedTo is not null) return RentalResponse.BookUnavailable;\n\nreturn RentalResponse.BookAvailable; }\n\nprivate RentalResponse CheckForMemberAccessibility(string bookName, string userName) { if (DataStore.FindUser(userName) is not { } user) return RentalResponse.MembershipRequired;\n\nif (!user.IsFaculty && IsReserved(bookName)) return RentalResponse.FacultyOnlyAccess;\n\nreturn RentalResponse.AccessibleToUser; }\n\nprivate RentalResponse CheckForAvailableBalance(string userName) { if (!HasBalance(userName)) return RentalResponse.InsufficientBalance;\n\nreturn RentalResponse.RentalApproved; }\n\nprivate RentalResponse IssueBook(string bookName, string userName) { var book = DataStore.FindBook(bookName)!; book.IssuedTo = userName;\n\n// Send email to user Console.WriteLine($\"Your request for {bookName} has been processed\");\n\nreturn RentalResponse.RentalIssued; }\n\nprivate static bool IsReserved(string bookName) => DataStore.FindBook(bookName) is { IsReserved: true };\n\nprivate static bool HasBalance(string userName) => DataStore.FindUser(userName) is { Balance: >= Book.RentalFee }; ```\n\nThis big monolithic class contains logic for all steps and conditional executions altogether making it tightly coupled and difficult to evolve further. The client code remains aware of how the request is processed in each step. Whenever we need to modify the internal logic of any operation, we must change the `RentalAssistService` class, leading to all the drawbacks of violating the Single Responsibility Principle.\n\nA more efficient and streamlined approach is to encapsulate each step in a separate class and link them together, precisely what the Chain of Responsibility pattern enables.\n\n## Implementation of Chain of Responsibility Pattern in C#\n\nLet’s revise our `RentalAssistService` class to incorporate the CoR pattern (check out the “Solution” folder in the source code).\n\nThe first and foremost action is transforming each step into an independent handler class.\n\nLet’s start with implementing `IHandler` interface in an abstract base handler class:\n\n``` public abstract class HandlerBase : IHandler { protected IHandler? _nextHandler;\n\npublic IHandler SetNext(IHandler nextHandler) { _nextHandler = nextHandler;\n\nreturn _nextHandler; }\n\npublic abstract RentalResponse Handle(RentalRequest request); } ```\n\nThe `SetNext()` method helps us connect with the next handler. We make it a bit more interesting by returning the reference of the next handler. This will simplify the chain formation from the client code.\n\nThe core request processing logic of concrete handlers will go inside the `Handle()` method.\n\nLet’s add the `BookAvailabilityCheckHandler` class to accommodate the logic of the book availability step:\n\nIs this material useful to you? Consider subscribing and get **ASP.NET Core Web API Best Practices** eBook for [FREE!](https://code-maze.com/free-ebook-aspnetcore-webapi-best-practices/)\n\n``` public class BookAvailabilityCheckHandler : HandlerBase { public override RentalResponse Handle(RentalRequest request) { if (DataStore.FindBook(request.BookName) is not { } book || book.IssuedTo is not null) return RentalResponse.BookUnavailable;\n\nif (_nextHandler is null) return RentalResponse.BookAvailable;\n\nreturn _nextHandler.Handle(request); } } ```\n\nSince our scenario reflects a multi-handler workflow, we call upon the next handler when the request meets the requirement of the current step.\n\nWe can similarly transform other processing steps into individual handlers – `MemberEligibilityCheckHandler` , `UserBalanceCheckHandler` and the terminal `RentalIssuanceHandler` class.\n\nOnce the handler classes are ready, we can refactor the `RentalAssistService` class:\n\n``` public RentalResponse ProcessRentRequest(RentalRequest request) { var handler = new BookAvailabilityCheckHandler();\n\nhandler.SetNext(new MemberAccessibilityCheckHandler()) .SetNext(new UserBalanceCheckHandler()) .SetNext(new RentalIssuanceHandler());\n\nreturn handler.Handle(request); } ```\n\nAs expected, the client code is now only responsible for defining the sequence of handlers and initiating the `Handle()` call on the first step. The execution call will propagate through the handlers if it satisfies the relevant condition.\n\n### An Implicit Advantage of Chain of Responsibility\n\nOne great advantage of the CoR pattern is the seamless workflow synthesis. For example, if the user requests a way to check the validity of the rental request without the actual issuance of the book, we can easily do that too:\n\n``` public RentalResponse AssessRentRequest(RentalRequest request) { var handler = new BookAvailabilityCheckHandler();\n\nhandler.SetNext(new MemberAccessibilityCheckHandler()) .SetNext(new UserBalanceCheckHandler());\n\nreturn handler.Handle(request); } ```\n\nWe just need to remove the last link of the chain, that’s it!\n\n## Drawbacks of Chain of Responsibility Pattern\n\nWhile the Chain of Responsibility pattern is useful for solving many design challenges, it requires thoughtful considerations during implementation.\n\n**One major concern with chained flow is the order of dependencies.** A common risk in such cases is incorrectly placing handlers at the appropriate points in the chain. For example, adding a validation handler after a processing handler will end up processing an invalid request.\n\n**The effectiveness of a chain pattern depends on clearly defining each step with a well-structured and reusable handler interface.** However, this can be challenging and may increase system complexity. For example, when steps need to exchange object states, handlers may become interdependent, leading to potential coupling.\n\nAnother potential side-effect of CoR is, that **there can be no guarantee of handling a request!** There is a risk that all handlers might be configured to pass the request without processing it, causing the request to be left entirely unhandled.\n\nDespite its drawbacks, the Chain of Responsibility remains one of the most powerful and effective design patterns.\n\n## Conclusion\n\nIn this article, we learned how to use the Chain of Responsibility design pattern in a C# application and discussed some factors to consider when using such patterns.\n\n[!\\[Code Maze Book Collection\\](https://code-maze.com/wp-content/uploads/2024/10/courses-template-wide.png)](https://courses.code-maze.com/courses/?source=bbanner&p=csharp-chain-of-responsibility-design-pattern/)\n\nReady to take your skills to the next level? Jump into our high-impact courses in web development and software architecture, all with a focus on mastering the .NET/C# framework. Whether you're **building sleek web applications or designing scalable software solutions**, our expert-led training will give you the tools to succeed. Visit our **[COURSES](https://courses.code-maze.com/courses/?source=bbanner&p=csharp-chain-of-responsibility-design-pattern/)** page now and kickstart your journey!\n\nLiked it? Take a second to support Code Maze on Patreon and get the ad free reading experience!\n\n[![Become a patron at Patreon!](https://code-maze.com/wp-content/plugins/patron-plugin-pro/plugin/lib/patron-button-and-widgets-by-codebard/images/become_a_patron_button.png)](https://www.patreon.com/oauth2/become-patron?response_type=code&min_cents=100&client_id=9_akhcsDQMGo-FTlVmNpM_uxSV4fbW3vnrz7CBRV9RxwjMPCLfWgodhrcE0UuHH4&scope=identity%20identity[email]&redirect_uri=https://code-maze.com/patreon-authorization/&state=eyJmaW5hbF9yZWRpcmVjdF91cmkiOiJodHRwczpcL1wvY29kZS1tYXplLmNvbVwvY3NoYXJwLWNoYWluLW9mLXJlc3BvbnNpYmlsaXR5LWRlc2lnbi1wYXR0ZXJuXC8ifQ%3D%3D&utm_source=https%3A%2F%2Fcode-maze.com%2Fcsharp-chain-of-responsibility-design-pattern%2F&utm_medium=patreon_wordpress_plugin&utm_campaign=11086160&utm_term=&utm_content=post_unlock_button)\n\nShare:\n\nhttp://www.facebook.com/sharer.php?u=https://code-maze.com/csharp-chain-of-responsibility-design-pattern/&#038;t=Chain%20of%20Responsibility%20Design%20Pattern%20in%20C%23http://twitter.com/intent/tweet?text=Chain%20of%20Responsibility%20Design%20Pattern%20in%20C%23%20https://code-maze.com/csharp-chain-of-responsibility-design-pattern/http://www.linkedin.com/shareArticle?mini=true&#038;url=https://code-maze.com/csharp-chain-of-responsibility-design-pattern/&#038;title=Chain%20of%20Responsibility%20Design%20Pattern%20in%20C%23\n\n### Leave a reply [Cancel reply](/csharp-chain-of-responsibility-design-pattern/#respond)\n\nYour email address will not be published. Required fields are marked \\*\n\nCOMMENT\n\nName \\*\n\nEmail \\*\n\nWebsite\n\n#### Courses – Code Maze\n\n[!\\[code maze courses side\\](https://code-maze.com/wp-content/uploads/2024/10/code-maze-courses-template-v3.png)](https://courses.code-maze.com/courses/)\n\nWhether you want to master web development or software architecture you should check our [COURSES](https://courses.code-maze.com/courses/) and pick the one that you like.\n\n#### Ad 1\n\n#### Ad 2\n\n#### Ad 3\n\n#### Ad 4",
  "PubDate": "2024-12-09T06:56:56+00:00"
}
