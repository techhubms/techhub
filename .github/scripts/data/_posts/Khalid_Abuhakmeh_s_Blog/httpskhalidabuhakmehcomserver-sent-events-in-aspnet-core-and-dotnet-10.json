{
  "Tags": [
    "aspnet",
    "dotnet"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Khalid Abuhakmeh",
  "ProcessedDate": "2025-08-05 14:22:13",
  "FeedUrl": "https://khalidabuhakmeh.com/feed.xml",
  "Title": "Server-Sent Events in ASP.NET Core and .NET 10",
  "Description": "Like many .NET developers, I‚Äôm starting to look at the features coming in .NET 10, C# 14, and specifically ASP.NET Core. To my surprise, ASP.NET Core Minimal APIs now support Server-Sent Events (SSE). For folks who don‚Äôt know what Server-Sent Events are, they are a unidirectional channel from the server to a client where a client can subscribe to events. SSE is handy for building live news feeds, stock ticker applications, or any system that has real-time information.\n\nInevitably, folks will ask, what‚Äôs the difference between SSE and SignalR? The difference is that SSE is lighter than WebSockets, and you can implement an SSE solution using the HTTP protocol. Whereas WebSockets, SignalR‚Äôs default operating mode, is a different protocol entirely. WebSockets are great, but the bidirectional communication between server and client adds additional costs that are typically unnecessary for the systems I mentioned previously.\n\nIn this post, I‚Äôll show you how to implement a straightforward SSE example using ASP.NET Core Minimal APIs, a background service, and some basic JavaScript.\n\n## The Anatomy of a SSE Endpoint\n\nStarting in .NET 10, you can now use the `TypedResults` class to return a `ServerSentEventsResult` , which takes an `IAsyncEnumerable` instance and an event type.\n\n```csharp using System.ComponentModel; using System.Runtime.CompilerServices;\n\nvar builder = WebApplication.CreateBuilder(args); builder.Services.AddSingleton(); builder.Services.AddHostedService();\n\nvar app = builder.Build(); app.UseDefaultFiles().UseStaticFiles();\n\napp.MapGet(\"/orders\", (FoodService foods, CancellationToken token) => TypedResults.ServerSentEvents( foods.GetCurrent(token), eventType: \"order\") );\n\napp.Run();\n\n```\n\nIn this example code, the `foods.GetCurrent` method call returns an `IAsyncEnumerable` of food-based emojis. The cancellation token allows the client to unsubscribe, stopping the enumeration and server-side computation.\n\nThat‚Äôs all you need; let‚Äôs see our `IAsyncEnumerable` implementation.\n\n## Implementing an IAsyncEnumerable Food Service\n\nWhile implementing an `IAsyncEnumerable` is straightforward, I wanted to write an implementation that synced all subscribers to a single source of truth. I accomplish this task in two classes: `FoodService` and `FoodServiceWorker` .\n\nThe `FoodService` implements an `INotifyPropertyChanged` and allows all subscribers to sync to get a single food item‚Äôs `Current` value.\n\n```csharp public class FoodService : INotifyPropertyChanged { public FoodService() { Current = Foods[Random.Shared.Next(Foods.Length)]; }\n\npublic event PropertyChangedEventHandler? PropertyChanged; private static readonly string[] Foods = [\"üçî\", \"üçü\", \"ü•§\", \"üç§\", \"üçï\", \"üåÆ\", \"ü•ô\"];\n\nprivate string Current { get; set { field = value; OnPropertyChanged(); } }\n\npublic async IAsyncEnumerable GetCurrent( [EnumeratorCancellation] CancellationToken ct) { while (ct is not { IsCancellationRequested: true }) { yield return Current; var tcs = new TaskCompletionSource(); PropertyChangedEventHandler handler = (_, _) => tcs.SetResult(); PropertyChanged += handler; try { await tcs.Task.WaitAsync(ct); } finally { PropertyChanged -= handler; } } }\n\npublic void Set() { Current = Foods[Random.Shared.Next(Foods.Length)]; }\n\nprotected void OnPropertyChanged([CallerMemberName] string? propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } }\n\n```\n\nNow, I need a background service that updates the food choices at a timed interval.\n\n```csharp public class FoodServiceWorker(FoodService foodService) : BackgroundService { protected override async Task ExecuteAsync(CancellationToken stoppingToken) { while (!stoppingToken.IsCancellationRequested) { foodService.Set(); await Task.Delay(1000, stoppingToken); } } }\n\n```\n\nNow, let‚Äôs write the HTML subscribing to the SSE endpoint defined in my simple sample.\n\n## Subscribing to SSE using JavaScript\n\nIn a new `index.html` file in `wwwroot` , I‚Äôll need to create a new EventSource object, listen for my `order` events to come through, and handle them appropriately.\n\n```html\n\nKhalid's Fast-Food Fair\n\n```\n\nIt‚Äôs that simple. When the browser loads the page, we‚Äôll immediately subscribe to the SSE endpoint and start receiving food emojis. If you open two pages, you‚Äôll see the emojis synced between the pages.\n\nTry this quick sample, and let me know if you have any questions. Cheers.",
  "Link": "https://khalidabuhakmeh.com/server-sent-events-in-aspnet-core-and-dotnet-10",
  "FeedName": "Khalid Abuhakmeh's Blog",
  "Author": "Khalid Abuhakmeh",
  "EnhancedContent": "![Server-Sent Events in ASP.NET Core and .NET 10](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_800/https://khalidabuhakmeh.com/assets/images/posts/misc/server-sent-events-dotnet-10-aspnetcore-minimal-apis.jpg)\n\nPhoto by [Allen Rad](https://unsplash.com/photos/cheese-burger-on-a-wooden-surface-9G_oJBKwi1c)\n\nLike many .NET developers, I‚Äôm starting to look at the features coming in .NET 10, C# 14, and specifically ASP.NET Core. To my surprise, ASP.NET Core Minimal APIs now support Server-Sent Events (SSE). For folks who don‚Äôt know what Server-Sent Events are, they are a unidirectional channel from the server to a client where a client can subscribe to events. SSE is handy for building live news feeds, stock ticker applications, or any system that has real-time information.\n\nInevitably, folks will ask, what‚Äôs the difference between SSE and SignalR? The difference is that SSE is lighter than WebSockets, and you can implement an SSE solution using the HTTP protocol. Whereas WebSockets, SignalR‚Äôs default operating mode, is a different protocol entirely. WebSockets are great, but the bidirectional communication between server and client adds additional costs that are typically unnecessary for the systems I mentioned previously.\n\nIn this post, I‚Äôll show you how to implement a straightforward SSE example using ASP.NET Core Minimal APIs, a background service, and some basic JavaScript.\n\n## The Anatomy of a SSE Endpoint\n\nStarting in .NET 10, you can now use the `TypedResults` class to return a `ServerSentEventsResult` , which takes an `IAsyncEnumerable<>` instance and an event type.\n\n```csharp using System.ComponentModel; using System.Runtime.CompilerServices;\n\nvar builder = WebApplication.CreateBuilder(args); builder.Services.AddSingleton<FoodService>(); builder.Services.AddHostedService<FoodServiceWorker>();\n\nvar app = builder.Build(); app.UseDefaultFiles().UseStaticFiles();\n\napp.MapGet(\"/orders\", (FoodService foods, CancellationToken token) => TypedResults.ServerSentEvents( foods.GetCurrent(token), eventType: \"order\") );\n\napp.Run();\n\n```\n\nIn this example code, the `foods.GetCurrent` method call returns an `IAsyncEnumerable` of food-based emojis. The cancellation token allows the client to unsubscribe, stopping the enumeration and server-side computation.\n\nThat‚Äôs all you need; let‚Äôs see our `IAsyncEnumerable` implementation.\n\n## Implementing an IAsyncEnumerable Food Service\n\nWhile implementing an `IAsyncEnumerable` is straightforward, I wanted to write an implementation that synced all subscribers to a single source of truth. I accomplish this task in two classes: `FoodService` and `FoodServiceWorker` .\n\nThe `FoodService` implements an `INotifyPropertyChanged` and allows all subscribers to sync to get a single food item‚Äôs `Current` value.\n\n```csharp public class FoodService : INotifyPropertyChanged { public FoodService() { Current = Foods[Random.Shared.Next(Foods.Length)]; }\n\npublic event PropertyChangedEventHandler? PropertyChanged; private static readonly string[] Foods = [\"üçî\", \"üçü\", \"ü•§\", \"üç§\", \"üçï\", \"üåÆ\", \"ü•ô\"];\n\nprivate string Current { get; set { field = value; OnPropertyChanged(); } }\n\npublic async IAsyncEnumerable<string> GetCurrent( [EnumeratorCancellation] CancellationToken ct) { while (ct is not { IsCancellationRequested: true }) { yield return Current; var tcs = new TaskCompletionSource(); PropertyChangedEventHandler handler = (_, _) => tcs.SetResult(); PropertyChanged += handler; try { await tcs.Task.WaitAsync(ct); } finally { PropertyChanged -= handler; } } }\n\npublic void Set() { Current = Foods[Random.Shared.Next(Foods.Length)]; }\n\nprotected void OnPropertyChanged([CallerMemberName] string? propertyName = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } }\n\n```\n\nNow, I need a background service that updates the food choices at a timed interval.\n\n```csharp public class FoodServiceWorker(FoodService foodService) : BackgroundService { protected override async Task ExecuteAsync(CancellationToken stoppingToken) { while (!stoppingToken.IsCancellationRequested) { foodService.Set(); await Task.Delay(1000, stoppingToken); } } }\n\n```\n\nNow, let‚Äôs write the HTML subscribing to the SSE endpoint defined in my simple sample.\n\n## Subscribing to SSE using JavaScript\n\nIn a new `index.html` file in `wwwroot` , I‚Äôll need to create a new EventSource object, listen for my `order` events to come through, and handle them appropriately.\n\n```html <!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <title>Title</title> </head> <style> ul { display: flex; flex-direction: row; list-style: none; flex-wrap: wrap; width: 90%; gap: 1rem; padding: 0; }\n\nli { font-size: 2rem; } </style> <body>\n\n<h1>Khalid's Fast-Food Fair</h1> <ul id=\"orders\"> </ul>\n\n<script> const eventSource = new EventSource('/orders'); const angelsList = document.getElementById('orders');\n\neventSource.addEventListener('order', event => { const li = document.createElement('li'); li.textContent = event.data; angelsList.appendChild(li); });\n\neventSource.onerror = error => { console.error('EventSource failed:', error); eventSource.close(); }; </script>\n\n</body> </html>\n\n```\n\nIt‚Äôs that simple. When the browser loads the page, we‚Äôll immediately subscribe to the SSE endpoint and start receiving food emojis. If you open two pages, you‚Äôll see the emojis synced between the pages.\n\nTry this quick sample, and let me know if you have any questions. Cheers.\n\n![Khalid Abuhakmeh's Picture](/assets/images/authorimage.jpg)\n\n## About Khalid Abuhakmeh\n\nKhalid is a developer advocate at JetBrains focusing on .NET technologies and tooling.\n\n## Read Next\n\n[!\\[Generic C# Methods with Enum Constraints for .NET\\](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_500/https://khalidabuhakmeh.com/assets/images/posts/misc/generic-csharp-methods-enums-dotnet.jpg)](/generic-csharp-methods-with-enum-constraints-for-dotnet)",
  "PubDate": "2025-04-22T00:00:00+00:00"
}
