{
  "Tags": [
    "csharp"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Khalid Abuhakmeh",
  "ProcessedDate": "2025-08-05 14:22:14",
  "FeedUrl": "https://khalidabuhakmeh.com/feed.xml",
  "Title": "Vogen and Value Objects with C# and .NET",
  "Description": "When it comes to programming, correctness is the name of the game. Every developer aims to understand, model, and limit potential outliers when executing code because those unknown variables can lead to exceptions and critical failures. There are many techniques developers use, but I recently discovered a new library (at least to me) in the .NET community that aims to help developers constrain potential inputs using value objects.\n\nIn this post, we’ll write a quick sample using Vogen to demonstrate how value objects can make our code clearer and less error-prone.\n\n## What is a Value Object?\n\nA value object represents a logical concept but is a .NET primitive value such as `int` , `bool` , `string` , and more. A straightforward example might be a birth date. Most developers would define a birth date using the `DateTime` type, hoping that the variable name clarifies the value’s intention.\n\n```csharp DateTime birthDate = new DateTime(1990, 1, 1);\n\n```\n\nThe drawback to this code is nothing stops a developer from unintentionally using the `birthDate` variable incorrectly.\n\n```csharp DateTime birthDate = new DateTime(1990, 1, 1); SetMovieReleaseDate(birthDate); void SetMovieReleaseDate(DateTime date) { }\n\n```\n\nWhile the code technically works, it may not be what the developers intended logically. The birth date may or may not be the release date of a movie, and it’s difficult to tell if this code is “correct.” Let’s fix it using value objects.\n\n```csharp var birthDate = new BirthDateTime(new (1990, 1, 1)); var movieReleaseDate = new MovieReleaseDateTime(birthDate.Value); SetMovieReleaseDate(movieReleaseDate);\n\nvoid SetMovieReleaseDate(MovieReleaseDateTime date) { } // value objects public record MovieReleaseDateTime(DateTime Value); public record BirthDateTime(DateTime Value);\n\n```\n\nLooking at this code, you can see that the developer intended to set a movie release date to the same value as the birth date. The goal is to minimize the chance of autocompleting your way into logical bugs that may be difficult to track down.\n\nYes, this can seem overly ceremonious, so consider the benefits and drawbacks before deciding if you want to adopt it.\n\nNow, let’s see what Vogen is about.\n\n## What is Vogen?\n\n[Vogen](https://stevedunn.github.io/Vogen/overview.html) is a NuGet library that utilizes source generators to generate value objects, taking much of the ceremony out of model creation. The library creates factory methods, comparisons, validation, and serializers on partial `struct` and `class` implementations.\n\nLet’s start by adding Vogen to a .NET console application.\n\n```xml\n\n```\n\nIn my example, I’ll create a `PacMan` class that requires a `FavoriteGhost` property to have a valid value of `Ghost` .\n\n```csharp public class PacMan { public Ghost FavoriteGhost { get; set; }\n\npublic override string ToString() { return $\"Pac Man's favorite ghost is {FavoriteGhost}.\"; } }\n\n```\n\nOur value object will be `Ghost` ; everyone knows that the ghosts that haunt Pac-Man include Blinky, Pinky, Inky, and Clyde. Let’s start with the unconstrained approach using Vogen.\n\n```csharp [ValueObject] [Instance(\"Blinky\", \"Blinky\")] [Instance(\"Pinky\", \"Pinky\")] [Instance(\"Inky\", \"Inky\")] [Instance(\"Clyde\", \"Clyde\")] public partial struct Ghost;\n\n```\n\nAfter the source generators have run, you’ll now have `public static readonly` instances of each ghost on the `Ghost` struct, allowing our code to run and set the `FavoriteGhost` property on our `pacMan` instance.\n\nYou can create any `Ghost` you like using the `From` method on the struct.\n\n```csharp var aNewGhost = Ghost.From(\"Khalid\");\n\n```\n\nIf your value objects are unconstrained, this might be a good time to stop, but we want to limit our `Ghost` values. Let’s rework our `Ghost` struct.\n\n```csharp [ValueObject] public partial struct Ghost { public static readonly Ghost Blinky = new(\"Blinky\"); public static readonly Ghost Pinky = new(\"Pinky\"); public static readonly Ghost Inky = new(\"Inky\"); public static readonly Ghost Clyde = new(\"Clyde\");\n\npublic static IReadOnlyCollection All { get; } = new[] { Blinky, Pinky, Inky, Clyde }.AsReadOnly();\n\nprivate static Validation Validate(string input) => All.Any(g => g.Equals(input)) ? Validation.Ok : Validation.Invalid($\"Ghost must be {string.Join(\", \", All)}\"); }\n\n```\n\nWith some extra code, we can now validate that all values used to create a `Ghost` fit within a defined set of values.\n\n```csharp // will throw an exception var aNewGhost = Ghost.From(\"Khalid\"); // will pass var aKnownGhost = Ghost.From(\"Blinky\");\n\n```\n\nLet’s see the use of Vogen in a complete C# sample.\n\n```csharp using Vogen;\n\nvar pacMan = new PacMan { FavoriteGhost = Ghost.Blinky };\n\nforeach (var ghost in Ghost.All) { Console.WriteLine(ghost); }\n\nConsole.WriteLine(pacMan);\n\n[ValueObject] public partial struct Ghost { public static readonly Ghost Blinky = new(\"Blinky\"); public static readonly Ghost Pinky = new(\"Pinky\"); public static readonly Ghost Inky = new(\"Inky\"); public static readonly Ghost Clyde = new(\"Clyde\");\n\npublic static IReadOnlyCollection All { get; } = new[] { Blinky, Pinky, Inky, Clyde }.AsReadOnly();\n\nprivate static Validation Validate(string input) => All.Any(g => g.Equals(input)) ? Validation.Ok : Validation.Invalid($\"Ghost must be {string.Join(\", \", All)}\"); }\n\npublic class PacMan { public Ghost FavoriteGhost { get; set; }\n\npublic override string ToString() { return $\"Pac Man's favorite ghost is {FavoriteGhost}.\"; } }\n\n```\n\n## Conclusion\n\nUsing value objects is an efficient way to constrain inputs and outputs logically. It helps you reflect logical constraints in the codebase and offers readability levels that could be lost using primitive types. With the addition of Vogen, you can remove boilerplate code and get straight to using value objects, with the benefits of quickly accessing the underlying primitive value through explicit and implicit means.\n\nI think the next step for folks is likely to take an existing part of a codebase and see if converting it to use value objects improves readability and correctness.\n\nI hope you enjoyed this post. As always, thanks for reading and sharing my posts.",
  "Link": "https://khalidabuhakmeh.com/vogen-and-value-objects-with-csharp-and-dotnet",
  "FeedName": "Khalid Abuhakmeh's Blog",
  "Author": "Khalid Abuhakmeh",
  "EnhancedContent": "![Vogen and Value Objects with C# and .NET](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_800/https://khalidabuhakmeh.com/assets/images/posts/misc/vogen-value-objects-csharp-dotnet.jpg)\n\nPhoto by [Captain Caveman](https://en.wikipedia.org/wiki/Captain_Caveman_and_the_Teen_Angels)\n\nWhen it comes to programming, correctness is the name of the game. Every developer aims to understand, model, and limit potential outliers when executing code because those unknown variables can lead to exceptions and critical failures. There are many techniques developers use, but I recently discovered a new library (at least to me) in the .NET community that aims to help developers constrain potential inputs using value objects.\n\nIn this post, we’ll write a quick sample using Vogen to demonstrate how value objects can make our code clearer and less error-prone.\n\n## What is a Value Object?\n\nA value object represents a logical concept but is a .NET primitive value such as `int` , `bool` , `string` , and more. A straightforward example might be a birth date. Most developers would define a birth date using the `DateTime` type, hoping that the variable name clarifies the value’s intention.\n\n```csharp DateTime birthDate = new DateTime(1990, 1, 1);\n\n```\n\nThe drawback to this code is nothing stops a developer from unintentionally using the `birthDate` variable incorrectly.\n\n```csharp DateTime birthDate = new DateTime(1990, 1, 1); SetMovieReleaseDate(birthDate); void SetMovieReleaseDate(DateTime date) { }\n\n```\n\nWhile the code technically works, it may not be what the developers intended logically. The birth date may or may not be the release date of a movie, and it’s difficult to tell if this code is “correct.” Let’s fix it using value objects.\n\n```csharp var birthDate = new BirthDateTime(new (1990, 1, 1)); var movieReleaseDate = new MovieReleaseDateTime(birthDate.Value); SetMovieReleaseDate(movieReleaseDate);\n\nvoid SetMovieReleaseDate(MovieReleaseDateTime date) { } // value objects public record MovieReleaseDateTime(DateTime Value); public record BirthDateTime(DateTime Value);\n\n```\n\nLooking at this code, you can see that the developer intended to set a movie release date to the same value as the birth date. The goal is to minimize the chance of autocompleting your way into logical bugs that may be difficult to track down.\n\nYes, this can seem overly ceremonious, so consider the benefits and drawbacks before deciding if you want to adopt it.\n\nNow, let’s see what Vogen is about.\n\n## What is Vogen?\n\n[Vogen](https://stevedunn.github.io/Vogen/overview.html) is a NuGet library that utilizes source generators to generate value objects, taking much of the ceremony out of model creation. The library creates factory methods, comparisons, validation, and serializers on partial `struct` and `class` implementations.\n\nLet’s start by adding Vogen to a .NET console application.\n\n```xml <PackageReference Include=\"Vogen\" Version=\"7.0.0-beta.1\" />\n\n```\n\nIn my example, I’ll create a `PacMan` class that requires a `FavoriteGhost` property to have a valid value of `Ghost` .\n\n```csharp public class PacMan { public Ghost FavoriteGhost { get; set; }\n\npublic override string ToString() { return $\"Pac Man's favorite ghost is {FavoriteGhost}.\"; } }\n\n```\n\nOur value object will be `Ghost` ; everyone knows that the ghosts that haunt Pac-Man include Blinky, Pinky, Inky, and Clyde. Let’s start with the unconstrained approach using Vogen.\n\n```csharp [ValueObject<string>] [Instance(\"Blinky\", \"Blinky\")] [Instance(\"Pinky\", \"Pinky\")] [Instance(\"Inky\", \"Inky\")] [Instance(\"Clyde\", \"Clyde\")] public partial struct Ghost;\n\n```\n\nAfter the source generators have run, you’ll now have `public static readonly` instances of each ghost on the `Ghost` struct, allowing our code to run and set the `FavoriteGhost` property on our `pacMan` instance.\n\nYou can create any `Ghost` you like using the `From` method on the struct.\n\n```csharp var aNewGhost = Ghost.From(\"Khalid\");\n\n```\n\nIf your value objects are unconstrained, this might be a good time to stop, but we want to limit our `Ghost` values. Let’s rework our `Ghost` struct.\n\n```csharp [ValueObject<string>] public partial struct Ghost { public static readonly Ghost Blinky = new(\"Blinky\"); public static readonly Ghost Pinky = new(\"Pinky\"); public static readonly Ghost Inky = new(\"Inky\"); public static readonly Ghost Clyde = new(\"Clyde\");\n\npublic static IReadOnlyCollection<Ghost> All { get; } = new[] { Blinky, Pinky, Inky, Clyde }.AsReadOnly();\n\nprivate static Validation Validate(string input) => All.Any(g => g.Equals(input)) ? Validation.Ok : Validation.Invalid($\"Ghost must be {string.Join(\", \", All)}\"); }\n\n```\n\nWith some extra code, we can now validate that all values used to create a `Ghost` fit within a defined set of values.\n\n```csharp // will throw an exception var aNewGhost = Ghost.From(\"Khalid\"); // will pass var aKnownGhost = Ghost.From(\"Blinky\");\n\n```\n\nLet’s see the use of Vogen in a complete C# sample.\n\n```csharp using Vogen;\n\nvar pacMan = new PacMan { FavoriteGhost = Ghost.Blinky };\n\nforeach (var ghost in Ghost.All) { Console.WriteLine(ghost); }\n\nConsole.WriteLine(pacMan);\n\n[ValueObject<string>] public partial struct Ghost { public static readonly Ghost Blinky = new(\"Blinky\"); public static readonly Ghost Pinky = new(\"Pinky\"); public static readonly Ghost Inky = new(\"Inky\"); public static readonly Ghost Clyde = new(\"Clyde\");\n\npublic static IReadOnlyCollection<Ghost> All { get; } = new[] { Blinky, Pinky, Inky, Clyde }.AsReadOnly();\n\nprivate static Validation Validate(string input) => All.Any(g => g.Equals(input)) ? Validation.Ok : Validation.Invalid($\"Ghost must be {string.Join(\", \", All)}\"); }\n\npublic class PacMan { public Ghost FavoriteGhost { get; set; }\n\npublic override string ToString() { return $\"Pac Man's favorite ghost is {FavoriteGhost}.\"; } }\n\n```\n\n## Conclusion\n\nUsing value objects is an efficient way to constrain inputs and outputs logically. It helps you reflect logical constraints in the codebase and offers readability levels that could be lost using primitive types. With the addition of Vogen, you can remove boilerplate code and get straight to using value objects, with the benefits of quickly accessing the underlying primitive value through explicit and implicit means.\n\nI think the next step for folks is likely to take an existing part of a codebase and see if converting it to use value objects improves readability and correctness.\n\nI hope you enjoyed this post. As always, thanks for reading and sharing my posts.\n\n![Khalid Abuhakmeh's Picture](/assets/images/authorimage.jpg)\n\n## About Khalid Abuhakmeh\n\nKhalid is a developer advocate at JetBrains focusing on .NET technologies and tooling.\n\n## Read Next\n\n[!\\[Initialize ASP.NET Core TagHelpers with Shared Data\\](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_500/https://khalidabuhakmeh.com/assets/images/posts/misc/aspnet-core-shared-data-tag-helpers-initialize.jpg)](/initialize-aspnet-core-taghelpers-with-shared-data)\n\n[!\\[ASP.NET Core and Chunking HTTP Cookies\\](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_500/https://khalidabuhakmeh.com/assets/images/posts/misc/aspnet-core-http-cookies-chunking.jpg)](/aspnet-core-and-chunking-http-cookies)",
  "PubDate": "2025-02-04T00:00:00+00:00"
}
