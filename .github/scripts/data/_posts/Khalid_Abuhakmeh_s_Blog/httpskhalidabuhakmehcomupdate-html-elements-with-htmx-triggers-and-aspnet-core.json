{
  "Tags": [
    "aspnet",
    "dotnet",
    "htmx"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Khalid Abuhakmeh",
  "ProcessedDate": "2025-08-05 14:22:14",
  "FeedUrl": "https://khalidabuhakmeh.com/feed.xml",
  "Title": "Update HTML Elements with Htmx Triggers and ASP.NET Core",
  "Description": "Let me start by saying that I love the combination of [Htmx](https://htmx.org) and ASP.NET Core, and it is a pairing that any .NET developer should consider, whether maintaining an existing application or building a new one. It’s very cool. I was recently talking about revisiting the `hx-trigger` and `HX-Trigger` header technique with ASP.NET Core on Mastodon with [Illya Busigin](https://mas.to/@illyabusigin), and they mentioned they use the same method to update the avatar image when a user updates their profile. So, I thought I’d try and see how to implement it myself.\n\nIn this post, we’ll see how to use the `HX-Trigger` facility in Htmx to update existing UI elements on a rendered HTML page.\n\n## The Moving Parts\n\nWhen building any new feature in an application, you need to arrange multiple components to work together. Let’s address all the parts you’ll need to make this experience.\n\n- A User Profile store\n- Profile Settings endpoints for display and updating\n- An endpoint to refresh the avatar element on the page\n\nWe’ll be using the capabilities of ASP.NET Core Razor Pages and Razor Views to handle the HTML snippets that Htmx needs for swapping elements. Before we get into HTML and Htmx, let’s deal with our user profile storage service.\n\nNote that you’ll need the NuGet packages of **Htmx** and, optionally, **Htmx.TagHelpers**.\n\n## The User Service\n\nI created a straightforward class for the demo that will hold the user name and the avatar URL. In a “real application”, you’d likely store this information in a database or third-party auth service. Let’s see what I wrote.\n\n```csharp public class UserService { public static readonly string[] AvatarUrls = [ \"~/img/avatar_one.png\", \"~/img/avatar_two.png\", \"~/img/avatar_three.png\", ];\n\npublic string Name { get; set; } = \"Khalid Abuhakmeh\"; public string AvatarUrl { get; set; } = AvatarUrls[0]; }\n\n```\n\nThe user can choose from three existing avatars, which are stored in the `wwwroot/img` folder. Fewer options mean less code for the demo and more focus on the Htmx bits that come later.\n\nNext, we’ll register the `UserService` as a `Singleton` in our ASP.NET Core setup class to maintain the state between requests. **Note: This is only for the demoand is not recommended in any other scenario.**\n\n```csharp var builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container. builder.Services.AddRazorPages(); builder.Services.AddSingleton();\n\nvar app = builder.Build();\n\n```\n\nCool! Now, we can inject this service where we need it to grab the current state of the user profile, which includes the name and avatar URL.\n\nI inject this service into my `Layout.cshtml` and then render the avatar partial.\n\n```razor @inject UserService UserService\n\n@await Html.PartialAsync(\"_Avatar\", UserService)\n\n```\n\nWe’ll examine the partial later in the article, but first, let’s discuss our account endpoints.\n\n## Profile Endpoints\n\nIn a new Razor page titled `Index` , we’ll have three endpoints:\n\n- Show the profile settings form.\n- Accept user updates\n- Render the `_Avatar`\nprofile image as partial content.\n\nI’ll paste the full class here, and we’ll break it down into one endpoint at a time.\n\n```csharp using System.Diagnostics.CodeAnalysis; using Htmx; using HtmxAvatarChange.Models; using Microsoft.AspNetCore.Mvc; using Microsoft.AspNetCore.Mvc.RazorPages; using Microsoft.AspNetCore.Mvc.Rendering;\n\nnamespace HtmxAvatarChange.Pages;\n\npublic class IndexModel(UserService userService, ILogger logger) : PageModel { [BindProperty] public string? Name { get; set; }\n\n[BindProperty] public string? AvatarUrl { get; set; }\n\n[TempData] public string? Message { get; set; } [TempData] public string? MessageCssClass { get; set; }\n\n[MemberNotNullWhen(true, nameof(Message))] public bool HasMessage => Message != null;\n\npublic List Avatars => UserService .AvatarUrls .Select((x, i) => new SelectListItem($\"avatar-{i:00}\", x)) .ToList();\n\npublic void OnGet() { Name = userService.Name; AvatarUrl = userService.AvatarUrl; }\n\npublic IActionResult OnPost() { if (ModelState.IsValid) { Message = \"Successfully saved account settings\"; MessageCssClass = \"alert-success\";\n\n// change values userService.Name = Name!; userService.AvatarUrl = AvatarUrl!;\n\nResponse.Htmx(h => h.WithTrigger(\"avatar\")); } else { Message = \"Failed to save account settings\"; MessageCssClass = \"alert-danger\"; }\n\nif (Request.IsHtmx()) { return Partial(\"_Form\", this); }\n\nreturn RedirectToPage(\"Index\"); }\n\npublic IActionResult OnGetAvatar() { return Partial(\"_Avatar\", userService); }\n\npublic string? IsCurrentAvatar(string avatarValue) { return avatarValue == AvatarUrl ? \"checked\" : null; } }\n\n```\n\nThe first method we’ll look at is `OnGet` . This method takes the information from the `UserService` and hydrates our property. These properties will be used to bind information to our form.\n\n```csharp public void OnGet() { Name = userService.Name; AvatarUrl = userService.AvatarUrl; }\n\n```\n\nNext, closer to the bottom of the class, let’s look at a similar method, `OnGetAvatar` .\n\n```csharp public IActionResult OnGetAvatar() { return Partial(\"_Avatar\", userService); }\n\n```\n\nThis method returns the partial view of `_Avatar` , simply displaying our user information. Now, let’s look at the `OnPost` method, which is the juiciest of the implementations.\n\n```csharp public IActionResult OnPost() { if (ModelState.IsValid) { Message = \"Successfully saved account settings\"; MessageCssClass = \"alert-success\";\n\n// change values userService.Name = Name!; userService.AvatarUrl = AvatarUrl!;\n\nResponse.Htmx(h => h.WithTrigger(\"avatar\")); } else { Message = \"Failed to save account settings\"; MessageCssClass = \"alert-danger\"; }\n\nif (Request.IsHtmx()) { return Partial(\"_Form\", this); }\n\nreturn RedirectToPage(\"Index\"); }\n\n```\n\nHere, we determine if the user input is valid and then update the page. The two most important lines include the `Htmx` references.\n\n```csharp Response.Htmx(h => h.WithTrigger(\"avatar\"));\n\n```\n\nIf the incoming request was initiated with Htmx, we add a response header to tell Htmx to fire a client-side event of `avatar` . Any element subscribing to this event will then trigger another request. In our case, we’ll be calling the `OnGetAvatar` endpoint. You can add as many events as you need here, but we only want one in our case.\n\nThe following reference to Htmx checks if Htmx initiated the request. If it was, we need to send back a partial Html snippet.\n\n```csharp if (Request.IsHtmx()) { return Partial(\"_Form\", this); }\n\n```\n\nThat’s it! But what do the Razor views look like?\n\n## Htmx and Partial Views\n\nLet’s start with the form since it is the focal point of our user experience. It’s straightforward Razor code with one exception: the Htmx attributes on the `form` tag.\n\n```razor @model IndexModel Account Settings\n\n@if (Model.HasMessage) {\n\n@Model.Message\n\n}\n\nName\n\nAvatar\n\n@foreach (var avatar in Model.Avatars) {\n\n}\n\n```\n\nThese Htmx attributes allow us to hijack the form submission and route it through an Htmx request, allowing the library to process the header request. Once processed, it fires the event on the `_Avatar` partial. Let’s take a look at that view now.\n\n```razor @model HtmxAvatarChange.Models.UserService\n\n@Model.Name\n\n```\n\nThe essential attribute on this view is the `hx-trigger` attribute. Note the exact value.\n\n```html hx-trigger=\"avatar from:body\"\n\n```\n\nThe `from:body` is essential, as the `body` element is what Htmx uses to broadcast the event. That’s it. Let’s see it in action!\n\n![Sample Running](https://github.com/khalidabuhakmeh/HtmxAvatarChange/raw/main/misc/htmx-hx-trigger-sample.gif)\n\nWow! That’s cool!\n\n## Conclusion\n\n`HX-Trigger` headers can help you decouple UI elements from each other and create a system of elements that can act independently. This can be very powerful, but it should be used in moderation, like all things. Remember, each triggered event results in a request back to the server, which could come at a cost. That said, many existing SPA UI approaches already make expensive calls to the server, so this might not be any worse than a GraphQL call or JSON over an HTTP request.\n\nI’ve uploaded the code for this sample to my [GitHub repository](https://github.com/khalidabuhakmeh/HtmxAvatarChange) so you can try it out.\n\nAs always, thanks for reading and hope you give this one a try.",
  "Link": "https://khalidabuhakmeh.com/update-html-elements-with-htmx-triggers-and-aspnet-core",
  "FeedName": "Khalid Abuhakmeh's Blog",
  "Author": "Khalid Abuhakmeh",
  "EnhancedContent": "![Update HTML Elements with Htmx Triggers and ASP.NET Core](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_800/https://khalidabuhakmeh.com/assets/images/posts/misc/htmx-aspnetcore-hx-trigger-html.jpg)\n\nPhoto by [Julian Hochgesang](https://unsplash.com/@julianhochgesang)\n\nLet me start by saying that I love the combination of [Htmx](https://htmx.org) and ASP.NET Core, and it is a pairing that any .NET developer should consider, whether maintaining an existing application or building a new one. It’s very cool. I was recently talking about revisiting the `hx-trigger` and `HX-Trigger` header technique with ASP.NET Core on Mastodon with [Illya Busigin](https://mas.to/@illyabusigin), and they mentioned they use the same method to update the avatar image when a user updates their profile. So, I thought I’d try and see how to implement it myself.\n\nIn this post, we’ll see how to use the `HX-Trigger` facility in Htmx to update existing UI elements on a rendered HTML page.\n\n## The Moving Parts\n\nWhen building any new feature in an application, you need to arrange multiple components to work together. Let’s address all the parts you’ll need to make this experience.\n\n- A User Profile store\n- Profile Settings endpoints for display and updating\n- An endpoint to refresh the avatar element on the page\n\nWe’ll be using the capabilities of ASP.NET Core Razor Pages and Razor Views to handle the HTML snippets that Htmx needs for swapping elements. Before we get into HTML and Htmx, let’s deal with our user profile storage service.\n\nNote that you’ll need the NuGet packages of **Htmx** and, optionally, **Htmx.TagHelpers**.\n\n## The User Service\n\nI created a straightforward class for the demo that will hold the user name and the avatar URL. In a “real application”, you’d likely store this information in a database or third-party auth service. Let’s see what I wrote.\n\n```csharp public class UserService { public static readonly string[] AvatarUrls = [ \"~/img/avatar_one.png\", \"~/img/avatar_two.png\", \"~/img/avatar_three.png\", ];\n\npublic string Name { get; set; } = \"Khalid Abuhakmeh\"; public string AvatarUrl { get; set; } = AvatarUrls[0]; }\n\n```\n\nThe user can choose from three existing avatars, which are stored in the `wwwroot/img` folder. Fewer options mean less code for the demo and more focus on the Htmx bits that come later.\n\nNext, we’ll register the `UserService` as a `Singleton` in our ASP.NET Core setup class to maintain the state between requests. **Note: This is only for the demoand is not recommended in any other scenario.**\n\n```csharp var builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container. builder.Services.AddRazorPages(); builder.Services.AddSingleton<UserService>();\n\nvar app = builder.Build();\n\n```\n\nCool! Now, we can inject this service where we need it to grab the current state of the user profile, which includes the name and avatar URL.\n\nI inject this service into my `Layout.cshtml` and then render the avatar partial.\n\n```razor @inject UserService UserService <!-- some HTML --> @await Html.PartialAsync(\"_Avatar\", UserService)\n\n```\n\nWe’ll examine the partial later in the article, but first, let’s discuss our account endpoints.\n\n## Profile Endpoints\n\nIn a new Razor page titled `Index` , we’ll have three endpoints:\n\n- Show the profile settings form.\n- Accept user updates\n- Render the `_Avatar`\nprofile image as partial content.\n\nI’ll paste the full class here, and we’ll break it down into one endpoint at a time.\n\n```csharp using System.Diagnostics.CodeAnalysis; using Htmx; using HtmxAvatarChange.Models; using Microsoft.AspNetCore.Mvc; using Microsoft.AspNetCore.Mvc.RazorPages; using Microsoft.AspNetCore.Mvc.Rendering;\n\nnamespace HtmxAvatarChange.Pages;\n\npublic class IndexModel(UserService userService, ILogger<IndexModel> logger) : PageModel { [BindProperty] public string? Name { get; set; }\n\n[BindProperty] public string? AvatarUrl { get; set; }\n\n[TempData] public string? Message { get; set; } [TempData] public string? MessageCssClass { get; set; }\n\n[MemberNotNullWhen(true, nameof(Message))] public bool HasMessage => Message != null;\n\npublic List<SelectListItem> Avatars => UserService .AvatarUrls .Select((x, i) => new SelectListItem($\"avatar-{i:00}\", x)) .ToList();\n\npublic void OnGet() { Name = userService.Name; AvatarUrl = userService.AvatarUrl; }\n\npublic IActionResult OnPost() { if (ModelState.IsValid) { Message = \"Successfully saved account settings\"; MessageCssClass = \"alert-success\";\n\n// change values userService.Name = Name!; userService.AvatarUrl = AvatarUrl!;\n\nResponse.Htmx(h => h.WithTrigger(\"avatar\")); } else { Message = \"Failed to save account settings\"; MessageCssClass = \"alert-danger\"; }\n\nif (Request.IsHtmx()) { return Partial(\"_Form\", this); }\n\nreturn RedirectToPage(\"Index\"); }\n\npublic IActionResult OnGetAvatar() { return Partial(\"_Avatar\", userService); }\n\npublic string? IsCurrentAvatar(string avatarValue) { return avatarValue == AvatarUrl ? \"checked\" : null; } }\n\n```\n\nThe first method we’ll look at is `OnGet` . This method takes the information from the `UserService` and hydrates our property. These properties will be used to bind information to our form.\n\n```csharp public void OnGet() { Name = userService.Name; AvatarUrl = userService.AvatarUrl; }\n\n```\n\nNext, closer to the bottom of the class, let’s look at a similar method, `OnGetAvatar` .\n\n```csharp public IActionResult OnGetAvatar() { return Partial(\"_Avatar\", userService); }\n\n```\n\nThis method returns the partial view of `_Avatar` , simply displaying our user information. Now, let’s look at the `OnPost` method, which is the juiciest of the implementations.\n\n```csharp public IActionResult OnPost() { if (ModelState.IsValid) { Message = \"Successfully saved account settings\"; MessageCssClass = \"alert-success\";\n\n// change values userService.Name = Name!; userService.AvatarUrl = AvatarUrl!;\n\nResponse.Htmx(h => h.WithTrigger(\"avatar\")); } else { Message = \"Failed to save account settings\"; MessageCssClass = \"alert-danger\"; }\n\nif (Request.IsHtmx()) { return Partial(\"_Form\", this); }\n\nreturn RedirectToPage(\"Index\"); }\n\n```\n\nHere, we determine if the user input is valid and then update the page. The two most important lines include the `Htmx` references.\n\n```csharp Response.Htmx(h => h.WithTrigger(\"avatar\"));\n\n```\n\nIf the incoming request was initiated with Htmx, we add a response header to tell Htmx to fire a client-side event of `avatar` . Any element subscribing to this event will then trigger another request. In our case, we’ll be calling the `OnGetAvatar` endpoint. You can add as many events as you need here, but we only want one in our case.\n\nThe following reference to Htmx checks if Htmx initiated the request. If it was, we need to send back a partial Html snippet.\n\n```csharp if (Request.IsHtmx()) { return Partial(\"_Form\", this); }\n\n```\n\nThat’s it! But what do the Razor views look like?\n\n## Htmx and Partial Views\n\nLet’s start with the form since it is the focal point of our user experience. It’s straightforward Razor code with one exception: the Htmx attributes on the `form` tag.\n\n```razor @model IndexModel\n\n<fieldset id=\"account-settings\"> <legend>Account Settings</legend>\n\n@if (Model.HasMessage) { <div class=\"alert @(Model.MessageCssClass ?? \"alert-info\")\" role=\"alert\"> @Model.Message </div> }\n\n<form method=\"post\" hx-post hx-target=\"#account-settings\" hx-swap=\"outerHTML\"> <div class=\"form-group row\"> <label asp-for=\"Name\" class=\"col-sm-2 col-form-label\">Name</label> <div class=\"col-sm-10\"> <input class=\"form-control\" asp-for=\"Name\"> </div> </div> <fieldset class=\"form-group mt-3\"> <div class=\"row\"> <legend class=\"col-form-label col-sm-2 pt-0\">Avatar</legend> <div class=\"col-sm-10\"> @foreach (var avatar in Model.Avatars) { <div class=\"form-check\"> <input id=\"@avatar.Text\" asp-for=\"AvatarUrl\" class=\"form-check-inline\" type=\"radio\" value=\"@avatar.Value\" checked=\"@Model.IsCurrentAvatar(avatar.Value)\"> <label class=\"form-check-label\" for=\"@avatar.Text\"> <img src=\"@Url.Content(avatar.Value)\" class=\"profile-pic\" alt=\"@avatar.Text\"/> </label> </div> } </div> </div> </fieldset> <div class=\"form-group row mt-3\"> <button type=\"submit\" class=\"btn btn-primary\">Save Profile</button> </div> </form> </fieldset>\n\n```\n\nThese Htmx attributes allow us to hijack the form submission and route it through an Htmx request, allowing the library to process the header request. Once processed, it fires the event on the `_Avatar` partial. Let’s take a look at that view now.\n\n```razor @model HtmxAvatarChange.Models.UserService\n\n<div id=\"profile-avatar\" class=\"mx-2 smooth\" hx-get=\"@Url.Page(\"Index\", \"Avatar\")\" hx-trigger=\"avatar from:body\"> <div class=\"profile-pic\"> <img src=\"@Url.Content(Model.AvatarUrl)\" alt=\"Profile Picture\"> </div> <span class=\"navbar-text\"> @Model.Name</span> </div>\n\n```\n\nThe essential attribute on this view is the `hx-trigger` attribute. Note the exact value.\n\n```html hx-trigger=\"avatar from:body\"\n\n```\n\nThe `from:body` is essential, as the `body` element is what Htmx uses to broadcast the event. That’s it. Let’s see it in action!\n\n![Sample Running](https://github.com/khalidabuhakmeh/HtmxAvatarChange/raw/main/misc/htmx-hx-trigger-sample.gif)\n\nWow! That’s cool!\n\n## Conclusion\n\n`HX-Trigger` headers can help you decouple UI elements from each other and create a system of elements that can act independently. This can be very powerful, but it should be used in moderation, like all things. Remember, each triggered event results in a request back to the server, which could come at a cost. That said, many existing SPA UI approaches already make expensive calls to the server, so this might not be any worse than a GraphQL call or JSON over an HTTP request.\n\nI’ve uploaded the code for this sample to my [GitHub repository](https://github.com/khalidabuhakmeh/HtmxAvatarChange) so you can try it out.\n\nAs always, thanks for reading and hope you give this one a try.\n\n![Khalid Abuhakmeh's Picture](/assets/images/authorimage.jpg)\n\n## About Khalid Abuhakmeh\n\nKhalid is a developer advocate at JetBrains focusing on .NET technologies and tooling.\n\n## Read Next\n\n[!\\[Add EF Core Migrations to .NET Aspire Solutions\\](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_500/https://khalidabuhakmeh.com/assets/images/posts/misc/dotnet-aspire-ef-core-migrations-approach.jpg)](/add-ef-core-migrations-to-dotnet-aspire-solutions)\n\n[!\\[Dynamic Htmx Islands with ASP.NET Core\\](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_500/https://khalidabuhakmeh.com/assets/images/posts/misc/dynamic-htmx-islands-aspnet-core-taghelpers.jpg)](/dynamic-htmx-islands-with-aspnet-core)",
  "PubDate": "2024-10-22T00:00:00+00:00"
}
