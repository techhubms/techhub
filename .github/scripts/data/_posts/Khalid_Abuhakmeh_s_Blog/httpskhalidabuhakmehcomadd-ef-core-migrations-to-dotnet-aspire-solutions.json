{
  "Tags": [
    "aspire",
    "dotnet"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Khalid Abuhakmeh",
  "ProcessedDate": "2025-08-05 14:22:14",
  "FeedUrl": "https://khalidabuhakmeh.com/feed.xml",
  "Title": "Add EF Core Migrations to .NET Aspire Solutions",
  "Description": "Folks working with EF Core are likely very fond of the library’s migration features, one of the most vital selling points for adopting an ORM. If you’re building a .NET solution, your database schema will evolve, and adding, removing, and updating are everyday actions you must perform.\n\n.NET Aspire can ease the development of distributed solutions, but you still need to bridge the gap between development time actions and runtime execution. With EF Core, a development time action is managing migrations, while at runtime, you’ll need to execute those migrations against a database. The [original tutorial by the Microsoft documentation](https://learn.microsoft.com/en-us/dotnet/aspire/database/ef-core-migrations) explains how to run a .NET Aspire application with migrations but leaves out how to do development time tasks.\n\nIn this post, we’ll explore how to manage migrations during the development process so you can get the most out of your .NET Aspire and Entity Framework Core adoption.\n\n## The Solution Structure\n\nWe’ll first need to understand the solution structure of our Aspire distributed application. This is what my solution looks like, but you can change the approach depending on your preferences.\n\n``` AspireSandbox |- AspireSandbox.AppHost |- AspireSandbox.Data |- AspireSandbox.ServiceDefaults |- AspireSandbox.Web\n\n```\n\nThe `AspireSanbox.Data` project contains my `DbContext` implementation, which is nothing remarkable.\n\n```csharp using Microsoft.EntityFrameworkCore;\n\nnamespace AspireSandbox.Data;\n\npublic class Database(DbContextOptions options) : DbContext(options) { public DbSet Counts => Set(); }\n\npublic class Count { public int Id { get; set; } public DateTimeOffset CountedAt { get; set; } = DateTimeOffset.UtcNow; }\n\n```\n\nThe dependencies for this project include the following Entity Framework Core packages.\n\n```xml\n\nnet8.0 enable enable\n\nall runtime; build; native; contentfiles; analyzers; buildtransitive\n\n```\n\nNext, we must add this project as a reference to our `AspireSandbox.AppHost` project, paying attention to adding the attribute of `IsAspireProjectResource` and setting its value to `false` . This opts this project out of the Aspire source generators.\n\nI have a few other package references, but pay attention to the Entity Framework Core dependencies.\n\n```xml\n\nExe net8.0 enable enable true ba2648f9-6953-4e8b-9918-c241b1d99b09\n\nall runtime; build; native; contentfiles; analyzers; buildtransitive\n\n```\n\nOK, we’re ready to write some code.\n\n## Entity Framework Core Design Time Factory\n\nEntity Framework Core provides a mechanism for the tooling to connect and work with a database. Since our database is in the scope of our distributed application, we need to run our tooling when Aspire has built our dependency. Don’t worry; it will make sense in a second.\n\nIn the `AspireSandbox.AppHost` , create a new `DataContextDesignTimeFactory` class.\n\n```csharp using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Design;\n\nnamespace AspireSandbox.AppHost;\n\npublic sealed class DataContextDesignTimeFactory : IDesignTimeDbContextFactory { public Data.Database CreateDbContext(string[] args) { var builder = DistributedApplication.CreateBuilder(args);\n\nvar postgres = builder .AddPostgres(\"postgres\") .AddDatabase(\"migrations\", databaseName: \"migrations\");\n\nvar optionsBuilder = new DbContextOptionsBuilder(); optionsBuilder.UseNpgsql(\"migrations\"); return new Data.Database(optionsBuilder.Options); } }\n\n```\n\nThis implementation will spin up our database dependency and allow us to create an instance of our `DbContext` implementation. At least long enough to create and add our migrations to our project. Remember that EF Core creates a model snapshot as a C# file, so there is no need to persist the database across migration runs.\n\n## EF Core CLI Command\n\nNow, we can run the following command to spin up Aspire long enough to create a migration.\n\n```bash dotnet ef migrations --project ./AspireSandbox.Data --startup-project ./AspireSandbox.AppHost add Initial\n\n```\n\nChange the `--project` and `--startup-project` to match your solution structure.\n\nIf all goes well, you should now have a new database migration.\n\n## Conclusion\n\nThere you have it; you can now work seamlessly between your development environment and Aspire solution with just a new `IDesignTimeDbContextFactory` implementation and tweaking your CLI command.\n\nThanks to James Hancock for leaving this comment on the Aspire GitHub issues and inspiring this blog post. His solution is pretty **+$%!** good.",
  "Link": "https://khalidabuhakmeh.com/add-ef-core-migrations-to-dotnet-aspire-solutions",
  "FeedName": "Khalid Abuhakmeh's Blog",
  "Author": "Khalid Abuhakmeh",
  "EnhancedContent": "![Add EF Core Migrations to .NET Aspire Solutions](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_800/https://khalidabuhakmeh.com/assets/images/posts/misc/dotnet-aspire-ef-core-migrations-approach.jpg)\n\nPhoto by [NIPYATA!](https://unsplash.com/@nipyata)\n\nFolks working with EF Core are likely very fond of the library’s migration features, one of the most vital selling points for adopting an ORM. If you’re building a .NET solution, your database schema will evolve, and adding, removing, and updating are everyday actions you must perform.\n\n.NET Aspire can ease the development of distributed solutions, but you still need to bridge the gap between development time actions and runtime execution. With EF Core, a development time action is managing migrations, while at runtime, you’ll need to execute those migrations against a database. The [original tutorial by the Microsoft documentation](https://learn.microsoft.com/en-us/dotnet/aspire/database/ef-core-migrations) explains how to run a .NET Aspire application with migrations but leaves out how to do development time tasks.\n\nIn this post, we’ll explore how to manage migrations during the development process so you can get the most out of your .NET Aspire and Entity Framework Core adoption.\n\n## The Solution Structure\n\nWe’ll first need to understand the solution structure of our Aspire distributed application. This is what my solution looks like, but you can change the approach depending on your preferences.\n\n``` AspireSandbox |- AspireSandbox.AppHost |- AspireSandbox.Data |- AspireSandbox.ServiceDefaults |- AspireSandbox.Web\n\n```\n\nThe `AspireSanbox.Data` project contains my `DbContext` implementation, which is nothing remarkable.\n\n```csharp using Microsoft.EntityFrameworkCore;\n\nnamespace AspireSandbox.Data;\n\npublic class Database(DbContextOptions<Database> options) : DbContext(options) { public DbSet<Count> Counts => Set<Count>(); }\n\npublic class Count { public int Id { get; set; } public DateTimeOffset CountedAt { get; set; } = DateTimeOffset.UtcNow; }\n\n```\n\nThe dependencies for this project include the following Entity Framework Core packages.\n\n```xml <Project Sdk=\"Microsoft.NET.Sdk\">\n\n<PropertyGroup> <TargetFramework>net8.0</TargetFramework> <ImplicitUsings>enable</ImplicitUsings> <Nullable>enable</Nullable> </PropertyGroup>\n\n<ItemGroup> <PackageReference Include=\"Microsoft.EntityFrameworkCore\" Version=\"8.0.8\" /> <PackageReference Include=\"Microsoft.EntityFrameworkCore.Design\" Version=\"8.0.8\"> <PrivateAssets>all</PrivateAssets> <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets> </PackageReference> <PackageReference Include=\"Npgsql.EntityFrameworkCore.PostgreSQL\" Version=\"8.0.8\" /> </ItemGroup>\n\n</Project>\n\n```\n\nNext, we must add this project as a reference to our `AspireSandbox.AppHost` project, paying attention to adding the attribute of `IsAspireProjectResource` and setting its value to `false` . This opts this project out of the Aspire source generators.\n\nI have a few other package references, but pay attention to the Entity Framework Core dependencies.\n\n```xml <Project Sdk=\"Microsoft.NET.Sdk\">\n\n<PropertyGroup> <OutputType>Exe</OutputType> <TargetFramework>net8.0</TargetFramework> <ImplicitUsings>enable</ImplicitUsings> <Nullable>enable</Nullable> <IsAspireHost>true</IsAspireHost> <UserSecretsId>ba2648f9-6953-4e8b-9918-c241b1d99b09</UserSecretsId> </PropertyGroup>\n\n<ItemGroup> <PackageReference Include=\"Aspire.Hosting.AppHost\" Version=\"8.2.1\"/> <PackageReference Include=\"Aspire.Hosting.PostgreSQL\" Version=\"8.2.1\" /> <PackageReference Include=\"Aspire.Hosting.Redis\" Version=\"8.2.1\" /> <PackageReference Include=\"Microsoft.EntityFrameworkCore\" Version=\"8.0.8\" /> <PackageReference Include=\"Microsoft.EntityFrameworkCore.Design\" Version=\"8.0.8\"> <PrivateAssets>all</PrivateAssets> <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets> </PackageReference> </ItemGroup>\n\n<ItemGroup> <ProjectReference Include=\"..\\AspireSandbox.Data\\AspireSandbox.Data.csproj\" IsAspireProjectResource=\"false\" /> <ProjectReference Include=\"..\\AspireSandbox.Web\\AspireSandbox.Web.csproj\" /> </ItemGroup>\n\n</Project>\n\n```\n\nOK, we’re ready to write some code.\n\n## Entity Framework Core Design Time Factory\n\nEntity Framework Core provides a mechanism for the tooling to connect and work with a database. Since our database is in the scope of our distributed application, we need to run our tooling when Aspire has built our dependency. Don’t worry; it will make sense in a second.\n\nIn the `AspireSandbox.AppHost` , create a new `DataContextDesignTimeFactory` class.\n\n```csharp using Microsoft.EntityFrameworkCore; using Microsoft.EntityFrameworkCore.Design;\n\nnamespace AspireSandbox.AppHost;\n\npublic sealed class DataContextDesignTimeFactory : IDesignTimeDbContextFactory<Data.Database> { public Data.Database CreateDbContext(string[] args) { var builder = DistributedApplication.CreateBuilder(args);\n\nvar postgres = builder .AddPostgres(\"postgres\") .AddDatabase(\"migrations\", databaseName: \"migrations\");\n\nvar optionsBuilder = new DbContextOptionsBuilder<Data.Database>(); optionsBuilder.UseNpgsql(\"migrations\"); return new Data.Database(optionsBuilder.Options); } }\n\n```\n\nThis implementation will spin up our database dependency and allow us to create an instance of our `DbContext` implementation. At least long enough to create and add our migrations to our project. Remember that EF Core creates a model snapshot as a C# file, so there is no need to persist the database across migration runs.\n\n## EF Core CLI Command\n\nNow, we can run the following command to spin up Aspire long enough to create a migration.\n\n```bash dotnet ef migrations --project ./AspireSandbox.Data --startup-project ./AspireSandbox.AppHost add Initial\n\n```\n\nChange the `--project` and `--startup-project` to match your solution structure.\n\nIf all goes well, you should now have a new database migration.\n\n## Conclusion\n\nThere you have it; you can now work seamlessly between your development environment and Aspire solution with just a new `IDesignTimeDbContextFactory` implementation and tweaking your CLI command.\n\nThanks to James Hancock for leaving this comment on the Aspire GitHub issues and inspiring this blog post. His solution is pretty **+$%!** good.\n\n![Khalid Abuhakmeh's Picture](/assets/images/authorimage.jpg)\n\n## About Khalid Abuhakmeh\n\nKhalid is a developer advocate at JetBrains focusing on .NET technologies and tooling.\n\n## Read Next\n\n[!\\[Htmx and Playwright Tests in C#\\](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_500/https://khalidabuhakmeh.com/assets/images/posts/misc/htmx-playwright-csharp-tests.jpg)](/htmx-and-playwright-tests-in-csharp)\n\n[!\\[Update HTML Elements with Htmx Triggers and ASP.NET Core\\](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_500/https://khalidabuhakmeh.com/assets/images/posts/misc/htmx-aspnetcore-hx-trigger-html.jpg)](/update-html-elements-with-htmx-triggers-and-aspnet-core)",
  "PubDate": "2024-10-08T00:00:00+00:00"
}
