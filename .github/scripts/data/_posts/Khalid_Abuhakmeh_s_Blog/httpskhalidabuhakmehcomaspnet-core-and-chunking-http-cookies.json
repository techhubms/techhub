{
  "Tags": [
    "aspnet",
    "http"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Khalid Abuhakmeh",
  "ProcessedDate": "2025-08-05 14:22:14",
  "FeedUrl": "https://khalidabuhakmeh.com/feed.xml",
  "Title": "ASP.NET Core and Chunking HTTP Cookies",
  "Description": "If youâ€™ve spent time around web development or your grocery storeâ€™s baked goods aisle, youâ€™ve probably dealt with **cookies**. Letâ€™s discuss the web kind today. A cookie is a header key-value pair that is set on the server using the [`Set-Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) key, and a value of `=` . Cookies persist on the client, where the client will send each cookie to the server on each subsequent request. Itâ€™s a simple way to persist state in the stateless web environment and avoid complex session management infrastructure. That said, cookies have limitations, mainly the [**4kb** size limit](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#data_storage) for each unique cookie. Size limits can be a serious problem for ASP.NET Core applications, which rely heavily on maintaining user session data in an encrypted and encoded cookie.\n\nIn this post, weâ€™ll look at a sample I wrote that uses the same `ICookieManager` abstraction that ASP.NET Core uses to chunk large cookies successfully.\n\n## Why You Would and Wouldnâ€™t Use Cookies\n\nAs the introduction mentions, cookies are a straightforward mechanism for maintaining the state between HTTP requests as users interact with your application. Cookies can significantly simplify your backend implementation, as you can expect requests to contain most of the information required to process user-intended actions. Cookies may include user information such as an ID, a name, an email address, and more. The request/response lifecycle of cookies also makes it easy to debug issues when they inevitably occur, as you can view an HTTP request and its headers in most logging mechanisms. These are only a few advantages, but letâ€™s discuss some disadvantages.\n\nWhile cookies are configurable, you can assume that, generally, the client will pass them along with each request to the server. The additional payload on each request can add unnecessary overhead to requests that donâ€™t take advantage of the cookies. For example, any request for a file might still receive all set cookies even though the goal is to serve static content. That adds unnecessary ingress and resource utilization to your applications. Imagine a request with 10 cookies with a maxed-out cookie size on each. Thatâ€™s an additional 40kb per request! And speaking of resource utilization, if cookies are chunked or encrypted, they first need to be reassembled and unencrypted before you can use them. Depending on your ASP.NET Core pipeline setup, this can unnecessarily add to your resource utilization, leading to increased memory and CPU usage.\n\nMy description does not say you should or shouldnâ€™t ever use cookies, but you should be mindful that they have an associated cost. Now, letâ€™s get to some code to see how to set a simple cookie and then use the `ChunkingCookieManager` to chunk larger cookies.\n\n## Setting Cookies in ASP.NET Core\n\n**You can see the [entire sample at this GitHub repository](https://github.com/khalidabuhakmeh/CookieMonster)**\n\nLike most web-related abstractions, you can access cookies from the current `HttpContext` . Using the current requestâ€™s context, letâ€™s set a cookie on an HTTP response.\n\n```csharp ctx.Response.Cookies.Append(\"cookie_monster\", \"nom nom nom\");\n\n```\n\nIn our sample, weâ€™ll be reading and rewriting a value with appended data.\n\n```csharp app.MapGet(\"/nom-nom\", async ctx => { ctx.Response.Cookies.Append(\"cookie_monster\", ctx.Request.Cookies.TryGetValue(\"cookie_monster\", out var cookie) ? $\"{cookie}, {RandomString()}\" : $\"{RandomString()}\"); // more code }\n\n```\n\nThat was easy! But thereâ€™s an issue: our cookie will continue expanding until it reaches our 4kb limit. Oh no! Admittedly, this is an example designed to fail quickly, but itâ€™s easy to find yourself in a situation where cookies slowly creep up to the size limit. Letâ€™s fix this code.\n\nInstall the `Microsoft.AspNetCore.Authentication.Cookies` NuGet package into your existing project to start using cookie chunking. In most cases, youâ€™ll likely already have this dependency due to a transitive inclusion, but it never hurts to include it explicitly.\n\nNext, weâ€™ll need to register the `ChunkingCookieManager` in our services collection as an implementation of `ICookieManager` .\n\n```csharp builder.Services.AddScoped(svc => new ChunkingCookieManager { // characters, not bytes... ðŸ¤” ChunkSize = 1000, ThrowForPartialCookies = true });\n\n```\n\nIn my case, I reduced the chunk size for a few reasons.\n\nSee the chunking behavior sooner than later. The `ChunkSize` is based on characters in .NET and not kilobytes, so youâ€™ll need to account for that based on the data youâ€™ll be storing. `1000` is a nice round number, but the default is `4050` .\n\nLetâ€™s look at the implementation in another minimal API endpoint.\n\n```csharp { app.MapGet(\"/chunks\", async (HttpContext ctx, ICookieManager cookieManager) => { var value = cookieManager.GetRequestCookie(ctx, \"chunky_monster\") is { } cookie ? $\"{cookie}, {RandomString()}\" : $\"{RandomString()}\";\n\ncookieManager.AppendResponseCookie(ctx, \"chunky_monster\", value, new CookieOptions());\n\n// more code... });\n\n```\n\nThere are a few essential elements to getting cookie chunking working:\n\nYou must use the `ICookieManager` implementation for all interactions of your logical cookie since it will take care of the chunks. Interacting with the cookies directly through the `HttpContext` will cause you issues. The `ICookieManager` API requires access to an `HttpContext` instance. There is no assumption that a cookie manager will have an HTTP context dependency injected. You could easily create an implementation that wraps this into a new API. The `CookieOptions` argument is required but can be left empty. Options allow you to set cookie options on the resulting cookie chunks, such as `Domain` , `Expires` , `Secure` , and more.\n\nAs the concrete type name suggests, we will be chunking cookies, meaning that if a cookieâ€™s contents exceed our configured limits, weâ€™ll produce multiple header values.\n\nYouâ€™ll usually see the following behavior in your browserâ€™s dev tools.\n\n| Name | Value | | --- | --- | | chunky\\_monster | chunks-2 | | chunky\\_monsterC1 | *value chunk up to `ChunkSize`* | | chunky\\_monsterC2 | *rest of value* | | chunky\\_monsterCN | *more to come if necessary* |\n\nThere you go, youâ€™ve successfully chunked your cookies using the mechanisms provided by ASP.NET Core.\n\n## Conclusion\n\nCookies are a bedrock of web development, but you need to be mindful of their benefits and drawbacks. If you do find yourself exceeding the size limits of cookies, Iâ€™d recommend first understanding why it has occurred and if you have room to optimize your data. In a pinch, adopting chunking can help you get over the sizing issue, but can have the drawbacks mentioned in one of the previous sections. If you think you have a better strategy, you can implement the `ICookieManager` yourself and take a completely different approach. If you do, drop me a message and send me a link to your implementation.\n\nTo [try this sample out for yourself, head to my GitHub repository](https://github.com/khalidabuhakmeh/CookieMonster). As always, thanks for reading and sharing my posts.",
  "Link": "https://khalidabuhakmeh.com/aspnet-core-and-chunking-http-cookies",
  "FeedName": "Khalid Abuhakmeh's Blog",
  "Author": "Khalid Abuhakmeh",
  "EnhancedContent": "![ASP.NET Core and Chunking HTTP Cookies](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_800/https://khalidabuhakmeh.com/assets/images/posts/misc/aspnet-core-http-cookies-chunking.jpg)\n\nPhoto by [LittleJakub](https://www.deviantart.com/littlejakub/art/Cookie-Monster-Wallpaper-194354451)\n\nIf youâ€™ve spent time around web development or your grocery storeâ€™s baked goods aisle, youâ€™ve probably dealt with **cookies**. Letâ€™s discuss the web kind today. A cookie is a header key-value pair that is set on the server using the [`Set-Cookie`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie) key, and a value of `<name>=<value>` . Cookies persist on the client, where the client will send each cookie to the server on each subsequent request. Itâ€™s a simple way to persist state in the stateless web environment and avoid complex session management infrastructure. That said, cookies have limitations, mainly the [**4kb** size limit](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#data_storage) for each unique cookie. Size limits can be a serious problem for ASP.NET Core applications, which rely heavily on maintaining user session data in an encrypted and encoded cookie.\n\nIn this post, weâ€™ll look at a sample I wrote that uses the same `ICookieManager` abstraction that ASP.NET Core uses to chunk large cookies successfully.\n\n## Why You Would and Wouldnâ€™t Use Cookies\n\nAs the introduction mentions, cookies are a straightforward mechanism for maintaining the state between HTTP requests as users interact with your application. Cookies can significantly simplify your backend implementation, as you can expect requests to contain most of the information required to process user-intended actions. Cookies may include user information such as an ID, a name, an email address, and more. The request/response lifecycle of cookies also makes it easy to debug issues when they inevitably occur, as you can view an HTTP request and its headers in most logging mechanisms. These are only a few advantages, but letâ€™s discuss some disadvantages.\n\nWhile cookies are configurable, you can assume that, generally, the client will pass them along with each request to the server. The additional payload on each request can add unnecessary overhead to requests that donâ€™t take advantage of the cookies. For example, any request for a file might still receive all set cookies even though the goal is to serve static content. That adds unnecessary ingress and resource utilization to your applications. Imagine a request with 10 cookies with a maxed-out cookie size on each. Thatâ€™s an additional 40kb per request! And speaking of resource utilization, if cookies are chunked or encrypted, they first need to be reassembled and unencrypted before you can use them. Depending on your ASP.NET Core pipeline setup, this can unnecessarily add to your resource utilization, leading to increased memory and CPU usage.\n\nMy description does not say you should or shouldnâ€™t ever use cookies, but you should be mindful that they have an associated cost. Now, letâ€™s get to some code to see how to set a simple cookie and then use the `ChunkingCookieManager` to chunk larger cookies.\n\n## Setting Cookies in ASP.NET Core\n\n**You can see the [entire sample at this GitHub repository](https://github.com/khalidabuhakmeh/CookieMonster)**\n\nLike most web-related abstractions, you can access cookies from the current `HttpContext` . Using the current requestâ€™s context, letâ€™s set a cookie on an HTTP response.\n\n```csharp ctx.Response.Cookies.Append(\"cookie_monster\", \"nom nom nom\");\n\n```\n\nIn our sample, weâ€™ll be reading and rewriting a value with appended data.\n\n```csharp app.MapGet(\"/nom-nom\", async ctx => { ctx.Response.Cookies.Append(\"cookie_monster\", ctx.Request.Cookies.TryGetValue(\"cookie_monster\", out var cookie) ? $\"{cookie}, {RandomString()}\" : $\"{RandomString()}\"); // more code }\n\n```\n\nThat was easy! But thereâ€™s an issue: our cookie will continue expanding until it reaches our 4kb limit. Oh no! Admittedly, this is an example designed to fail quickly, but itâ€™s easy to find yourself in a situation where cookies slowly creep up to the size limit. Letâ€™s fix this code.\n\nInstall the `Microsoft.AspNetCore.Authentication.Cookies` NuGet package into your existing project to start using cookie chunking. In most cases, youâ€™ll likely already have this dependency due to a transitive inclusion, but it never hurts to include it explicitly.\n\nNext, weâ€™ll need to register the `ChunkingCookieManager` in our services collection as an implementation of `ICookieManager` .\n\n```csharp builder.Services.AddScoped<ICookieManager>(svc => new ChunkingCookieManager { // characters, not bytes... ðŸ¤” ChunkSize = 1000, ThrowForPartialCookies = true });\n\n```\n\nIn my case, I reduced the chunk size for a few reasons.\n\nSee the chunking behavior sooner than later. The `ChunkSize` is based on characters in .NET and not kilobytes, so youâ€™ll need to account for that based on the data youâ€™ll be storing. `1000` is a nice round number, but the default is `4050` .\n\nLetâ€™s look at the implementation in another minimal API endpoint.\n\n```csharp { app.MapGet(\"/chunks\", async (HttpContext ctx, ICookieManager cookieManager) => { var value = cookieManager.GetRequestCookie(ctx, \"chunky_monster\") is { } cookie ? $\"{cookie}, {RandomString()}\" : $\"{RandomString()}\";\n\ncookieManager.AppendResponseCookie(ctx, \"chunky_monster\", value, new CookieOptions());\n\n// more code... });\n\n```\n\nThere are a few essential elements to getting cookie chunking working:\n\nYou must use the `ICookieManager` implementation for all interactions of your logical cookie since it will take care of the chunks. Interacting with the cookies directly through the `HttpContext` will cause you issues. The `ICookieManager` API requires access to an `HttpContext` instance. There is no assumption that a cookie manager will have an HTTP context dependency injected. You could easily create an implementation that wraps this into a new API. The `CookieOptions` argument is required but can be left empty. Options allow you to set cookie options on the resulting cookie chunks, such as `Domain` , `Expires` , `Secure` , and more.\n\nAs the concrete type name suggests, we will be chunking cookies, meaning that if a cookieâ€™s contents exceed our configured limits, weâ€™ll produce multiple header values.\n\nYouâ€™ll usually see the following behavior in your browserâ€™s dev tools.\n\n| Name | Value | | --- | --- | | chunky\\_monster | chunks-2 | | chunky\\_monsterC1 | *value chunk up to `ChunkSize`* | | chunky\\_monsterC2 | *rest of value* | | chunky\\_monsterCN | *more to come if necessary* |\n\nThere you go, youâ€™ve successfully chunked your cookies using the mechanisms provided by ASP.NET Core.\n\n## Conclusion\n\nCookies are a bedrock of web development, but you need to be mindful of their benefits and drawbacks. If you do find yourself exceeding the size limits of cookies, Iâ€™d recommend first understanding why it has occurred and if you have room to optimize your data. In a pinch, adopting chunking can help you get over the sizing issue, but can have the drawbacks mentioned in one of the previous sections. If you think you have a better strategy, you can implement the `ICookieManager` yourself and take a completely different approach. If you do, drop me a message and send me a link to your implementation.\n\nTo [try this sample out for yourself, head to my GitHub repository](https://github.com/khalidabuhakmeh/CookieMonster). As always, thanks for reading and sharing my posts.\n\n![Khalid Abuhakmeh's Picture](/assets/images/authorimage.jpg)\n\n## About Khalid Abuhakmeh\n\nKhalid is a developer advocate at JetBrains focusing on .NET technologies and tooling.\n\n## Read Next\n\n[!\\[Vogen and Value Objects with C# and .NET\\](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_500/https://khalidabuhakmeh.com/assets/images/posts/misc/vogen-value-objects-csharp-dotnet.jpg)](/vogen-and-value-objects-with-csharp-and-dotnet)\n\n[!\\[The Curious Case of .NET ConcurrentDictionary and Closures\\](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_500/https://khalidabuhakmeh.com/assets/images/posts/misc/dotnet-concurrentdictionary-getoradd-closures.jpg)](/the-curious-case-of-dotnet-concurrentdictionary-and-closures)",
  "PubDate": "2025-02-11T00:00:00+00:00"
}
