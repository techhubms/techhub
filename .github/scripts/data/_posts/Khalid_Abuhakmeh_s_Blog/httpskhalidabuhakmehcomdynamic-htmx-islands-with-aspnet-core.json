{
  "Tags": [
    "aspnet",
    "htmx"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Khalid Abuhakmeh",
  "ProcessedDate": "2025-08-05 14:22:14",
  "FeedUrl": "https://khalidabuhakmeh.com/feed.xml",
  "Title": "Dynamic Htmx Islands with ASP.NET Core",
  "Description": "Iâ€™m a big fan of static site renderers, and they are still one of the missing elements that would make ASP.NET Core more compelling for users across the vast ecosystem divide. In the meantime, developers must rely on tools like Astro, Jekyll, and 11ty to build static site experiences. Recently, I read about Astro 5.0 and its [server island implementation](https://5-0-0-beta.docs.astro.build/en/guides/server-islands/). Server islands allow for mostly static pages to carve out portions of the page that will be rendered on-demand by, you guessed it, the server. This allows site authors to deliver fast, statically rendered pages that benefit the user while allowing for dynamic user-specific content.\n\nIn this post, weâ€™ll see how to implement a similar island approach in ASP.NET Core applications that utilize **response and output caching** for performance increases while still carving out small page sections for dynamic content. Weâ€™ll use Htmx to trigger requests for dynamic content based on three exclusive page events.\n\n## What is an Island?\n\nAs described in the introduction, an island is part of the document object model (DOM) that is loaded after the initial page load. This allows the shared DOM across users to be cached while dynamic content specific to a user session is loaded afterward. While a post-load event is commonly used to retrieve dynamic content, islands can also be lazily loaded and take advantage of the `revealed` or `intersect` events. These will only trigger requests if the user sees this DOM element on the page. Optimizing pages by selecting island events can reduce unnecessary service processing. In general, islands are a powerful technique when building web applications.\n\nExamples of islands may include a profile name in a pageâ€™s navigation, customized recommendations on a storefront, user-based statistics for a dashboard, and more. These islands typically comprise a small yet critical part of the user experience.\n\nNow, letâ€™s implement an `island` component for ASP.NET Core web applications.\n\n## The Island Plan\n\nAn island has three parts: the initial content, the triggering event, and the endpoint that returns the dynamic content.\n\nLetâ€™s start by seeing what our `island` implementation will look like on a Razor page.\n\n```razor\n\nLoading...\n\n```\n\nThe `island` element has a URL attribute and some inner content that will be used as a placeholder while dynamic content is loaded. The handler for our dynamic content is a straightforward endpoint, but it could be any backend you choose. What you donâ€™t see in this initial example is a configurable event. Weâ€™ll see that in action later in the post.\n\n```csharp app.MapGet(\"/profile/avatar\", () => Results.Content( //lang=html $\"\"\"\n\nðŸŒ´ Welcome to the island Khalid!\n\nYou arrived on ({DateTime.Now.ToLongTimeString()})\n\n\"\"\") );\n\n```\n\nOK, letâ€™s build it!\n\n## Creating an Island TagHelper\n\nWhile I initially attempted to do this with a `ViewComponent` I found it needing more in what it could accomplish. Tag Helpers are vastly more powerful and capable in this case.\n\n```csharp using System.ComponentModel.DataAnnotations; using Microsoft.AspNetCore.Razor.TagHelpers;\n\npublic enum IslandEvents { Load, Revealed, Intersect }\n\n[HtmlTargetElement(\"island\")] public class IslandTagHelper : TagHelper { [HtmlAttributeName(\"url\"), Required] public string? Url { get; set; }\n\n[HtmlAttributeName(\"event\")] public IslandEvents Event { get; set; } = IslandEvents.Load;\n\npublic override async Task ProcessAsync(TagHelperContext context, TagHelperOutput output) { // Changing the tag name to \"div\" output.TagName = \"div\";\n\nvar @event = Event switch { IslandEvents.Load => \"load\", IslandEvents.Revealed => \"revealed\", IslandEvents.Intersect => \"intersect once\", _ => \"load\" };\n\noutput.Attributes.SetAttribute(\"hx-get\", Url); output.Attributes.SetAttribute(\"hx-trigger\", @event); output.Attributes.SetAttribute(\"hx-swap\", \"outerHTML\");\n\n// Retrieve the inner content var childContent = await output.GetChildContentAsync(); output.Content.SetHtmlContent(childContent);\n\n// Ensuring the tag is not self-closing output.TagMode = TagMode.StartTagAndEndTag; } }\n\n```\n\nRemember to register the tag helper in `_ViewImports.cshtml` . Since weâ€™re using [Htmx](https://htmx.org), you must add the script reference to your `_Layout.cshtml` .\n\n```html\n\n```\n\nYouâ€™ll notice we have an `enum` of `IslandEvents` . Letâ€™s discuss what each person does and how their behavior differs.\n\n- **Load**: After the initial page load, the page will retrieve the dynamic content.\n- **Revealed**: The dynamic content will be retrieved only after the element is visible to the user.\n- **Intersect**: If the element is in an `overflow`\n, the page will only retrieve the dynamic content after it intersects with the visible part of the page.\n\nLetâ€™s look at how to change the default loading behavior.\n\n```razor\n\nLoading...\n\n```\n\nIn the example, the `margin-top` is `2000px` . This forces us to scroll down to reveal the element, and only then will we call for dynamic content.\n\n## Response and Output Caching\n\nWhile not the main focus of this post, response and output caching will be essential to using islands. As mentioned, you want to share as much as possible across user sessions to reap the benefits of these techniques.\n\nYou must update your `Program` file to include the following components to add output and response cachingâ€”first, the service registrations.\n\n```csharp builder.Services.AddOutputCache(); builder.Services.AddResponseCaching();\n\n```\n\nThen, as part of your ASP.NET Core pipeline, youâ€™ll need to add the following middleware calls.\n\n```csharp app.UseResponseCaching(); app.UseOutputCache();\n\n```\n\nOnce registered, you can apply output caching to the endpoint, which displays most of the content. Here is an example of its use on a Razor page.\n\n```csharp using Microsoft.AspNetCore.Mvc; using Microsoft.AspNetCore.Mvc.RazorPages; using Microsoft.AspNetCore.OutputCaching;\n\n[OutputCache(Duration = 100), ResponseCache( Duration = 100, Location = ResponseCacheLocation.Any, NoStore = false)] public class IndexModel(ILogger logger) : PageModel { private readonly ILogger logger = logger;\n\npublic void OnGet() { } }\n\n```\n\nFeel free to apply caching to the dynamic endpoints, being mindful of cache-busting based on a userâ€™s session variables.\n\n```csharp app.MapGet(\"/profile/avatar\", () => Results.Content( //lang=html $\"\"\"\n\nðŸŒ´ Welcome to the island Khalid!\n\nYou arrived on ({DateTime.Now.ToLongTimeString()})\n\n\"\"\")) .CacheOutput(policy => { /* apply caching policy here */ });\n\n```\n\nIf you are unfamiliar with caching in ASP.NET Core, [I recommend that you read the official documentation on the topic](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/output?view=aspnetcore-8.0).\n\nThere you have it. ASP.NET Core Islands using Htmx.\n\n## Conclusion\n\nSome folks may wonder why they should not just do all the caching and reuse on the server, including techniques like [*donut caching* and *donut hole caching](https://www.computerworld.com/article/1604649/what-exactly-is-donut-caching.html)*. The advantage of this approach is that dynamic content can come from **anywhere** and isnâ€™t explicitly tied to your ASP.NET Core server backend. You can deliver dynamic content from CDNs, function as service endpoints, use other static sites, and more. Itâ€™s a technique that benefits from ASP.NET Core but isnâ€™t tied to it.\n\nIf I spent more time on this implementation, Iâ€™d likely integrate islands more closely to ASP.NET Coreâ€™s routing mechanisms, allowing users to specify pages, handlers, MVC actions, and more. That said, a simple `url` attribute works just fine.\n\nFinally, TagHelpers are an underrated feature of the ASP.NET Core stack, and I think people should revisit them.\n\nIf youâ€™d like to see a running sample of this project, visit my **[GitHub repository and try it out for yourself](https://github.com/khalidabuhakmeh/aspnetcore-htmx-islands)**. Cheers.",
  "Link": "https://khalidabuhakmeh.com/dynamic-htmx-islands-with-aspnet-core",
  "FeedName": "Khalid Abuhakmeh's Blog",
  "Author": "Khalid Abuhakmeh",
  "EnhancedContent": "![Dynamic Htmx Islands with ASP.NET Core](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_800/https://khalidabuhakmeh.com/assets/images/posts/misc/dynamic-htmx-islands-aspnet-core-taghelpers.jpg)\n\nPhoto by [Denys Nevozhai](https://unsplash.com/@dnevozhai)\n\nIâ€™m a big fan of static site renderers, and they are still one of the missing elements that would make ASP.NET Core more compelling for users across the vast ecosystem divide. In the meantime, developers must rely on tools like Astro, Jekyll, and 11ty to build static site experiences. Recently, I read about Astro 5.0 and its [server island implementation](https://5-0-0-beta.docs.astro.build/en/guides/server-islands/). Server islands allow for mostly static pages to carve out portions of the page that will be rendered on-demand by, you guessed it, the server. This allows site authors to deliver fast, statically rendered pages that benefit the user while allowing for dynamic user-specific content.\n\nIn this post, weâ€™ll see how to implement a similar island approach in ASP.NET Core applications that utilize **response and output caching** for performance increases while still carving out small page sections for dynamic content. Weâ€™ll use Htmx to trigger requests for dynamic content based on three exclusive page events.\n\n## What is an Island?\n\nAs described in the introduction, an island is part of the document object model (DOM) that is loaded after the initial page load. This allows the shared DOM across users to be cached while dynamic content specific to a user session is loaded afterward. While a post-load event is commonly used to retrieve dynamic content, islands can also be lazily loaded and take advantage of the `revealed` or `intersect` events. These will only trigger requests if the user sees this DOM element on the page. Optimizing pages by selecting island events can reduce unnecessary service processing. In general, islands are a powerful technique when building web applications.\n\nExamples of islands may include a profile name in a pageâ€™s navigation, customized recommendations on a storefront, user-based statistics for a dashboard, and more. These islands typically comprise a small yet critical part of the user experience.\n\nNow, letâ€™s implement an `island` component for ASP.NET Core web applications.\n\n## The Island Plan\n\nAn island has three parts: the initial content, the triggering event, and the endpoint that returns the dynamic content.\n\nLetâ€™s start by seeing what our `island` implementation will look like on a Razor page.\n\n```razor <island url=\"/profile/avatar\"> <div class=\"alert alert-info d-flex justify-content-center vertical-align-center\"> <div class=\"spinner-border\" role=\"status\"> <span class=\"visually-hidden\">Loading...</span> </div> </div> </island>\n\n```\n\nThe `island` element has a URL attribute and some inner content that will be used as a placeholder while dynamic content is loaded. The handler for our dynamic content is a straightforward endpoint, but it could be any backend you choose. What you donâ€™t see in this initial example is a configurable event. Weâ€™ll see that in action later in the post.\n\n```csharp app.MapGet(\"/profile/avatar\", () => Results.Content( //lang=html $\"\"\" <div class=\"alert alert-info\"> <p class=\"fs-1 fw-bold\">ðŸŒ´ Welcome to the island Khalid!</p> <p class=\"fs-3\">You arrived on ({DateTime.Now.ToLongTimeString()})</p> </div> \"\"\") );\n\n```\n\nOK, letâ€™s build it!\n\n## Creating an Island TagHelper\n\nWhile I initially attempted to do this with a `ViewComponent` I found it needing more in what it could accomplish. Tag Helpers are vastly more powerful and capable in this case.\n\n```csharp using System.ComponentModel.DataAnnotations; using Microsoft.AspNetCore.Razor.TagHelpers;\n\npublic enum IslandEvents { Load, Revealed, Intersect }\n\n[HtmlTargetElement(\"island\")] public class IslandTagHelper : TagHelper { [HtmlAttributeName(\"url\"), Required] public string? Url { get; set; }\n\n[HtmlAttributeName(\"event\")] public IslandEvents Event { get; set; } = IslandEvents.Load;\n\npublic override async Task ProcessAsync(TagHelperContext context, TagHelperOutput output) { // Changing the tag name to \"div\" output.TagName = \"div\";\n\nvar @event = Event switch { IslandEvents.Load => \"load\", IslandEvents.Revealed => \"revealed\", IslandEvents.Intersect => \"intersect once\", _ => \"load\" };\n\noutput.Attributes.SetAttribute(\"hx-get\", Url); output.Attributes.SetAttribute(\"hx-trigger\", @event); output.Attributes.SetAttribute(\"hx-swap\", \"outerHTML\");\n\n// Retrieve the inner content var childContent = await output.GetChildContentAsync(); output.Content.SetHtmlContent(childContent);\n\n// Ensuring the tag is not self-closing output.TagMode = TagMode.StartTagAndEndTag; } }\n\n```\n\nRemember to register the tag helper in `_ViewImports.cshtml` . Since weâ€™re using [Htmx](https://htmx.org), you must add the script reference to your `_Layout.cshtml` .\n\n```html <script src=\"https://unpkg.com/htmx.org@2.0.3\"></script>\n\n```\n\nYouâ€™ll notice we have an `enum` of `IslandEvents` . Letâ€™s discuss what each person does and how their behavior differs.\n\n- **Load**: After the initial page load, the page will retrieve the dynamic content.\n- **Revealed**: The dynamic content will be retrieved only after the element is visible to the user.\n- **Intersect**: If the element is in an `overflow`\n, the page will only retrieve the dynamic content after it intersects with the visible part of the page.\n\nLetâ€™s look at how to change the default loading behavior.\n\n```razor <div style=\"margin-top: 2000px\"> <island url=\"/profile/avatar\" event=\"Revealed\"> <div class=\"alert alert-info d-flex justify-content-center vertical-align-center\"> <div class=\"spinner-border\" role=\"status\"> <span class=\"visually-hidden\">Loading...</span> </div> </div> </island> </div>\n\n```\n\nIn the example, the `margin-top` is `2000px` . This forces us to scroll down to reveal the element, and only then will we call for dynamic content.\n\n## Response and Output Caching\n\nWhile not the main focus of this post, response and output caching will be essential to using islands. As mentioned, you want to share as much as possible across user sessions to reap the benefits of these techniques.\n\nYou must update your `Program` file to include the following components to add output and response cachingâ€”first, the service registrations.\n\n```csharp builder.Services.AddOutputCache(); builder.Services.AddResponseCaching();\n\n```\n\nThen, as part of your ASP.NET Core pipeline, youâ€™ll need to add the following middleware calls.\n\n```csharp app.UseResponseCaching(); app.UseOutputCache();\n\n```\n\nOnce registered, you can apply output caching to the endpoint, which displays most of the content. Here is an example of its use on a Razor page.\n\n```csharp using Microsoft.AspNetCore.Mvc; using Microsoft.AspNetCore.Mvc.RazorPages; using Microsoft.AspNetCore.OutputCaching;\n\n[OutputCache(Duration = 100), ResponseCache( Duration = 100, Location = ResponseCacheLocation.Any, NoStore = false)] public class IndexModel(ILogger<IndexModel> logger) : PageModel { private readonly ILogger<IndexModel> logger = logger;\n\npublic void OnGet() { } }\n\n```\n\nFeel free to apply caching to the dynamic endpoints, being mindful of cache-busting based on a userâ€™s session variables.\n\n```csharp app.MapGet(\"/profile/avatar\", () => Results.Content( //lang=html $\"\"\" <div class=\"alert alert-info\"> <p class=\"fs-1 fw-bold\">ðŸŒ´ Welcome to the island Khalid!</p> <p class=\"fs-3\">You arrived on ({DateTime.Now.ToLongTimeString()})</p> </div> \"\"\")) .CacheOutput(policy => { /* apply caching policy here */ });\n\n```\n\nIf you are unfamiliar with caching in ASP.NET Core, [I recommend that you read the official documentation on the topic](https://learn.microsoft.com/en-us/aspnet/core/performance/caching/output?view=aspnetcore-8.0).\n\nThere you have it. ASP.NET Core Islands using Htmx.\n\n## Conclusion\n\nSome folks may wonder why they should not just do all the caching and reuse on the server, including techniques like [*donut caching* and *donut hole caching](https://www.computerworld.com/article/1604649/what-exactly-is-donut-caching.html)*. The advantage of this approach is that dynamic content can come from **anywhere** and isnâ€™t explicitly tied to your ASP.NET Core server backend. You can deliver dynamic content from CDNs, function as service endpoints, use other static sites, and more. Itâ€™s a technique that benefits from ASP.NET Core but isnâ€™t tied to it.\n\nIf I spent more time on this implementation, Iâ€™d likely integrate islands more closely to ASP.NET Coreâ€™s routing mechanisms, allowing users to specify pages, handlers, MVC actions, and more. That said, a simple `url` attribute works just fine.\n\nFinally, TagHelpers are an underrated feature of the ASP.NET Core stack, and I think people should revisit them.\n\nIf youâ€™d like to see a running sample of this project, visit my **[GitHub repository and try it out for yourself](https://github.com/khalidabuhakmeh/aspnetcore-htmx-islands)**. Cheers.\n\n![Khalid Abuhakmeh's Picture](/assets/images/authorimage.jpg)\n\n## About Khalid Abuhakmeh\n\nKhalid is a developer advocate at JetBrains focusing on .NET technologies and tooling.\n\n## Read Next\n\n[!\\[Update HTML Elements with Htmx Triggers and ASP.NET Core\\](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_500/https://khalidabuhakmeh.com/assets/images/posts/misc/htmx-aspnetcore-hx-trigger-html.jpg)](/update-html-elements-with-htmx-triggers-and-aspnet-core)\n\n[!\\[Building a Persistent Counter with Alpine.Js\\](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_500/https://khalidabuhakmeh.com/assets/images/posts/misc/building-persistent-counter-alpinejs-javascript.jpg)](/building-a-persistent-counter-with-alpinejs)",
  "PubDate": "2024-11-19T00:00:00+00:00"
}
