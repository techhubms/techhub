{
  "Tags": [
    "csharp",
    "dotnet"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Khalid Abuhakmeh",
  "ProcessedDate": "2025-08-05 14:22:13",
  "FeedUrl": "https://khalidabuhakmeh.com/feed.xml",
  "Title": "Generic C# Methods with Enum Constraints for .NET",
  "Description": "Every couple of years, I tend to write the same variation of an `enum` helper that reads metadata from an enumeration using reflection. Almost any .NET developer with a few years of experience has done the same. The implementation uses Generics to work for any `enum` defined in my solution, as there is typically more than one described in a typical .NET solution. Historically, generics and enums didn’t work well because of the limitations of generics when dealing with this particular type, but to my surprise, they do now!\n\nIn this post, we’ll explore how to write the helper method I’m describing while ensuring the generic constraints stop us from passing in arguments other than enums.\n\n## Straight To The Implementation\n\nSince this post will be short, I’ll start with a sample you can play with.\n\n```csharp using System.ComponentModel; using System.Reflection;\n\n// get all descriptions { Console.WriteLine(\"Groceries:\\n\"); var descriptions = Enums.GetDescriptions(); foreach (var (value, description) in descriptions) { Console.WriteLine($\"{value} - {description}\"); } Console.WriteLine(); }\n\n// Get a description for a single value { var (value, description) = Enums.GetDescription(Groceries.Fruit); Console.WriteLine($\"Single value:\\n{value} - {description}\"); }\n\npublic enum Groceries { [Description(\"Apples, Oranges, Bananas\")] Fruit, [Description(\"Spinach, Kale, Broccoli, Cabbage\")] Vegetables, [Description(\"Cheese, Milk, Yogurt\")] Dairy, [Description(\"Chicken, Beef, Pork, Lamb, Turkey\")] Meat, [Description(\"Anything not listed above\")] Other }\n\npublic static class Enums { public static IEnumerable GetDescriptions() where TEnum : struct, Enum { var values = Enum.GetValues(); foreach (var value in values) { yield return GetDescription(value); } }\n\npublic static (TEnum Value, string Description) GetDescription(TEnum value) where TEnum : struct, Enum { var type = typeof(TEnum); var name = value.ToString(); var info = type.GetMember(name)[0]; var description = info.GetCustomAttribute() is { } attr ? attr.Description : name;\n\nreturn (value, description); } }\n\n```\n\nThe helper code is here for people who don’t want to visualize the previous sample.\n\n```csharp public static class Enums { public static IEnumerable GetDescriptions() where TEnum : struct, Enum { var values = Enum.GetValues(); foreach (var value in values) { yield return GetDescription(value); } }\n\npublic static (TEnum Value, string Description) GetDescription(TEnum value) where TEnum : struct, Enum { var type = typeof(TEnum); var name = value.ToString(); var info = type.GetMember(name)[0]; var description = info.GetCustomAttribute() is { } attr ? attr.Description : name;\n\nreturn (value, description); } }\n\n```\n\nThe essential part of our generic methods is our method declarations’ `where` clause.\n\n```csharp where TEnum: struct, Enum\n\n```\n\nThis line adds two crucial elements to our generic method.\n\nIt makes sure that `TEnum` is an `Enum` type. The `struct` ensures that `TEnum` is non-nullable.\n\nThe non-nullability of an `Enum` is essential since we are using the `Enum.GetValues` method to get known values. You could remove this constraint, but your implementation would require more boxing and defensive programming in the form of null checks. It’s more straightforward to enforce the `struct` requirement.\n\n## Conclusion\n\nThere you go, a constrained generic method implementation that can get metadata from an Enum value. If you’re still wondering, “where would I use this?” I find these methods helpful in web applications for creating a `SelectListItem` , but I stuck with Tuples for this post. What a time to be alive. Cheers!",
  "Link": "https://khalidabuhakmeh.com/generic-csharp-methods-with-enum-constraints-for-dotnet",
  "FeedName": "Khalid Abuhakmeh's Blog",
  "Author": "Khalid Abuhakmeh",
  "EnhancedContent": "![Generic C# Methods with Enum Constraints for .NET](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_800/https://khalidabuhakmeh.com/assets/images/posts/misc/generic-csharp-methods-enums-dotnet.jpg)\n\nPhoto by [Stephanie Klepacki](https://unsplash.com/@sklepacki)\n\nEvery couple of years, I tend to write the same variation of an `enum` helper that reads metadata from an enumeration using reflection. Almost any .NET developer with a few years of experience has done the same. The implementation uses Generics to work for any `enum` defined in my solution, as there is typically more than one described in a typical .NET solution. Historically, generics and enums didn’t work well because of the limitations of generics when dealing with this particular type, but to my surprise, they do now!\n\nIn this post, we’ll explore how to write the helper method I’m describing while ensuring the generic constraints stop us from passing in arguments other than enums.\n\n## Straight To The Implementation\n\nSince this post will be short, I’ll start with a sample you can play with.\n\n```csharp using System.ComponentModel; using System.Reflection;\n\n// get all descriptions { Console.WriteLine(\"Groceries:\\n\"); var descriptions = Enums.GetDescriptions<Groceries>(); foreach (var (value, description) in descriptions) { Console.WriteLine($\"{value} - {description}\"); } Console.WriteLine(); }\n\n// Get a description for a single value { var (value, description) = Enums.GetDescription(Groceries.Fruit); Console.WriteLine($\"Single value:\\n{value} - {description}\"); }\n\npublic enum Groceries { [Description(\"Apples, Oranges, Bananas\")] Fruit, [Description(\"Spinach, Kale, Broccoli, Cabbage\")] Vegetables, [Description(\"Cheese, Milk, Yogurt\")] Dairy, [Description(\"Chicken, Beef, Pork, Lamb, Turkey\")] Meat, [Description(\"Anything not listed above\")] Other }\n\npublic static class Enums { public static IEnumerable<(TEnum Value, string Description)> GetDescriptions<TEnum>() where TEnum : struct, Enum { var values = Enum.GetValues<TEnum>(); foreach (var value in values) { yield return GetDescription(value); } }\n\npublic static (TEnum Value, string Description) GetDescription<TEnum>(TEnum value) where TEnum : struct, Enum { var type = typeof(TEnum); var name = value.ToString(); var info = type.GetMember(name)[0]; var description = info.GetCustomAttribute<DescriptionAttribute>() is { } attr ? attr.Description : name;\n\nreturn (value, description); } }\n\n```\n\nThe helper code is here for people who don’t want to visualize the previous sample.\n\n```csharp public static class Enums { public static IEnumerable<(TEnum Value, string Description)> GetDescriptions<TEnum>() where TEnum : struct, Enum { var values = Enum.GetValues<TEnum>(); foreach (var value in values) { yield return GetDescription(value); } }\n\npublic static (TEnum Value, string Description) GetDescription<TEnum>(TEnum value) where TEnum : struct, Enum { var type = typeof(TEnum); var name = value.ToString(); var info = type.GetMember(name)[0]; var description = info.GetCustomAttribute<DescriptionAttribute>() is { } attr ? attr.Description : name;\n\nreturn (value, description); } }\n\n```\n\nThe essential part of our generic methods is our method declarations’ `where` clause.\n\n```csharp where TEnum: struct, Enum\n\n```\n\nThis line adds two crucial elements to our generic method.\n\nIt makes sure that `TEnum` is an `Enum` type. The `struct` ensures that `TEnum` is non-nullable.\n\nThe non-nullability of an `Enum` is essential since we are using the `Enum.GetValues<TEnum>` method to get known values. You could remove this constraint, but your implementation would require more boxing and defensive programming in the form of null checks. It’s more straightforward to enforce the `struct` requirement.\n\n## Conclusion\n\nThere you go, a constrained generic method implementation that can get metadata from an Enum value. If you’re still wondering, “where would I use this?” I find these methods helpful in web applications for creating a `SelectListItem` , but I stuck with Tuples for this post. What a time to be alive. Cheers!\n\n![Khalid Abuhakmeh's Picture](/assets/images/authorimage.jpg)\n\n## About Khalid Abuhakmeh\n\nKhalid is a developer advocate at JetBrains focusing on .NET technologies and tooling.\n\n## Read Next\n\n[!\\[Strongly-Typed Markdown for ASP.NET Core Content Apps\\](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_500/https://khalidabuhakmeh.com/assets/images/posts/misc/strongly-typed-markdown-aspnetcore-content-apps.jpg)](/strongly-typed-markdown-for-aspnet-core-content-apps)\n\n[!\\[Server-Sent Events in ASP.NET Core and .NET 10\\](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_500/https://khalidabuhakmeh.com/assets/images/posts/misc/server-sent-events-dotnet-10-aspnetcore-minimal-apis.jpg)](/server-sent-events-in-aspnet-core-and-dotnet-10)",
  "PubDate": "2025-03-04T00:00:00+00:00"
}
