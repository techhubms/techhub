{
  "Tags": [
    "csharp",
    "dotnet"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Khalid Abuhakmeh",
  "ProcessedDate": "2025-08-05 14:22:13",
  "FeedUrl": "https://khalidabuhakmeh.com/feed.xml",
  "Title": "The Curious Case of .NET ConcurrentDictionary and Closures",
  "Description": "I was recently looking at the [Duende Software](https://duendesoftware.com) codebase, and I kept seeing the same suggestion offered by the IDE tooling whenever I encountered a `ConcurrentDictionary` : **“Closure can be eliminated: method has overload to avoid closure creation.”**\n\nWhile the suggestion appears in the tooling, there isn’t a quick fix action to apply the change. It left me scratching my head because there wasn’t an immediately obvious solution.\n\nThis post will define closures and explain their problems. We’ll also explain how to change your usage of `ConcurrentDictionary` to avoid closures altogether.\n\n## What Are Closures?\n\nIf you’ve ever worked with an `Action` , `Func` , `delegate` , or LINQ, then you’ve likely encountered a closure. A closure is a language mechanism that allows you to treat a function with **free variables** as if it were an object instance you may pass, invoke, or use in another context from when you first created it. [Justin Etheredge](https://www.simplethread.com/c-closures-explained/) has a great article explaining closures in-depth, but it’s when you use a lambda with a state outside the current scope of the lambda.\n\nLet’s create a closure by capturing a variable in a straightforward example.\n\n```csharp void SayHello(string name) { var hello = () => { // name is captured causing an allocation // and potential concurrency issues Console.WriteLine($\"Hello {name}\"); }; hello(); }\n\n```\n\nIn the code above, the compiler needs to capture the `name` parameter to ensure all future calls to our `hello` lambda can execute. Capture can cause issues that may be difficult to predict until you execute your code.\n\n1. Additional allocations are needed to capture a value and can have resource utilization implications.\n2. A value captured from outside the closure scope may be alterable if it is a reference type. Unintended state change can lead to unpredictable behavior.\n3. Long-lived references may lead to memory leaks in the long run.\n\nTo avoid capture, ensure all lambdas pass state required as arguments.\n\n```csharp void SayHello(string name) { var hello = (string n) => { Console.WriteLine($\"Hello {n}\"); }; hello(name); }\n\n```\n\nNow that we understand the basics, let’s examine the `ConcurrentDictionary` suggestion and see how we might fix it.\n\n## ConcurrentDictionary.GetOrAdd and Closure Creation\n\nLet’s write a straightforward use of the `GetOrAdd` method on `ConcurrentDictionary` and see what the issue might be.\n\n```csharp using System.Collections.Concurrent;\n\nConcurrentDictionary concurrentDictionary = new();\n\nvar key = \"khalid\"; var value = \"awesome\";\n\nvar result = concurrentDictionary.GetOrAdd(key, (k) => { Console.WriteLine($\"Building {k}\"); return new Item(value, DateTime.Now); });\n\nConsole.WriteLine(result);\n\n```\n\nLooking at the code, what variable do you think is creating the unnecessary closure?\n\nIf you guessed `value` , then you would be correct!\n\nHow do we fix the closure since our tooling now suggests that there is a solution to this issue?\n\n```text Closure can be eliminated: method has overload to avoid closure creation.\n\n```\n\nWell, let’s refactor and see how our code changes. I’ll add parameter prefixes to make clear what is happening.\n\n```csharp using System.Collections.Concurrent;\n\nConcurrentDictionary concurrentDictionary = new();\n\nvar key = \"khalid\"; var value = \"awesome\";\n\nvar result = concurrentDictionary.GetOrAdd( key: key, valueFactory: (k, arg) => { Console.WriteLine($\"Building {k}\"); return new Item(arg, DateTime.Now); }, factoryArgument: value);\n\nConsole.WriteLine(result);\n\nrecord Item(string Value, DateTime Time);\n\n```\n\nSo there is an overload on `ConcurrentDictionary.GetOrAdd` that takes three parameters:\n\n1. The key to our value.\n2. The lambda function responsible for creating our value when we do not find it.\n3. A singular factory argument. You must wrap multiple arguments in a container class.\n\nUsing this overload, we now avoid closures, reduce allocations, and avoid potentially nasty concurrency or memory leak issues.\n\nIf you’re using `ConcurrentDictionary` check to see if you’re using `GetOrAdd` and see if you’re using the more efficient overload. Thanks for reading and sharing my posts with friends and colleagues. Cheers.",
  "Link": "https://khalidabuhakmeh.com/the-curious-case-of-dotnet-concurrentdictionary-and-closures",
  "FeedName": "Khalid Abuhakmeh's Blog",
  "Author": "Khalid Abuhakmeh",
  "EnhancedContent": "![The Curious Case of .NET ConcurrentDictionary and Closures](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_800/https://khalidabuhakmeh.com/assets/images/posts/misc/dotnet-concurrentdictionary-getoradd-closures.jpg)\n\nPhoto by [Chris Arthur-Collins](https://unsplash.com/@anotherleaf)\n\nI was recently looking at the [Duende Software](https://duendesoftware.com) codebase, and I kept seeing the same suggestion offered by the IDE tooling whenever I encountered a `ConcurrentDictionary` : **“Closure can be eliminated: method has overload to avoid closure creation.”**\n\nWhile the suggestion appears in the tooling, there isn’t a quick fix action to apply the change. It left me scratching my head because there wasn’t an immediately obvious solution.\n\nThis post will define closures and explain their problems. We’ll also explain how to change your usage of `ConcurrentDictionary` to avoid closures altogether.\n\n## What Are Closures?\n\nIf you’ve ever worked with an `Action` , `Func` , `delegate` , or LINQ, then you’ve likely encountered a closure. A closure is a language mechanism that allows you to treat a function with **free variables** as if it were an object instance you may pass, invoke, or use in another context from when you first created it. [Justin Etheredge](https://www.simplethread.com/c-closures-explained/) has a great article explaining closures in-depth, but it’s when you use a lambda with a state outside the current scope of the lambda.\n\nLet’s create a closure by capturing a variable in a straightforward example.\n\n```csharp void SayHello(string name) { var hello = () => { // name is captured causing an allocation // and potential concurrency issues Console.WriteLine($\"Hello {name}\"); }; hello(); }\n\n```\n\nIn the code above, the compiler needs to capture the `name` parameter to ensure all future calls to our `hello` lambda can execute. Capture can cause issues that may be difficult to predict until you execute your code.\n\n1. Additional allocations are needed to capture a value and can have resource utilization implications.\n2. A value captured from outside the closure scope may be alterable if it is a reference type. Unintended state change can lead to unpredictable behavior.\n3. Long-lived references may lead to memory leaks in the long run.\n\nTo avoid capture, ensure all lambdas pass state required as arguments.\n\n```csharp void SayHello(string name) { var hello = (string n) => { Console.WriteLine($\"Hello {n}\"); }; hello(name); }\n\n```\n\nNow that we understand the basics, let’s examine the `ConcurrentDictionary` suggestion and see how we might fix it.\n\n## ConcurrentDictionary.GetOrAdd and Closure Creation\n\nLet’s write a straightforward use of the `GetOrAdd` method on `ConcurrentDictionary` and see what the issue might be.\n\n```csharp using System.Collections.Concurrent;\n\nConcurrentDictionary<string, Item> concurrentDictionary = new();\n\nvar key = \"khalid\"; var value = \"awesome\";\n\nvar result = concurrentDictionary.GetOrAdd(key, (k) => { Console.WriteLine($\"Building {k}\"); return new Item(value, DateTime.Now); });\n\nConsole.WriteLine(result);\n\n```\n\nLooking at the code, what variable do you think is creating the unnecessary closure?\n\nIf you guessed `value` , then you would be correct!\n\nHow do we fix the closure since our tooling now suggests that there is a solution to this issue?\n\n```text Closure can be eliminated: method has overload to avoid closure creation.\n\n```\n\nWell, let’s refactor and see how our code changes. I’ll add parameter prefixes to make clear what is happening.\n\n```csharp using System.Collections.Concurrent;\n\nConcurrentDictionary<string, Item> concurrentDictionary = new();\n\nvar key = \"khalid\"; var value = \"awesome\";\n\nvar result = concurrentDictionary.GetOrAdd( key: key, valueFactory: (k, arg) => { Console.WriteLine($\"Building {k}\"); return new Item(arg, DateTime.Now); }, factoryArgument: value);\n\nConsole.WriteLine(result);\n\nrecord Item(string Value, DateTime Time);\n\n```\n\nSo there is an overload on `ConcurrentDictionary.GetOrAdd` that takes three parameters:\n\n1. The key to our value.\n2. The lambda function responsible for creating our value when we do not find it.\n3. A singular factory argument. You must wrap multiple arguments in a container class.\n\nUsing this overload, we now avoid closures, reduce allocations, and avoid potentially nasty concurrency or memory leak issues.\n\nIf you’re using `ConcurrentDictionary` check to see if you’re using `GetOrAdd` and see if you’re using the more efficient overload. Thanks for reading and sharing my posts with friends and colleagues. Cheers.\n\n![Khalid Abuhakmeh's Picture](/assets/images/authorimage.jpg)\n\n## About Khalid Abuhakmeh\n\nKhalid is a developer advocate at JetBrains focusing on .NET technologies and tooling.\n\n## Read Next\n\n[!\\[ASP.NET Core and Chunking HTTP Cookies\\](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_500/https://khalidabuhakmeh.com/assets/images/posts/misc/aspnet-core-http-cookies-chunking.jpg)](/aspnet-core-and-chunking-http-cookies)\n\n[!\\[Strongly-Typed Markdown for ASP.NET Core Content Apps\\](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_500/https://khalidabuhakmeh.com/assets/images/posts/misc/strongly-typed-markdown-aspnetcore-content-apps.jpg)](/strongly-typed-markdown-for-aspnet-core-content-apps)",
  "PubDate": "2025-02-18T00:00:00+00:00"
}
