{
  "Tags": [
    "htmx",
    "playwright"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Khalid Abuhakmeh",
  "ProcessedDate": "2025-08-05 14:22:14",
  "FeedUrl": "https://khalidabuhakmeh.com/feed.xml",
  "Title": "Htmx and Playwright Tests in C#",
  "Description": "Community member Jonathan Channon recently approached me about an appropriate way to test your Htmx-powered applications using the Playwright testing framework. It can be annoying to get the timing right between sending an HTMX request, processing it on the server, and applying it to the page.\n\nIn this post, we’ll see a surefire way to wait for Htmx to finish before testing the state of your pages, thus leading to more reliable tests and faster test execution. Let’s go.\n\n## The Htmx Counter Application\n\nLet’s first see what application we’ll be testing. It’s a simple \\*\\*Counter \\*\\* component that increases in value when the user presses a button.\n\n```razor @model HtmxPlaywrightIntegration.ViewModels.CounterViewModel\n\n@Model.Count\n\n```\n\nThe ASP.NET Core endpoint is straightforward.\n\n```csharp using HtmxPlaywrightIntegration.ViewModels; using Microsoft.AspNetCore.Mvc; using Microsoft.AspNetCore.Mvc.RazorPages;\n\nnamespace HtmxPlaywrightIntegration.Pages;\n\npublic class IndexModel(ILogger logger) : PageModel { public static CounterViewModel Value { get; set; } = new();\n\npublic void OnGet() { }\n\npublic IActionResult OnPost() { Value.Count += 1; return Partial(\"_Counter\", Value); } }\n\n```\n\nClicking the button will make a request to the server, increment the value, and return the HTML snippet to be processed into the page.\n\nNow, let’s move on to the next part of the process, the Htmx lifecycle.\n\n## Htmx Request Lifecycle Events\n\nHtmx contains multiple lifecycle events that we can utilize during a request. These events allow us to modify outgoing requests and understand what stages Htmx is at during the processing phase.\n\nThe lifecycle event we are most interested in is `htmx:afterSettle` . Settling is the process after all DOM changes have been applied and the page is now stable. Let’s hook into this page event and write a console message. I’ve added this to the typical `site.js` file, but it can go anywhere within your application.\n\n```javascript document.body.addEventListener('htmx:afterSettle', function(evt) { console.log('playwright:continue'); });\n\n```\n\nNow, whenever we settle the page, a console message will be written with the value of `playwright:continue` . We’ll see how to register this script into our page in the next section using the Playwright APIs.\n\n## Playwright and Htmx Extensions\n\nNow, let’s look at our test.\n\n```csharp namespace HtmxPlaywrightIntegration.Tests;\n\n[Parallelizable(ParallelScope.Self)] [TestFixture] public class Tests : PageTest { [Test] public async Task CanIncrementCountUsingHtmx() { await Page.GotoAsync(\"http://localhost:5170\");\n\nawait Page.RegisterHtmxLifecycleListener();\n\nvar button = Page.Locator(\"text=Increment\"); var body = Page.Locator(\"#value\");\n\nvar currentCount = int.Parse(await body.TextContentAsync() ?? \"-1\");\n\nawait button.ClickAsync(); await Page.WaitForHtmx();\n\nawait Expect(body).ToHaveTextAsync($\"{currentCount+1}\"); } }\n\n```\n\nWe first call the `RegisterHtmxLifecycleListener` script. This is the same JavaScript seen above. Then, we call `WaitForHtmx` , which will wait for the console message in our page’s output. Let’s see how these extension methods work.\n\n```csharp using Microsoft.Playwright;\n\nnamespace HtmxPlaywrightIntegration.Tests;\n\npublic static class HtmxExtensions { private const string Continue = \"playwright:continue\";\n\npublic static Task WaitForHtmx(this IPage page) { return page.WaitForConsoleMessageAsync(new() { Predicate = message => message.Text == Continue }); }\n\npublic static Task RegisterHtmxLifecycleListener(this IPage page) { return page.AddScriptTagAsync(new() { // language=javascript Content = $$\"\"\" document.body.addEventListener('htmx:afterSettle', function(evt) { console.log('{{Continue}}'); }); \"\"\" }); } }\n\n```\n\nIt’s that easy. Now, your Playwright tests can wait for messages generated by the Htmx lifecycle, so you don’t have to worry about changes to your implementation on the front or back end changing how your tests execute. Additionally, you won’t have to waste time waiting for random delays to progress through your tests.\n\nI hope you found this post helpful. Have fun building Htmx apps tested by Playwright. Cheers.",
  "Link": "https://khalidabuhakmeh.com/htmx-and-playwright-tests-in-csharp",
  "FeedName": "Khalid Abuhakmeh's Blog",
  "Author": "Khalid Abuhakmeh",
  "EnhancedContent": "![Htmx and Playwright Tests in C#](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_800/https://khalidabuhakmeh.com/assets/images/posts/misc/htmx-playwright-csharp-tests.jpg)\n\nPhoto by [Ricardio de Penning](https://unsplash.com/@ricardio)\n\nCommunity member Jonathan Channon recently approached me about an appropriate way to test your Htmx-powered applications using the Playwright testing framework. It can be annoying to get the timing right between sending an HTMX request, processing it on the server, and applying it to the page.\n\nIn this post, we’ll see a surefire way to wait for Htmx to finish before testing the state of your pages, thus leading to more reliable tests and faster test execution. Let’s go.\n\n## The Htmx Counter Application\n\nLet’s first see what application we’ll be testing. It’s a simple \\*\\*Counter \\*\\* component that increases in value when the user presses a button.\n\n```razor @model HtmxPlaywrightIntegration.ViewModels.CounterViewModel\n\n<div id=\"counter\" class=\"card\"> <div id=\"value\" class=\"card-body\"> @Model.Count </div> <div class=\"card-footer\"> <form asp-page=\"Index\" method=\"post\" hx-post hx-target=\"#counter\" hx-swap=\"outerHTML\"> <button class=\"btn btn-primary\">Increment</button> </form> </div> </div>\n\n```\n\nThe ASP.NET Core endpoint is straightforward.\n\n```csharp using HtmxPlaywrightIntegration.ViewModels; using Microsoft.AspNetCore.Mvc; using Microsoft.AspNetCore.Mvc.RazorPages;\n\nnamespace HtmxPlaywrightIntegration.Pages;\n\npublic class IndexModel(ILogger<IndexModel> logger) : PageModel { public static CounterViewModel Value { get; set; } = new();\n\npublic void OnGet() { }\n\npublic IActionResult OnPost() { Value.Count += 1; return Partial(\"_Counter\", Value); } }\n\n```\n\nClicking the button will make a request to the server, increment the value, and return the HTML snippet to be processed into the page.\n\nNow, let’s move on to the next part of the process, the Htmx lifecycle.\n\n## Htmx Request Lifecycle Events\n\nHtmx contains multiple lifecycle events that we can utilize during a request. These events allow us to modify outgoing requests and understand what stages Htmx is at during the processing phase.\n\nThe lifecycle event we are most interested in is `htmx:afterSettle` . Settling is the process after all DOM changes have been applied and the page is now stable. Let’s hook into this page event and write a console message. I’ve added this to the typical `site.js` file, but it can go anywhere within your application.\n\n```javascript document.body.addEventListener('htmx:afterSettle', function(evt) { console.log('playwright:continue'); });\n\n```\n\nNow, whenever we settle the page, a console message will be written with the value of `playwright:continue` . We’ll see how to register this script into our page in the next section using the Playwright APIs.\n\n## Playwright and Htmx Extensions\n\nNow, let’s look at our test.\n\n```csharp namespace HtmxPlaywrightIntegration.Tests;\n\n[Parallelizable(ParallelScope.Self)] [TestFixture] public class Tests : PageTest { [Test] public async Task CanIncrementCountUsingHtmx() { await Page.GotoAsync(\"http://localhost:5170\");\n\nawait Page.RegisterHtmxLifecycleListener();\n\nvar button = Page.Locator(\"text=Increment\"); var body = Page.Locator(\"#value\");\n\nvar currentCount = int.Parse(await body.TextContentAsync() ?? \"-1\");\n\nawait button.ClickAsync(); await Page.WaitForHtmx();\n\nawait Expect(body).ToHaveTextAsync($\"{currentCount+1}\"); } }\n\n```\n\nWe first call the `RegisterHtmxLifecycleListener` script. This is the same JavaScript seen above. Then, we call `WaitForHtmx` , which will wait for the console message in our page’s output. Let’s see how these extension methods work.\n\n```csharp using Microsoft.Playwright;\n\nnamespace HtmxPlaywrightIntegration.Tests;\n\npublic static class HtmxExtensions { private const string Continue = \"playwright:continue\";\n\npublic static Task WaitForHtmx(this IPage page) { return page.WaitForConsoleMessageAsync(new() { Predicate = message => message.Text == Continue }); }\n\npublic static Task RegisterHtmxLifecycleListener(this IPage page) { return page.AddScriptTagAsync(new() { // language=javascript Content = $$\"\"\" document.body.addEventListener('htmx:afterSettle', function(evt) { console.log('{{Continue}}'); }); \"\"\" }); } }\n\n```\n\nIt’s that easy. Now, your Playwright tests can wait for messages generated by the Htmx lifecycle, so you don’t have to worry about changes to your implementation on the front or back end changing how your tests execute. Additionally, you won’t have to waste time waiting for random delays to progress through your tests.\n\nI hope you found this post helpful. Have fun building Htmx apps tested by Playwright. Cheers.\n\n![Khalid Abuhakmeh's Picture](/assets/images/authorimage.jpg)\n\n## About Khalid Abuhakmeh\n\nKhalid is a developer advocate at JetBrains focusing on .NET technologies and tooling.\n\n## Read Next\n\n[!\\[Intersperse Values for Enumerable Collections\\](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_500/https://khalidabuhakmeh.com/assets/images/posts/misc/intersperse-values-enumerable-csharp.jpg)](/intersperse-values-for-enumerable-collections)\n\n[!\\[Add EF Core Migrations to .NET Aspire Solutions\\](https://res.cloudinary.com/abuhakmeh/image/fetch/c_limit,f_auto,q_auto,w_500/https://khalidabuhakmeh.com/assets/images/posts/misc/dotnet-aspire-ef-core-migrations-approach.jpg)](/add-ef-core-migrations-to-dotnet-aspire-solutions)",
  "PubDate": "2024-09-24T00:00:00+00:00"
}
