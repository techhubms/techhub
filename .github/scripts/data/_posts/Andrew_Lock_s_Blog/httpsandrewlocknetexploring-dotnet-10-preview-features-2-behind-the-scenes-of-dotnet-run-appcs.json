{
  "Tags": [
    ".NET 10",
    "C#",
    "Source Code Dive"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Andrew Lock | .NET Escapades",
  "ProcessedDate": "2025-08-05 14:29:47",
  "FeedUrl": "https://andrewlock.net/rss.xml",
  "Title": "Behind the scenes of dotnet run app.cs: Exploring the .NET 10 preview - Part 2",
  "Description": "In this post I looks at how the new single-file .NET run experience is implemented inside the .NET SDK, focusing on how the virtual-project file is built",
  "Link": "https://andrewlock.net/exploring-dotnet-10-preview-features-2-behind-the-scenes-of-dotnet-run-app.cs/",
  "FeedName": "Andrew Lock's Blog",
  "Author": "Andrew Lock",
  "EnhancedContent": "In the [previous post](/exploring-dotnet-10-preview-features-1-exploring-the-dotnet-run-app.cs/), I described the new feature coming in .NET 10 for building and running a single C# file *without* needing to first create a *.csproj* project. In that post I described the various features currently implemented, what's coming soon, and the vision for the feature.\n\nIn this post, I look behind the scenes to see *how* the feature is implemented. I'm looking at the code at a point of time, so no doubt things will change, potentially a *lot*, before the final release with .NET 10. But I still think there's value in the looking at how it works *in general*, so you have a mental model for how the feature works, the limitations, and various edge cases you may run into.\n\nAs way of an introduction, we'll briefly take a look at the `dotnet run app.cs` experience, and then we'll dig into the code later.\n\n## What is `dotnet run app.cs`\n?\n\nPrior to .NET 10, a \"hello world\" C# application required at least 2 files:\n\n- A *.csproj* project file\n- A *.cs* file containing [top-level statements](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/program-structure/top-level-statements)\n\nNow .NET 10 includes [preview support](https://devblogs.microsoft.com/dotnet/announcing-dotnet-run-app/) for removing the need for the *.csproj* file too. Finally, a .NET application *only* needs a single *.cs* file. The hello-world C# program now becomes:\n\n```csharp Console.WriteLine(\"Hello, world\");\n\n```\n\nSave that to a file, *app.cs* for example, and you can run your application with `dotnet run app.cs` :\n\n```bash\n> dotnet run app.cs\nHello, world\n\n```\n\nAlternatively, a more complex example that demonstrates many of the features available in .NET 10 preview 5 might look like this:\n\n```csharp #!/usr/bin/dotnet run\n\n#:sdk Microsoft.NET.Sdk.Web #:package [emailÂ protected] #:property UserSecretsId 2eec9746-c21a-4933-90af-c22431f35459\n\nvar builder = WebApplication.CreateBuilder(args); var app = builder.Build();\n\napp.MapGet(\"/\", () => JsonConvert.SerializeObject(new { Greeting = \"Hello, World!\" }));\n\napp.Run();\n\n```\n\nThis shows the `#:` directives currently available, as well as the shebang. Next we'll look into the code behind these features.\n\n## How does it work behind the scenes?\n\nMany of [the](https://github.com/oleg-shilo/cs-script/wiki/CS-Script-Overview) [previous](https://github.com/dotnet-script/dotnet-script) [single-file](https://cakebuild.net/) or [REPL](https://learn.microsoft.com/en-us/archive/msdn-magazine/2016/january/essential-net-csharp-scripting#the-c-repl-command-line-interface-csiexe) experiences for C# and .NET used subtly different \"dialects\" of C#. Each of those tools used slightly different approaches and worked in different ways, which was similarly different to the \"full\" C# experience.\n\nThe `dotnet run app.cs` approach is to create a \"virtual\" *.csproj* file, and otherwise aim to fallback to the \"full\" `dotnet build` experience that you get with a \"traditional\" .NET project using a *.csproj* file. The advantage of this approach is that you can pretty much do anything you would do with a \"normal\" project in the single-file case. It also means there's always a direct route to converting the single-file into a project; it's essentially just whatever the *virtual* project looks like.\n\nSo what happens when you call `dotnet run app.cs` ? At a high level, the CLI takes the following steps:\n\n- Determine if the provided path, `app.cs`\n, is [a valid single-file program](https://github.com/dotnet/sdk/blob/87febc1daa96f146653611ace6f5e8c39af41722/src/Cli/dotnet/Commands/Run/VirtualProjectBuildingCommand.cs#L920).\n- If it is, create [a `VirtualProjectBuildingCommand`](https://github.com/dotnet/sdk/blob/87febc1daa96f146653611ace6f5e8c39af41722/src/Cli/dotnet/Commands/Run/VirtualProjectBuildingCommand.cs#L30), and execute it.\n- [Calculate a cache object](https://github.com/dotnet/sdk/blob/87febc1daa96f146653611ace6f5e8c39af41722/src/Cli/dotnet/Commands/Run/VirtualProjectBuildingCommand.cs#L273), to determine whether the project needs to be rebuilt.\n- If it does, parse the file, [extracting all the directives](https://github.com/dotnet/sdk/blob/87febc1daa96f146653611ace6f5e8c39af41722/src/Cli/dotnet/Commands/Run/VirtualProjectBuildingCommand.cs#L757).\n- Use the directives to [create an in-memory string version](https://github.com/dotnet/sdk/blob/87febc1daa96f146653611ace6f5e8c39af41722/src/Cli/dotnet/Commands/Run/VirtualProjectBuildingCommand.cs#L506) of a *.csproj* project file\n- Use MSBuild to do a `Restore`\nand `Build` with the provided virtual project file\n- Run the built command\n\nFor the rest of the post we'll be looking at these steps in order.\n\n### Identifying candidate single-file programs\n\nThe `dotnet` SDK uses System.CommandLine to parse the provided arguments, and tries to find the project or single-file to execute [by calling `DiscoverProjectFilePath`](https://github.com/dotnet/sdk/blob/4177291d4d3dabd5341239d01b3e844125659304/src/Cli/dotnet/Commands/Run/RunCommand.cs#L449). This method first tries to find a corresponding project file, but if one isn't provided (and you're not [reading from stdin](/exploring-dotnet-10-preview-features-1-exploring-the-dotnet-run-app.cs/#running-c-directly-from-stdin-code)), then the `RunCommand` checks if the provided argument is a valid entry point for the single-file program by calling `VirtualProjectBuildingComman.IsValidEntryPointPath()` :\n\n```csharp public static bool IsValidEntryPointPath(string entryPointFilePath) { if (!File.Exists(entryPointFilePath)) { return false; }\n\nif (entryPointFilePath.EndsWith(\".cs\", StringComparison.OrdinalIgnoreCase)) { return true; }\n\n// Check if the first two characters are #! try { using var stream = File.OpenRead(entryPointFilePath); int first = stream.ReadByte(); int second = stream.ReadByte(); return first == '#' && second == '!'; } catch { return false; } }\n\n```\n\nHopefully the logic here makes sense: if the file exists and it either ends with `.cs` *or* the first two characters of the file are `#!` , then the file is considered a valid entry point for a single-file program.\n\nIf you *are* reading from stdin, then you pass the argument `-` to `dotnet run` , e.g.\n\n```csharp\n> 'Console.WriteLine(\"Hello, World!\");' | dotnet run -\nHello, World!\n\n```\n\nThis is identified in [the `RunCommand.ParseResult()`](https://github.com/dotnet/sdk/blob/4177291d4d3dabd5341239d01b3e844125659304/src/Cli/dotnet/Commands/Run/RunCommand.cs#L566-L572) method, which writes the input to a temporary file:\n\n```csharp // If '-' is specified as the input file, read all text from stdin into a temporary file and use that as the entry point. entryPointFilePath = Path.GetTempFileName(); using (var stdinStream = Console.OpenStandardInput()) using (var fileStream = File.OpenWrite(entryPointFilePath)) { stdinStream.CopyTo(fileStream); }\n\n```\n\nAfter all this parsing is complete, a new `RunCommand` is created, passing in the path to the single-file.\n\n### Checking for previous builds\n\nAs part of the `RunCommand.Execute()` method, a new `VirtualProjectBuildingCommand` [is created](https://github.com/dotnet/sdk/blob/4177291d4d3dabd5341239d01b3e844125659304/src/Cli/dotnet/Commands/Run/RunCommand.cs#L286) and [executed](https://github.com/dotnet/sdk/blob/4177291d4d3dabd5341239d01b3e844125659304/src/Cli/dotnet/Commands/Run/RunCommand.cs#L265). The first step is running `NeedsToBuild()` to check whether a new build actually needs to be started, or whether a cached build result can be reused.\n\nThe [`NeedsToBuild`](https://github.com/dotnet/sdk/blob/4177291d4d3dabd5341239d01b3e844125659304/src/Cli/dotnet/Commands/Run/VirtualProjectBuildingCommand.cs#L298) method starts by [building a cache entry object](https://github.com/dotnet/sdk/blob/4177291d4d3dabd5341239d01b3e844125659304/src/Cli/dotnet/Commands/Run/VirtualProjectBuildingCommand.cs#L273-L296) based on all the files that are part of the compilation. That includes all of [the following files](https://github.com/dotnet/sdk/blob/4177291d4d3dabd5341239d01b3e844125659304/src/Cli/dotnet/Commands/Run/VirtualProjectBuildingCommand.cs#L44) in the directory, and all parent directories:\n\n- [*global.json*](https://learn.microsoft.com/en-us/dotnet/core/tools/global-json)\n- [*NuGet.config*](https://learn.microsoft.com/en-us/nuget/reference/nuget-config-file)\n- [*Directory.Build.props*](https://learn.microsoft.com/en-us/visualstudio/msbuild/customize-by-directory?view=vs-2022#directorybuildprops-and-directorybuildtargets)\n- [*Directory.Build.targets*](https://learn.microsoft.com/en-us/visualstudio/msbuild/customize-by-directory?view=vs-2022#directorybuildprops-and-directorybuildtargets)\n- [*Directory.Packages.props*](https://devblogs.microsoft.com/dotnet/introducing-central-package-management/)\n- [*Directory.Build.rsp*](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-response-files?view=vs-2022)\n- [*MSBuild.rsp*](https://learn.microsoft.com/en-us/visualstudio/msbuild/msbuild-response-files?view=vs-2022)\n\nThe `NeedsToBuild` method then checks for a file called `build-success.cache` in the output folder, which is written after a build is completed. If this file is found, it's deserialized into a `RunFileBuildCacheEntry` object. This entry is compared to the one created for the current run. The previous build is considered valid if:\n\n- The global MSBuild properties are the same\n- The entrypoint file has not changed since the last build\n- None of the implicit files (listed previously) have changed or been deleted since the last build\n- There are no *new* implicit build files\n\nIf all these are satisfied, then `dotnet run` can skip most of the build. Otherwise we continue with the build.\n\n### Preparing the virtual project\n\nThe first step of the build is to create a sentinel file, `build-start.cache` , in the single-file's output directory. This is used to optimize the cache checks; if the start file does not exist, or it's newer than the success file, then a build is definitely required. With the caching all dealt with, [an MSBuild build is initialized](https://github.com/dotnet/sdk/blob/4177291d4d3dabd5341239d01b3e844125659304/src/Cli/dotnet/Commands/Run/VirtualProjectBuildingCommand.cs#L167-L184), and the building of the virtual project starts properly with `PrepareProjectInstance()` :\n\n```csharp public VirtualProjectBuildingCommand PrepareProjectInstance() { var sourceFile = LoadSourceFile(EntryPointFileFullPath); _directives = FindDirectives(sourceFile, reportAllErrors: false, errors: null);\n\nreturn this; }\n\n```\n\nAs you can see from the above, this method reads the file into memory and [calls `FindDirectives()`](https://github.com/dotnet/sdk/blob/4177291d4d3dabd5341239d01b3e844125659304/src/Cli/dotnet/Commands/Run/VirtualProjectBuildingCommand.cs#L757C51-L757C65), which looks for both the shebang (`#!` ) and all the `#:` directives in the file. I won't go through all the details of exactly how that works, but it uses [the experimental `SyntaxTokenParser` API](https://github.com/dotnet/roslyn/blob/75e79dace86b274327a1afe479228d82a06051a4/src/Compilers/CSharp/Portable/Syntax/SyntaxTokenParser.cs) to parse the file up until the first C# token, and to extract all of the directives.\n\nThe virtual project file is created [in `CreateProjectInstance()`](https://github.com/dotnet/sdk/blob/4177291d4d3dabd5341239d01b3e844125659304/src/Cli/dotnet/Commands/Run/VirtualProjectBuildingCommand.cs#L447), which in turn calls `CreateProjectRootElement()` , shown below:\n\n```csharp ProjectRootElement CreateProjectRootElement(ProjectCollection projectCollection) { Debug.Assert(!_directives.IsDefault, $\"{nameof(PrepareProjectInstance)} should have been called first.\");\n\nvar projectFileFullPath = Path.ChangeExtension(EntryPointFileFullPath, \".csproj\"); var projectFileWriter = new StringWriter(); WriteProjectFile( projectFileWriter, _directives, isVirtualProject: true, targetFilePath: EntryPointFileFullPath, artifactsPath: GetArtifactsPath(), includeRuntimeConfigInformation: BuildTarget != \"Publish\"); var projectFileText = projectFileWriter.ToString();\n\nusing var reader = new StringReader(projectFileText); using var xmlReader = XmlReader.Create(reader); var projectRoot = ProjectRootElement.Create(xmlReader, projectCollection); projectRoot.FullPath = projectFileFullPath; return projectRoot; }\n\n```\n\nThis method\n\n- Sets the virtual project's file path to be the path to the single-file program.\n- Writes a project file to a `StringWriter()`\ninstance.\n- Reads the project file into and `XmlReader`\ninstance and creates an MSBuild project `ProjectRootElement` instance\n\nThe interesting method here is `WriteProjectFile()` , this is a pretty long method, but we'll look at it in detail, as it is the heart of the implementation.\n\n### Creating the virtual project\n\nThe `WriteProjectFile()` method handles two distinct scenarios. It's used to create the \"virtual\" project used by `dotnet run` , but also the \"output\" project file created by `dotnet project convert` . We'll look at both paths at the same time, as that's how the code is structured inside `WriteProjectFile()` .\n\n#### Handling `#:sdk`\ndirectives\n\nThe method starts by extracting all the supported directives from the `ImmutableArray<>` passed in:\n\n```csharp public static void WriteProjectFile( TextWriter writer, ImmutableArray<CSharpDirective> directives, bool isVirtualProject, string? targetFilePath = null, string? artifactsPath = null, bool includeRuntimeConfigInformation = true) { int processedDirectives = 0;\n\nvar sdkDirectives = directives.OfType<CSharpDirective.Sdk>(); var propertyDirectives = directives.OfType<CSharpDirective.Property>(); var packageDirectives = directives.OfType<CSharpDirective.Package>(); var projectDirectives = directives.OfType<CSharpDirective.Project>(); // ... }\n\n```\n\nIt then calculates what is the main SDK to use. The single-file projects uses the [SDK-style projects](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview) common with .NET Core, so we need at least *one* SDK for the project.\n\n```csharp string sdkValue = \"Microsoft.NET.Sdk\";\n\nif (sdkDirectives.FirstOrDefault() is { } firstSdk) { sdkValue = firstSdk.ToSlashDelimitedString(); processedDirectives++; }\n\n```\n\nIf you don't specify an SDK in your single-file using the `#:sdk` directive, then the value `\"Microsoft.NET.Sdk\"` is used. Interestingly, when building with dotnet run, the virtual project does *not* specify the `Sdk` attribute in the `<Project>` element. Instead it directly imports the `Sdk.props` file, and subsequently the `Sdk.targets` file, as we'll see shortly.\n\n```csharp if (isVirtualProject) { // Building with dotnet run writer.WriteLine($\"\"\" <Project>\n\n<PropertyGroup> <IncludeProjectNameInArtifactsPaths>false</IncludeProjectNameInArtifactsPaths> <ArtifactsPath>{EscapeValue(artifactsPath)}</ArtifactsPath> </PropertyGroup>\n\n<!-- We need to explicitly import Sdk props/targets so we can override the targets below. --> <Import Project=\"Sdk.props\" Sdk=\"{EscapeValue(sdkValue)}\" /> \"\"\"); } else { // Create project file with dotnet convert project writer.WriteLine($\"\"\" <Project Sdk=\"{EscapeValue(sdkValue)}\">\n\n\"\"\"); }\n\n```\n\n>\n> I'm not entirely sure *why* we need to take the approach of directly importing the `Sdk.props`\n> files and `Sdk.targets`\n> files (later) individually for the virtual project, but I assume there's some reason the ordering isn't right otherwise ð\n> >\n\nThat handles the primary SDK, but you can also provide additive MSBuild projects, like [the one needed for Aspire](https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/dotnet-aspire-sdk) by providing additional `#:sdk` directives, which optionally have a version. The next part of `WriteProjectFile`\n\n```csharp foreach (var sdk in sdkDirectives.Skip(1)) { if (isVirtualProject) { // ð I inlinedthe method below for simplicity // WriteImport(writer, \"Sdk.props\", sdk); if (sdk.Version is null) { // dotnet run, no version writer.WriteLine($\"\"\" <Import Project=\"Sdk.props\" Sdk=\"{EscapeValue(sdk.Name)}\" /> \"\"\"); } else { // dotnet run, with version writer.WriteLine($\"\"\" <Import Project=\"Sdk.props\" Sdk=\"{EscapeValue(sdk.Name)}\" Version=\"{EscapeValue(sdk.Version)}\" /> \"\"\"); } } else if (sdk.Version is null) { // dotnet project convert, no version writer.WriteLine($\"\"\" <Sdk Name=\"{EscapeValue(sdk.Name)}\" /> \"\"\"); } else { // dotnet project convert, with version writer.WriteLine($\"\"\" <Sdk Name=\"{EscapeValue(sdk.Name)}\" Version=\"{EscapeValue(sdk.Version)}\" /> \"\"\"); }\n\nprocessedDirectives++; }\n\n```\n\n#### Handling `#:property`\ndirectives\n\nOnce all the SDK directives are handled we get to the standard properties. The only potential surprise here is that `PublishAot` is set, which is a new addition in preview 6.\n\n```csharp // Kept in sync with the default `dotnet new console` project file (enforced by `DotnetProjectAddTests.SameAsTemplate`). writer.WriteLine($\"\"\" <PropertyGroup> <OutputType>Exe</OutputType> <TargetFramework>net10.0</TargetFramework> <ImplicitUsings>enable</ImplicitUsings> <Nullable>enable</Nullable> <PublishAot>true</PublishAot> </PropertyGroup> \"\"\");\n\n```\n\nNext [`EnableDefaultItems` is disabled](https://learn.microsoft.com/en-us/dotnet/core/project-sdk/msbuild-props#enabledefaultitems). This ensures the default includes for *.cs* files, embedded resources, and other content files *aren't* included in the implicit project. That's important for being able to have multiple single-file apps side-by-side:\n\n```csharp if (isVirtualProject) { writer.WriteLine(\"\"\"\n\n<PropertyGroup> <EnableDefaultItems>false</EnableDefaultItems> </PropertyGroup> \"\"\"); }\n\n```\n\nThe next block is for setting all the remaining properties set via `#:property` directives. They're all added into a `<PropertyGroup>` as follows:\n\n```csharp if (propertyDirectives.Any()) { writer.WriteLine(\"\"\"\n\n<PropertyGroup> \"\"\");\n\nforeach (var property in propertyDirectives) { writer.WriteLine($\"\"\" <{property.Name}>{EscapeValue(property.Value)}</{property.Name}> \"\"\");\n\nprocessedDirectives++; }\n\nwriter.WriteLine(\" </PropertyGroup>\"); }\n\n```\n\nFor virtual projects, `FileBasedProgram` is also added to the `Features` compilation:\n\n```csharp if (isVirtualProject) { // After `#:property` directives so they don't override this. writer.WriteLine(\"\"\"\n\n<PropertyGroup> <Features>$(Features);FileBasedProgram</Features> </PropertyGroup> \"\"\"); }\n\n```\n\nThe `FileBasedProgram` feature is a [switch that makes the Roslyn compiler ignore `#:` directives](https://github.com/dotnet/roslyn/blob/c8b5f306d86bc04c59a413ad17b6152663a1e744/src/Compilers/CSharp/Portable/CSharpParseOptions.cs#L233-L239). Without it, the compiler will report errors if you try to use `#:` in non single-file program.\n\n#### Handling `#:package`\nand `#:project` directives\n\nNext up, we have the `#:package` directives. These are written pretty plainly as you'd expect, every directive becomes a `<PackageReference>` :\n\n```csharp if (packageDirectives.Any()) { writer.WriteLine(\"\"\"\n\n<ItemGroup> \"\"\");\n\nforeach (var package in packageDirectives) { if (package.Version is null) { writer.WriteLine($\"\"\" <PackageReference Include=\"{EscapeValue(package.Name)}\" /> \"\"\"); } else { writer.WriteLine($\"\"\" <PackageReference Include=\"{EscapeValue(package.Name)}\" Version=\"{EscapeValue(package.Version)}\" /> \"\"\"); }\n\nprocessedDirectives++; }\n\nwriter.WriteLine(\" </ItemGroup>\"); }\n\n```\n\nSimilarly, `#:project` references are written as `<ProjectReference>` elements:\n\n```csharp if (projectDirectives.Any()) { writer.WriteLine(\"\"\"\n\n<ItemGroup> \"\"\");\n\nforeach (var projectReference in projectDirectives) { writer.WriteLine($\"\"\" <ProjectReference Include=\"{EscapeValue(projectReference.Name)}\" /> \"\"\");\n\nprocessedDirectives++; }\n\nwriter.WriteLine(\" </ItemGroup>\"); }\n\n```\n\n#### File references and `#:sdk`\ntargets\n\nWe're nearly at the end of the method now, but before we get there we've got some important final elements to write if we're creating a virtual project for `dotnet run` . First of all, we write a `Compile` reference to the single-file. Unlike \"normal\" SDK-style projects that add all .cs files by default, that was disabled by setting `EnableDefaultItems=False` :\n\n```csharp if (isVirtualProject) { Debug.Assert(targetFilePath is not null);\n\nwriter.WriteLine($\"\"\"\n\n<ItemGroup> <Compile Include=\"{EscapeValue(targetFilePath)}\" /> </ItemGroup>\n\n\"\"\"); // ... }\n\n```\n\nNext, two `RuntimeHostConfigurationOption` values are set (as long as we're *not* doing a `dotnet publish` , i.e. you're only doing a `dotnet run` )\n\n```csharp if (includeRuntimeConfigInformation) { var targetDirectory = Path.GetDirectoryName(targetFilePath) ?? \"\"; writer.WriteLine($\"\"\" <ItemGroup> <RuntimeHostConfigurationOption Include=\"EntryPointFilePath\" Value=\"{EscapeValue(targetFilePath)}\" /> <RuntimeHostConfigurationOption Include=\"EntryPointFileDirectoryPath\" Value=\"{EscapeValue(targetDirectory)}\" /> </ItemGroup>\n\n\"\"\"); }\n\n```\n\nSetting these values allow you to retrieve the \"original\" file path at runtime using `AppContext` :\n\n```csharp string? filePath = AppContext.GetData(\"EntryPointFilePath\") as string; string? directoryPath = AppContext.GetData(\"EntryPointFileDirectoryPath\") as string;\n\n```\n\nAs far as I can tell, this isn't actually used by the SDK anywhere, it's just useful if you want to determine the current single-file's path from inside the single-file program. As noted above though, this information is lost if you *publish* the app.\n\nNear the end of the file we have the `Sdk.targts` imports, which correspond to all the `Sdk.props` added at the top of the file:\n\n```csharp foreach (var sdk in sdkDirectives) { // WriteImport(writer, \"Sdk.targets\", sdk); if (sdk.Version is null) { writer.WriteLine($\"\"\" <Import Project=\"Sdk.targets\" Sdk=\"{EscapeValue(sdk.Name)}\" /> \"\"\"); } else { writer.WriteLine($\"\"\" <Import Project=\"Sdk.targets\" Sdk=\"{EscapeValue(sdk.Name)}\" Version=\"{EscapeValue(sdk.Version)}\" /> \"\"\"); } }\n\nif (!sdkDirectives.Any()) { Debug.Assert(sdkValue == \"Microsoft.NET.Sdk\"); writer.WriteLine(\"\"\" <Import Project=\"Sdk.targets\" Sdk=\"Microsoft.NET.Sdk\" /> \"\"\"); }\n\n```\n\nThe last addition for the virtual project is a workaround for [an issue logged in NuGet](https://github.com/NuGet/Home/issues/14148), where some restore targets fail when used with the in-memory virtual project. To work around the issue for now, [a bunch of targets are overridden](https://github.com/dotnet/sdk/blob/4177291d4d3dabd5341239d01b3e844125659304/src/Cli/dotnet/Commands/Run/VirtualProjectBuildingCommand.cs#L61-L109) and written to the project:\n\n```csharp writer.WriteLine(); writer.WriteLine(TargetOverrides);\n\n```\n\nThe targets are defined [here](https://github.com/dotnet/sdk/blob/4177291d4d3dabd5341239d01b3e844125659304/src/Cli/dotnet/Commands/Run/VirtualProjectBuildingCommand.cs#L61-L109); I'll show what that looks like shortly when we recap.\n\nAnd with that, we close off the `<Project>` element, and we're done!\n\n```csharp writer.WriteLine(\"\"\"\n\n</Project> \"\"\");\n\n```\n\n#### Putting it all together\n\nBefore we move on, let's put this all together to see what a \"complete\" virtual-project file looks like. The easiest way to see that is to take a look at some of [the tests](https://github.com/dotnet/sdk/blob/3c21adb924c3c33682255711fd42a714210d8075/test/dotnet.Tests/CommandTests/Run/RunFileTests.cs#L1578). The following is taken from just such a test.\n\nIf you have the following simple single-file app:\n\n```csharp #!/program #:sdk Microsoft.NET.Sdk #:sdk [emailÂ protected] #:property TargetFramework=net11.0 #:package [emailÂ protected] #:property LangVersion=preview Console.WriteLine();\n\n```\n\nThen the virtual project built looks like this:\n\n```xml <Project>\n\n<PropertyGroup> <IncludeProjectNameInArtifactsPaths>false</IncludeProjectNameInArtifactsPaths> <ArtifactsPath>/artifacts</ArtifactsPath> </PropertyGroup>\n\n<!-- We need to explicitly import Sdk props/targets so we can override the targets below. --> <Import Project=\"Sdk.props\" Sdk=\"Microsoft.NET.Sdk\" /> <Import Project=\"Sdk.props\" Sdk=\"Aspire.Hosting.Sdk\" Version=\"9.1.0\" />\n\n<PropertyGroup> <OutputType>Exe</OutputType> <TargetFramework>net10.0</TargetFramework> <ImplicitUsings>enable</ImplicitUsings> <Nullable>enable</Nullable> <PublishAot>true</PublishAot> </PropertyGroup>\n\n<PropertyGroup> <EnableDefaultItems>false</EnableDefaultItems> </PropertyGroup>\n\n<PropertyGroup> <TargetFramework>net11.0</TargetFramework> <LangVersion>preview</LangVersion> </PropertyGroup>\n\n<PropertyGroup> <Features>$(Features);FileBasedProgram</Features> </PropertyGroup>\n\n<ItemGroup> <PackageReference Include=\"System.CommandLine\" Version=\"2.0.0-beta4.22272.1\" /> </ItemGroup>\n\n<ItemGroup> <Compile Include=\"/path/to/Program.cs\" /> </ItemGroup>\n\n<ItemGroup> <RuntimeHostConfigurationOption Include=\"EntryPointFilePath\" Value=\"/path/to/Program.cs\" /> <RuntimeHostConfigurationOption Include=\"EntryPointFileDirectoryPath\" Value=\"/path/to/\" /> </ItemGroup>\n\n<Import Project=\"Sdk.targets\" Sdk=\"Microsoft.NET.Sdk\" /> <Import Project=\"Sdk.targets\" Sdk=\"Aspire.Hosting.Sdk\" Version=\"9.1.0\" />\n\n<!-- Override targets which don't work with project files that are not present on disk. See https://github.com/NuGet/Home/issues/14148. -->\n\n<Target Name=\"_FilterRestoreGraphProjectInputItems\" DependsOnTargets=\"_LoadRestoreGraphEntryPoints\"> <!-- No-op, the original output is not needed by the overwritten targets. --> </Target>\n\n<Target Name=\"_GetAllRestoreProjectPathItems\" DependsOnTargets=\"_FilterRestoreGraphProjectInputItems;_GenerateRestoreProjectPathWalk\" Returns=\"@(_RestoreProjectPathItems)\"> <!-- Output from dependency _GenerateRestoreProjectPathWalk. --> </Target>\n\n<Target Name=\"_GenerateRestoreGraph\" DependsOnTargets=\"_FilterRestoreGraphProjectInputItems;_GetAllRestoreProjectPathItems;_GenerateRestoreGraphProjectEntry;_GenerateProjectRestoreGraph\" Returns=\"@(_RestoreGraphEntry)\"> <!-- Output partly from dependency _GenerateRestoreGraphProjectEntry and _GenerateProjectRestoreGraph. -->\n\n<ItemGroup> <_GenerateRestoreGraphProjectEntryInput Include=\"@(_RestoreProjectPathItems)\" Exclude=\"$(MSBuildProjectFullPath)\" /> </ItemGroup>\n\n<MSBuild BuildInParallel=\"$(RestoreBuildInParallel)\" Projects=\"@(_GenerateRestoreGraphProjectEntryInput)\" Targets=\"_GenerateRestoreGraphProjectEntry\" Properties=\"$(_GenerateRestoreGraphProjectEntryInputProperties)\">\n\n<Output TaskParameter=\"TargetOutputs\" ItemName=\"_RestoreGraphEntry\" /> </MSBuild>\n\n<MSBuild BuildInParallel=\"$(RestoreBuildInParallel)\" Projects=\"@(_GenerateRestoreGraphProjectEntryInput)\" Targets=\"_GenerateProjectRestoreGraph\" Properties=\"$(_GenerateRestoreGraphProjectEntryInputProperties)\">\n\n<Output TaskParameter=\"TargetOutputs\" ItemName=\"_RestoreGraphEntry\" /> </MSBuild> </Target> </Project>\n\n```\n\nThere's a *lot* there, right?!ð The interesting thing is if we look at what the *converted* project looks like:\n\n```xml <Project Sdk=\"Microsoft.NET.Sdk\">\n\n<Import Project=\"Sdk.props\" Sdk=\"Microsoft.NET.Sdk\" /> <Import Project=\"Sdk.props\" Sdk=\"Aspire.Hosting.Sdk\" Version=\"9.1.0\" />\n\n<PropertyGroup> <OutputType>Exe</OutputType> <TargetFramework>net10.0</TargetFramework> <ImplicitUsings>enable</ImplicitUsings> <Nullable>enable</Nullable> <PublishAot>true</PublishAot> </PropertyGroup>\n\n<PropertyGroup> <TargetFramework>net11.0</TargetFramework> <LangVersion>preview</LangVersion> </PropertyGroup>\n\n<ItemGroup> <PackageReference Include=\"System.CommandLine\" Version=\"2.0.0-beta4.22272.1\" /> </ItemGroup>\n\n</Project>\n\n```\n\n*Much* simpler! ð\n\nWith that, we can get back on track with the process of actually building the app.\n\n### Building with MSBuild\n\nWe left off just before we were going to do a restore and build of our single-file app. Now that we have built an in-memory project file, and parsed it into an MSBuild `ProjectInstance` , we can finally get started. First we need to do a restore, though the current MSBuild API [makes this quite cumbersome to achieve](https://github.com/dotnet/msbuild/issues/11519), requiring setting [a bunch of properties and flags](https://github.com/dotnet/sdk/blob/4177291d4d3dabd5341239d01b3e844125659304/src/Cli/dotnet/Commands/Run/VirtualProjectBuildingCommand.cs#L188-L207):\n\n```csharp // Creating project instance details not shown ProjectInstance project = CreateProjectInstance(...);\n\nvar restoreRequest = new BuildRequestData( project, targetsToBuild: [\"Restore\"], hostServices: null, BuildRequestDataFlags.ClearCachesAfterBuild | BuildRequestDataFlags.SkipNonexistentTargets | BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports | BuildRequestDataFlags.FailOnUnresolvedSdk); var restoreResult = BuildManager.DefaultBuildManager.BuildRequest(restoreRequest);\n\n```\n\nUltimately there's just two statements here, creating a `BuildRequestData` instance, and passing it to the previously-initialized MSBuild `BuildManager` . This does the restore, and if all is well, we can run a build too:\n\n```csharp var buildRequest = new BuildRequestData( CreateProjectInstance(projectCollection), targetsToBuild: [BuildTarget]); var buildResult = BuildManager.DefaultBuildManager.BuildRequest(buildRequest);\n\n```\n\nThis is essentially the same two stepsâcreate a `BuildRequest` and call `BuildManager` âbut in this case it's much easier to create the request.\n\nIf that all succeeds, the cache entry is serialized to the `build-success.cache` file, and the single-file build is complete!\n\nAt this point, the single-file app is built, and as far as the `RunCommand` is concerned, it's mostly just like any other .NET app. This post has already gone on *way* too long, so I'll leave it there. If you've made it this far, congratulations ð I don't know how *useful* this post will be in a practical sense, but I often find it useful to dig into the details like this occasionally, to get a real feel for how things work.\n\n## Summary\n\nIn the [previous post](/exploring-dotnet-10-preview-features-1-exploring-the-dotnet-run-app.cs/), I described the new feature coming in .NET 10 for building and running a single C# file *without* needing to first create a *.csproj* project. In this post, I showed the code that implements the single-file feature in the `dotnet` SDK. I showed how the SDK identifies a target as a single-file program, how the caching system reduces the number of rebuilds, and then focused primarily on the code that creates an in-memory virtual-project. This may not be particularly practical useful, but I always find it interesting to see how things work under the hood!\n\n## Tags\n\nAndrew Lock | .Net Escapades\n\n![](/assets/img/icons/apple/apple-touch-icon-180x180.png) Want an email when there's new posts?\n\nStay up to the date with the latest posts!\n\nOops! Check your details and try again.\n\nThanks! Check your email for confirmation.",
  "PubDate": "2025-07-08T10:00:00+00:00"
}
