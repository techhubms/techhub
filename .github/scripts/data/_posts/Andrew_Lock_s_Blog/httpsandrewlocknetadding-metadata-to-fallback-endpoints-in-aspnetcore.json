{
  "OutputDir": "_posts",
  "EnhancedContent": "In this post I describe how metadata works for \"fallback\" endpoints in ASP.NET Core. First I briefly discuss the routing infrastructure of ASP.NET Core, and how you can add metadata to endpoints to drive other functionality. Next I describe what fallback endpoints are and why they are useful. Finally, I describe how adding metadata works for fallback endpoints, and why this might not work as you first expect for MVC and Razor Pages apps.\n\n## Background: the routing infrastructure in ASP.NET Core\n\nThe routing infrastructure in ASP.NET Core is a fundamental component that sits as part of the middleware pipeline, it is the primary way that incoming URLs are mapped to \"handlers\" which are responsible for executing code and generating a response. For example, the following hello world app maps a single route `/` to a handler (the lambda method) which returns a string `\"Hello World!\"` :\n\n```csharp var builder = WebApplication.CreateBuilder(args); var app = builder.Build();\n\napp.MapGet(\"/\", () => \"Hello World!\");\n\napp.Run();\n\n```\n\nIt's not apparent from this simple example, but routing in ASP.NET Core is driven by *two* main pieces of middleware:\n\n- `EndpointRoutingMiddleware`\nâ€”This middleware chooses which registered endpoint to execute for a given request at runtime. It's sometimes referred to as `RoutingMiddleware` (which is the name I use in this post).\n- `EndpointMiddleware`\nâ€”This middleware is typically placed at the end of the middleware pipeline. The middleware executes the endpoint selected by the `RoutingMiddleware` for a given request.\n\n>\n> Prior to .NET 6, you would typically add these middleware to your pipeline explicitly by calling `UseRouting()`\n> and `UseEndpoints()`\n> . However `WebApplication`\n> adds these for your automatically, so the explicit calls generally aren't required. I described in more detail how `WebApplication`\n> works and how it compares to the \"traditional\" `Startup`\n> approach in [previous posts](/exploring-dotnet-6-part-4-building-a-middleware-pipeline-with-webapplication/#a-hello-world-pipeline).\n> >\n\nYou might wonder why ASP.NET Core uses two pieces of middleware instead of just one. Separating the *selection* of an endpoint from the *execution* of an endpoint gives a specific advantageâ€”you can execute middleware *between* these two events. This middleware can change its behaviour based on *metadata* associated with the endpoint that is going to be executed, *before* that endpoint executes.\n\n## Adding metadata to endpoints to control functionality\n\nAs already described, endpoint routing is a core feature of ASP.NET Core. Adding *metadata* to specific endpoints is important for controlling the behaviour of different endpoints.\n\nThere are several features that rely on metadata to work correctly. The most common examples are the `AuthorizationMiddleware` and `CorsMiddleware` , which must be placed *between* the `RoutingMiddleware` and `EndpointMiddleware` so that they know which policies to apply for the selected endpoint.\n\n![Image of routing in ASP.NET Core ](/content/images/2019/endpoint_routing.svg)\n\nFor example, you might have a global authorization requirement policy which applies to all endpoints in your application. You would then apply specific \"Allow anonymous access\" policies to the \"login\" and \"forgotten password\" endpoints so they can be accessed when you're not logged in.\n\nFor this functionality to work, you need to apply metadata to the login and forgot password policies. You typically apply metadata in one of two ways:\n\n- Adding attributes, e.g. `[AllowAnonymous]`\nor `[Authorize]` , to an MVC action or Razor Page.\n- Using an extension method, e.g. `AllowAnonymous()`\nor `RequireAuthorization()` to a minimal API or other endpoint.\n\nWhen the `RoutingMiddleware` endpoint executes, it selects the endpoint that will execute. Subsequent middleware can then inspect the endpoint details to see if there's any attached middleware and act accordingly.\n\nLet's look at the authorization case again. Calling the `AllowAnonymous()` method, for example, [adds an instance of the `AllowAnonymousAttribute` as metadata to the endpoint](https://github.com/dotnet/aspnetcore/blob/d4349298d046f24282a6030d8935e81aa2440141/src/Security/Authorization/Policy/src/AuthorizationEndpointConventionBuilderExtensions.cs#L125):\n\n```csharp public static class AuthorizationEndpointConventionBuilderExtensions { private static readonly IAllowAnonymous _allowAnonymousMetadata = new AllowAnonymousAttribute();\n\npublic static TBuilder AllowAnonymous<TBuilder>(this TBuilder builder) where TBuilder : IEndpointConventionBuilder { builder.Add(endpointBuilder => { endpointBuilder.Metadata.Add(_allowAnonymousMetadata); }); return builder; } }\n\n```\n\nSimilarly, calling `RequireAuthorization()` [adds an instance of the `AuthorizeAttribute`](https://github.com/dotnet/aspnetcore/blob/d4349298d046f24282a6030d8935e81aa2440141/src/Security/Authorization/Policy/src/AuthorizationEndpointConventionBuilderExtensions.cs#L21) as metadata:\n\n```csharp public static class AuthorizationEndpointConventionBuilderExtensions { public static TBuilder RequireAuthorization<TBuilder>(this TBuilder builder) where TBuilder : IEndpointConventionBuilder { return builder.RequireAuthorization(new AuthorizeAttribute()); } }\n\n```\n\nThe `AuthorizationMiddleware` , which runs after the `RoutingMiddleware` and before the `EndpointMiddleware` , can inspect the selected endpoint and read this metadata to decide what authorization policies to apply to the selected endpoint.\n\n## Trying it out in a sample app\n\nWe can try this all out in a simple minimal API app that just shows the basics:\n\n```csharp using Microsoft.AspNetCore.Authorization;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Configure basic cookie authentication (so that authorization works) builder.Services.AddAuthentication().AddCookie(); builder.Services.AddAuthorization(opt => { // Unless specified, you must be logged in to be authorized opt.FallbackPolicy = new AuthorizationPolicyBuilder() .RequireAuthenticatedUser() .Build(); });\n\nvar app = builder.Build();\n\napp.MapGet(\"/\", () => \"Hello World!\"); // You can't view this unless logged in app.MapGet(\"/Account/Login\", () => \"Login page\").AllowAnonymous(); // You can always view this app.Run();\n\n```\n\nThis is a simple minimal API that has two endpoints:\n\n- `/`\nthe home page\n- `/Account/Login`\nwhich is the login page\n\nFor this app I added rudimentary authentication and authorization. I've not added any way to actually sign in or anything, literally I've just configured the minimum requirements. We then configure a global policy that says \"unless otherwise specified, you must be logged in to be authorized to view the page\".\n\nThe result is that if we try to run the app, and navigate to `/` , We're automatically redirected to the `/Account/Login` page, because we're not (and can't be) logged in. However, we *can* view the `/Account/Login` page, because it's decorated with `AllowAnonymous()` metadata.\n\n![The authorization metadata prevents directly accessing /, but allows accessing the /Acount/Login route](/content/images/2025/fallbackroutes_01.png)\n\nMany cross-cutting features which are implemented in middleware but which must behave differently for specific endpoints use this metadata approach. Authorization is the canonical example, but [CORS policies](https://learn.microsoft.com/en-us/aspnet/core/security/cors?view=aspnetcore-9.0), [OpenAPI documentation](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/openapi/aspnetcore-openapi?view=aspnetcore-9.0), [or my security headers library](https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders) work in similar ways.\n\n## Fallback routing in ASP.NET Core\n\nRouting is a core component of ASP.NET Core, and consists of many distinct concepts. For example:\n\n- **Route patterns**â€”This is the URL path pattern that should be matched to an incoming request.\n- **Handlers**â€”Every route pattern has an associated handler which is is the code that runs to generate a response when the pattern matches an incoming request.\n- **Route parameters**â€”These are variable sections in a route pattern that can be extracted and automatically converted to types for use in your handlers.\n- **Binding**â€”You can automatically extract details from an incoming request for use in your handlers\n\nand many more! These features manifest to greater or lesser extent whichever part of ASP.NET Core you're using, whether it's MVC, Razor Pages, Blazor, or minimal APIs.\n\nThe fundamental first step of routing is deciding *which* route pattern the incoming URL matches. This is done by building a graph of the registered endpoints and then finding the correct match for the incoming URL:\n\n![A ValuesController endpoint routing application](/content/images/2020/graphs_2_01.png)\n\n>\n> I discussed how ASP.NET Core creates an endpoint graph and how you can visualize that graph in my series [Visualizing ASP.NET Core 3.0 endpoints using GraphvizOnline](/series/visualizing-asp-net-core-3-endpoints-using-graphvizonline/).\n> >\n\nEach route is associated with a handler, but there's also the concept of a *fallback* route. This route matches *any* incoming request, as long as the request is *not* matched by any other route, and it invokes the provided handler.\n\nThere are many different ways to add a fallback route to your app, and in general it will depend which part of ASP.NET Core you're using; minimal APIs, MVC, Razor Pages etc. The simplest approach is to call the `MapFallback()` method, and provide a handler to execute directly. For example, we could add a fallback endpoint to my previous sample:\n\n```csharp var app = builder.Build();\n\napp.MapGet(\"/\", () => \"Hello World!\"); app.MapGet(\"/Account/Login\", () => \"Login page\").AllowAnonymous(); app.MapFallback(() => \"Fallback\"); // ðŸ‘ˆ Add this app.Run();\n\n```\n\nNow, if we run the app and hit any random URL, we're redirected to the `/Account/Login` page. That's because our fallback \"you must be logged in\" authorization policy kicks in, and redirects us. In the image below you can see that `/random-url` was matched, but redirected automatically to our login page:\n\n![The fallback route /random-url was automatically redirected](/content/images/2025/fallbackroutes_02.png)\n\nIt's probably more common to have your fallback route redirect to an *existing* endpoint, whether that's a file, an MVC controller, or a Razor Page. The most common reason for using a fallback route like this is for handling SPA applications. Many SPA applications [handle \"routing\" on the client-side](https://weblog.west-wind.com/posts/2020/Jul/12/Handling-SPA-Fallback-Paths-in-a-Generic-ASPNET-Core-Server#client-side-navigation) and generate nice, normal looking routes. However, if the client refreshes the page then the \"incorrect\" path is sent as a request to ASP.NET Core.\n\nFor example, the client side SPA app might send a request to `/something/customers/123` , but that doesn't necessarily *mean* anything to your application. Instead, in that scenario, you often need to return your \"home page\", have the SPA app run its boot up code and then do the routing on the client-side.\n\nExactly what \"return your 'home page'\" means will depend on your app, but there's probably a `MapFallback*` overload for you: For example:\n\n- `MapFallbackToFile(string filepath)`\nreturns a file e.g. `Index.html` when there's no match for a route.\n- `MapFallbackToPath(string page)`\nexecutes the given Razor Page as the fallback.\n- `MapFallbackToController(string action, string controller)`\nexecutes the indicated MVC controller and action as the fallback.\n\nAll these `MapFallback()` overloads seem similar, but they actually behave somewhat differently when it comes to metadata, as we'll look at in the next section.\n\n## Fallback routing and metadata for simple endpoints\n\nWe can explore the differences in metadata handling by thinking about the same simple authorization app we've been looking at so far. To test how metadata works, we can simply add an `AllowAnonymous()` call to our `MapFallback()` methods. For example, taking our initial `MapFallback()` example:\n\n```csharp using Microsoft.AspNetCore.Authorization;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddAuthentication().AddCookie(); builder.Services.AddAuthorization(opt => { opt.FallbackPolicy = new AuthorizationPolicyBuilder() .RequireAuthenticatedUser() .Build(); });\n\nvar app = builder.Build();\n\napp.MapGet(\"/\", () => \"Hello World!\"); app.MapGet(\"/Account/Login\", () => \"Login page\").AllowAnonymous(); app.MapFallback(() => \"Fallback\").AllowAnonymous(); // ðŸ‘† Add this app.Run();\n\n```\n\nAll I've added in this case is the `AllowAnonymous()` call to the `MapFallback()` configuration. Prior to adding the `AllowAnonymous()` , call, hitting a random URL would result in an unauthorized request, and we would be redirected to the `/Account/Login` endpoint. However, by adding `AllowAnonymous()` , we've added metadata to the fallback endpoint which means that the endpoint *is* authorized, and executes for a random URL:\n\n![The fallback endpoint is allowed to execute](/content/images/2025/fallbackroutes_03.png)\n\nSimilarly, with the `MapFallbackToFile()` method, adding `AllowAnonymous()` attaches metadata to this fallback endpoint. Changing the above `MapFallback()` call to `MapFallbackToFile(\"index.html\")` (and adding an *index.html* file to the application in the *wwwroot* folder) gives the same result; hitting any unknown URL returns the *index.html* file:\n\n```csharp app.MapFallbackToFile(\"index.html\").AllowAnonymous();\n\n```\n\n![The fallback file is also allowed to execute](/content/images/2025/fallbackroutes_04.png)\n\nYou would be forgiven for thinking that the Razor Page and MVC based fallback methods behaved in a similar way, but somewhat surprisingly, they don't!\n\n## Fallback routing and metadata for Razor Pages and MVC\n\nTo show this in action, I created a tiny Razor Pages app, and added three very simple Razor Pages, which are somewhat equivalent to the minimal API version above:\n\n*/Index.chstml*:\n\n```cshtml @page <h1>Index</h1>\n\n```\n\n*/Account/Login.chstml* - note the `[AllowAnonymous]` attribute here to allow anonymous access\n\n```cshtml @page @attribute [Microsoft.AspNetCore.Authorization.AllowAnonymous] <h1>Login</h1>\n\n```\n\nAnd finally */Fallback.cshtml*:\n\n```cshtml @page <h1>Fallback</h1>\n\n```\n\nI then added the same authentication and authorization services as before to the Razor pages app, and added a fallback mapping using `MapFallbackToPage(\"/Fallback\")` , and marked that fallback route with `AllowAnonymous()` :\n\n```csharp using Microsoft.AspNetCore.Authorization;\n\nvar builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddRazorPages();\n\n// same authentication and authorization services as before builder.Services.AddAuthentication().AddCookie(); builder.Services.AddAuthorization(opt => { opt.FallbackPolicy = new AuthorizationPolicyBuilder().RequireAuthenticatedUser().Build(); }); var app = builder.Build();\n\n// Standard Razor Pages stuff app.UseRouting(); app.UseAuthorization(); app.MapStaticAssets(); app.MapRazorPages().WithStaticAssets();\n\n// Add a fallback page and try to mark it as allow anonymous app.MapFallbackToPage(\"/Fallback\").AllowAnonymous(); app.Run();\n\n```\n\nOverall this is essentially the Razor Pages equivalent of the minimal API app from before. Consequently, if we navigate to `/Index` , the authorization policy means we get redirected to the `/Account/Login` page. That page has the `[AllowAnonymous]` attribute, so we can view that page:\n\n![The /Index page redirects to /Account/Login](/content/images/2025/fallbackroutes_05.png)\n\nNow let's try hitting the fallback route by trying a random URL. Seeing as we marked the fallback route as `AllowAnonymous()` then we should see the `/Fallback` page, right?\n\n![The fallback route still redirects to /Account/Login too](/content/images/2025/fallbackroutes_06.png)\n\nHmmmâ€¦ that's not right ðŸ¤” It seems like the `AllowAnonymous()` call on the `MapFallbackToPage()` definition isn't working?!\n\nThe explanation is a little more nuancedâ€¦\n\n## Why doesn't `AllowAnonymous()`\nwork on `MapFallbackToPage()` ?\n\n[The `MapFallback()`](https://github.com/dotnet/aspnetcore/blob/main/src/Http/Routing/src/Builder/EndpointRouteBuilderExtensions.cs#L390) and `MapFallbackToFile()` calls [are actually registering *new* endpoints](https://github.com/dotnet/aspnetcore/blob/main/src/Middleware/StaticFiles/src/StaticFilesEndpointRouteBuilderExtensions.cs#L54-L56); they have a catch-all route pattern and a handler, and the metadata gets associated to this new endpoint.\n\n`MapFallbackToPage()` and `MapFallbackToController()` work [slightly differently](https://github.com/dotnet/aspnetcore/blob/cf40577071ca80f7396e702a75212ed0f7ff8f54/src/Mvc/Mvc.RazorPages/src/Builder/RazorPagesEndpointRouteBuilderExtensions.cs#L139-L147). These do add an extra endpoint, but the endpoint is added with additional `DynamicPageMetadata` metadata (for Razor Pages) or `DynamicControllerMetadata` metadata (for MVC). The Razor Pages/MVC infrastructure then finds this metadata and uses it to select a *different* endpoint to execute. *That's* the endpoint selected by the routing infrastructure, not the \"original\" fallback endpoint.\n\nThis all means that [the \"fallback\" endpoint is essentially *replaced* by the real page it points to](https://github.com/dotnet/aspnetcore/issues/14679#issuecomment-537715318). Which *also* means that any metadata you add to that fallback endpoint is *lost* when it's actually invoked, which includes the `AllowAnonymous()` call! In other words, calling `AllowAnonymous()` (or adding any *other* metadata) on a `MapFallbackToPage()` or `MapFallbackToController()` call does nothing.\n\nTo make our fallback page behave like we want it to, we have to add the `[AllowAnonymous]` attribute to the *destination* page instead, to the `/Fallback` page:\n\n```cshtml @page @attribute [Microsoft.AspNetCore.Authorization.AllowAnonymous] <h1>Fallback</h1>\n\n```\n\nAfter making that change, now if we hit a random URL we *can* access the page, because the *destination* has the required metadata:\n\n![After adding the allow anonymous to the destination, it works](/content/images/2025/fallbackroutes_07.png)\n\nAnd that pretty much covers it. Just remember that if you need to add metadata to a fallback Razor Page or MVC controller, then you must add it to the *destination* endpoint, not the \"fallback\" endpoint itself.\n\n## Summary\n\nIn this post I briefly described the routing infrastructure of ASP.NET Core, and how you can add metadata to endpoints to drive other functionality. Next I describe what fallback endpoints are and why they are useful. Finally, I showed how adding metadata works differently when creating fallback endpoints using `MapFallbackToPage()` and `MapFallbackToController()` .\n\nFor these cases, the fallback endpoint is replaced by the real *destination* endpoint. Consequently, if you want to add metadata to these endpoints, you must add it to the destination endpoint *not* the fallback endpoint.\n\n## Tags\n\nAndrew Lock | .Net Escapades\n\n![](/assets/img/icons/apple/apple-touch-icon-180x180.png) Want an email when there's new posts?\n\nStay up to the date with the latest posts!\n\nOops! Check your details and try again.\n\nThanks! Check your email for confirmation.",
  "Link": "https://andrewlock.net/adding-metadata-to-fallback-endpoints-in-aspnetcore/",
  "Description": "In this post I discuss fallback endpoints and show how adding metadata to MVC or Razor Page fallback endpoints has some quirks to be aware of",
  "FeedLevelAuthor": "Andrew Lock | .NET Escapades",
  "Tags": [
    ".NET Core",
    "ASP.NET Core",
    "MVC",
    "Razor Pages"
  ],
  "FeedUrl": "https://andrewlock.net/rss.xml",
  "Title": "Adding metadata to fallback endpoints in ASP.NET Core",
  "FeedName": "Andrew Lock's Blog",
  "Author": "Andrew Lock",
  "PubDate": "2025-10-22T10:00:00+00:00",
  "ProcessedDate": "2025-10-22 13:50:15"
}
