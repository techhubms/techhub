{
  "Tags": [
    "ASP.NET Core",
    "Middleware",
    "Security"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Andrew Lock | .NET Escapades",
  "ProcessedDate": "2025-08-05 14:29:47",
  "FeedUrl": "https://andrewlock.net/rss.xml",
  "Title": "NetEscapades.â€‹AspNetCore.â€‹SecurityHeaders 1.0.0 has been released",
  "Description": "In this post I describe the recent major changes to NetEscapades.AspNetCore.SecurityHeaders, a NuGet package for adding security headers to your apps.",
  "Link": "https://andrewlock.net/netescapades-aspnetcore-securityheaders-1-0-0-released/",
  "FeedName": "Andrew Lock's Blog",
  "Author": "Andrew Lock",
  "EnhancedContent": "This post is to announce that I have finally released the 1.0.0 version of the [*NetEscapades.AspNetCore.SecurityHeaders*](https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders) project. This version addresses some longstanding requests for extra functionality, updates the supported target frameworks, and obsoletes some old behaviours.\n\n>\n> Many of these changes were introduced in preview versions, the `1.0.0`\n> includes only minimal changes compared to the previous `1.0.0-preview.4`\n> package.\n> >\n\nIn this post I provide a quick overview of the library, and then discuss the major changes made in this release, compared to version 0.24.0.\n\n- What are security headers?\n- Adding security headers to your app\n- Major changes in `1.0.0`\n- Changes to the supported frameworks\n- Changes to headers\n- Changes to the default headers\n- `X-XSS-Protection=1; mode-block`\nis no longer recommended\n- `Expect-CT`\nis no longer recommended\n- New `PermisionsPolicyBuilder.AddDefaultSecureDirectives()`\nmethod\n- New `AddDefaultApiSecurityHeaders()`\nmethod\n- New support for Trusted Types\n- `Feature-Policy`\nis marked obsolete\n- Applying different headers to some endpoints\n- Customizing the headers completely\n- \"Document headers\" functionality has been removed\n- Changes to nonce generation\n- Updates to build provenance\n- Summary\n\n## What are security headers?\n\nSecurity headers are HTTP headers that you can return in your responses which improve the overall security of your application. The headers instruct browsers to activate or disable various features, with the overall goal of hardening your application and reducing your attack surface area.\n\nSome of [these headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security) apply to all HTTP responses, while [others](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy) only really make sense for HTML responses. Nevertheless, it *can* make sense to apply theoretically-HTML-only headers to non-HTML responses as part of a defence-in-depth approach, [as described by OWASP](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html#security-headers).\n\nThe main problem with security headers is that there are [a *lot* of them](https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html#security-headers), and the list is generally growing and evolving, with new headers being introduced and others being retired. What's more, different headers use different patterns for listsâ€”some use `;` separators, others use `,` , and others use a spaceâ€”so it's easy to set them up incorrectly.\n\nThe [*NetEscapades.AspNetCore.SecurityHeaders*](https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders) package aims to help you set up security headers for your ASP.NET Core app. It provides sensible defaults, with a fluent builder pattern for customizing and configuring the headers for your specific application requirements.\n\n## Adding security headers to your app\n\nIn this section I show the quickest way to get started with [*NetEscapades.AspNetCore.SecurityHeaders*](https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders) and to start adding security headers to your application.\n\nFirst, add the package to your app:\n\n```bash dotnet add package NetEscapades.AspNetCore.SecurityHeaders\n\n```\n\nAlternatively, add the package to your *.csproj* directly\n\n```xml <Project Sdk=\"Microsoft.NET.Sdk.Web\"> <PropertyGroup> <TargetFramework>net8.0</TargetFramework> </PropertyGroup>\n\n<ItemGroup> <!-- ðŸ‘‡ Add the package --> <PackageReference Include=\"NetEscapades.AspNetCore.SecurityHeaders\" Version=\"1.0.0\" /> </ItemGroup> </Project>\n\n```\n\nFinally, add the security headers middleware to the start of your middleware pipeline with the `UseSecurityHeaders()` extension method. For example:\n\n```csharp var builder = WebApplication.CreateBuilder(); var app = builder.Build();\n\n// ðŸ‘‡ Add the security headers to the start of the pipeline app.UseSecurityHeaders();\n\napp.MapGet(\"/\", () => \"Hello world!\");\n\napp.Run();\n\n```\n\nThe `SecurityHeadersMiddleware` registers a callback that adds several headers to all responses. By default, the middleware adds the following header to your responses:\n\n- `X-Content-Type-Options: nosniff`\n- `X-Frame-Options: Deny`\n- `Referrer-Policy: strict-origin-when-cross-origin`\n- `Content-Security-Policy: object-src 'none'; form-action 'self'; frame-ancestors 'none'`\n- `Strict-Transport-Security: max-age=31536000; includeSubDomains`\n- *only applied to HTTPS responses*\n- `Cross-Origin-Opener-Policy: same-origin`\n- `Cross-Origin-Embedder-Policy: credentialless`\n- `Cross-Origin-Resource-Policy: same-origin`\n\nThese headers were chosen based on [guidance from OWASP](https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html#security-headers) to provide security hardening benefits, while being broadly applicable to most applications.\n\n>\n> These headers don't represent the *most* secure set you could choose, but rather a \"generally safe\" set for most applications. Ideally you should customise these headers to add a more secure (and more restrictive) set.\n> >\n\nIf you want to change the headers that are applied, you can create an instance of `HeaderPolicyCollection` , and use the fluent builder interface to customize the added headers. The following shows an example which specifically adds all the default headers independently, and then adds an extra custom header.\n\n```csharp var policyCollection = new HeaderPolicyCollection() .AddFrameOptionsDeny() .AddContentTypeOptionsNoSniff() .AddStrictTransportSecurityMaxAge(maxAgeInSeconds: 60 * 60 * 24 * 365) // maxage = one year in seconds .AddReferrerPolicyStrictOriginWhenCrossOrigin() .RemoveServerHeader() .AddContentSecurityPolicy(builder => { builder.AddObjectSrc().None(); builder.AddFormAction().Self(); builder.AddFrameAncestors().None(); }) .AddCrossOriginOpenerPolicy(x => x.SameOrigin()) .AddCrossOriginEmbedderPolicy(builder => builder.Credentialless()) .AddCrossOriginResourcePolicy(builder => builder.SameSite()) .AddCustomHeader(\"X-My-Test-Header\", \"Header value\");\n\napp.UseSecurityHeaders(policyCollection);\n\n```\n\nFor most of the history of *NetEscapades.AspNetCore.SecurityHeaders*, this was been the only way to configure the security headers for your application. The advantage is that it's *simple*â€”there's no services to add, nothing to \"reason\" aboutâ€”whatever headers you configure, are added.\n\nHowever, some people wanted more control, for example to be able to add different headers to different endpoints in their application, or to customize the headers on a request-by-request basis. That flexibility is largely what the changes in `1.0.0` are about, but as this is a major version, I took the opportunity to make some other larger changes too.\n\nFor the rest of this post I'll describe some of the biggest changes in `1.0.0` .\n\n## Major changes in `1.0.0`\n\nThe following sections describe the high level changes and features included in `1.0.0` . Before we get started, the first thing to note is that *NetEscapades.AspNetCore.SecurityHeaders* finally [has a logo](https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders/issues/194):\n\n![NetEscapades.AspNetCore.SecurityHeaders](/content/images/2024/headers_logo.png)\n\nA big thanks to [Khalid](https://hachyderm.io/@khalidabuhakmeh@mastodon.social) for putting that together [so quickly](https://hachyderm.io/@khalidabuhakmeh@mastodon.social/113205536777140020)! Now lets look at the new features and breaking changes.\n\n### Changes to the supported frameworks\n\nI first created *NetEscapades.AspNetCore.SecurityHeaders* way back in 2016, when ASP.NET Core was just being released. Back then, ASP.NET Core could *also* be run on .NET Framework. The original thought was that this mode would serve as a migration path from ASP.NET to ASP.NET Core.\n\nThat path is rarely recommended these days, and instead, [a \"strangler fig\" pattern is recommended](https://learn.microsoft.com/en-us/aspnet/core/migration/inc/overview). ASP.NET Core has not been supported on .NET Framework since version 2.1 (OK, [ASP.NET Core 2.3 now](https://devblogs.microsoft.com/dotnet/servicing-release-advisory-aspnetcore-23/)), and as such `1.0.0` of *NetEscapades.AspNetCore.SecurityHeaders* finally drops support for .NET Framework too, by [dropping support for `netstandard2.0`](https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders/pull/167) and everything prior to .NET Core 3.1.\n\n>\n> You might be wondering \"why .NET Core 3.1+ and not .NET 8+, seeing as that's all that's supported by Microsoft\". The short answer, is that supporting the extra TFMs requires basically no extra work, and it means more people can use the package. I'm not really losing anything by supporting the earlier TFMs. Sure, there's probably a few cases where I'd use different APIs if targeting .NET 8, but those are few and far between.\n> >\n\nGiven the package still supports .NET Core 3.1+ it's *very* unlikely you'll be impacted by this change unless you're on a (very) unsupported version of .NET Core. And if you are, I would strongly advise you to update anyway!\n\n### Changes to headers\n\nIn the next section I describe some of the changes to specific security headers, including changes to default values, new APIs, and deprecated methods.\n\n#### Changes to the default headers\n\nWhen you don't specify a custom `HeaderPolicyCollection` , *NetEscapades.AspNetCore.SecurityHeaders* applies a default set of headers, as I described previously. These headers are encapsulated in the `AddDefaultSecurityHeaders()` extension method, so the following are equivalent:\n\n```csharp app.UseSecurityHeaders(); // ðŸ‘ˆ This...\n\nvar policies = new HeaderPolicyCollection() .AddDefaultSecurityHeaders(); app.UseSecurityHeaders(policies); // ðŸ‘ˆ ..is equivalent to this.\n\n```\n\nIn `1.0.0-preview.1` the headers that are applied have changed slightly:\n\n- `Cross-Origin-Opener-Policy: same-origin`\nis now added.\n- `Cross-Origin-Embedder-Policy: credentialless`\nis now added.\n- `Cross-Origin-Resource-Policy: same-origin`\nis now added.\n- `X-XSS-Protection=1; mode-block`\nis no longer added.\n\nThe full set of headers added by default are now:\n\n- `X-Content-Type-Options: nosniff`\n- `X-Frame-Options: Deny`\n- `Referrer-Policy: strict-origin-when-cross-origin`\n- `Content-Security-Policy: object-src 'none'; form-action 'self'; frame-ancestors 'none'`\n- `Cross-Origin-Opener-Policy: same-origin`\n- `Cross-Origin-Embedder-Policy: credentialless`\n- `Cross-Origin-Resource-Policy: same-origin`\n- `Strict-Transport-Security: max-age=31536000; includeSubDomains`\n- *HTTPS responses only*\n\nIf you don't want this change, you can simply create a custom `HeaderPolicyCollection` configured as it was previously:\n\n```csharp new HeaderPolicyCollection() .AddFrameOptionsDeny() .AddXssProtectionBlock() // This is no longer included by default .AddContentTypeOptionsNoSniff() .AddStrictTransportSecurityMaxAge() .AddReferrerPolicyStrictOriginWhenCrossOrigin() .RemoveServerHeader() .AddContentSecurityPolicy(builder => { builder.AddObjectSrc().None(); builder.AddFormAction().Self(); builder.AddFrameAncestors().None(); });\n\n```\n\n#### `X-XSS-Protection=1; mode-block`\nis no longer recommended\n\nYou may wonder why `X-XSS-Protection` was removed from the default headers. The `X-XSS-Protection` header is interesting in that it's a security header that *used* to be recommended to add to your applications to improve security. However these days it's *not* recommended, because, as described on [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection):\n\n>\n> The `X-XSS-Protection`\n> header \"can create XSS vulnerabilities in otherwise safe websites\"\n> >\n\nThat's clearly not an example of a good header to add by default, so [it's been removed](https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders/pull/168) from the default set of security headers and [marked obsolete](https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders/pull/191). You can still add it to your application if you want to, it's just not recommended unless you understand the risks.\n\n#### `Expect-CT`\nis no longer recommended\n\nThe `Expect-CT` header lets sites opt-in to [certificate transparency](https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency) requirements, but only Chrome and other Chromium-based browsers implemented Expect-CT, On top of that, Chromium deprecated the header in version 107 (Oct 2022), because [Chromium now enforces CT by default](https://chromestatus.com/feature/6244547273687040).\n\nGiven the header is deprecated and [no longer recommended](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expect-CT), it's [now marked obsolete in *NetEscapades.AspNetCore.SecurityHeaders*](https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders/pull/197).\n\n#### New `PermisionsPolicyBuilder.AddDefaultSecureDirectives()`\nmethod\n\nThe [`Permissions-Policy` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy) provides a way to allow or deny the browser from using various features, such as the [Web Bluetooth API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Bluetooth_API) or the [Camera](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy/camera). Support for `Permissions-Policy` has been available for some time (with [many new policies added recently](https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders/pull/177)).\n\nOne slight annoyance with building up a `Permissions-Policy` is that there are so *many* policies. If you're building a JSON API (for example) then you'll likely want to disable [essentially all of them](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html#security-headers), at which point you're calling a *lot* of methods.\n\n`1.0.0` adds two new convenience method that add (most) of [the headers recommended by OWASP for REST endpoints](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html#security-headers). If you just want to add the default set of directives you can call `AddPermissionsPolicyWithDefaultSecureDirectives()` directly on `HeaderPolicyCollection` :\n\n```csharp var policies = new HeaderPolicyCollection() .AddPermissionsPolicyWithDefaultSecureDirectives();\n\n```\n\nAlternatively, if you want to customize the `Permissions-Policy` , you can call `PermissionsPolicyBuilder.AddDefaultSecureDirectives()` , and then add (or override) additional directives:\n\n```csharp var policies = new HeaderPolicyCollection() .AddPermissionsPolicy(p => { p.AddDefaultSecureDirectives(); // Add the default directives p.AddAttributionReporting().None(); // Additional customization });\n\n```\n\nIn both cases the default secure directives added are equivalent to:\n\n```http accelerometer=(), autoplay=(), camera=(), display-capture=(), encrypted-media=(), fullscreen=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), midi=(), payment=(), picture-in-picture=(), publickey-credentials-get=(), screen-wake-lock=(), sync-xhr=(), usb=(), web-share=(), xr-spatial-tracking=()\n\n```\n\nNote that this isn't quite the same set of headers [as suggested by OWASP](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html#security-headers), because *NetEscapades.AspNetCore.SecurityHeaders* doesn't include experimental features (to limit the scope and avoid too many breaking changes), but if you want to replicate those directives, you can always use the `AddCustomDirective()` helper.\n\n#### New support for Trusted Types\n\nThe Trusted Types directive is part of the Content-Security-Policy (CSP) feature to prevent against cross-site-scripting (XSS) attacks. By using the Trusted Types APIs, in combination with the Trusted Types directive, you can prevent cross-site scripting attacks that use DOM-based attacks by leveraging dangerous APIs.\n\n>\n> If you're new to the Trusted Types APIs, you can [read about them in my post here](/preventing-client-side-cross-site-scripting-vulnerabilities-with-trusted-types/) that shows how the attacks work and how the CSP can protect you. It's worth noting that the Trusted Types API is currently only available in Chromium based browsers, but it has been available in Chromium since version 83, released in 2020.\n> >\n\nYou can [add a trusted types directive](/preventing-client-side-cross-site-scripting-vulnerabilities-with-trusted-types/#blocking-cross-site-scripting-with-trusted-types-and-a-content-security-policy) to your CSP with *NetEscapades.AspNetCore.SecurityHeaders* using the `AddRequireTrustedTypesFor()` method. For example:\n\n```csharp var builder = new WebApplication.CreateBuilder(); var app = builder.Build();\n\n// Configure the policy app.UseSecurityHeaders(new HeaderPolicyCollection() .AddContentSecurityPolicy(builder => { // Add \"require-trusted-types-for 'script'\" header builder.AddRequireTrustedTypesFor().Script();\n\n// Add \"trusted-types my-policy\" header builder.AddTrustedTypes().AllowPolicy(\"my-policy\"); }));\n\n// other configuration app.Run();\n\n```\n\nThis adds a header like the following to the response:\n\n```http Content-Security-Policy: require-trusted-types-for 'script'; trusted-types my-policy\n\n```\n\nAttempting to execute a cross-site scripting attack using the [dangerous `innerHTML` API](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) will now fail with an error:\n\n![Showing trusted-types protections using a CSP](/content/images/2025/trusted_types_03.png)\n\nThe `require-trusted-types-for` and `trusted-types` directives work together to protect your application in Chrome, and you can use [a polyfill in other browsers](https://github.com/w3c/trusted-types?tab=readme-ov-file#polyfill).\n\n#### New `AddDefaultApiSecurityHeaders()`\nmethod\n\nThe set of security headers added by `AddDefaultSecurityHeaders()` was chosen to provide a good balance between security and applicability for a basic ASP.NET Core website that's serving HTML. But many apps *only* serve JSON and are never expected to be loaded directly in the browser. In those scenarios we can apply a more \"aggressive\" set of headers.\n\nThe new `AddDefaultApiSecurityHeaders()` extension method is designed for applying to APIs, and is based on [the recommendation from OWASP](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html#security-headers). It adds the following headers (I've also highlighted any differences with `AddDefaultSecurityHeaders()` ):\n\n- `X-Content-Type-Options: nosniff`\n- `X-Frame-Options: Deny`\n- `Referrer-Policy: no-referrer`\n- Compared to `strict-origin-when-cross-origin`\nfor `AddDefaultSecurityHeaders()`\n- `Content-Security-Policy: default-src 'none'; frame-ancestors 'none'`\n- Compared to `object-src 'none'; form-action 'self'; frame-ancestors 'none'`\nfor `AddDefaultSecurityHeaders()`\n- `Permissions-Policy: accelerometer=(), autoplay=(), camera=(), display-capture=(), encrypted-media=(), fullscreen=(), geolocation=(), gyroscope=(), magnetometer=(), microphone=(), midi=(), payment=(), picture-in-picture=(), publickey-credentials-get=(), screen-wake-lock=(), sync-xhr=(), usb=(), web-share=(), xr-spatial-tracking=()`\n- Not included in `AddDefaultSecurityHeaders()`\n- `Cross-Origin-Opener-Policy: same-origin`\n- `Cross-Origin-Embedder-Policy: require-corp`\n- Compared to `credentialless`\nfor `AddDefaultSecurityHeaders()`\n- `Cross-Origin-Resource-Policy: same-origin`\n\nYou can use `AddDefaultApiSecurityHeaders()` in your application by applying it to a `HeaderPolicyCollection` , for example:\n\n```csharp var builder = WebApplication.CreateBuilder(); var app = builder.Build();\n\n// ðŸ‘‡ Configure to use the API security headers app.UseSecurityHeaders(p => p.AddDefaultApiSecurityHeaders());\n\napp.MapGet(\"/\", () => \"Hello world!\"); app.Run();\n\n```\n\nIt's worth noting that [OWASP recommends](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html#security-headers) always adding other non-security headers to API responses, such as `Cache-Control: no-store` and `Content-Type` .\n\n##### `Feature-Policy`\nis marked obsolete\n\n`Feature-Policy` is a now-obsolete name for the `Permissions-Policy` header. The header has been deprecated, and as such the extension methods for adding `Feature-Policy` to your header collection have been marked `[Obsolete]` . You're recommended to switch to using `Permissions-Policy` instead.\n\n### Applying different headers to some endpoints\n\nThe biggest feature by far in `1.0.0` is the ability to apply different headers to different endpoints. This can be particularly useful if you want to maximally lock down your site, for example by applying a more restrictive [`Content-Security-Policy`](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) on certain pages, and relaxing it only when necessary.\n\nLet's say, for example, that your application contains both HTML and JSON endpoints. Perhaps you're serving HTML via Razor Pages, but you have some API endpoints that are also available. You would want to:\n\n- Apply the default security headers to all responses by default\n- For the API endpoints, apply the headers added by `AddDefaultApiSecurityHeaders()`\n\nPrior to `1.0.0` , that wasn't possible, but now it is! ðŸŽ‰ To achieve this we need to do 3 things:\n\n1. Configure default and named policies for the application.\n2. Add the middleware using `UseSecurityHeaders()`\n(as before).\n3. Apply custom policies to endpoints.\n\nThe following example shows all of those steps\n\n```csharp var builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddRazorPages();\n\n// 1. ðŸ‘‡ Configure the policies for the application builder.Services.AddSecurityHeaderPolicies() .SetDefaultPolicy(p => p.AddDefaultSecurityHeaders()) // ðŸ‘ˆ Configure the default policy .AddPolicy(\"API\", p => p.AddDefaultApiSecurityHeaders()); // ðŸ‘ˆ Configure named policies\n\nvar app = builder.Build();\n\n// 2. ðŸ‘‡ Add the security headers middleware app.UseSecurityHeaders();\n\napp.UseHttpsRedirection(); app.UseStaticFiles(); app.UseRouting(); app.UseAuthorization();\n\napp.MapRazorPages(); app.MapGet(\"/api\", () => \"Hello world\") .WithSecurityHeadersPolicy(\"API\"); // 3. ðŸ‘ˆ Apply a named policy to the endpoint\n\napp.Run();\n\n```\n\nIn the example above, the default security headers are applied to all responses *except* when the `/api` endpoint is invoked, in which case the named policy `\"API\"` is applied (which adds the `AddDefaultApiSecurityHeaders()` headers instead).\n\n>\n> If you're working with MVC controllers or Razor Pages, you can apply a named policy to an endpoint using the `[SecurityHeadersPolicy]`\n> attribute.\n> >\n\nThis should cater to the vast majority of cases where you need to apply multiple policies in an application, but if you really need it, you can now completely customise the policy that's applied, as you'll see in the next section.\n\n### Customizing the headers completely\n\nApplying different policies to different endpoints works well when you have a fixed number of policies to apply. However, in some cases you need to completely customise the headers for a given request. This might be the case if, for example, you are running a multi-tenant application, and the headers need to be matched to the incoming request.\n\nIn `1.0.0` , you can now completely customize the headers that will be applied by providing a lambda method that is executed just before the headers are applied, and by returning the `HeaderPolicyCollection` to apply.\n\nFor example, lets imagine that you want to apply a different set of headers for some requests. You can call the `SetPolicySelector()` , as shown below, and provide a function to execute whenever a policy is about to be applied:\n\n```csharp var builder = WebApplication.CreateBuilder(args);\n\nbuilder.Services.AddSecurityHeaderPolicies() .SetPolicySelector((PolicySelectorContext ctx) => { // TODO: anything you need to build the HeaderPolicyCollection // e.g. use services from the DI container (if you need to) IServiceProvider services = ctx.HttpContext.RequestServices;\n\nvar selector = services.GetService<TenantHeaderPolicyCollectionSelector>(); var tenant = services.GetService<ITenant>();\n\nHeaderPolicyCollection policy = selector.GetPolicyForTenant(tenant); return policy; // ðŸ‘ˆ This is the policy that is applied });\n\nvar app = builder.Build();\n\napp.UseSecurityHeaders(); app.MapGet(\"/api\", () => \"Hello world\"); app.Run();\n\n```\n\nThe lambda/method you pass to `SetPolicySelector()` is provided a `PolicySelectorContext` , which includes all the information you might need to decide which policy to apply:\n\n- `HttpContext HttpContext`\nâ€”The current `HttpContext` for the request.\n- `IReadOnlyDictionary<string, IReadOnlyHeaderPolicyCollection> ConfiguredPolicies`\nâ€”The named policies configured for the application.\n- `IReadOnlyHeaderPolicyCollection DefaultPolicy`\nâ€”The default policy that applies to the request.\n- `string? EndpointPolicyName`\nâ€”The name of the endpoint policy that applies to the request, if any.\n- `IReadOnlyHeaderPolicyCollection? EndpointPolicy`\nâ€”The endpoint policy that applies to the request, if any. If no endpoint-specific policy applies to the request, returns `null` .\n- `IReadOnlyHeaderPolicyCollection SelectedPolicy`\nâ€”The policy that would be applied to the endpoint by default: equivalent to `EndpointPolicy` if available, otherwise `DefaultPolicy` .\n\nYour policy selector *must* return a policy collection. If you don't want to customise the policy for the request, return `ctx.SelectedPolicy` .\n\n>\n> Note that you should avoid building a new `HeaderPolicyCollection`\n> on every request for performance reasons. Where possible, cache and reuse `HeaderPolicyCollection`\n> instances. If you do need to create a new `HeaderPolicyCollection`\n> from a `IReadOnlyHeaderPolicyCollection`\n> , you can call `Copy()`\n> to return a mutable instance.\n> >\n\nWith the combination of endpoint-specific policies and the customisation available in `SetPolicySelector()` , I hope that people will now be able to customise their applications more easily, without needing to resort to hacking the internals of the library!\n\n### \"Document headers\" functionality has been removed\n\nOne consequence of the additional customisation possible with `SetPolicySelector()` and endpoint policies is that [the concept of \"document headers\" have been removed](https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders/pull/186). The `ApplyDocumentHeadersToContentTypes()` and `ApplyDocumentHeadersToAllResponses()` extension methods have now been marked `[Obsolete]` and are no-ops.\n\nThese methods were originally added because some security headers don't really make *sense* when applied to passive content like JSON responses compared to HTML responses. Consequently, by default, some security headers (such as `Content-Security-Policy` ) would be omitted unless the response was HTML or JavaScript.\n\nThe only real benefit to this approach was that it reduced the size of the response (by omitting some headers). The down-side was that it added confusion and an additional configuration knob people had to consider. What's more, [OWASP actually recommends you *do* send these headers](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html#security-headers), even if you have no intention of returning HTML, as part of a defence-in-depth approach. What's more, some of the headers that were previously considered \"document/HTML only\" actually *should* be added to all responses to protect against [drag-and-drop style clickjacking attacks](https://www.w3.org/Security/wiki/Clickjacking_Threats#Drag_and_drop_attacks).\n\nSo in `1.0.0` the concept of a `DocumentHeaderPolicy` has been removed, and headers are *always* applied to *all* requests regardless of the response content type.\n\n>\n> Mostlyâ€¦some headers only apply to HTTPS requests for example, or should not be applied to `localhost`\n> requests. But the \"document header\" concept is no more.\n> >\n\nIf you want to re-instate the \"document header\" functionality for some reason, you can recreate something similar with `SetPolicySelector()` . There are lots of different ways you could achieve it, but here's one example:\n\n```csharp var builder = WebApplication.CreateBuilder(args);\n\n// The mime types considered \"documents\" string[] documentTypes = [ \"text/html\", \"application/javascript\", \"text/javascript\" ]; var documentPolicy = new HeaderPolicyCollection().AddDefaultSecurityHeaders();\n\nbuilder.Services.AddSecurityHeaderPolicies() .SetDefaultPolicy(p => p.AddDefaultApiSecurityHeaders()) .SetPolicySelector(ctx => { // If the response is one of the \"document\" types... if (documentTypes.Contains(ctx.HttpContext.Response.ContentType)) { // ... then return the \"document\" policy return documentPolicy; }\n\n// Otherwise return the original selected policy return ctx.SelectedPolicy; });\n\nvar app = builder.Build();\n\napp.UseSecurityHeaders(); app.MapGet(\"/api\", () => \"Hello world\"); app.Run();\n\n```\n\nAs I've already said, I don't recommend you do this, but the point is that now you *can* if you want to, which is why I chose to remove the document headers functionality.\n\n### Changes to nonce generation\n\nIn previous versions of *NetEscapades.AspNetCore.SecurityHeaders* a [nonce (number used once)](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce) was generated at the start of a request only when required by a `Content-Security-Policy` . However, with the changes in `1.0.0` it's no longer possible to know ahead of time that a nonce will be required (because the header policies can change later in the request, due to a named endpoint policy for example).\n\nAs a result, the nonce is no longer generated at the *start* of the request. Instead, it's generated lazily when you call `HttpContext.GetNonce()` . The end result is the same as beforeâ€”a single nonce is generated per-request, and only when it's required. The slight breaking change is the fact that you now *must* call `GetNonce()` to retrieve the nonce. Previously you *could* have retrieved the nonce directly from `HttpContext.Items` (even though that wasn't explicitly supported); in `1.0.0` that's no longer possible.\n\nThat covers the majority of the major changes made between versions `0.24.0` and `1.0.0` . You can find the [full diff here](https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders/compare/v0.24.0...v1.0.0), including an API diff (using [the workflow I described in a previous post](/preventing-breaking-changes-in-public-apis-with-publicapigenerator/)).\n\n### Updates to build provenance\n\nThe final category of updates in `1.0.0` are related to how the project is built and packaged. In summary, for each public release, you can now find:\n\n- [Provenance attestations](/creating-provenance-attestations-for-nuget-packages-in-github-actions/) describing the build and pipeline that produced the NuGet package.\n- [Software Bill of Materials (SBOM)](https://www.cisa.gov/sbom) in [CycloneDX](https://cyclonedx.org/) format.\n- An [attestation for the SBOM](/creating-sbom-attestations-in-github-actions/) that links the generated SBOM to the NuGet package.\n\nUnfortunately, as described in the above linked posts, nuget.org modifies packages that are uploaded to it, so verifying the above attestations is more convoluted than would be ideal, but is [described in the project README](https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders?tab=readme-ov-file#verifying-nuget-provenance-attestations).\n\n## Summary\n\nAdding [security-related headers](https://owasp.org/www-project-secure-headers/) to your HTTP responses is an easy way to harden your application against attacks. [*NetEscapades.AspNetCore.SecurityHeaders*](https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders) provides an easy way to do this, and has recently been through some major changes that I'm looking for feedback on before releasing the final stable version.\n\nIn summary, the major changes are:\n\n- Support for .NET Core 3.1+ only\n- Updates to headers\n- Changes to the default headers\n- New utility methods for adding API-related security headers and a locked-down `Permissions-Policy`\nheader\n- `X-XSS-Protection`\n, `Expect-CT` , and `Feature-Policy` are now obsolete\n- Support for applying different header policies to different endpoints\n- Support for customizing the header policy per-request\n- Removal of \"document header\" concept\n- Changes to nonce generation.\n\nI recommend updating to `1.0.0` now. There have been 4 preview releases since `0.24.0` so I'm pretty comfortable with the current release. But nevertheless, if you find any issues, please let me know by [opening an issue on GitHub](https://github.com/andrewlock/NetEscapades.AspNetCore.SecurityHeaders/issues). Thanks!\n\n## Tags\n\nAndrew Lock | .Net Escapades\n\n![](/assets/img/icons/apple/apple-touch-icon-180x180.png) Want an email when there's new posts?\n\nStay up to the date with the latest posts!\n\nOops! Check your details and try again.\n\nThanks! Check your email for confirmation.",
  "PubDate": "2025-04-15T09:00:00+00:00"
}
