{
  "Tags": [
    ".NET Core",
    "Aspire",
    "Docker"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Andrew Lock | .NET Escapades",
  "ProcessedDate": "2025-08-05 14:29:47",
  "FeedUrl": "https://andrewlock.net/rss.xml",
  "Title": "Converting a docker-compose file to .NET Aspire",
  "Description": "In this post I describe how I converted the deployment method of the mailing-list manager lismonk from a docker-compose.yml file to an Aspire app host project",
  "Link": "https://andrewlock.net/converting-a-docker-compose-file-to-aspire/",
  "FeedName": "Andrew Lock's Blog",
  "Author": "Andrew Lock",
  "EnhancedContent": "In this post, I take a *docker-compose.yml* file for [the open-source mailing list manager listmonk](https://listmonk.app/), and rewrite it to use .NET Aspire. Functionally, this results in the same app, but as an app directly modelled in .NET it's (theoretically) easier to both run the stack locally with your IDE *and* to generate \"publish\" artifacts for deploying the app. To prove the app is modelled as expected I subsequently *publish* the app again as a *docker-compose.yml* file, and compare the output.\n\n>\n> Note that I have only dabbled with Aspire, not used it in anger, and I haven't got my head around all of the intricacies yet. If you see something weird in this post‚ÄîI'm not doing something in the best way, or something doesn't work as I *think* it does‚Äîplease do leave a comment and correct me!\n> >\n\nI start by giving a high-level overview of .NET Aspire and why you might want to use it. I then describe the listmonk app, and show the docker-compose setup we're seeking to implement. Piece by piece, we'll convert the standard *docker-compose.yml* file to an Aspire app host. Finally, we'll add a publisher which allows aspire to generate a *docker-compose.yml* file *from* the app host project, and see how it compares to the original.\n\n## What is .NET Aspire?\n\nAccording to [the documentation](https://learn.microsoft.com/en-us/dotnet/aspire/get-started/aspire-overview):\n\n>\n> .NET Aspire provides tools, templates, and packages to help you build observable, production-ready apps. Delivered through NuGet packages, .NET Aspire simplifies common challenges in modern app development.\n> >\n\nThe primary focus of .NET Aspire is the *local* development experience. It's intended to simplify the interconnections (and associated configuration) that are often required to connect various parts of your system.\n\nFor example, most apps require a database. When you're working locally, maybe you spin up a PostgreSQL Docker container, or perhaps you rely on a local SQL Server installation. Either way, there are usernames, passwords, ports, connection strings, database names‚Ä¶ all things that you need to feed both into the configuration of the database, but *also* into any apps and services that *use* the database.\n\nInherently, this configuration isn't *hard*. After all, we've been doing it for decades. But it *is* annoying and somewhat error prone. What's more, if someone new starts trying to work on the same project, they have to decode all these requirements for running the app before they can get started. With .NET Aspire the goal is to simplify that process.\n\n.NET Aspire has many different parts to it, but at its core, it has an app host project. This is a .NET project which describes and models all the interconnections between your apps. This is where you declare that you need *this* database with *that* password, and so on.\n\nThere's a lot more to .NET Aspire, especially if you're building .NET applications‚Äîyou can ensure your .NET apps are automatically injected with connection strings, for example‚Äîbut the app host *isn't* strictly tied to .NET. The app *itself* is .NET, but that's just the language for modelling the interconnections between services. It can be used to model *any* applications, very similar to how a *docker-compose.yml* file can model any docker-based applications.\n\n## What is listmonk?\n\n[Listmonk](https://listmonk.app/) is a self-hosted newsletter and mailing list manager. It doesn't handle sending emails itself, it relies on third-party services for that. Rather, listmonk handles designing email campaigns, managing subscribers, and performing analytics.\n\n![The listmonk app](/content/images/2025/lismonk.png)\n\nListmonk is written in Go, using a Vue frontend with Buefy for UI, and is free and open source software licensed under AGPLv3. Being Go, you can run listmonk [as a single binary](https://listmonk.app/docs/installation/#binary), but there's [also a suggested *docker-compose.yml*](https://listmonk.app/docs/installation/#docker) for running the application.\n\nFor this post, I'm not going to be looking into the listmonk app itself at all. All I'm interested in is whether it's possible to create a .NET aspire app host project for running listmonk using the same suggested setup as the docker-compose file.\n\nFor reference, I'm using [the docker-compose file](https://github.com/knadh/listmonk/blob/86f808bc77ccded66a42bc19d96ebbd8d5e199ff/docker-compose.yml) at the time of the v5.0.1 release, reproduced below. This file only contains two services:\n\n- `app`\n. The listmonk app itself, running as a docker container.\n- `db`\n. A PostgreSQL database, again running as a docker container.\n\nThere's a bunch of shared configuration between the two apps, some volumes and bind mounts, and various other docker-compose specific configuration. For the rest of the app we'll aim to convert this entirely to an Aspire app.\n\nFor completeness, [this is the original *docker-compose.yml* file](https://github.com/knadh/listmonk/blob/86f808bc77ccded66a42bc19d96ebbd8d5e199ff/docker-compose.yml) we're converting:\n\n```yaml x-db-credentials: &db-credentials # Use the default POSTGRES_ credentials if they're available or simply default to \"listmonk\" POSTGRES_USER: &db-user listmonk # for database user, password, and database name POSTGRES_PASSWORD: &db-password listmonk POSTGRES_DB: &db-name listmonk\n\nservices:\n# listmonk app\napp: image: listmonk/listmonk:latest container_name: listmonk_app restart: unless-stopped ports:\n- \"9000:9000\" # To change the externally exposed port, change to: $custom_port:9000\nnetworks:\n- listmonk\nhostname: listmonk.example.com # Recommend using FQDN for hostname depends_on:\n- db\ncommand: [sh, -c, \"./listmonk --install --idempotent --yes --config '' && ./listmonk --upgrade --yes --config '' && ./listmonk --config ''\"]\n# --config (file) param is set to empty so that listmonk only uses the env vars (below) for config.\n# --install --idempotent ensures that DB installation happens only once on an empty DB, on the first ever start.\n# --upgrade automatically runs any DB migrations when a new image is pulled.\n\nenvironment: # The same params as in config.toml are passed as env vars here. LISTMONK_app__address: 0.0.0.0:9000 LISTMONK_db__user: *db-user LISTMONK_db__password: *db-password LISTMONK_db__database: *db-name LISTMONK_db__host: listmonk_db LISTMONK_db__port: 5432 LISTMONK_db__ssl_mode: disable LISTMONK_db__max_open: 25 LISTMONK_db__max_idle: 25 LISTMONK_db__max_lifetime: 300s TZ: Etc/UTC LISTMONK_ADMIN_USER: ${LISTMONK_ADMIN_USER:-} # If these (optional) are set during the first `docker compose up`, then the Super Admin user is automatically created. LISTMONK_ADMIN_PASSWORD: ${LISTMONK_ADMIN_PASSWORD:-} # Otherwise, the user can be setup on the web app after the first visit to http://localhost:9000 volumes:\n- ./uploads:/listmonk/uploads:rw # Mount an uploads directory on the host to /listmonk/uploads inside the container.\n# To use this, change directory path in Admin -> Settings -> Media to /listmonk/uploads\n\n# Postgres database\ndb: image: postgres:17-alpine container_name: listmonk_db restart: unless-stopped ports:\n- \"127.0.0.1:5432:5432\" # Only bind on the local interface. To connect to Postgres externally, change this to 0.0.0.0\nnetworks:\n- listmonk\nenvironment: <<: *db-credentials healthcheck: test: [\"CMD-SHELL\", \"pg_isready -U listmonk\"] interval: 10s timeout: 5s retries: 6 volumes:\n- type: volume\nsource: listmonk-data target: /var/lib/postgresql/data\n\nnetworks: listmonk:\n\nvolumes: listmonk-data:\n\n```\n\nBefore we can get started on the conversion, we'll install the prerequisites for Aspire.\n\n## Getting started with Aspire\n\nTo work with Aspire, I first made sure I had [installed the prerequisites](https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/setup-tooling?tabs=windows&amp;pivots=dotnet-cli#install-net-aspire-prerequisites):\n\n- .NET 9 SDK (you can also use .NET 8)\n- Docker Desktop for Windows (you can also use other OCI runtimes like Podman)\n\nIt's *very* likely you already have those if you're a .NET developer, which is nice. I primarily used [JetBrains Rider](https://blog.jetbrains.com/dotnet/2024/02/19/jetbrains-rider-and-the-net-aspire-plugin/) to work on the app, but for this post I primarily use the .NET CLI.\n\nOnce you have the prerequisites, it's best to install the Aspire project templates. This makes it easy to create new projects. Install the templates with `dotnet new install Aspire.ProjectTemplates` :\n\n```bash $ dotnet new install Aspire.ProjectTemplates The following template packages will be installed: Aspire.ProjectTemplates\n\nSuccess: Aspire.ProjectTemplates::9.3.0 installed the following templates: Template Name Short Name Language Tags ----------------------------- ---------------------- -------- ------------------------------------------------------------------------------- .NET Aspire App Host aspire-apphost [C#] Common/.NET Aspire/Cloud .NET Aspire Empty App aspire [C#] Common/.NET Aspire/Cloud/Web/Web API/API/Service .NET Aspire Service Defaults aspire-servicedefaults [C#] Common/.NET Aspire/Cloud/Web/Web API/API/Service .NET Aspire Starter App aspire-starter [C#] Common/.NET Aspire/Blazor/Web/Web API/API/Service/Cloud/Test/MSTest/NUnit/xUnit .NET Aspire Test Project (... aspire-mstest [C#] Common/.NET Aspire/Cloud/Web/Web API/API/Service/Test/MSTest .NET Aspire Test Project (... aspire-nunit [C#] Common/.NET Aspire/Cloud/Web/Web API/API/Service/Test/NUnit .NET Aspire Test Project (... aspire-xunit [C#] Common/.NET Aspire/Cloud/Web/Web API/API/Service/Test/xUnit\n\n```\n\nThe template I wanted was `aspire-apphost` . This creates *just* the app host project, without creating associated .NET apps or class libraries. I created a new folder, and then created the new project inside it:\n\n```bash mkdir LismonkAspire cd LismonkAspire dotnet new aspire-apphost\n\n```\n\nThis created a .NET 9 Aspire 9.3 app host project. The *AppHost.cs* project contained the following code; effectively an empty app host project:\n\n```csharp var builder = DistributedApplication.CreateBuilder(args);\n\nbuilder.Build().Run();\n\n```\n\nThere's a bunch of additional files, but for now, this was what I was interested in, so I set about modelling the listmonk services in this file. I started with the PostgreSQL database, seeing as the listmonk app depends on it.\n\n## Modelling the database in Aspire\n\nThe base Aspire app host project includes the ability to [model various resources](https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/app-host-overview#built-in-resource-types), such as executables, .NET apps, and docker containers. However there are also various [*integrations*](https://learn.microsoft.com/en-us/dotnet/aspire/get-started/aspire-overview#net-aspire-integrations), which are NuGet package \"plugins\", intended to simplify connecting to common services or platforms. There is just such a package for PostgreSQL.\n\nTo install the integration, simply install [the relevant NuGet package](https://www.nuget.org/packages/Aspire.Hosting.PostgreSQL#readme-body-tab):\n\n```bash dotnet add package Aspire.Hosting.PostgreSQL\n\n```\n\nThis installs v9.3.0 of the NuGet package in the project and makes the `AddPostgres()` extension method available. The section of the docker-compose we need to model is this:\n\n```yaml x-db-credentials: &db-credentials # Use the default POSTGRES_ credentials if they're available or simply default to \"listmonk\" POSTGRES_USER: &db-user listmonk # for database user, password, and database name POSTGRES_PASSWORD: &db-password listmonk POSTGRES_DB: &db-name listmonk\n\nservices:\n# Postgres database\ndb: image: postgres:17-alpine container_name: listmonk_db restart: unless-stopped ports:\n- \"127.0.0.1:5432:5432\" # Only bind on the local interface. To connect to Postgres externally, change this to 0.0.0.0\nnetworks:\n- listmonk\nenvironment: <<: *db-credentials healthcheck: test: [\"CMD-SHELL\", \"pg_isready -U listmonk\"] interval: 10s timeout: 5s retries: 6 volumes:\n- type: volume\nsource: listmonk-data target: /var/lib/postgresql/data\n\n```\n\nThe first part of this, the `x-db-credentials` section, may be unfamiliar to you. It's a way of getting some \"code-reuse\" in YAML. I'm not going to go into it in detail here. For now, it's enough to know that the `db` service *effectively* has the following environment variables defined:\n\n```yaml environment: POSTGRES_USER: listmonk POSTGRES_PASSWORD: listmonk POSTGRES_DB: listmonk\n\n```\n\nWith that in mind, we'll now model this service in Aspire. I've opted for a close-to direct representation, with some exceptions, which I'll describe later. I've annotated the code below to explain what's going on:\n\n```csharp var builder = DistributedApplication.CreateBuilder(args);\n\n// Create these values as secrets var postgresUser = builder.AddParameter(\"db-user\", secret: true); var postgresPassword = builder.AddParameter(\"db-password\", secret: true);\n\n// Add a default for the database name var postgresDbName = builder.AddParameter(\"db-name\", \"listmonk\", publishValueAsDefault: true);\n\n// Create these as variables to be used elsewhere var dbPort = 5432; var dbContainerName = \"listmonk_db\";\n\n// Sets the POSTGRES_USER and POSTGRES_PASSWORD implicitly var db = builder.AddPostgres(\"db\", postgresUser, postgresPassword, port: dbPort) .WithImage(\"postgres\", \"17-alpine\") // Ensure we use the same image as docker-compose .WithContainerName(dbContainerName) // Use a fixed container name .WithLifetime(ContainerLifetime.Persistent) // Don't tear-down the container when we stop Aspire .WithDataVolume(\"listmonk-data\") // Wire up the PostgreSQL data volume .WithEnvironment(\"POSTGRES_DB\", postgresDbName); // Explicitly set this value, so that it's auto-created\n\n```\n\nOne big advantage of .NET Aspire over YAML is that creating \"variables\" to share in multiple places is simple and intuitive. Instead of having to create YAML \"anchors\" and reference them elsewhere, we simply create values and pass them around.\n\nWhat's more, by using `AddParameter()` we can declare that a value should be provided *externally*, as it is above for `db-user` and `db-password` . What's more, we can mark the fact that these should be secrets, so that if we publish our Aspire app, Aspire can handle the fact they contain sensitive data.\n\nThere's a few things from the *docker-compose.yml* that *aren't* modelled in Aspire, namely the \"restart behaviour\" and the healthcheck. I left these out, as the `AddPostgres()` integration adds its own health check, and these are fundamentally specific to docker-compose; we'll look at them again later when we configure a Docker publisher.\n\n## Modelling the app in Aspire\n\nWith the database implemented, we move on to the listmonk app itself. This, again, is implemented as a Docker container, but there's no helpful integration or extension method for it; we'll have to model this one ourselves. Luckily, there's not much to configure; we're mostly just setting a bunch of environment variables, exposing the app over port 9000, and changing the command used to run the app:\n\n```csharp // Optional initial super-user configuration var listmonkSuperUser = builder.AddParameter(\"listmonk-admin-user\", secret: true); var listmonkSuperUserPassword = builder.AddParameter(\"listmonk-admin-password\", secret: true);\n\nvar publicPort = 9000; // The port to access the app from the browser\n\nbuilder.AddContainer(name: \"listmonk\", image: \"listmonk/listmonk\", tag: \"latest\") .WaitFor(db) // The app depends on the db, so wait for it to be healthy .WithHttpEndpoint(port: publicPort, targetPort: 9000) // Expose port 9000 in the container as \"publicPort\" .WithExternalHttpEndpoints() // The HTTP endpoint should be publicly accessibly .WithArgs(\"sh\", \"-c\", \"./listmonk --install --idempotent --yes --config '' && ./listmonk --upgrade --yes --config '' && ./listmonk --config ''\") .WithBindMount(source: \"./uploads\", target: \"/listmonk/uploads\") // mount the folder ./uploads on the host into the container .WithEnvironment(\"LISTMONK_app__address\", $\"0.0.0.0:{publicPort.ToString()}\") // This points to the app itself (used in emails) .WithEnvironment(\"LISTMONK_db__user\", postgresUser) // Database connection settings .WithEnvironment(\"LISTMONK_db__password\", postgresPassword) .WithEnvironment(\"LISTMONK_db__database\", postgresDbName) .WithEnvironment(\"LISTMONK_db__host\", dbContainerName) .WithEnvironment(\"LISTMONK_db__port\", dbPort.ToString()) .WithEnvironment(\"LISTMONK_db__ssl_mode\", \"disable\") .WithEnvironment(\"LISTMONK_db__max_open\", \"25\") .WithEnvironment(\"LISTMONK_db__max_idle\", \"25\") .WithEnvironment(\"LISTMONK_db__max_lifetime\", \"300s\") .WithEnvironment(\"TZ\", \"Etc/UTC\") .WithEnvironment(\"LISTMONK_ADMIN_USER\", listmonkSuperUser) // Optional super-user .WithEnvironment(\"LISTMONK_ADMIN_PASSWORD\", listmonkSuperUserPassword);\n\n```\n\nMost of the variables we set are values that are mirrored in the `db` configuration. Using variables means we can easily flow the values to both places, which highlights one of the benefits of Aspire.\n\n>\n> There's a number of things I'm fairly sure I'm not doing \"correctly\" here. For example, the `dbContainerName`\n> and `dbPort`\n> ; I hard-coded those as variables when configuring the `db`\n> service and re-used them here. Is that reasonable? Is that a problem if I (for example) later decide to run my PostgreSQL instance as a service instead of a Docker container? Probably, but that's always something I could address later I guess.\n> >\n> Another example is the public port: I hardcoded it to `9000`\n> , because that's what the docker-compose file does, but I would probably *like* to just be able to have Aspire choose the host port automatically and then have that flow through. That *almost* works, but I couldn't see an easy way to have it set the `LISTMONK_app__address`\n> environment variable to include the host `0.0.0.0`\n> the way I need it to, without manually creating an `EnvironmentCallbackAnnotation`\n> . And that just got too ugly.\n> >\n\nIgnoring the caveats above, theoretically we've now converted the app and can take it for a spin!\n\n## Testing it out\n\nBefore we can run the app, we first need to set the values for the parameters we defined in our app host. Given that many of these are marked as secrets, we should probably do this using [user-secrets](https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-9.0&amp;tabs=windows) when running locally. You can edit the user-secrets for your app host using the IDE, or alternatively, set the values using the command line. I opted for the latter, setting some \"super-secret\" values.\n\n```bash dotnet user-secrets set \"Parameters:db-user\" \"listmonk\" dotnet user-secrets set \"Parameters:db-password\" \"listmonk\" dotnet user-secrets set \"Parameters:listmonk-admin-user\" \"admin-user\" dotnet user-secrets set \"Parameters:listmonk-admin-password\" \"admin-password\"\n\n```\n\nNote that the secrets are all nested under the `Parameters` key, by prefixing the values with `Parameters:` . We can now run the app. Either hit F5 in your IDE or type `dotnet run` , and the app starts up. The Aspire app host starts [the Aspire dashboard](https://learn.microsoft.com/en-us/dotnet/aspire/fundamentals/dashboard/overview?tabs=bash), showing our apps. From there we can view the logs, environment, and various other aspects of our apps:\n\n![The Aspire dashboard for our listmonk app](/content/images/2025/listmonk_aspire.png)\n\nWe can also see a link to our listmonk app at http://localhost:9000. Clicking the link opens the app, where we can login with our Admin username and password. And there we have it, our listmonk app, running in Aspire!\n\n![The listmonk app running in Aspire](/content/images/2025/listmonk_aspire_2.png)\n\nWith the app modelled in Aspire, I decided to see what it would like if we went the other way: creating the *docker-compose.yml* file *from* the Aspire app host.\n\n## Publishing the app host as a docker-compose.yml file\n\nMy reason for re-creating the *docker-compose.yml* file was to see if the *generated* file looked the same as the *source* file. If so, then I could be pretty comfortable that Aspire was doing what I intended, at the modelling worked correctly. To do this, I needed to configure an Aspire [*publisher*](https://learn.microsoft.com/en-us/dotnet/aspire/whats-new/dotnet-aspire-9.3#deployment--publish).\n\nA publisher takes your Aspire app host and spits out a bunch of artifacts that can be used by other tools. This could be a *docker-compose.yml* file, which is what I wanted, but it could also be Kubernetes Helm charts, it could be Azure ARM/Bicep templates, or anything really. This part of the Aspire experience is less mature than the local-dev-loop, but with 9.3 it's looking much more promising.\n\nI started by installing the preview package of [the *Aspire.Hosting.Docker* NuGet package](https://www.nuget.org/packages/Aspire.Hosting.Docker/9.3.0-preview.1.25265.20#readme-body-tab). This provides publishing capabilities for the app host:\n\n```bash dotnet add package Aspire.Hosting.Docker --version 9.3.0-preview.1.25265.20\n\n```\n\nNext, we enable the publisher by adding the following to our app host:\n\n```csharp builder.AddDockerComposeEnvironment(\"docker-compose\");\n\n```\n\nThat's all we *need* to do, but I decided to make a few tweaks to the app host, to ensure we more closely replicate the final docker-compose file.\n\nFirst, for the `listmonk` app, I used the `PublishAsDockerComposeService()` extension to add the `restart: unless-stopped` setting to the output *docker-compose.yml* file.\n\n```csharp builder.AddContainer(name: \"listmonk\", image: \"listmonk/listmonk\", tag: \"latest\") // ... other config not shown .PublishAsDockerComposeService((resource, service) => { service.Restart = \"unless-stopped\"; });\n\n```\n\nSimilarly, for the database service, I used the same method to set the `restart` setting and provide the same `healthcheck` as the original docker-compose file used:\n\n```csharp var db = builder.AddPostgres(\"db\", postgresUser, postgresPassword, port: dbPort) // ... other config not shown .PublishAsDockerComposeService((resource, service) => { service.Restart = \"unless-stopped\"; service.Healthcheck = new() { Interval = \"10s\", Timeout = \"5s\", Retries = 6, StartPeriod = \"0s\", Test = [\"CMD-SHELL\", \"pg_isready -U listmonk\"] }; });\n\n```\n\nNote that these settings are *only* applied when *publishing* the app, they don't really make sense when running locally.\n\nTo use the publisher it seems I needed to install [the Aspire CLI](https://learn.microsoft.com/en-gb/dotnet/aspire/whats-new/dotnet-aspire-9.2#-aspire-cli-preview). This is still in preview at the moment, but I couldn't see a way of invoking the publisher without it:\n\n```bash $ dotnet tool install --global aspire.cli --prerelease You can invoke the tool using the following command: aspire Tool 'aspire.cli' (version '9.3.0-preview.1.25265.20') was successfully installed.\n\n```\n\nWith the tool installed you can run `aspire publish` , and the CLI will publish the app host as a *.env* file and a *docker-compose.yml* file:\n\n```ps\n> aspire publish -o publish\nüõ† Generating artifacts...\n\n‚úî Publishing artifacts ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ 00:00:00\n\nüëç Successfully published artifacts to: D:\\repos\\ListmonkAspire\\publish\n\n```\n\nThe files produced are shown below. First of all, we have the *.env* file, which is where all the parameters that we set in user-secrets are set when running in a docker-compose deployment:\n\n```ini\n# Parameter db-user\nDB_USER=\n\n# Parameter db-password\nDB_PASSWORD=\n\n# Parameter db-name\nDB_NAME=listmonk\n\n# Parameter listmonk-admin-user\nLISTMONK_ADMIN_USER=\n\n# Parameter listmonk-admin-password\nLISTMONK_ADMIN_PASSWORD=\n\n```\n\nThen we have the *docker-compose.yml* itself. That file is reproduced below\n\n```yaml services: db: image: \"docker.io/postgres:17-alpine\" container_name: \"listmonk_db\" environment: POSTGRES_HOST_AUTH_METHOD: \"scram-sha-256\" POSTGRES_INITDB_ARGS: \"--auth-host=scram-sha-256 --auth-local=scram-sha-256\" POSTGRES_USER: \"${DB_USER}\" POSTGRES_PASSWORD: \"${DB_PASSWORD}\" POSTGRES_DB: \"${DB_NAME}\" ports:\n- \"5432:5432\"\nvolumes:\n- type: \"volume\"\ntarget: \"/var/lib/postgresql/data\" source: \"listmonk-data\" read_only: false networks:\n- \"aspire\"\nrestart: \"unless-stopped\" healthcheck: test:\n- \"CMD-SHELL\"\n- \"pg_isready -U listmonk\"\ninterval: \"10s\" timeout: \"5s\" retries: 6 start_period: \"0s\" listmonk: image: \"listmonk/listmonk:latest\" command:\n- \"sh\"\n- \"-c\"\n- \"./listmonk --install --idempotent --yes --config '' && ./listmonk --upgrade --yes --config '' && ./listmonk --config ''\"\nenvironment: LISTMONK_app__address: \"0.0.0.0:9000\" LISTMONK_db__user: \"${DB_USER}\" LISTMONK_db__password: \"${DB_PASSWORD}\" LISTMONK_db__database: \"${DB_NAME}\" LISTMONK_db__host: \"listmonk_db\" LISTMONK_db__port: \"5432\" LISTMONK_db__ssl_mode: \"disable\" LISTMONK_db__max_open: \"25\" LISTMONK_db__max_idle: \"25\" LISTMONK_db__max_lifetime: \"300s\" TZ: \"Etc/UTC\" LISTMONK_ADMIN_USER: \"${LISTMONK_ADMIN_USER}\" LISTMONK_ADMIN_PASSWORD: \"${LISTMONK_ADMIN_PASSWORD}\" ports:\n- \"9000:9000\"\nvolumes:\n- type: \"bind\"\ntarget: \"/listmonk/uploads\" source: \"D:\\\\repos\\\\blog-examples\\\\ListmonkAspire\\\\uploads\" read_only: false depends_on: db: condition: \"service_started\" networks:\n- \"aspire\"\nrestart: \"unless-stopped\" networks: aspire: driver: \"bridge\" volumes: listmonk-data: driver: \"local\"\n\n```\n\nThere's a few cosmetic differences between this generated file and the original, but for the *most* part they seem functionally equivalent to me! With a bit more work I'm sure I could make them identical, but they're close-enough for me for this experiment. Overall, I'd say it was a success!\n\n## Summary\n\nIn this post I described .NET Aspire and the open-source mailing-list manager [listmonk](https://listmonk.app/). Listmonk provides a *docker-compose.yml* file as a suggested approach to deployment, and I wanted to see how easy it would be to convert the project to run as a .NET Aspire app host instead. The listmonk app runs a PostgreSQL docker container as the database and a separate Docker container as the main app.\n\nAfter the conversion, I used the Aspire CLI and the Docker publisher to export the Aspire app as a *docker-compose.yml* file, to see how close the conversion was. Overall I think the experiment was a success, though I'm sure there are things I could do better in the Aspire app (let me know in the comments if you have suggestions!)\n\n## Tags\n\nAndrew Lock | .Net Escapades\n\n![](/assets/img/icons/apple/apple-touch-icon-180x180.png) Want an email when there's new posts?\n\nStay up to the date with the latest posts!\n\nOops! Check your details and try again.\n\nThanks! Check your email for confirmation.",
  "PubDate": "2025-05-27T09:00:00+00:00"
}
