{
  "Tags": [
    "ASP.NET Core",
    "Dependency Injection"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Andrew Lock | .NET Escapades",
  "ProcessedDate": "2025-08-05 14:29:47",
  "FeedUrl": "https://andrewlock.net/rss.xml",
  "Title": "Creating a 'pooled' dependency injection lifetime",
  "Description": "In this post I investigate how to create a 'pooled' dependency injection scope that automatically pools services between multiple requests",
  "Link": "https://andrewlock.net/creating-a-pooled-dependency-injection-lifetime/",
  "FeedName": "Andrew Lock's Blog",
  "Author": "Andrew Lock",
  "EnhancedContent": "This post follows on from [my previous post](/going-beyond-singleton-scoped-and-transient-lifetimes/), in which I discussed some theoretical/experimental dependency-injection lifetimes, based on the discussion in an episode of [The Breakpoint Show](https://www.breakpoint.show/podcast/episode-036-episode-of-a-lifetime/). In the previous post I provided an overview of the built-in Dependency Injection lifetimes, and described the additional proposed lifetimes: tenant, pooled, and drifter.\n\nThe previous post provided a overview of each of these proposed lifetimes, and an implementation of the drifter (time-based) lifetime. In this post I provide an example of the \"pooled\" lifetime.\n\n## Dependency injection lifetimes\n\nThis post is intended as a direct follow-on from the [previous post](/going-beyond-singleton-scoped-and-transient-lifetimes/) in which I provide the full context, but I'll provide a brief outline of the premise here. When you register services in the .NET Core DI container, you choose one of three different lifetimes.\n\n- Singleton\n- Scoped\n- Transient\n\nThe lifetime you specify controls how and when the DI container chooses to create a new instance of a given service, and when it instead returns an already-existing instance of the service:\n\n- Singleton—only a single instance is ever created\n- Scoped—a new instance is created once per \"scope\" (typically per request)\n- Transient—a new instance is created every time it's needed\n\n>\n> For a full introduction to dependency injection in .NET Core, see [the Microsoft documentation](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection), or [chapters 8](https://livebook.manning.com/book/asp-net-core-in-action-third-edition/chapter-8/) [and 9](https://livebook.manning.com/book/asp-net-core-in-action-third-edition/chapter-9/) of my book.\n> >\n\nIn [episode 36 of The Breakpoint Show](https://www.breakpoint.show/podcast/episode-036-episode-of-a-lifetime/), Khalid, Maarten, and Woody discuss the three lifetimes I described above, providing some examples of when you might choose each one, problems to watch out for, and other things to consider.\n\nThroughout the show, they also discuss the desire for three \"additional\" types of services, which didn't quite fit into the standard lifetimes:\n\n- Tenant-scoped services—effectively per-tenant singletons\n- Time-based (drifter) services—singleton services that are replaced periodically\n- Pooled services—reuses a \"pool\" of services\n\nYou can read one way to implement tenant-scoped services [in this blog series](https://michael-mckenna.com/multi-tenant-asp-dot-net-8-tenant-resolution/) from Michael McKenna and I showed an implementation of the time-based/drifter lifetime [in my previous post](/going-beyond-singleton-scoped-and-transient-lifetimes/#implementing-a-simple-time-based-lifetime-service). In this post I look at one possible implementation of a pooled lifetime.\n\n## Pooled lifetime requirements\n\nWoody mentioned pooling in [the podcast episode](https://www.breakpoint.show/podcast/episode-036-episode-of-a-lifetime/) as a way to reduce allocations and thereby improve performance. The pooled lifetime (inspired by [EF Core's `DbContext` pooling feature](https://learn.microsoft.com/en-us/ef/core/performance/advanced-performance-topics?tabs=with-di%2Cexpression-api-with-constant#dbcontext-pooling)) would make this capability a general DI feature, allowing pooling of \"arbitrary\" services.\n\nIn general, I considered the requirements for this feature to be:\n\n- Pooled services should have \"scoped\" semantics, i.e. when a pooled instance is used, it should be used for the whole request scope, and should not be used by parallel requests.\n- When a pooled service is requested, the DI should use a pooled instance first, if available. If no pooled instances are available, the DI container should create a new instance.\n- When the scope is disposed, pooled services should be returned to the pool.\n- The DI container should pool a maximum of `N`\ninstances of the service. When an instance is returned, if there are already `N` instances in the pool, the returned instance should be discarded (calling `Dispose()` if required).\n- Pooled services must implement the `IResettableService`\ninterface, which contains a single `Reset` method.\n- When an instance is returned to the pool, the pool should call `Reset()`\non the instance. This must reset the instance, so that it's safe to reuse in another request.\n- Other than `IResettableService`\n, there should be no other \"additional\" requirements on the pooled service.\n- If a service implements `IDisposable`\n, it must be disposed if it is not returned to the pool.\n\nI considered those to be the main requirements, but to make my proof of concept implementation a bit easier, I added a few anti-requirements:\n\n- It's permissible to return a \"wrapper\" type to access the pooled service (similar to how the `IOptions<>`\nabstraction works in ASP.NET Core).\n- Ignore `async`\nrequirements for now i.e. no need for a `ResetAsync()` or supporting `IAsyncDisposable` .\n- Don't worry about configuration of the pool i.e. allow a \"fixed\" maximum size for the pool.\n\nThat covers the majority of the important behaviour points. In the next section, I'll show an example implementation that meets all of these.\n\n>\n> Note that I chose *not* to use `ObjectPool<T>`\n> to explore this. Not for any principled reason, I was just hoping to have a slightly different API. You can see a similar implementation that uses `ObjectPool<T>`\n> in [the Microsoft docs](https://learn.microsoft.com/en-us/aspnet/core/performance/objectpool?view=aspnetcore-9.0).\n> >\n\n## Implementing a pooled lifetime service\n\nThere are 5 different moving parts in the implementation:\n\n- `IResettableService`\n—The interface that resettable services must implement\n- `IPooledService<T>`\n—The interface used to access an instance of item `T` (analogous to `IOptions<T>` )\n- `PooledService<T>`\n—The internal implementation of `IPooledService<T>`\n- `DependencyPool<T>`\n—The pooling implementation, responsible for the rent and return of `IPooledService<T>`\n- `PoolingExtensions`\n—Helper methods for adding the required services to the DI container.\n\nNow let's look at each of these in turn\n\n### `IResettableService`\n\nThis is the only requirement on the pooled service itself, and there's only one method to implement, `Reset()` :\n\n```csharp public interface IResettableService { void Reset(); }\n\n```\n\nWhen called, `Reset()` should reset the service to its \"original\" state, so that it can be reused when it's removed from the pool. If we compare this to `DbContext` (the original inspiration for the pooling idea), this is where the change tracking would be reset, for example.\n\n### `IPooledService<T>`\n\nThe `IPooledService<T>` interface is how the application primarily retrieves instances of a pooled service `T` . It's the type that you inject into your service constructors, and it's how you access instances of `T` , similar to how `IOptions<T>` works for configuration:\n\n```csharp public interface IPooledService<out T> where T : IResettableService { T Value { get; } }\n\n```\n\nAs you can see from the above, the service `T` must implement `IResettableService` and can be accessed via the `Value` property. For example, you might use it in a dependent service like this:\n\n```csharp public class DependentService { private readonly IMyService _myService; public DependentService(IPooledService<IMyService> pooled) { // Extract the value from the IPooledService<T> _myService = pooled.Value; } }\n\n```\n\nThis level of indirection is a bit annoying from a practical point of view, but I found it to be a necessary evil to create a *generalised* pooling lifetime. All the alternatives I could come up with that wouldn't require `IPooledService<T>` instead required the `IResettableService` to do a lot more work, which I wanted to avoid for this implementation.\n\n### `PooledService<T>`\n\n`PooledService<T>` is the `internal` implementation of `IPooledService<T>` :\n\n```csharp internal class PooledService<T> : IPooledService<T>, IDisposable where T : IResettableService { private readonly DependencyPool<T> _pool;\n\npublic PooledService(DependencyPool<T> pool) { _pool = pool; // Rent a service from the pool Value = _pool.Rent(); }\n\npublic T Value { get; }\n\nvoid IDisposable.Dispose() { // When the PooledService<T> is disposed, // the service is returned to the pool _pool.Return(Value); } }\n\n```\n\nAs you can see from the code above, the `PooledService<T>` implementation depends on the `DependencyPool<T>` , which we'll look into in detail shortly. The service rents an instance of `T` from the pool in the constructor. The DI container will then automatically dispose the `PooledService<T>` when the service scope ends, which returns the service `T` to the pool.\n\n### `DependencyPool<T>`\n\nThe `DependencyPool<T>` instance is where the bulk of the work happens for the implementation. The `DependencyPool<T>` is responsible for:\n\n- Creating new instances of the service `<T>`\nif there are none in the pool.\n- Adding returned services to the pool.\n- Returning pooled services when available.\n- Disposing services that can't be added to the pool.\n\n```csharp internal class DependencyPool<T>(IServiceProvider provider) : IDisposable where T : IResettableService { private int _count = 0; // The number of instances in the pool private int _maxPoolSize = 3; // TODO: Set via options private readonly ConcurrentQueue<T> _pool = new(); private readonly Func<T> _factory = () => ActivatorUtilities.CreateInstance<T>(provider);\n\npublic T Rent() { // Try to retrieve an item from the pool if (_pool.TryDequeue(out var service)) { // the Interlocked.Decrement(ref _count); return service; }\n\n// No services in the pool return _factory(); }\n\npublic void Return(T service) { if (Interlocked.Increment(ref _count) <= _maxPoolSize) { // there was space in the pool, so reset and return the service service.Reset(); _pool.Enqueue(service); } else { // The maximum pool size has been exceeded // We incremented when attempting to return, so reverse that Interlocked.Decrement(ref _count); (service as IDisposable)?.Dispose(); } }\n\npublic void Dispose() { // If the pool itself is disposed, dispose all the pooled services _maxPoolSize = 0;\n\nwhile (_pool.TryDequeue(out var service)) { (service as IDisposable)?.Dispose(); } } }\n\n```\n\nThe implementation is relatively simple, but with a couple of interesting points:\n\n- An `IServiceProvider`\nis passed in the constructor, and is used with `ActivatorUtilities.CreateInstance()` to create a \"factory\" `Func<T>` for creating instances of the service `T` .\n- The number of pooled instances is stored in `_count`\nand is stored separately from `ConcurrentQueue<T>` . The use of `Interlocked.Increment()` and `Interlocked.Decrement()` ensure we don't exceed the maximum pool size.\n- The maximum pool size in the above implementation is fixed at `3`\nbut that could easily be made configurable.\n- When the `DependencyPool<T>`\nitself is disposed, the pool ensures no more instances can be rented, and disposes all currently pooled instances.\n\n### `PoolingExtensions`\n\nWe've pretty much covered all the moving parts now, the one last step is to register everything in the DI container. We only have two services we need to register here, `DependencyPool<T>` and `IPooledService<T>`\n\n```csharp public static class PoolingExtensions { public static IServiceCollection AddScopedPooling<T>(this IServiceCollection services) where T : class, IResettableService { services.TryAddSingleton<DependencyPool<T>>(); services.TryAddScoped<IPooledService<T>, PooledService<T>>();\n\nreturn services; } }\n\n```\n\nNote that we *don't* register `T` itself as a service that you can directly pull from the container; you always need to retrieve an `IPooledService<T>` and access the `T` by calling `Value` . You *might* think that you could handle this automatically in the container, doing something like the following:\n\n```csharp services.AddScoped(s => s.GetRequiredService<IPooledService<T>>().Value);\n\n```\n\nBut unfortunately, that doesn't work. By having the DI container return the `T` directly, the DI container will automatically dispose the `T` when the scope ends. That's not what we want for pooled services—the pooled service will be handed out again, and we don't want it to be *disposed*, we rather want it to be *reset*.\n\n>\n> A reminder that an alternative to this implementation would be to use the `ObjectPool<T>`\n> implementation, as described in [the Microsoft docs](https://learn.microsoft.com/en-us/aspnet/core/performance/objectpool?view=aspnetcore-9.0).\n> >\n\nOk, we have a complete implementation, time to take it for a spin!\n\n## Testing the implementation\n\nTo test the service I'm using a similar test service as I used [in the previous post](/going-beyond-singleton-scoped-and-transient-lifetimes/#testing-out-the-timed-dependencies), where each instance gets a different ID for its lifetime, so that we can easily see when new instances are created:\n\n```csharp public class TestService : IResettableService, IDisposable { private static int _id = 0;\n\npublic int Id { get; } = Interlocked.Increment(ref _id);\n\npublic void Dispose() => Console.WriteLine($\"Disposing service: {Id}\");\n\npublic void Reset() => Console.WriteLine($\"Resetting service: {Id}\"); }\n\n```\n\nIn addition, I've added some basic logs to the `Reset()` and `Dispose()` methods so we can more easily track what's going on.\n\nTo test it out, I created a small console app. The app creates a `ServiceCollection` , builds an `IServiceProvider` and then generates a bunch of scopes in parallel. For each scope, it retrieves a `TestService` instance, and print its `Id` . It then disposes all the scopes. We then run the same sequence again:\n\n```csharp var collection = new ServiceCollection(); collection.AddScopedPooling<TestService>(); var services = collection.BuildServiceProvider();\n\nConsole.WriteLine(\"Generating scopes A\") GenerateScopes(services); Console.WriteLine() Console.WriteLine(\"Generating scopes B\") GenerateScopes(services);\n\nstatic void GenerateScopes(IServiceProvider services) { var count = 5; List<IServiceScope> scopes = new(count);\n\n// Simulate 5 parallel requests for (int i = 0; i < count; i++) { // Create a scope, but don't dispose it yet var scope = services.CreateScope(); scopes.Add(scope); // Retrieve an instance of the pooled service var service = scope.ServiceProvider.GetRequiredService<IPooledService<TestService>>().Value; Console.WriteLine($\"Received service: {service.Id}\"); }\n\nforeach (var scope in scopes) { scope.Dispose(); } }\n\n```\n\nWhen we run this code, we get the following sequence:\n\n```bash Generating scopes A Received value: 1 Received value: 2 Received value: 3 Received value: 4 Received value: 5 Resetting service: 1 Resetting service: 2 Resetting service: 3 Disposing service: 4 Disposing service: 5\n\nGenerating scopes B Received value: 1 Received value: 2 Received value: 3 Received value: 6 Received value: 7 Resetting service: 1 Resetting service: 2 Resetting service: 3 Disposing service: 6 Disposing service: 7\n\n```\n\nBy looking at the Ids printed, we can see this works as expected:\n\n- 5 new instances are created to satisfy the 5 parallel scopes.\n- When the scopes are disposed, the maximum 3 instances are reset and stored in the pool. The remaining two services are disposed as they can't be pooled.\n- When the sequence is run again, the first 3 requests use pooled instances. The remaining two instances must be created, giving Ids `6`\nand `7` .\n- When the scopes are disposed, again the 3 instances are pooled, and the remaining 2 are disposed.\n\nSo it seems the implementation is working as expected, but I think it's worth thinking about the limitations and considering whether you *should* use something like this.\n\n## Limitations in the pooled lifetime implementation\n\nThe inspiration for the pooling lifetime was EF Core's pooling of `DbContext` , but the above implementation is fundamentally a bit different. The `DbContext` was designed to \"know\" about pooling, and its internal implementation has knowledge of `DbContextLease` which tracks the origin of `DbContext` instances etc. That stands in contrast to the above implementation in which the implementation class doesn't need to know about the pooling details (other than providing a `Reset()` implementation).\n\nThe net result of the `DbContext` implementation is that the *usage* of `DbContext` is identical, whether or not you use pooling. That again contrasts with the implementation in this post, in which you must use the `IPooledService<T>` intermediate abstraction.\n\nAnother thing to consider in the above implementation is that your pooled services *can't* depend on scoped services, even though the services behave somewhat like scoped services themselves. That's because the instances \"live\" longer than a single service scope, so the only lifetime that really makes sense for dependencies is singleton, or possibly transient.\n\nYet another aspect to consider is that the pool is very simplistic. It's first-come first-served in both renting and return. Once the items are in the pool, they're there to stay until they rented again. You *could* improve all that of course, but as you make things more complicated, you risk removing the benefits that pooling could bring.\n\n## Is pooling actually useful?\n\nThe original inspiration for the pooling lifetime was EF Core's `DbContext` pooling, for which a [single-threaded benchmark](https://github.com/dotnet/EntityFramework.Docs/tree/main/samples/core/Benchmarks/ContextPooling.cs) shows that pooling can improve performance and reduce allocation:\n\n| Method | NumBlogs | Mean | Error | StdDev | Gen 0 | Gen 1 | Gen 2 | Allocated | | --- | --- | --- | --- | --- | --- | --- | --- | --- | | WithoutContextPooling | 1 | 701.6 us | 26.62 us | 78.48 us | 11.7188 | - | - | 50.38 KB | | WithContextPooling | 1 | 350.1 us | 6.80 us | 14.64 us | 0.9766 | - | - | 4.63 KB |\n\nHowever, just because it is beneficial overall for EF Core, doesn't *necessarily* mean it will always be beneficial. This is explicitly called out by Microsoft in [a blog post discussing pooling of `ValueTask` instances](https://devblogs.microsoft.com/dotnet/async-valuetask-pooling-in-net-5/), back in .NET 5\n\n>\n> In employing such a pool, the developer is betting that they can implement a custom allocator (which is really what a pool is) that’s better than the general-purpose GC allocator. Beating the GC is not trivial. But, a developer might be able to, given knowledge they have of their specific scenario.\n> >\n\nMemory allocation in .NET is very efficient; the runtime is *fast* at allocating memory and is even quick at cleaning up small objects. So although pooling means the allocator generally doesn't need to run as much, that's not really where you're getting performance improvements.\n\nOne possible source of performance improvements from pooling can come when the objects being allocated are large. Large objects are generally more expensive for the GC, because the more memory allocated, the more often the GC has to run, and the more work it has to do (to zero out the memory etc).\n\nPooling can also provide an advantage if constructing the objects is expensive. This could be because the constructor itself does a bunch of work. It could also be because the DI container doesn't need to calculate and reconstruct the full dependency graph for the object every time it's requested. Or it could be because you need to use a limited OS resource.\n\nHowever, there are interesting problems to think about here, which *could* undermine any garbage collection improvements you might expect to see from pooling.\n\nFirst of all, if the `Reset()` method has to do more work than the GC would in collecting it, then you've immediately lost any advantage you could expect to get from pooling. But there's an even more subtle issue.\n\nThe .NET GC is a generational garbage collector. Newly allocated objects are placed in Gen 0, and can typically be quickly cleaned up. If a given object survives a garbage collection because it is still in use, it is promoted to Gen 1. The longest living objects are eventually promoted to Gen 2.\n\nIn general, the higher the GC generation, the more expensive it is to clean up. Ideally the GC tries to scan all the Gen 0 objects to see if they're still alive. This works well because generally Gen 0 objects reference *other* Gen 0 objects. Where things get tricky is if a Gen **2** object has a reference to a Gen 0 object. Then suddenly the GC needs to check the Gen 2 objects to find out if that Gen 0 object can be collected. And that's a *lot* more expensive.\n\nAnd what does pooling do? It makes objects live longer, so they end up in Gen 2. If those objects hold references to short-lived objects…then suddenly you've made GCs *much* more expensive.😬\n\n>\n> These issues (and others) are discussed by Stephen Toub with Scott Hanselman in [the Deep .NET video on ArrayPool](https://learn.microsoft.com/en-us/shows/on-dotnet/lets-build-our-own-arraypool-deep-dotnet-with-stephen-scott#time=39m51s).\n> >\n\nSo in conclusion: should you use this? Probably not, but I enjoyed exploring it 😀\n\n## Summary\n\nThis post followed on from [my previous post](/going-beyond-singleton-scoped-and-transient-lifetimes/), in which I discussed some theoretical/experimental dependency-injection lifetimes, based on the discussion in an episode of [The Breakpoint Show](https://www.breakpoint.show/podcast/episode-036-episode-of-a-lifetime/). In this post I presented a possible implementation of a \"pooled\" lifetime, which could be used with arbitrary services. The implementation has a bunch of limitations that I dig into, and use it as an excuse to discuss whether pooling of generic objects makes sense or not.\n\n## Tags\n\nAndrew Lock | .Net Escapades\n\n![](/assets/img/icons/apple/apple-touch-icon-180x180.png) Want an email when there's new posts?\n\nStay up to the date with the latest posts!\n\nOops! Check your details and try again.\n\nThanks! Check your email for confirmation.",
  "PubDate": "2025-04-29T09:00:00+00:00"
}
