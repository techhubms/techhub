{
  "Tags": [
    "Game Development"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Andrew Lock | .NET Escapades",
  "ProcessedDate": "2025-08-05 14:29:47",
  "FeedUrl": "https://andrewlock.net/rss.xml",
  "Title": "Creating your first sample game with MonoGame",
  "Description": "In this post I provide an introduction to MonoGame, looking at it's history, the requirements for building with MonoGame, and finally a first sample app.",
  "Link": "https://andrewlock.net/creating-your-first-sample-game-with-monogame/",
  "FeedName": "Andrew Lock's Blog",
  "Author": "Andrew Lock",
  "EnhancedContent": "In this post I provide an introduction to the [MonoGame](https://monogame.net/) framework. I start by looking at the history of MonoGame and the XNA framework and then show how to get started with MonoGame. Finally we take a look at a default sample app. In my next post I will show how I used MonoGame to port a Microsoft XNA game from 2009 to run on .NET 8 in just a few hours.\n\n## Background: A brief history of Microsoft XNA and MonoGame\n\nMicrosoft's XNA framework was first announced back in 2004 (and first released in preview in 2006) as a set of tools for building video games that would run on Windows and Xbox 360 (and later, Windows phone). The Microsoft XNA framework was originally based on .NET Framework 2.0 on Windows and [.NET Compact Framework](https://en.wikipedia.org/wiki/.NET_Compact_Framework) on Xbox 360, with this later being updated to support .NET Framework 3.5.\n\n![The XNA logo](/content/images/2025/Microsoft_XNA_logo.svg)\n\nThe XNA framework was meant to provide an easy way of writing games that focused on the content, rather than having to think about all the minutia that would change between platforms. It had a big focus on indie games, where gameplay is the key attraction, rather than the focus being the highest performance or the best graphics. XNA didn't provide a full game engine, instead providing lower-level abstractions, as well as a collection of tools for building content-pipelines and such.\n\nShortly after the XNA framework was released and was heavily promoted by Microsoft, a project called [Mono.XNA](https://web.archive.org/web/20120620235417/http://www.monoxna.org/node/4) was created. Much as [Mono](https://en.wikipedia.org/wiki/Mono_%28software%29) was intended as an open-source cross-platform version of .NET Framework, so Mono.XNA was conceived as an open-source cross-platform version of Microsoft XNA, enabling users to build games that would run on Windows, Mac, and Linux, using OpenGL for rendering. At around the same time, Bill Reiss started a project called [SilverSprite](https://web.archive.org/web/20090317075046/http://silversprite.codeplex.com:80/), with the goal of running XNA games in the browser, using Silverlight 2.0, and later 3.0.\n\nIn 2009 [José Antonio Leal de Farias](https://github.com/jalf), [started an open-source project](https://monogame.net/presskit/#history) called [XNA.Touch](https://web.archive.org/web/20140225023450/https://monogame.codeplex.com/releases/view/36738), with the goal of porting simple 2D XNA games to mobile. XNA.Touch used code primarily from SilverSprite and some parts from Mono.XNA to create a framework that enabled running XNA games on the iPhone. This culminated in 2010 with multiple games being released to the Apple App Store.\n\nIn 2011, XNA.Touch was renamed to [MonoGame](https://monogame.net/). MonoGame added support for Android, Mac, Linux, Windows (using OpenGL) in the same year; they added support for DirectX 11, Windows 8, and Windows 8 Phone in 2012; and then in 2013 they added support for the PlayStation 4. Today, MonoGame even supports PlayStation 5 and Nintendo Switch.\n\n![](/content/images/2025/mono_arch.png) The architecture of the various MonoGame options, from [MonoGame](https://monogame.net/). Today, MonoGame implements the Microsoft XNA 4.0 API. Just as for XNA, MonoGame provides the *building blocks* to build your own engine and tools, but it isn't quite an engine itself. It also provides a bunch of tools for working with content (similar to the tools XNA provided).\n\n## Getting started with MonoGame\n\n[Getting started with MonoGame](https://docs.monogame.net/articles/getting_started/index.html) is incredibly simple if you're already a .NET developer. There are basically only two steps:\n\n1. Install the .NET 8 SDK (or newer)\n2. Install the MonoGame templates\n\nI obviously already had the .NET 9 SDK installed, so all that remained was to install the MonoGame templates with:\n\n```bash dotnet new install MonoGame.Templates.CSharp\n\n```\n\nAfter installing the templates you have a bunch of templates available:\n\n```txt The following template packages will be installed: MonoGame.Templates.CSharp\n\nSuccess: MonoGame.Templates.CSharp::3.8.3 installed the following templates: Template Name Short Name Language Tags --------------------------- ----------------- -------- ------------------------------------------------------------- MonoGame 2D StartKit mg2dstartkit [C#] MonoGame/Games/Mobile/Android/iOS/Desktop/Windows/Linux/macOS MonoGame Android Application mgandroid [C#] MonoGame/Games/Mobile/Android MonoGame Blank 2D StartKit mgblank2dstartkit [C#] MonoGame/Games/Mobile/Android/iOS/Desktop/Windows/Linux/macOS MonoGame Content Pipeline Extension mgpipeline [C#] MonoGame/Games/Extensions MonoGame Cross-Platform Desktop Application mgdesktopgl [C#] MonoGame/Games/Desktop/Windows/Linux/macOS MonoGame Game Library mglib [C#] MonoGame/Games/Library MonoGame iOS Application mgios [C#] MonoGame/Games/Mobile/iOS MonoGame Shared Library Project mgshared [C#] MonoGame/Games/Library MonoGame Windows Desktop Application mgwindowsdx [C#] MonoGame/Games/Desktop/Windows/Linux/macOS\n\n```\n\nMonoGame supports all the IDEs you would expect (Visual Studio, VS Code, and [Rider](https://docs.monogame.net/articles/getting_started/2_choosing_your_ide_rider.html)). I was just going to use the OpenGL-based application, so as far as I could tell, I didn't need to install any additional components. If you're using one of the other templates, then you may need to install additional components using Visual Studio or the dotnet CLI, [as described in the documentation](https://docs.monogame.net/articles/getting_started/2_choosing_your_ide_visual_studio.html).\n\nWith the templates installed, I set about creating my first MonoGame application.\n\n## Creating my first MonoGame application\n\nBefore creating the MonoGame project, I created a solution to hold the project. Just to try it out, I decided to use [the new slnx format](https://devblogs.microsoft.com/dotnet/introducing-slnx-support-dotnet-cli/) seeing as [Rider supports it](https://blog.jetbrains.com/dotnet/2024/10/04/support-for-slnx-solution-files/).\n\nAs far as I can tell, you can't create a slnx file *directly* using the .NET CLI, so I created a new sln file, and converted it instead:\n\n```bash\n# Create the new sln file\ndotnet new sln\n# Convert the sln file to a slnx file\ndotnet sln migrate\n# Delete the original sln file\nrm *.sln\n\n```\n\nNext I created a \"MonoGame Cross-Platform Desktop Application\" using the `mgdesktopgl` template:\n\nCreate the project\n\n```powershell\n# Create the template in a \"MyGame\" subfolder\ndotnet new mgdesktopgl --output MyGame\n# Add the new project to the template\ndotnet sln add ./MyGame/\n\n```\n\nWe now have our sample application. Before testing it out, let's take a look at some of the files it includes.\n\n## Exploring the default MonoGame template\n\nWe'll start by looking at the project template. As you can see below, the project is a .NET 8 app, which adds a couple of embedded resources for the app icon. It references two NuGet packages:\n\n- `MonoGame.Framework.DesktopGL`\n—This is the \"main\" MonoGame NuGet package for the sample that includes the required implementation for creating a cross-platform desktop application based on OpenGL. There are other packages for other MonoGame targets.\n- `MonoGame.Content.Builder.Task`\n—[This small package](https://nuget.info/packages/MonoGame.Content.Builder.Task) contains MSBuild properties and tasks for running MonoGame's content pipeline.\n\n```xml <Project Sdk=\"Microsoft.NET.Sdk\"> <PropertyGroup> <OutputType>WinExe</OutputType> <TargetFramework>net8.0</TargetFramework> <RollForward>Major</RollForward> <PublishReadyToRun>false</PublishReadyToRun> <TieredCompilation>false</TieredCompilation> </PropertyGroup>\n\n<PropertyGroup> <ApplicationManifest>app.manifest</ApplicationManifest> <ApplicationIcon>Icon.ico</ApplicationIcon> </PropertyGroup>\n\n<ItemGroup> <None Remove=\"Icon.ico\" /> <None Remove=\"Icon.bmp\" /> </ItemGroup>\n\n<ItemGroup> <EmbeddedResource Include=\"Icon.ico\"> <LogicalName>Icon.ico</LogicalName> </EmbeddedResource> <EmbeddedResource Include=\"Icon.bmp\"> <LogicalName>Icon.bmp</LogicalName> </EmbeddedResource> </ItemGroup>\n\n<ItemGroup> <PackageReference Include=\"MonoGame.Framework.DesktopGL\" Version=\"3.8.*\" /> <PackageReference Include=\"MonoGame.Content.Builder.Task\" Version=\"3.8.*\" /> </ItemGroup>\n\n<Target Name=\"RestoreDotnetTools\" BeforeTargets=\"Restore\"> <Message Text=\"Restoring dotnet tools\" Importance=\"High\" /> <Exec Command=\"dotnet tool restore\" /> </Target> </Project>\n\n```\n\nAnother interesting point is the additional MSBuild target `RestoreDotnetTools` which runs `dotnet tool restore` just before restoring NuGet packages. This restores the various `mgcb` dotnet tools that are included as part of the manifest in *.config/dotnet-tools.json*. These are the MonoGame Content Builder (MGCB) tools which provide graphical and command-line tools for editing and optimising your content for processing:\n\n```json { \"version\": 1, \"isRoot\": true, \"tools\": { \"dotnet-mgcb\": { \"version\": \"3.8.3\", \"commands\": [ \"mgcb\" ] }, \"dotnet-mgcb-editor\": { \"version\": \"3.8.3\", \"commands\": [ \"mgcb-editor\" ] }, \"dotnet-mgcb-editor-linux\": { \"version\": \"3.8.3\", \"commands\": [ \"mgcb-editor-linux\" ] }, \"dotnet-mgcb-editor-windows\": { \"version\": \"3.8.3\", \"commands\": [ \"mgcb-editor-windows\" ] }, \"dotnet-mgcb-editor-mac\": { \"version\": \"3.8.3\", \"commands\": [ \"mgcb-editor-mac\" ] } } }\n\n```\n\nThe manifest includes 5 different tools:\n\n- `dotnet-mgcb`\n—[The MonoGame Content Builder (MGCB) command line tool](https://www.nuget.org/packages/dotnet-mgcb) is used for optimizing content for runtime use.\n- `dotnet-mgcb-editor`\n—[The MonoGame Framework Content Builder Editor (MGCB-Editor)](https://www.nuget.org/packages/dotnet-mgcb-editor) is a graphical tool used for editing your content projects ready for processing. There are Windows/Linux/Mac specific versions of the tool, but as far as I can tell, you can just run the generic tool.\n\nFinally, we come to the code. The *Program.cs* file leverages all the modern .NET goodness to be just two lines:\n\n```csharp using var game = new MyGame.Game1(); game.Run();\n\n```\n\nFinally, we can see the `Game1` class itself. This very simple example includes the basics—creating a `GraphicsDeviceManager` and a `SpriteBatch` —but mostly highlights the different stages in the XNA/MonoGame game loop that you should override to create your own game.\n\n```csharp using Microsoft.Xna.Framework; using Microsoft.Xna.Framework.Graphics; using Microsoft.Xna.Framework.Input;\n\nnamespace MyGame;\n\npublic class Game1 : Game { private GraphicsDeviceManager _graphics; private SpriteBatch _spriteBatch;\n\npublic Game1() { _graphics = new GraphicsDeviceManager(this); Content.RootDirectory = \"Content\"; IsMouseVisible = true; }\n\nprotected override void Initialize() { // TODO: Add your initialization logic here\n\nbase.Initialize(); }\n\nprotected override void LoadContent() { _spriteBatch = new SpriteBatch(GraphicsDevice);\n\n// TODO: use this.Content to load your game content here }\n\nprotected override void Update(GameTime gameTime) { if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.Escape)) Exit();\n\n// TODO: Add your update logic here\n\nbase.Update(gameTime); }\n\nprotected override void Draw(GameTime gameTime) { GraphicsDevice.Clear(Color.CornflowerBlue);\n\n// TODO: Add your drawing code here\n\nbase.Draw(gameTime); } }\n\n```\n\nAside from some basic setup, the sample game essentially contains just two behaviours:\n\n- Listen for the Escape key on the keyboard, or the Back button on a keypad, and exit the game if they're pressed.\n- Paint the colour Cornflower Blue as the game background.\n\nAnd that's essentially all there is to it. You can run the template using `dotnet run` , or by pushing F5 in your IDE. The resulting \"game\" just shows a blue screen until you hit exit:\n\n![The default MonoGame sample 'game'](/content/images/2025/monogame_00.png)\n\nAnd that's all there is to it. In the next post I'll show how I started from this sample to port a Microsoft XNA game from 2009 to run on .NET 8 in just a few hours.\n\n## Summary\n\nIn this post I described a brief history of the Microsoft XNA framework and the creation of MonoGame as an open-source implementation of the Microsoft XNA 4.0 API. I then discussed the basic requirements for building a MonoGame Windows application: the .NET 8 SDK and the .NET CLI templates. Finally, we took a tour of the sample app to see the relevant NuGet packages, tools, and code that the sample uses. In the next post I'll show how I started from this sample to port a Microsoft XNA game to MonoGame in just a few hours.\n\n## Tags\n\nAndrew Lock | .Net Escapades\n\n![](/assets/img/icons/apple/apple-touch-icon-180x180.png) Want an email when there's new posts?\n\nStay up to the date with the latest posts!\n\nOops! Check your details and try again.\n\nThanks! Check your email for confirmation.",
  "PubDate": "2025-06-03T09:00:00+00:00"
}
