{
  "Tags": [
    ".NET 10",
    "C#"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Andrew Lock | .NET Escapades",
  "ProcessedDate": "2025-08-05 14:29:47",
  "FeedUrl": "https://andrewlock.net/rss.xml",
  "Title": "C# 14 extension members; AKA extension everything: Exploring the .NET 10 preview - Part 3",
  "Description": "In this post I look at the C#14 extension members feature. I show how to convert extension methods to the new syntax and how to add new types of extension.",
  "Link": "https://andrewlock.net/exploring-dotnet-10-preview-features-3-csharp-14-extensions-members/",
  "FeedName": "Andrew Lock's Blog",
  "Author": "Andrew Lock",
  "EnhancedContent": "In this post I take a short look at the C#14 *extension members* feature which is available in the latest .NET 10 previews. In this post I describe what the feature is, how it extends the existing capabilities of extension methods, and how to create extension members in .NET 10. Finally, I show how I added support for the feature in the latest version of my [NetEscapades.EnumGenerators](https://github.com/andrewlock/NetEscapades.EnumGenerators) NuGet package.\n\n>\n> This post was written using the features available in .NET 10 preview 5. Many things may change between now and the final release of .NET 10.\n> >\n\n## Background: Extension methods\n\nExtension methods were introduced *way* back in 2007 with .NET Framework 3.5 as a supporting feature for [LINQ](https://learn.microsoft.com/en-us/dotnet/csharp/linq/). They provided a way to emulate adding an instance method to a type, by writing a `static` method. For example, you could add an extension method to `IEnumerable` called `IsEmpty()` :\n\n```csharp public static class EnumerableExtensions { public static bool IsEmpty<T>(this IEnumerable<T> target) => !target.Any(); }\n\n```\n\nThe extension method is pretty much just an \"ordinary\" extension method. You can call it the same way you would call any other `static` method in a class if you like:\n\n```csharp var values = Enumerable.Empty<string>(); if (EnumerableExtensions.IsEmpty(values)) // Calling the extension method using the type { Console.WriteLine(\"Enumerable is empty\"); }\n\n```\n\nHowever, the `this` modifier on the first argument indicates that the method can *also* be called as an instance method, on the *receiver* type, `IEnumerable<T>` . This is the typical way to call extension methods and results in terser code overall:\n\n```csharp var values = Enumerable.Empty<string>(); if (values.IsEmpty()) // Invoking as an extension method { Console.WriteLine(\"Enumerable is empty\"); }\n\n```\n\nThe instance method approach is generally used everywhere possible, and the static invocation is only used where disambiguation is required due to naming clashes. Today, extension methods are used in a diverse range of scenarios and use many different patterns, but you will find them all over most code bases; including in the .NET runtime itself.\n\n## Extension members and extension everything\n\nShortly after extension methods were introduced, way back in C# 3.0, there were requests to allow additional extension members. \"Instance\" extension methods were great, but why not extension properties? Why not *static* extension methods?\n\nWell apparently, for C# 4.0, an attempt to design the \"extension everything\" feature was explored, but ultimately failed. Periodically [new efforts to try to reimagine extension everything](https://github.com/dotnet/csharplang/blob/90ed288e3c4871b1d19862a418bced7dafa12721/meetings/2016/LDM-2016-05-10.md) would flare up, but ultimately they came to nothing. Until now.ðŸŽ‰ In C# 14.0, finally, extension everything is essentially here, under the name *extension members*.\n\nBefore we look at how to define extension members, a word of warning. The extension members feature introduces some new syntax, which can often be controversial. You may well think it's ugly, and to be honest, I probably wouldn't disagree with you. Ultimately, the C# design team opted to optimize the experience of *using* the extension members over brevity of the syntax used to *author* extension members, which I think makes sense.\n\n>\n> The [blog post announcing extension members in .NET 10 preview 3](https://devblogs.microsoft.com/dotnet/csharp-exploring-extension-members/) is great and covers a lot of the design decisions about the current feature, so I encourage you to check it out after this post, if you haven't already!\n> >\n\nWe'll start by looking at how to convert an existing extension method to use the new extension member syntax as a way of introducing the changes.\n\n### Converting an extension method to an extension member\n\nBefore I show some code, it's important to know that you *don't* have to convert your extension methods over to the new syntax; the new syntax is entirely optional. Your existing extension methods will continue to work with the old `this` syntax without any changes:\n\n```csharp public static class EnumerableExtensions { // The \"old\" extension member syntax still works in .NET 10 and C#14 public static bool IsEmpty<T>(this IEnumerable<T> target) => !target.Any(); }\n\n```\n\nIf you wish to explore the new syntax, then you need to make sure you're using C#14 in your project. While .NET 10 is still in preview, that means you need to set the `<LangVersion>` property to `preview` , *even if you're using the .NET 10 SDK and targeting* `net10.0` :\n\n```xml <Project Sdk=\"Microsoft.NET.Sdk\">\n\n<PropertyGroup> <OutputType>Exe</OutputType> <!-- ðŸ‘‡ You can set any target framework as long as you're using the .NET 10 SDK...--> <TargetFramework>net10.0</TargetFramework> <ImplicitUsings>enable</ImplicitUsings> <Nullable>enable</Nullable> <!-- ... but you must set this ðŸ‘‡--> <LangVersion>preview</LangVersion> </PropertyGroup>\n\n</Project>\n\n```\n\nIf you wish to convert your method to the new extension member syntax, you need to do four things:\n\n1. Add an `extension(){ }`\nblock around your method.\n2. Move the receiver parameter, `IEnumerable<T> target`\nin this case, as a \"parameter\" to the `extension` block.\n3. Move the generic type arguments, `T`\nin this case, from the method to the `extension` block.\n4. Remove the `static`\nmodifier from the method to make it an instance method.\n\n>\n> Note that not *all* extension methods can be converted to the new syntax, as described [in this post](https://devblogs.microsoft.com/dotnet/csharp-exploring-extension-members/).\n> >\n\nPutting that all together, the new extension member implementation looks like the following:\n\n```csharp public static class EnumerableExtensions { extension<T>(IEnumerable<T> target) { public bool IsEmpty() => !target.Any(); } }\n\n```\n\nwhich makes all the changes I described above:\n\n```csharp public static class EnumerableExtensions { // ðŸ‘‡ extension block with type parameters and receiver parameter extension<T>(IEnumerable<T> target) { // ðŸ‘‡ no static modifier public bool IsEmpty() => !target.Any(); // ðŸ‘† 'this' receiver parameter removed\n\n} }\n\n```\n\nThe `extension` block is the key to the new syntax, and is likely where developer \"feelings\" are going to come out i.e. how much do you dislike this new unusual syntax and the extra nesting it requires ðŸ˜…. Of course, there's very good reason for this syntax, and we'll explore that more in the next section, but there's some aspects which are clearly quite nice about it. For example, a nice side-effect is that the instance extension method now looks more like it does when it's *invoked*; i.e. its a zero-parameter instance method instead of a one parameter static method.\n\nOne downside of the very new syntax, is that it confuses any tooling that isn't aware of it ðŸ˜… I haven't installed [the Rider EAP](https://www.jetbrains.com/rider/nextversion/) yet to see if it handles this syntax, but I don't think it does yet. Visual Studio preview does support the syntax however, and even includes a code fix to automatically convert to the new syntax if you wish:\n\n![Visual Studio provides a code fix to convert to extension members](/content/images/2025/extension_everything.png)\n\nThere's no particularly compelling reason to convert extension methods to the extension member syntax if you're not doing anything else. It's purely a syntactic difference; they both compile to the exact same thing. The more interesting case is if you want to use other *types* of extension member.\n\n### Adding other extension members\n\nWe've seen the new syntax, but we haven't seen any new *features* yet. However, the extension members feature that shipped in .NET 10 preview 3 adds support for three new *types* of extension member\n\n- Static extension methods\n- Static extension properties\n- Instance extension properties\n\nAdditionally, extension operators have already been implemented and should be available in .NET 10 preview 7.\n\nI'll start with static extension methods, because they're the most interesting to me. *Implementation* wise, the syntax looks very similar to the instance extension method syntax we've already seen, with two minor differences:\n\n1. The method should be `static`\n2. You don't need to specify a name for the receiver parameter (and even if you add it, it can't be accessed from the `static`\nmethod you define)\n\nLet's look at an example. The following creates a static method on `string` called `HasValue()` which is the inverse of `string.IsNullOrEmpty`\n\n```csharp public static class StringExtensions { // ðŸ‘‡ Extension block specifies receiver type but doesn't specify a parameter name extension(string) { // ðŸ‘‡ static extension method public static bool HasValue(string value) => !string.IsNullOrEmpty(value); } }\n\n```\n\nThe following shows an example of its use:\n\n```csharp string someValue = \"something\"; if (string.HasValue(someValue)) { Console.WriteLine(\"The value was: \" + someValue); }\n\n```\n\nThe revelation here, and the difference from instance extension methods, is that the extension method is added to the `string` *type*, not the `someValue` *variable*.\n\nNext, we'll look at an extension property. The following adds an `IsAscii` instance extension property to string:\n\n```csharp public static class StringExtensions { // ðŸ‘‡ Extension block specifies receiver type and target parameter extension(string target) { // ðŸ‘‡ You can just write the property like you'd write a \"normal\" property public bool IsAscii => target.All(x => char.IsAscii(x)); // ðŸ‘† You can access the receive paramter because it's an instance extension } }\n\n```\n\nYou can then use the property on `string` instances, just as you would for an instance extension method\n\n```csharp string someValue = \"something\"; bool isAscii = someValue.IsAscii; // ðŸ‘ˆ Access the instance extension property on a variable\n\n```\n\nDefining a static extension property is very similar, so for the sake of brevity I'll leave that for now. As a brief bonus treat, here's what a static operator definition might look like:\n\n```csharp static class PathExtensions { extension(string) { public static string operator /(string left, string right) => Path.Combine(left, right); } }\n\n```\n\nThis could then be used something like the following:\n\n```csharp var fullPath = \"part1\" / \"part2\" / \"test.txt\"; // \"part1/part2/test.txt\"\n\n```\n\nSo hold on for .NET 10 preview 7 for that!\n\n### Disambiguating extension members\n\nBefore we move on, it's worth addressing the disambiguation story. Sometimes you may need to invoke the extension methods directly, typically due to clashes between multiple extension methods with the same signature. This has always been the way to handle the ambiguity for extension methods, and it's essentially the same for other extension members.\n\n- For instance extension methods, you invoke statically and pass the instance as the first parameter.\n- For static extension methods, you invoke as a simple zero parameter `static`\nmethod.\n- For instance extension properties, you call the `get_`\nprefixed method, and pass the instance as the first parameter.\n- For static extension methods, you call the `get_`\nprefixed method.\n\nFor example, for the extensions shown so far we might invoke them directly like this\n\n```csharp bool hasValue = EnumerableExtensions.IsEmpty([]); // An instance extension method bool hasValue = StringExtensions.HasValue(\"something\"); // A static extension method bool isAscii = StringExtensions.get_IsAscii(\"something\"); // An instance extension property\n\n```\n\nThe `get_` prefix for the property might seem strange given normal C# naming, but it's actually how properties are *normally* implemented behind the scenes in C#. Indeed if you looks at the assembly metadata in a .NET dll using a tool such as [dotPeek](https://www.jetbrains.com/decompiler/), then you'll see that properties really *are* implemented as methods with `get_` and `set_` prefixes:\n\n![Looking at the metadata in a dll](/content/images/2025/extension_everything_2.png)\n\nThe screenshot above shows that once compiled, the `StringExtensions.IsAscii` extension property has a very similar implementation to \"normal\" properties like this:\n\n```csharp public class SomeClass { public string Value { get; set; } }\n\n```\n\nThat pretty much covers everything for this post, so I'll finish with a quick update on my [NetEscapades.EnumGenerators](https://github.com/andrewlock/NetEscapades.EnumGenerators) NuGet package.\n\n## A case study: NetEscapades.EnumGenerators\n\nThe [NetEscapades.EnumGenerators](https://github.com/andrewlock/NetEscapades.EnumGenerators) NuGet package lets you generate extension methods and helpers for enums, to allow fast \"reflection\". You use it by adding the `[EnumExtensions]` attribute to an enum:\n\n```csharp [EnumExtensions] public enum MyColours { Red, Green, Blue, }\n\n```\n\nand by default the package generates a class called `MyColoursExtensions` similar to the following:\n\n```csharp public static partial class MyColoursExtensions { public static string ToStringFast(this global::MyColours value) { }\n\npublic static int AsUnderlyingType(this global::MyColours value) { }\n\npublic static bool IsDefined(global::MyColours value) { }\n\npublic static global::MyColours Parse(string? name) { }\n\n// ... }\n\n```\n\nI've only shown a couple of the methods above but as you can see, there's basically two different types of method:\n\n- Extension methods like `ToStringFast()`\nand `AsUnderlyingType()`\n- Static methods like `IsDefined()`\nand `Parse()`\n\nUntil now, you always had to call the static methods using the `MyColoursExtensions` type, e.g.\n\n```csharp var colour = MyColoursExtensions.Parse(\"Red\");\n\n```\n\nBut if you're targeting C#14, the package simply adds an extension block around these members:\n\n```csharp public static partial class MyColoursExtensions { public static string ToStringFast(this global::MyColours value) { }\n\npublic static int AsUnderlyingType(this global::MyColours value) { }\n\n// ðŸ‘‡ Added if you target C#14 extension(global::MyColours) { public static bool IsDefined(global::MyColours value) { }\n\npublic static global::MyColours Parse(string? name) { }\n\n// ... } }\n\n```\n\nand now those static extension members are available on the `MyColours` enum type itself:\n\n```csharp var colour = MyColours.Parse(\"Red\");\n\n```\n\nwhich just feels much nicer to me! Anyway, the fact that it was frankly a trivial change to convert these static methods into extension methods was a real bonus, and definitely gives me renewed confidence that even if the new syntax looks a bit janky at first glance, it's clearly well thought out.\n\n## Summary\n\nIn this post I described the new extension members feature coming in C#14 and .NET 10. I started by providing some background on extension methods in case you haven't seem then before, and then showed how you could convert these to use the new extension member syntax. I then showed how you could add the new extension member types: static extension methods, static and instance extension properties, and extension operators (coming in .NET 10 preview 7). Finally, I described how adding support for C#14 in the latest version of the [NetEscapades.EnumGenerators](https://github.com/andrewlock/NetEscapades.EnumGenerators) NuGet package makes for a better experience using the extensions.\n\n## Tags\n\nAndrew Lock | .Net Escapades\n\n![](/assets/img/icons/apple/apple-touch-icon-180x180.png) Want an email when there's new posts?\n\nStay up to the date with the latest posts!\n\nOops! Check your details and try again.\n\nThanks! Check your email for confirmation.",
  "PubDate": "2025-07-15T10:00:00+00:00"
}
