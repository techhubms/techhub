{
  "FeedName": "Andrew Lock's Blog",
  "FeedUrl": "https://andrewlock.net/rss.xml",
  "ProcessedDate": "2025-09-23 11:10:04",
  "FeedLevelAuthor": "Andrew Lock | .NET Escapades",
  "Tags": [
    ".NET 10",
    ".NET Core",
    "AOT",
    "NuGet"
  ],
  "OutputDir": "_posts",
  "EnhancedContent": "In this post I describe a small .NET tool that I built to force a Windows PC to go to sleep after a timer expires. I describe the Win32 API I used to send my laptop to sleep, and how I expanded the proof of concept to be a Native AOT-compiled .NET tool that you can [view on GitHub](https://github.com/andrewlock/sleep-pc) or install [from Nuget](https://www.nuget.org/packages/sleep-pc).\n\n## Background: go to sleep!\n\nGetting a laptop to go to sleep seems to be one of those things that's just way harder than it should be. Whether it's a MacBook that decides to wake up and heat my backpack over night, or a Windows laptop that just *won't* go to sleep, I always seem to have issues.\n\nOne weekend, I was wrestling with exactly the latter issue: I just couldn't get my Windows laptop to sleep. *Specifically*, I couldn't get it to sleep when [Windows Media Player Legacy](https://support.microsoft.com/en-us/windows/windows-media-player-legacy-e8f84f54-cd64-865c-2e83-1d8ec121b5b8) finished playing a playlist. As someone that goes to sleep with videos playing in the background, it's *very* annoying…\n\n>\n> Yes, I know it's old. Yes, I use [VLC](https://www.videolan.org/) too. I still prefer the old WMP for some things, namely adding a few videos to a playlist from my library, seeing the last played time etc\n> >\n\nWhat's particularly annoying is that I've tried every troubleshooting approach under the sun. The power plans are correct. I've run and explored `powercfg` . I did it all, man. And eventually I just got bored and wrote a tiny app that *forces* the laptop to sleep after a given time limit has expired.\n\n## Sending a PC to sleep with `SetSuspendState`\n\nThe first version I knocked out in just a few minutes, and it looked something like this:\n\n```csharp using System.Runtime.InteropServices;\n\nvar wait = TimeSpan.FromSeconds(60 * 60); // 1 hour Console.WriteLine(\"Waiting for {wait}\"); Thread.Sleep(wait);\n\nConsole.WriteLine(\"Sleeping!\"); SetSuspendState(false, false, false);\n\n[DllImport(\"PowrProf.dll\", SetLastError = true)] static extern bool SetSuspendState(bool hibernate, bool forceCritical, bool disableWakeEvent);\n\n```\n\nThis tiny program simply sleeps for a hardcoded period of time (1 hour for my purposes) and then makes a P/Invoke call to the [`SetSuspendState` method in `PowrProf.dll`](https://learn.microsoft.com/en-us/windows/win32/api/powrprof/nf-powrprof-setsuspendstate), a Win32 API (i.e. Windows only) which sends the laptop to sleep.\n\n>\n> I set `hibernate=false`\n> here, however it appears that Windows often still hibernates regardless of this value, depending on your system settings. This can apparently happen particularly when Hybrid Sleep is enabled. In my case it does hibernate, which is fine for me, as that's what I *really* wanted anyway.\n> >\n\nAnd that's pretty much all you need to implement the functionality I was after! Of course, I couldn't *quite* leave it at simple as that.\n\n## Adding some pizzazz\n\nGiven this was such a little tool, my first thoughts were:\n\n- Add some proper command-line arg parsing\n- Package it as a Native AOT tool using [the new .NET 10 tools support](/exploring-dotnet-10-preview-features-7-packaging-self-contained-and-native-aot-dotnet-tools-for-nuget/)\n- Jazz up the console somewhat\n- Allow a \"dry run\" option\n\nI first set about adding command-line parsing and help generation as a quick way for testing various options.\n\n### Using ConsoleAppFramework to create console apps\n\nThere's lots of different options for this, for example:\n\n- [System.CommandLine](https://www.nuget.org/packages/System.CommandLine)\n- [Spectre.Console.Cli](https://www.nuget.org/packages/Spectre.Console.Cli)\n- [ConsoleAppFramework](https://www.nuget.org/packages/ConsoleAppFramework)\n\n*ConsoleAppFramework* is a project I haven't seen mentioned very much, but it's one I've used in the past that I've had a good experience with. As per [the project description](https://github.com/Cysharp/ConsoleAppFramework):\n\n>\n> **ConsoleAppFramework** v5 is Zero Dependency, Zero Overhead, Zero Reflection, Zero Allocation, AOT Safe CLI Framework powered by C# Source Generator; achieves exceptionally high performance, fastest start-up time(with NativeAOT) and minimal binary size. Leveraging the latest features of .NET 8 and C# 13 ([IncrementalGenerator](https://github.com/dotnet/roslyn/blob/main/docs/features/incremental-generators.md), [managed function pointer](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers#function-pointers-1), [params arrays and default values lambda expression](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions#input-parameters-of-a-lambda-expression), [`ISpanParsable<T>`](https://learn.microsoft.com/en-us/dotnet/api/system.ispanparsable-1), [`PosixSignalRegistration`](https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.posixsignalregistration), etc.), this library ensures maximum performance while maintaining flexibility and extensibility.\n> >\n\nWhich you know, is all pretty cool😄 From my point of view, what I like the most is the simplicity, but it also ticks a lot of boxes for performance. It does require a modern version of .NET (.NET 8+) but that's fine with me in this case.\n\nAdd the package to your project:\n\n```bash dotnet add package ConsoleAppFramework\n\n```\n\nConverting my little proof of concept to a \"real\" console app, with help text, argument parsing and validation was as simple as this:\n\n```csharp using System.ComponentModel.DataAnnotations; using ConsoleAppFramework; using System.Runtime.InteropServices;\n\nawait ConsoleApp.RunAsync(args, App.Countdown);\n\nstatic partial class App { /// <summary> /// Waits for the provided number of seconds before sending the computer to sleep /// </summary> /// <param name=\"sleepDelaySeconds\">-s|--seconds, The time in seconds before the computer is put to sleep. Defaults to 1 hour</param> /// <param name=\"dryRun\">If true, prints a message instead of sleeping</param> /// <param name=\"ct\">Used to cancel execution</param> /// <returns></returns> public static async Task Countdown( [Range(1, 99 * 60 * 60)]uint sleepDelaySeconds = 60 * 60, bool dryRun = false, CancellationToken ct = default) { var wait = TimeSpan.FromSeconds(sleepDelaySeconds); Console.WriteLine(\"Waiting for {wait}\"); await Task.Delay(wait, ct);\n\nConsole.WriteLine(\"Sleeping!\"); if (!dryRun) { SetSuspendState(false, false, false); } }\n\n[DllImport(\"PowrProf.dll\", SetLastError = true)] static extern bool SetSuspendState(bool hibernate, bool forceCritical, bool disableWakeEvent); }\n\n```\n\nTo add `ConsoleAppFramework` support I just had to:\n\n- Call the source-generated `ConsoleApp.RunAsync()`\nmethod\n- Decorate my target method with XML comments describing the command, the arguments, and validation requirements\n\nThis generates all the help text you would expect:\n\n```bash\n> dotnet run -- --help\nUsage: [options...] [-h|--help] [--version]\n\nWaits for the provided number of seconds before sending the computer to sleep\n\nOptions: -s|--seconds|--sleep-delay-seconds <uint> The time in seconds before the computer is put to sleep. Defaults to 1 hour (Default: 3600) --dry-run If true, prints a message instead of sleeping (Optional)\n\n```\n\nPretty neat!\n\nBeing source generated, you can even F12 the implementation and see exactly what it's doing, but I'm not going to dig into that here. You can see I also added the \"dry run\" option, so that I could easily test without my laptop going to sleep repeatedly!\n\n### Adding Native AOT support\n\nAdding Native AOT support was pretty simple, as ConsoleAppFramework already supports Native AOT, and the app isn't doing much else. I added the `<PublishAot>true</PublishAot>` setting to my project file, and there were no build warnings.\n\nI was somewhat surprised to find that `[DllImport]` wasn't flagged, as I thought you had to use the new `[LibraryImport]` source-generator-based attribute, but apparently that's not always necessary. The [docs still recommend using it](https://learn.microsoft.com/en-us/dotnet/standard/native-interop/best-practices) though, so I switched to the new attribute, specifying all the marshalling value as required:\n\n```csharp [LibraryImport(\"PowrProf.dll\", SetLastError = true)] [return: MarshalAs(UnmanagedType.Bool)] // return is actually BOOL (int) private static partial bool SetSuspendState( [MarshalAs(UnmanagedType.U1)] bool hibernate, [MarshalAs(UnmanagedType.U1)] bool forceCritical, [MarshalAs(UnmanagedType.U1)] bool disableWakeEvent);\n\n```\n\nAfter making this change I tested publishing a Native AOT version of the app using\n\n```bash dotnet publish -r win-x64 -c Release\n\n```\n\nAnd the resulting *sleep-pc.exe* file was 3.3MB—not bad for a .NET app including all the runtime bits it needs! But I wondered if I could push that further…\n\nAfter looking through [the trimming options documentation](https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trimming-options), I found a bunch of knobs and levers to pull and ultimately managed to shave off ~0.3MB. Not a massive additional improvement, and maybe I could have gone smaller, but meh, good enough! I show the final *.csproj* I ended up with in the next section.\n\n>\n> [Michal Strehovský's Sizoscope project](https://github.com/MichalStrehovsky/sizoscope) is a neat way to \"peak inside\" your Native AOT binaries to see where all that space is going, and to give you ideas for things you could remove.\n> >\n\nWith the tool now publishing as Native AOT, I worked on publishing it as a NuGet package.\n\n### Packaging as a Native AOT tool\n\nI've [written](/using-and-authoring-dotnet-tools/) [a lot](/exploring-dotnet-10-preview-features-7-packaging-self-contained-and-native-aot-dotnet-tools-for-nuget/) [recently](/exploring-dotnet-10-preview-features-8-supporting-platform-specific-dotnet-tools-on-old-sdks/) about .NET tools, and particularly the .NET 10 feature for creating Native AOT .NET tools. Somewhat as a proof of concept, I tried applying this to my new *sleep-pc* tool.\n\nI opted for the [\"compromise package\"](/exploring-dotnet-10-preview-features-8-supporting-platform-specific-dotnet-tools-on-old-sdks/#the-best-of-both-worlds-framework-dependent-and-platform-specific-tools-in-the-same-package) approach that I described in my previous post. With this appoach:\n\n- The \"root\" *sleep-pc.nupkg* contains a .NET 8 framework-dependent build of the tool, with a pointer to the platform-specific version of the tool for .NET 10 SDK users.\n- The packaged application has `<RollForward>Major</RollForward>`\nso that it will run on .NET 9 if the user has that installed and no .NET 8 runtime.\n- The platform-specific package contains the Native AOT asset only, which is used when the user has .NET 10+ installed.\n\nI discussed this compromise package style a lot in the last post, so here I just show my final *.csproj* file:\n\n```xml <Project Sdk=\"Microsoft.NET.Sdk\">\n\n<PropertyGroup> <OutputType>Exe</OutputType> <RootNamespace>SleepPc</RootNamespace> <ImplicitUsings>enable</ImplicitUsings> <Nullable>enable</Nullable> <LangVersion>latest</LangVersion> <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n\n<!-- NuGet/Tool settings --> <PackAsTool>true</PackAsTool> <ToolCommandName>sleep-pc</ToolCommandName> <PackageId>sleep-pc</PackageId> <PackageVersion>0.1.0</PackageVersion> <Authors>Andrew Lock</Authors> <Description>A tool for sending your windows laptop to sleep after a given time</Description> <PackageTags>sleep;timer;windows;tool</PackageTags> <PackageLicenseExpression>MIT</PackageLicenseExpression> <RollForward>Major</RollForward> <CopyOutputSymbolsToPublishDirectory>false</CopyOutputSymbolsToPublishDirectory> </PropertyGroup>\n\n<!-- Conditional framework version to support NuGet tool --> <PropertyGroup Condition=\"$(RuntimeIdentifier) != ''\"> <TargetFramework>net10.0</TargetFramework> </PropertyGroup>\n\n<PropertyGroup Condition=\"$(RuntimeIdentifier) == ''\"> <TargetFrameworks>net8.0;net10.0</TargetFrameworks> </PropertyGroup>\n\n<PropertyGroup Condition=\"$(TargetFramework) == 'net10.0'\"> <RuntimeIdentifiers>win-x64</RuntimeIdentifiers> <PublishAot>true</PublishAot>\n\n<!-- Size optimisation bits for Native AOT --> <DebuggerSupport>false</DebuggerSupport> <EventSourceSupport>false</EventSourceSupport> <HttpActivityPropagationSupport>false</HttpActivityPropagationSupport> <MetricsSupport>false</MetricsSupport> <TrimmerRemoveSymbols>true</TrimmerRemoveSymbols> <StripSymbols>true</StripSymbols> <InvariantGlobalization>true</InvariantGlobalization> <IlcDisableReflection>true</IlcDisableReflection> <IlcTrimMetadata>true</IlcTrimMetadata> <IlcOptimizationPreference>Size</IlcOptimizationPreference>\n\n<!-- For analysis by Sizoscope --> <IlcGenerateMstatFile>true</IlcGenerateMstatFile> <IlcGenerateDgmlFile>true</IlcGenerateDgmlFile> </PropertyGroup>\n\n<ItemGroup> <PackageReference Include=\"ConsoleAppFramework\" Version=\"5.5.0\"> <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets> <PrivateAssets>all</PrivateAssets> </PackageReference> </ItemGroup>\n\n</Project>\n\n```\n\nWith this project file we can now package the tool as two NuGet packages by running\n\n```bash dotnet pack dotnet pack -r win-x64\n\n```\n\nand the resulting packages are pretty decent sizes:\n\n![The two sleep-pc NuGet packages](/content/images/2025/sleep-pc.png)\n\nThat covers most things, so all that's left is spicing up the console logs!\n\n### Improving the console output\n\nYour go-to option whenever you want to have nice looking console output is to use [Spectre.Console](https://www.nuget.org/packages/Spectre.Console) but, perhaps controversially, I decided to forgo it in this case. My reasoning being that Spectre.Console technically isn't AOT compatible, and there was really only a tiny amount of dynamism that I wanted.\n\nBasically, all I wanted to add was a countdown timer, instead of the app just sitting in a `Thread.Sleep()` or `Task.Wait()` . To achieve that I used a [trick](https://stackoverflow.com/questions/888533/how-can-i-update-the-current-line-in-a-c-sharp-windows-console-app) that I've used in the past to \"replace\" a line in the console, by sending backspaces in a `Console.WriteLine()` :\n\n```csharp var wait = TimeSpan.FromSeconds(sleepDelaySeconds);\n\n// Write the initial text Console.Write(\"⏰ Time remaining: \");\n\n// Send a bunch of backspaces followed by the formatted text Console.Write(\"\\b\\b\\b\\b\\b\\b\\b\\b{0:hh\\\\:mm\\\\:ss}\", wait);\n\n```\n\nWhen this is running, it looks like the console is updating in place. It's not perfect, but it does the job well enough for me:\n\n![The animated console loop](/content/images/2025/sleep-pc.gif)\n\nTo make the countdown run properly, we have to switch to a loop to make sure we're updating the console regularly. That adds a bit of complexity, particularly given we don't want to \"drift\" from the deadline, but it's relatively self explanatory:\n\n```csharp // Calculate when we should end, to avoid drift var wait = TimeSpan.FromSeconds(sleepDelaySeconds); var deadline = DateTimeOffset.UtcNow.Add(wait); var dryRunText = (dryRun ? \" (dry run)\" : \"\");\n\nConsole.OutputEncoding = System.Text.Encoding.UTF8; Console.WriteLine($@\"Will sleep after, {wait:hh\\:mm\\:ss} at {deadline:dd MMM yy HH:mm:ss}{dryRunText}\"); Console.WriteLine(\"Press ctrl-c to cancel\"); Console.WriteLine(); Console.Write(\"⏰ Time remaining: \");\n\nwhile (!ct.IsCancellationRequested) { // Update the clock Console.Write(\"\\b\\b\\b\\b\\b\\b\\b\\b{0:hh\\\\:mm\\\\:ss}\", wait); try { await Task.Delay(1_000, ct); } catch { // Canceled by the user (Ctrl+C) goto canceled; }\n\nwait = deadline - DateTimeOffset.UtcNow;\n\nif (wait <= TimeSpan.Zero) { Console.WriteLine(); Console.WriteLine($\"💤 Deadline reached, sleeping{dryRunText}\"); if (!dryRun) { try { SetSuspendState(false, false, false); } catch (Exception ex) { Console.WriteLine($\"⚠️ Error triggering sleep: {ex}\"); } }\n\nreturn; } }\n\ncanceled: Console.WriteLine(); Console.WriteLine(\"❌ Sleep cancelled\");\n\n```\n\nAnd that's it!\n\nYou can find the [full code for the tool on GitHub](https://github.com/andrewlock/sleep-pc) and the tool [on NuGet](https://www.nuget.org/packages/sleep-pc):\n\n![The sleep-pc tool on NuGet](/content/images/2025/sleep-pc_2.png)\n\nInstall it using `dotnet tool install -g sleep-pc` , and no more failed sleeping!\n\n## Summary\n\nIn this post I described a small .NET tool that I built to force a Windows PC to go to sleep after a timer expires. I started by showing the the Win32 API I used to send my laptop to sleep, and the small proof of concept app. I then expanded this implementation to Native AOT compile the app, pack it as a .NET tool, and add some improved console output. You can [view the code on GitHub](https://github.com/andrewlock/sleep-pc) or install the tool [from Nuget](https://www.nuget.org/packages/sleep-pc).\n\n## Tags\n\nAndrew Lock | .Net Escapades\n\n![](/assets/img/icons/apple/apple-touch-icon-180x180.png) Want an email when there's new posts?\n\nStay up to the date with the latest posts!\n\nOops! Check your details and try again.\n\nThanks! Check your email for confirmation.",
  "Description": "In this post I describe a small native AOT .NET tool that I built to force a Windows PC to go to sleep after a timer expires",
  "PubDate": "2025-09-23T10:00:00+00:00",
  "Link": "https://andrewlock.net/sleep-pc-a-dotnet-tool-to-make-windows-sleep-after-a-timeout/",
  "Author": "Andrew Lock",
  "Title": "sleep-pc: a .NET Native AOT tool to make Windows sleep after a timeout"
}
