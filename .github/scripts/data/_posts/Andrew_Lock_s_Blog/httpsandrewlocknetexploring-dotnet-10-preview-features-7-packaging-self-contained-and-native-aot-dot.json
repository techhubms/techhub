{
  "Link": "https://andrewlock.net/exploring-dotnet-10-preview-features-7-packaging-self-contained-and-native-aot-dotnet-tools-for-nuget/",
  "FeedName": "Andrew Lock's Blog",
  "ProcessedDate": "2025-09-09 11:11:10",
  "Tags": [
    ".NET 10",
    "AOT",
    "NuGet"
  ],
  "OutputDir": "_posts",
  "FeedUrl": "https://andrewlock.net/rss.xml",
  "EnhancedContent": "In this post we'll look at the support for platform-specific .NET tools feature added in .NET 10,. This new feature allows you to pack tools in a variety of different ways—including self-contained, trimmed, and using native AOT—mirroring the many different ways you can publish .NET apps today.\n\nIn this post we'll use a sample app to look at each of those package types in turn to see the impact the package type has on the package size and the contents of the packages. I'll highlight some of the bugs I found during testing, and also when the various package types might be most useful.\n\n## .NET tools\n\nI discussed .NET tools at length in [my previous post](/using-and-authoring-dotnet-tools/), so for this post I'm going to assume you're already familiar with the general .NET tools feature. There's not been much change to them since .NET Core 3.0, so that's a pretty safe bet!\n\nThat said, the previous post covers one important aspect that's particularly relevant to this post: [ensuring compatibility for consumers of your package by multi-targeting your tool against multiple frameworks](/using-and-authoring-dotnet-tools/#ensuring-compatibility-by-multi-targeting). I strongly recommend reading that section of the post at least, if you haven't already.\n\n## The many ways to deploy .NET applications.\n\nSo I'm assuming you already know a bit about .NET tools, but before we get to the new .NET tool features in .NET 10, we first need to look at some of the ways you can [publish your .NET applications](https://learn.microsoft.com/en-us/dotnet/core/deploying/) today:\n\n- **Framework-dependent executable**. The .NET runtime must be installed on the target machine. The published app is small because it does not include any of the runtime binaries.\n- **Self-contained executable**. The published app includes all the .NET runtime binaries it needs, so is very large, but the benefit is that you don't need a .NET runtime installed on the target machine.\n- **Trimmed self-contained executable**. As with the previous example, but the binaries are [trimmed](https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trim-self-contained) to remove unused code, significantly reducing the size of the published app.\n- **Native AOT executable**. [Native Ahead of Time (AOT)](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/?tabs=windows%2Cnet8) compiled applications have fast startup and smaller memory footprints, and don't need a .NET runtime installed on the host machine. They are platform-specific and some features (like some reflection APIs) are not available.\n\nAnother dimension to consider is whether deployments are \"platform agnostic\" or \"platform specific\". In simple terms:\n\n- **Platform agnostic deployments** can run on *any* platform, e.g. Linux ARM64 or Windows x64, typically expressed as a runtime ID e.g. `linux-arm64`\n, `win-x64` .\n- **Platform specific deployments** can *only* run on a specific platform.\n\nThis becomes particularly important when you have *native* dependencies, so you need a different version of the library for each platform. In these cases, platform agnostic deployments include the native libraries for *all* supported platforms, whereas platform specific deployments need only include the libraries for a single platform.\n\nThe rough summary is that the .NET 10 SDK now supports creating and consuming .NET tools using all these new deployment models.\n\n## .NET tools support more deployment models in .NET 10\n\nPrior to .NET 10, it was only possible to publish .NET tools using the \"framework dependent\" deployment model. .NET 10 preview 6 [announced support](https://github.com/dotnet/core/blob/main/release-notes/10.0/preview/preview6/sdk.md#platform-specific-net-tools) for publishing .NET tools using more deployment models:\n\n- Framework-dependent, platform-agnostic (the way it works today)\n- Framework-dependent, platform-specific\n- Self-contained, platform-specific\n- Trimmed, platform-specific\n- Native AOT-compiled, platform-specific\n\nThe \"Framework-dependent, platform-specific\" option is useful if you have native dependencies in your app, as it effectively splits these across multiple NuGet packages, making each individual package smaller.\n\nThe self-contained, trimmed, and NativeAOT options are particularly useful, as they mean you're no longer dependent on the consumer having the correct .NET runtime already installed on the target machine. Instead of having to [support multiple runtimes](/using-and-authoring-dotnet-tools/#ensuring-compatibility-by-multi-targeting) or [configure `RollForward`](/using-and-authoring-dotnet-tools/#configuring-your-tools-to-roll-forward) for your application, you can just pack the whole runtime (ideally, trimmed or AOT compiled) into your package, and don't worry about the target machine.\n\n>\n> There's some caveats to this, which I discuss at the end of this post.\n> >\n\nThat's the crux of the feature, so for the remainder of the post we'll look at how to generate each of the different packages, what the NuGet packages look like, and what they contain.\n\n### The sample app\n\nFor the test app, I created a sample based on Chet Husk's [multi-rid-tool](https://github.com/baronfel/multi-rid-tool) which looked a bit like this:\n\n```xml <Project Sdk=\"Microsoft.NET.Sdk\">\n\n<PropertyGroup> <OutputType>Exe</OutputType> <TargetFrameworks>netcoreapp3.1;net5.0;net6.0;net7.0;net8.0;net9.0</TargetFrameworks> <EmbedUntrackedSources>true</EmbedUntrackedSources> <CopyOutputSymbolsToPublishDirectory>false</CopyOutputSymbolsToPublishDirectory> <PackAsTool>true</PackAsTool> <ToolCommandName>sayhello</ToolCommandName> <PackageId>sayhello</PackageId> <PackageVersion>1.0.0</PackageVersion> <Authors>Andrew Lock</Authors> <Description>A tool that says hello</Description> <PackageLicenseExpression>MIT</PackageLicenseExpression> </PropertyGroup>\n\n<ItemGroup> <PackageReference Include=\"Spectre.Console\" Version=\"0.50.0\" /> <PackageReference Include=\"Microsoft.Data.Sqlite\" Version=\"9.0.8\" /> </ItemGroup> </Project>\n\n```\n\nThere's nothing particularly interesting there, it's a simple exe called `sayhello` that has a *bunch* of target frameworks, is packed as a .NET tool, and has a couple of dependencies. The *Microsoft.Data.Sqlite* dependency is there to ensure we have a native dependency (SQLite) while Spectre.Console is there because it's cool.\n\nIn *Program.cs* we have some simple code that ensures we use the dependencies (to make sure they're not completely trimmed out for example):\n\n```csharp using Microsoft.Data.Sqlite; using Spectre.Console;\n\nusing var connection = new SqliteConnection(\"Data Source=:memory:\"); connection.Open();\n\nvar command = connection.CreateCommand(); command.CommandText = \"SELECT 'world'\";\n\nusing var reader = command.ExecuteReader(); while (reader.Read()) { var name = reader.GetString(0);\n\nvar figlet = new FigletText($\"Hello {name}!\") .Centered() .Color(Color.Green);\n\nAnsiConsole.Write(figlet); }\n\n```\n\nThis program just prints `Hello world!` when you run it:\n\n```powershell _ _ _ _ _ _ _ | | | | ___ | | | | ___ __ __ ___ _ __ | | __| | | | | |_| | / _ \\ | | | | / _ \\ \\ \\ /\\ / / / _ \\ | '__| | | / _` | | | | _ | | __/ | | | | | (_) | \\ V V / | (_) | | | | | | (_| | |_| |_| |_| \\___| |_| |_| \\___/ \\_/\\_/ \\___/ |_| |_| \\__,_| (_)\n\n```\n\nNext we're going to publish it using each of the five different approaches. In each case we *could* control the publish output by passing values to the `dotnet pack` commands. However, in practice you'll likely want to embed the options inside the project file, so that's the approach I take in this post.\n\n### Framework-dependent, platform agnostic\n\nFor the application above, by default, when you run `dotnet pack` you'll get a framework-dependent, platform agnostic package. The tool can be installed on any of the supported platforms, but you need one of the supported .NET runtimes installed on the target machine:\n\n```bash dotnet pack -o ./artifacts/packages/agnostic\n\n```\n\nThis produces the package in the *./artifacts/packages/agnostic* folder, and results in a single, chonky, package:\n\n![The sayhello package is large, at 91MB](/content/images/2025/multirid_01.png)\n\nIf you open the package using [NuGet Package Explorer](https://github.com/nugetpackageexplorer), you can see why the package is so large: it contains duplicate files for every target framework, and each target framework contains the native files for *all* the supported platforms\n\n![The package contains a folder for each target framework, each of which contains all the runtimes](/content/images/2025/multirid_02.png)\n\nFinally, if we look at the *DotnetToolSettings.xml* file, we see something like this:\n\n```xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <DotNetCliTool Version=\"1\"> <Commands> <Command Name=\"sayhello\" EntryPoint=\"MultiRid.dll\" Runner=\"dotnet\" /> </Commands> </DotNetCliTool>\n\n```\n\nThis package is effectively the same as you get today if you're packing your .NET tools with the .NET 9 SDK or earlier.\n\nThere are two main reasons the package is large:\n\n- We target multiple frameworks to support multiple .NET runtime environments\n- We support all platforms in a single package.\n\nFor the next scenario, we address the second of those points.\n\n### Framework-dependent, platform specific\n\nIn the next scenario, instead of supporting *all* platforms (`linux-x64` /`win-x64` etc) in a single package, we split each of those into a separate package. This is handled automatically by the .NET 10 SDK when you specify runtime IDs in your project. To produce platform-specific NuGet packages, we simply add the following property group to our project:\n\n```xml <!-- specific --> <PropertyGroup> <RuntimeIdentifiers>linux-x64;linux-arm64;win-x64;win-arm64;any</RuntimeIdentifiers> <PublishSelfContained>false</PublishSelfContained> </PropertyGroup>\n\n```\n\nThere's a couple of interesting points here:\n\n- **We explicitly set `PublishSelfContained=false`**. This is because on earlier versions of .NET Core, setting a runtime ID would automatically set `PublishSelfContained=true`\n, but that's a different scenario we're going to get to later!\n- **We have an additional `any` runtime ID**. The `any`\noption was [added in .NET 10 preview 7](https://github.com/dotnet/core/blob/main/release-notes/10.0/preview/preview7/sdk.md#any-rid-in-multi-rid-tools) and is meant to ensure you still produce a \"platform agnostic\" package *in addition* to the platform-specific packages, so that you have a \"fallback\".\n\nIf we run .NET pack again:\n\n```bash dotnet pack -o ./artifacts/packages/specific\n\n```\n\nThis time we end up with 6 different packages:\n\n![The dotnet pack command produces 6 different packages](/content/images/2025/multirid_03.png)\n\nWe now have\n\n- A \"top level\" NuGet package with the \"correct\" name for our tool.\n- A package for each of the 4 specific runtime IDs we specified in our project file.\n- An \"any\" package, which should be used on platforms that don't have a dedicated package.\n\nWe'll look at each of these packages in turn.\n\nThe top-level package is tiny, and contains just a single file for each target framework:\n\n![The DotnetToolSettings.xml file for each framework ](/content/images/2025/multirid_04.png)\n\nThe *DotnetToolSettings.xml* file in this case looks like this:\n\n```xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <DotNetCliTool Version=\"2\"> <Commands> <Command Name=\"sayhello\" /> </Commands> <RuntimeIdentifierPackages> <RuntimeIdentifierPackage RuntimeIdentifier=\"linux-x64\" Id=\"sayhello.linux-x64\" /> <RuntimeIdentifierPackage RuntimeIdentifier=\"linux-arm64\" Id=\"sayhello.linux-arm64\" /> <RuntimeIdentifierPackage RuntimeIdentifier=\"win-x64\" Id=\"sayhello.win-x64\" /> <RuntimeIdentifierPackage RuntimeIdentifier=\"win-arm64\" Id=\"sayhello.win-arm64\" /> <RuntimeIdentifierPackage RuntimeIdentifier=\"any\" Id=\"sayhello.any\" /> </RuntimeIdentifierPackages> </DotNetCliTool>\n\n```\n\nThere's some interesting aspects to this file compared to the platform agnostic version:\n\n- The `<DotNetCliTool>`\nelement has `Version=2` for the platform-specific version, and `Version=1` for the platform-agnostic version.\n- There's a collection of `<RuntimeIdentifierPackage>`\nwhich match a runtime ID to a different package.\n\nIf we look at one of those platform-specific packages, e.g. *sayhello.linux-x64.1.0.0*, and compare it to the platform agnostic version, we can see why it's so much smaller:\n\n![The sayhello.linux-x64 package contents](/content/images/2025/multirid_05.png)\n\nThere's still a folder for every target framework, but now instead of a *runtimes* folder with all the different platform-specific binaries, there's only the single platform, `linux-x64` in this case.\n\n![Comparing the platform agnostic package to the platform specific package](/content/images/2025/multirid_14.png)\n\nIt's also worth looking at the *DotnetToolSettings.xml* file in these packages:\n\n```xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <DotNetCliTool Version=\"2\"> <Commands> <Command Name=\"sayhello\" EntryPoint=\"MultiRid\" Runner=\"executable\" /> </Commands> </DotNetCliTool>\n\n```\n\nAs you can see, this is another `Version=2` manifest and interestingly this is where we see a new \"runner\" type, `executable` , with a defined `EntryPoint` which is the executable that will run.\n\nSo the platform-specific packages can be much smaller as they only need a single runtime, but the `any` package *does* still need all those runtimes, so that it will work on any platform. Unfortunately, [there's currently a bug](https://github.com/dotnet/sdk/issues/50312) which means that *none* of the runtimes are currently included, so actually the *any* package *won't* work on any platform if your app has native dependencies 😅 That should be fixed [in .NET 10 RC2](https://github.com/dotnet/sdk/pull/50376).\n\n### Self-contained, platform specific\n\nFor the next permutation, we build a self-contained application, so we bundle the .NET runtime as part of the package. The other change in this case is that there's no point in targeting multiple frameworks for increased compatibility; you only need to target one, because it's going to be bundled in the package anyway:\n\n```xml <PropertyGroup> <TargetFramework>net9.0</TargetFramework> <RuntimeIdentifiers>linux-x64;linux-arm64;win-x64;win-arm64</RuntimeIdentifiers> <PublishSelfContained>true</PublishSelfContained> </PropertyGroup>\n\n```\n\nThe other thing to note is that there's no `any` runtime ID here. That's because there's currently a bug that will cause errors if you try to add it:\n\n```bash C:\\Program Files\\dotnet\\sdk\\10.0.100-preview.7.25380.108\\Sdks\\Microsoft.NET.Sdk\\targets\\Microsoft.NET.Sdk.FrameworkReferenceResolution.targets(528,5): error NETSDK1082: There was no runtime pack for Microsoft.NETCore.App available for the specified RuntimeIdentifier 'any'.\n\n```\n\nThis [should also be fixed](https://github.com/dotnet/sdk/pull/50421) for .NET 10 RC 2, and will mean you can have a true fallback package, just as we saw for the framework-dependent, platform-specific case. For now though, we'll have to do without the `any` package.\n\nRunning `dotnet pack` once again:\n\n```bash dotnet pack -o ./artifacts/packages/specific\n\n```\n\nIf we look at the packages this scenario produces, they're very similar to the previous framework-dependent platform-specific case, but much larger, because they ship .NET in the package too:\n\n![The self-contained, platform-specific packages](/content/images/2025/multirid_06.png)\n\nThe root `sayhello` package is essentially the same as the root package for the platform-specific version, the only difference being that the self-contained package only contains a single target framework.\n\n![The sayhello root package only contains a sing any](/content/images/2025/multirid_08.png)\n\nHowever, If we look inside the platform-specific packages like `sayhello.linux-arm64` you'll see that there's a *lot* of files in the package, everything you need to run the .NET app, even when there's no .NET runtime installed on the target application.\n\n![Inside the sayhello.linux-arm64 package there are a lot files, that are part of the .NET runtime](/content/images/2025/multirid_07.png)\n\nIf we look at the *DotnetToolSettings.xml* file in these self-contained package you can see that it's still the same as the framework-dependent platform-specific package, pointing towards the executable shim:\n\n```xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <DotNetCliTool Version=\"2\"> <Commands> <Command Name=\"sayhello\" EntryPoint=\"MultiRid.exe\" Runner=\"executable\" /> </Commands> </DotNetCliTool>\n\n```\n\nEven though these packages are large, if you think back to the first framework-dependent, platform agnostic package we're much smaller than the 90MB we started with.\n\n### Self-contained, trimmed\n\nIf you're going to go to the effort of building self-contained, platform-specific packages, then it *likely* makes sense to go to the next step and enable trimming too. [Enabling an application for trimming](https://learn.microsoft.com/en-us/dotnet/core/deploying/trimming/trim-self-contained) *can* be somewhat risky depending on the libraries and methods your application uses. However, if your application *is* amenable to trimming, it can significantly reduce the resulting package sizes.\n\nTo create trimmed NuGet packages, you just need the `<PublishTrimmed>` property on top of our previous configuration:\n\n```xml <PropertyGroup> <TargetFramework>net9.0</TargetFramework> <RuntimeIdentifiers>linux-x64;linux-arm64;win-x64;win-arm64</RuntimeIdentifiers> <PublishSelfContained>true</PublishSelfContained> <!-- 👇 Add this --> <PublishTrimmed>true</PublishTrimmed> </PropertyGroup>\n\n```\n\nAgain we publish with\n\n```bash dotnet pack -o ./artifacts/packages/trimmed\n\n```\n\nAnd this time the packages are a third of the size, around 10MB each, much better!\n\n![The packages when building self-contained trimmed packages](/content/images/2025/multirid_09.png)\n\nWe're almost done, the last case we have to look at is native AOT.\n\n### Native AOT\n\nAs per [the documentation](https://learn.microsoft.com/en-us/dotnet/core/deploying/native-aot/):\n\n>\n> Publishing your app as *Native AOT* produces an app that's self-contained and that has been ahead-of-time (AOT) compiled to native code. Native AOT apps have faster startup time and smaller memory footprints. These apps can run on machines that don't have the .NET runtime installed.\n> >\n\nIf you're *already* packaging your application as both self-contained and trimmed, it's very possible that your application could be Native AOT compatible too. And given that you're building tools, it's very possible that you could get real benefits from compiling your application as native AOT.\n\nWe'll update the tool to build as Native AOT, and to reduce the size of the package, we'll also strip the symbols\n\n```xml <PropertyGroup> <RuntimeIdentifiers>linux-x64;linux-arm64;win-x64;win-arm64;</RuntimeIdentifiers> <PublishSelfContained>true</PublishSelfContained> <PublishTrimmed>true</PublishTrimmed> <!-- 👇 Add these --> <PublishAot>true</PublishAot> <StripSymbols>true</StripSymbols> </PropertyGroup>\n\n```\n\nPublishing for native AOT is a little trickier than for the other packages, because you can *only* native AOT compile on the same platform as you're running on. In total, you need to run `dotnet pack` once for each runtime, and once for the \"root\" package.\n\nRunning the simple `dotnet pack` produces the \"root\" package:\n\n```bash dotnet pack -o ./artifacts/packages/nativeoat\n\n```\n\nand then you need to run `dotnet pack` for each runtime ID, for example:\n\n```bash dotnet pack -o ./artifacts/packages/nativeaot --runtime-id win-x64\n\n```\n\nThis produces the `sayhello.win-x64.1.0.0` package only. You then need to run it again for each of the supported runtimes.\n\n>\n> [Chet Husk](https://bsky.app/profile/chethusk.bsky.social) has an example of how you can do this in GitHub actions and later aggregate the packages together. Note that he uses `--current-runtime`\n> instead of listing each runtime ID specifically. Be aware that [this *doesn't* work](https://github.com/dotnet/sdk/issues/50313) if you are using `<TargetFrameworks>`\n> in your project; you must use `<TargetFramework>`\n> instead.\n> >\n\nIf we look at those packages, you can see that the native AOT packages are even smaller than the trimmed packages!\n\n![The native AOT packages are only 2.5MB](/content/images/2025/multirid_10.png)\n\nAnd if we look inside the package, you can see that there's only 2 application files left: the native AOT'd .NET tool, and the native library:\n\n![The contents of the native AOT package](/content/images/2025/multirid_11.png)\n\nIn many ways this represents the \"pinnacle\" of .NET tool usability; on supported platforms, consumers of your tool will benefit from the fastest start up times and the smallest download sizes (which further improves [the dnx one-off-tool experience](/exploring-dotnet-10-preview-features-5-running-one-off-dotnet-tools-with-dnx/)). In the cases where you're on an unsupported platform, you should be able to fallback to the same framework dependent, platform-agnostic packages that are available today, so there's nothing much lost there.\n\n>\n> Note that as mentioned earlier, the `any`\n> fallback for self-contained, trimmed, and Native AOT packages does not work as of .NET 10 preview 7, but [it should be working](https://github.com/dotnet/sdk/pull/50421) for RC2.\n> >\n\nSo the last remaining question is: as a tool author, should you actually use these new platform-specific packages?\n\n## Limitations and recommendations\n\nThe main limitation with *all* of the new platform-specific package types is that they only work when you're using the .NET 10 SDK. If you try to install any of the packages that use version 2 of the `<DotNetCliTool>` element then you'll get an error similar to the following:\n\n```bash\n> dotnet tool install sayhello --tool-path .\\specific --source D:\\repos\\blog-examples\\MultiRid\\artifacts\\packages\\specific\n\nTool 'sayhello' failed to update due to the following: The settings file in the tool's NuGet package is invalid: Command 'sayhello' uses unsupported runner ''.\" Tool 'sayhello' failed to install. Contact the tool author for assistance.\n\n```\n\nGiven this requirement, depending on the specifics of the .NET tool you're creating, the benefits of creating a platform-specific tool may be limited.\n\nFirst of all, if your tool don't have any native dependencies, then there's fundamentally no difference between the framework-dependent platform-*specific* packages and the framework-dependent platform *agnostic* packages, other than the fact that you can only run the platform-specific tool if you're using the .NET 10 SDK.\n\nWhere things get interesting is if you're currently targeting *multiple* frameworks with your tool. In these cases you end up with multiple instances of the app, compiled for each target framework, all packaged in the same *.nupkg*. If you want to support the widest range of installed frameworks, then theoretically you need a new copy for every framework. That can both increase complexity in the tool and increase the size of the package that needs to be downloaded.\n\n>\n> You can avoid that somewhat by configuring [the `rollForward`\n> rules](/using-and-authoring-dotnet-tools/#configuring-your-tools-to-roll-forward) for your tool, but there's always a certain amount of risk in relying solely on that approach.\n> >\n\nThe neat thing about the self-contained/trimmed/Native AOT packages is that you *don't* need to multi-target your application for multiple frameworks, because you include the framework in the package! That reduces the complexity in your tool (no need to multi-target) and the size of your package (no need for multiple copies of the compiled app).\n\nAt least, that's the theory. *Today*, it's not really true, because these packages *only* support .NET 10, because they require the .NET 10 SDK to install the tool. So ease of support and compatibility is actually a reason *not* to use the platform-specific packages today. This will become less of a problem as time goes on and more people are using the latest .NET SDKs, but today it's hard to recommend as your sole approach.\n\nThat said, there are *some* \"escape route\" avenues I explored to try to get the best of both worlds. These may work for you if you want to support both the enhanced experience of the .NET 10 SDK while still supporting users stuck on older SDKs.\n\n## Summary\n\nIn this post I described the new platform-specific .NET tool packages that are supported in .NET 10 as of preview 6 and 7. The .NET 10 SDK allows you to easily create \"root\" meta-packages that delegate to platform-specific versions of your .NET tool. This is particularly useful if your app has native dependencies, as it can significantly reduce the size of each package.\n\nIn addition, you can create self-contained, trimmed, or native AOT compiled versions of your app. These packages mean you're no longer beholden to the consumer having the correct version of the runtime installed for your tool (though currently it does mean they *must* have the .NET 10 SDK installed).\n\nIn this post we looked at the results of using each of the new package types, the impact it has on the package size and the contents of the packages. I highlighted some of the bugs I found during testing (but which will hopefully be resolved by the time .NET 10 goes GA in November). Finally, I discussed some of the limitations of the new packages, the most important being that you must have the .NET 10 SDK installed to install tools that use the new package types.\n\n## Tags\n\nAndrew Lock | .Net Escapades\n\n![](/assets/img/icons/apple/apple-touch-icon-180x180.png) Want an email when there's new posts?\n\nStay up to the date with the latest posts!\n\nOops! Check your details and try again.\n\nThanks! Check your email for confirmation.",
  "PubDate": "2025-09-09T10:00:00+00:00",
  "Author": "Andrew Lock",
  "Title": "Packaging self-contained and native AOT .NET tools for NuGet: Exploring the .NET 10 preview - Part 7",
  "Description": "In this post we look at the new support for platform-specific .NET tools, so that you can pack your tools as self-contained or Native AOT packages",
  "FeedLevelAuthor": "Andrew Lock | .NET Escapades"
}
