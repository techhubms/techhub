{
  "Tags": [
    ".NET 10",
    "ASP.NET Core",
    "Security"
  ],
  "OutputDir": "_posts",
  "FeedLevelAuthor": "Andrew Lock | .NET Escapades",
  "ProcessedDate": "2025-08-05 14:29:46",
  "FeedUrl": "https://andrewlock.net/rss.xml",
  "Title": "Running one-off .NET tools with dnx: Exploring the .NET 10 preview - Part 5",
  "Description": "In this post I show the new dnx command for running .NET tools without installing them and look at exactly how it works.",
  "Link": "https://andrewlock.net/exploring-dotnet-10-preview-features-5-running-one-off-dotnet-tools-with-dnx/",
  "FeedName": "Andrew Lock's Blog",
  "Author": "Andrew Lock",
  "EnhancedContent": "In this post I briefly show the new `dnx` command for running one-off .NET tools without installing them. I show how to use the command, how the command works in practice, and how the command works behind the scenes in the .NET SDK.\n\n## Running tools without installing them with `dnx`\n\nThe Node.js ecosystem has had a tool called `npx` [since 2017](https://blog.npmjs.org/post/162869356040/introducing-npx-an-npm-package-runner?utm_source=chatgpt.com). Sitting alongside the `npm` package-manager tool, it allows running a Node.js tool from a package without having to installing it globally. .NET Core added support for tools in NuGet packages shortly afterwards in 2018, back in .NET Core 2.1, but this has always required an explicit `dotnet tool install` command before you can run the tool. Until now.\n\n.NET 10 preview 6 added support for running .NET tools without explicitly installing them first with the introduction of the new .NET SDK command `dnx` . What's more, the .NET SDK also ships a standalone `dnx` command so that you can run `dnx <tool>` directly instead of `dotnet dnx <tool>` .\n\nOne of the easiest ways to understand what's available with the new `dnx` command is to take a look at the built-in command line help:\n\n```bash\n> dnx --help\nDescription: Executes a tool from source without permanently installing it.\n\nUsage: dotnet dnx <packageId> [<commandArguments>...] [options]\n\nArguments: <PACKAGE_ID> Package reference in the form of a package identifier like 'Newtonsoft.Json' or package identifier and version separated by '@' like '[email protected]'. <commandArguments> Arguments forwarded to the tool\n\nOptions: --version <VERSION> The version of the tool package to install. -y, --yes Accept all confirmation prompts using \"yes.\" --interactive Allows the command to stop and wait for user input or action (for example to complete authentication). [default: True] --allow-roll-forward Allow a .NET tool to roll forward to newer versions of the .NET runtime if the runtime it targets isn't installed. --prerelease Include pre-release packages. --configfile <FILE> The NuGet configuration file to use. --source <SOURCE> Replace all NuGet package sources to use during installation with these. --add-source <ADDSOURCE> Add an additional NuGet package source to use during installation. --disable-parallel Prevent restoring multiple projects in parallel. --ignore-failed-sources Treat package source failures as warnings. --no-http-cache Do not cache packages and http requests. -v, --verbosity <LEVEL> Set the MSBuild verbosity level. Allowed values are q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic]. -?, -h, --help Show command line help.\n\n```\n\nAs you might expect, there's a lot of overlap with the existing `dotnet tool` commands. One point that differs is the (optional) way you can specify the package version with a `@` separator, for example, `[email protected]` . This is a common pattern used in other ecosystems like Node.js and Go, for example, and it's now making it's way to .NET.\n\n>\n> I think we first saw this notation in .NET [with the recent `dotnet run app.cs`\n> feature](/exploring-dotnet-10-preview-features-1-exploring-the-dotnet-run-app.cs/#adding-nuget-package-references). Overall, it points to a willingness to break from some of .NET's tendency towards verbosity in favour of embracing more concise patterns, particularly patterns from other ecosystems.\n> >\n\nSo now let's try it out. As an example, I'll use the classic demo tool `dotnetsay` . When you run using `dnx dotnetsay` , you have to confirm that the .NET SDK should download the tool. If you answer `n` , the run is cancelled; if you answer `y` then it downloads and runs the tool:\n\n```bash\n> dnx dotnetsay\nTool package [email protected] will be downloaded from source https://api.nuget.org/v3/index.json. Proceed? [y/n] (y): y\n\nWelcome to using a .NET Core global tool!\n\n```\n\nNote that you only get the confirmation the first time you run and download the tool. The next time, the tool runs without confirmation:\n\n```bash\n> dnx dotnetsay\n\nWelcome to using a .NET Core global tool!\n\n```\n\nAnd there you have it: one-shot .NET tool execution.\n\n## How is `dnx`\ndifferent to `dotnet tool install` ?\n\nNow, you might be thinking that this `dnx` is nice and short, but is it *really* that different to installing the tool? And the answer is both yes and no.\n\nThe typical way you would *install* the `dotnetsay` tool globally would be using:\n\n```bash dotnet tool install -g dotnetsay\n\n```\n\nThe `-g` means the tool is installed globally, though you can [also install tools locally](/new-in-net-core-3-local-tools/). You can then run the tool by simply running:\n\n```bash dotnetsay\n\nWelcome to using a .NET Core global tool!\n\n```\n\nBut what does \"installed globally\" actually *mean*? And how does it differ from what `dnx` does?\n\nStep one in both cases is to download [the dotnetsay NuGet package](https://www.nuget.org/packages/dotnetsay). This goes through layers of caching and is ultimately expanded into the global package location. This is also where all the NuGet packages that are downloaded as part of project builds are stored by default.\n\n>\n> You can see the location of the NuGet-related folders on your machine by running `dotnet nuget locals all --list`\n> > >\n\nAfter downloading the package, the SDK also copies the expanded package to the \"dotnet tool\" store location. By default, these expanded directories can be found at `~/.dotnet/tools/.store` . The .NET SDK *also* installs an executable shim in `~/.dotnet/tools` , which is also on the machine's `PATH` , so they can be easily invoked.\n\nIn contrast, the `dnx` command downloads the package and installs it into the global package cache, but it *doesn't* install anything in the tool store or add a shim to `~/.dotnet/tools` . Instead it runs the tool directly from the package cache. This is what makes it the \"one shot\" run instead of the persistent `dotnet tool install` approach.\n\n## How does `dnx`\nwork behind the scenes?\n\nWhenever a big new feature drops in .NET, I like to sniff around to see how it was implemented, and `dnx` was no different. I started by finding the origin of the `dnx` command itself by running `where dnx` from a command line:\n\n```bash\n> where dnx\nC:\\Program Files\\dotnet\\dnx.cmd\n\n```\n\nAs you can see, the `dnx` command is actually a `cmd` file, installed side-by-side with the `dotnet.exe` . If you crack it open you can see that all it's doing is invoking `dotnet dnx` , and passing the remaining arguments:\n\n```cmd @echo off \"%~dp0dotnet.exe\" dnx %*\n\n```\n\nThere's [a similar file](https://github.com/dotnet/sdk/blob/main/src/Layout/redist/dnx) for Linux and MacOS that provides the `dnx` command, and as expected, it does a similar thing:\n\n```bash #!/bin/sh\n\n# Licensed to the .NET Foundation under one or more agreements.\n# The .NET Foundation licenses this file to you under the MIT license.\n\n\"$(dirname \"$0\")/dotnet\" dnx \"$@\"\n\n```\n\nSo the .NET SDK exposes [a `dnx` command](https://github.com/dotnet/sdk/blob/681138b2d3d7255a17ad6cb4812787a0d5edef99/src/Cli/dotnet/Commands/Dnx/DnxCommandParser.cs#L10) which parses the arguments and options, and creates an instance of [the `ToolExecuteCommand`](https://github.com/dotnet/sdk/blob/main/src/Cli/dotnet/Commands/Tool/Execute/ToolExecuteCommand.cs#L42). This command is responsible for downloading and running the command.\n\nAt a high level, this command does the following things:\n\n1. If a version for the tool is *not* specified, try to locate the tool [in the local tools manifest](https://learn.microsoft.com/en-us/dotnet/core/tools/global-tools#install-a-local-tool). If it's present in the manifest, run the tool from there.\n2. Otherwise, try to find the package to install from nuget.org.\n3. If the tool is not currently downloaded, ask for permission and download the tool.\n4. Finally, run the tool.\n\nThat's pretty much all there is to it, but I'll go into a little more detail below.\n\nThe `ToolExecuteCommand` only considers the local tool manifest if you don't specify a version to install, otherwise it skips the step entirely. Next the command looks for a tool manifest, *dotnet-tools.json*. If it finds a manifest, and the tool being run is *listed* in the manifest, the command downloads and runs the tool without any further interaction.\n\nIf you *do* specify a version, or if there's no manifest, or the manifest doesn't list the tool being run, then it moves onto installing the tool globally. First it searches for the package on nuget.org, or whichever sources are configured in the *nuget.config* file.\n\nAssuming the requested package exists, the command next checks whether it has permission to download the package. The command prompts for confirmation as we saw earlier (`Proceed? [y/n] (y): y` ). Interestingly, this prompt is shown whether or not you're running in an interactive setting; though you can bypass the flag by passing the auto-confirm `--yes` flag.\n\nOnce the command has confirmation, it downloads the tool and runs it. Voila!\n\nThat's about all there is to the `dnx` command. It's a nice little quality of life bump for the .NET ecosystem, which leverages all the existing features of .NET tools to make things that little bit easier.\n\n## Summary\n\nIn this short post I showed the new `dnx` command and how to use it to run .NET tools without explicitly installing them first. Next I discussed the difference between the `dnx` command and the `dotnet tool install` command. Finally I walked through the code behind the feature; the `ToolExecuteCommand` in the .NET SDK.\n\n## Tags\n\nAndrew Lock | .Net Escapades\n\n![](/assets/img/icons/apple/apple-touch-icon-180x180.png) Want an email when there's new posts?\n\nStay up to the date with the latest posts!\n\nOops! Check your details and try again.\n\nThanks! Check your email for confirmation.",
  "PubDate": "2025-07-29T10:00:00+00:00"
}
