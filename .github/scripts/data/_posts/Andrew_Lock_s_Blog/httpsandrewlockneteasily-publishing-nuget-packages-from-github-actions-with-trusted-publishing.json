{
  "Link": "https://andrewlock.net/easily-publishing-nuget-packages-from-github-actions-with-trusted-publishing/",
  "PubDate": "2025-09-30T10:00:00+00:00",
  "FeedLevelAuthor": "Andrew Lock | .NET Escapades",
  "OutputDir": "_posts",
  "FeedName": "Andrew Lock's Blog",
  "Title": "Publishing NuGet packages from GitHub actions the easy way with Trusted Publishing",
  "EnhancedContent": "In this post I describe how you can use [nuget.org](https://www.nuget.org/)'s [new Trusted Publishing feature](https://devblogs.microsoft.com/dotnet/enhanced-security-is-here-with-the-new-trust-publishing-on-nuget-org/) to publish NuGet packages from a GitHub Actions workflow, *without* having to generate and store API keys, while simultaneously benefiting from improved security.\n\n## How do you push NuGet packages today?\n\nIf you're someone that creates NuGet packages and pushes them to [nuget.org](https://www.nuget.org/) today, then you're probably doing so in one of several ways:\n\n- Building the packages locally and manually uploading them to [nuget.org](https://www.nuget.org).\n- Building the packages in CI, downloading them, and manually uploading them to [nuget.org](https://www.nuget.org).\n- Building the packages in CI, and pushing them directly to [nuget.org](https://www.nuget.org) from CI.\n\nEach of these approaches is progressively \"better\" in that they generally improve the consistency of your builds and reduce the number of manual steps you require. However, pushing your *.nupkg* files to NuGet from CI is also somewhat \"harder\" than just uploading them locally, via the [nuget.org website](https://www.nuget.org/packages/manage/upload).\n\nInstead of just dragging-and-dropping your package onto the web page, you now need to:\n\n- Generate an API key\n- Store it *securely* in GitHub Actions (e.g. as a Secret)\n- Pass the secret in your GitHub Actions workflow\n- Rotate the secret whenever it changes\n- Make sure others in your organisation can do the same (if you're publishing packages for an org)\n\nNone of that is insurmountable, but managing the lifecycle of long-lived secrets [is notoriously difficult](https://www.bleepingcomputer.com/news/security/over-12-million-auth-secrets-and-keys-leaked-on-github-in-2023/). And that's where Trusted Publishing steps in.\n\n## What is Trusted Publishing?\n\nTrusted Publishing is an initiative that's been in place for many ecosystems for a while. For example Python has it for PyPI, Ruby has it for RubyGems.org, and JavaScript has it for npm. And as of last week, .NET has Trusted Publishing for [nuget.org](https://www.nuget.org) ðŸŽ‰\n\n[Trusted Publishing](https://repos.openssf.org/trusted-publishers-for-all-package-repositories) is an approach that uses existing authentication standards ([OpenID Connect](https://openid.net/developers/how-connect-works/)) to connect CI infrastructure provides (such as GitHub Actions or GitLab Pipelines) with public package repositories (like PyPI and [nuget.org](https://www.nuget.org)). Instead of needing to store and manage API keys so that the two systems can talk to each other, you use OpenID Connect to retrieve short-lived authentication tokens, which you can then use to push packages to the package repository.\n\nExactly how this works will vary by provider and package repository, but the overall flow is the same. For GitHub actions and [nuget.org](https://www.nuget.org), it looks something like this:\n\n- The user configures a \"trust policy\" on [nuget.org](https://www.nuget.org).\n- In a CI workflow, you retrieve an OpenID Connect token for the job from GitHub.\n- In this example, GitHub is the Identity Provider (IdP).\n- The token is a signed JSON Web Token (JWT), which includes details about the repository and the workflow that's running.\n- You send the token to [nuget.org](https://www.nuget.org), exchanging the token for an API key.\n- NuGet.org verifies the contents of the JWT against the configured trust policy.\n- If everything matches up, [nuget.org](https://www.nuget.org) issues a short-lived API token that can be used to publish packages.\n- The CI workflow uses the API token to push the *.nupkg* packages to [nuget.org](https://www.nuget.org).\n\n![](/content/images/2025/trusted_publishing_01.png) Diagram of Trusted Publishers flow. From [Trusted Publishers for All Package Repositories](https://repos.openssf.org/trusted-publishers-for-all-package-repositories). Because the trust-policy is configured ahead of time, and you're *already* authenticated with GitHub (due to running in their infrastructure) it's pretty easy to get up and running.\n\n## Configuring Trusted Publishing on NuGet.org\n\nOnce I saw the blog post, I decided to give it a try for [my new sleep-pc tool](/sleep-pc-a-dotnet-tool-to-make-windows-sleep-after-a-timeout/), seeing as I hadn't set up CI for it yet. I'll start by showing the workflow *without* NuGet publishing, to provide the baseline, and then show the steps I took to add publishing via Trusted Publishing.\n\n### The workflow starting point\n\nThe initial workflow, without publishing, is shown below. This is stored in the file `.github/workflows/BuildAndPack.yml` :\n\n```yml name: BuildAndPack on: push: branches: [main] tags: ['*'] pull_request:\n\njobs: build-and-publish: permissions: contents: read runs-on: windows-latest steps:\n- uses: actions/checkout@v4\n- uses: actions/setup-dotnet@v4\nwith: dotnet-version: 10.0.x\n\n- name: dotnet pack\nrun: | dotnet pack dotnet pack -r win-x64\n\n```\n\nThis just does 3 things:\n\n- Checkout the repo\n- Install .NET 10\n- Run `dotnet pack`\n\nIt's worth nothing that I added the `permissions` entry to limit the permissions to reading from the repository [as a security best practice](https://docs.github.com/en/actions/tutorials/authenticate-with-github_token#modifying-the-permissions-for-the-github_token). This isn't required, but I added it mostly to show what needs to change when we use trusted publishing.\n\n### Updating the workflow to add Trusted Publishing support\n\nTo add trusted publishing, we need to do three things:\n\n- Add the `id-token: write`\npermission.\n- Use `NuGet/login@v1`\nto exchange an OIDC token for a NuGet API key.\n- Use the generated API key to push the packages to NuGet\n\nThe following shows the updated workflow, with comments highlighting the differences:\n\n```yml name: BuildAndPack on: push: branches: [main] tags: ['*'] pull_request:\n\njobs: build-and-publish: permissions: contents: read id-token: write # enable GitHub OIDC token issuance for this job\n\nruns-on: windows-latest steps:\n- uses: actions/checkout@v4\n- uses: actions/setup-dotnet@v4\nwith: dotnet-version: 10.0.x\n\n- name: dotnet pack\nrun: | dotnet pack dotnet pack -r win-x64\n\n# Use the ambient GitHub token to login to NuGet and retrieve an API key\n- name: NuGet login (OIDC â†’ temp API key)\nuses: NuGet/login@v1 id: login with:\n# Secret is your NuGet username, e.g. andrewlock\nuser: ${{ secrets.NUGET_USER }}\n\n- name: push to NuGet\n# Only push to NuGet if we're building a tag (optional)\nif: startsWith(github.ref, 'refs/tags/') shell: pwsh\n# Loop through all the packages in the output folder and push them to\n# nuget.org, using the NUGET_API_KEY generated by the previous login step\nrun: | Get-ChildItem artifacts/package/release -Filter *.nupkg | ForEach-Object { dotnet nuget push $_.FullName ` --api-key \"${{ steps.login.outputs.NUGET_API_KEY }}\" ` --source https://api.nuget.org/v3/index.json }\n\n```\n\nIn this workflow, the only secret you need to configure is the `NUGET_USER` secret, which should be set to your [nuget.org](https://www.nuget.org) *username* (not your email address). Given that it's public information anyway, storing it in a secret seems a tad overkill, but why not ðŸ˜„\n\n![Add the NUGET_USER name to your repo](/content/images/2025/trusted_publishing.png)\n\nIf you run this workflow now, the `NuGet login` step will fail with an error like the following:\n\n``` Requesting GitHub OIDC token from: https://run-actions-1-azure-eastus.actions.githubusercontent.com/100//idtoken/aae150a5-757c-411a-b2b0-f82a9b26401f/1943e299-9d47-50e7-8d56-90681c654f24?api-version=2.0&audience=https%3A%2F%2Fwww.nuget.org Error: Token exchange failed (401): No matching trust policy owned by user '***' was found.\n\n```\n\nAs you can see from the message, the stage failed because we haven't yet configured a trust policy on [nuget.org](https://www.nuget.org), so that's our next job.\n\n### Configuring a trust policy on NuGet.org\n\nConfiguring a trust policy is very easy. We start by signing in at [nuget.org](https://www.nuget.org/) and navigating to [the Trusted Publishing page](https://www.nuget.org/account/trustedpublishing):\n\n![The Trusted Publishing page is available in the account menu](/content/images/2025/trusted_publishing_02.png)\n\nClick **Create** to create a new policy, and fill in all the required fields:\n\n- A name for the policy. I think it makes sense to be the name of the package/github repo.\n- The package owner (whether it's an individual account or an organisation)\n- The GitHub repository details (owner and repository)\n- The workflow file that will be pushing to Nuget\n\nYou can see how I completed this for my sleep-pc tool below:\n\n![The configured details for the sleep-pc tool](/content/images/2025/trusted_publishing_03.png)\n\nOnce you've created the trust policy, it exists in a \"partially\" active state until you *use* the policy\n\n![The partially active policy](/content/images/2025/trusted_publishing_04.png)\n\nNow if you run the workflow again the login step is successful:\n\n``` Requesting GitHub OIDC token from: https://run-actions-1-azure-eastus.actions.githubusercontent.com/73//idtoken/21d84c5d-b6a5-49e0-bc04-e46694e083df/b3fac26f-8847-5e96-b7ae-47d656a98f51?api-version=2.0&audience=https%3A%2F%2Fwww.nuget.org Successfully exchanged OIDC token for NuGet API key.\n\n```\n\nand the policy has changed to be fully active:\n\n![The fully active policy](/content/images/2025/trusted_publishing_05.png)\n\nAssuming everything else goes to plan, in the next step your package will be published to NuGet, no long-lived API keys required ðŸŽ‰\n\n## Wrapping up\n\nAs far as I can tell, as of today, there's no additional benefits from using trusted publishing on [nuget.org](https://www.nuget.org), aside from the ease of publishing, and the lack of long-lived credentials. I can certainly foresee additional benefits in the future, with packages pushed via trusted publishing having additional verification marks. For example, maybe there will be some [tie-in to provenance attestations](/creating-provenance-attestations-for-nuget-packages-in-github-actions/) in the future? I guess we'll wait and see!\n\n## Summary\n\nIn this post I discussed [Trusted Publishing](https://repos.openssf.org/trusted-publishers-for-all-package-repositories) and how it can help by avoiding the need to store long-lived credentials in your GitHub repositories. I then showed how I configured publishing of my sleep-pc package from my [GitHub repository](https://github.com/andrewlock/sleep-pc) to [nuget.org](https://www.nuget.org/packages/sleep-pc) using Trusted Publishing.\n\n## Tags\n\nAndrew Lock | .Net Escapades\n\n![](/assets/img/icons/apple/apple-touch-icon-180x180.png) Want an email when there's new posts?\n\nStay up to the date with the latest posts!\n\nOops! Check your details and try again.\n\nThanks! Check your email for confirmation.",
  "ProcessedDate": "2025-09-30 11:03:19",
  "Description": "In this post I describe how you can use nuget.org's new Trusted Publishing feature to publish NuGet packages from a GitHub Actions workflow",
  "FeedUrl": "https://andrewlock.net/rss.xml",
  "Tags": [
    "DevOps",
    "GitHub",
    "NuGet",
    "Security"
  ],
  "Author": "Andrew Lock"
}
