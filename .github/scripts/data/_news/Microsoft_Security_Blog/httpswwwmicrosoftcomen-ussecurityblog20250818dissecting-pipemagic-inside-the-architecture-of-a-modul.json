{
  "FeedLevelAuthor": "Microsoft Security Blog",
  "Tags": [],
  "ProcessedDate": "2025-08-18 16:15:04",
  "Link": "https://www.microsoft.com/en-us/security/blog/2025/08/18/dissecting-pipemagic-inside-the-architecture-of-a-modular-backdoor-framework/",
  "EnhancedContent": "Among the plethora of advanced attacker tools that exemplify how threat actors continuously evolve their tactics, techniques, and procedures (TTPs) to evade detection and maximize impact, PipeMagic, a highly modular backdoor used by Storm-2460 masquerading as a legitimate open-source [ChatGPT Desktop Application](https://github.com/lencx/ChatGPT), stands out as particularly advanced.\n\nBeneath its disguise, PipeMagic is a sophisticated malware framework designed for flexibility and persistence. Once deployed, it can dynamically execute payloads while maintaining robust command-and-control (C2) communication via a dedicated networking module. As the malware receives and loads payload modules from C2, it grants the threat actor granular control over code execution on the compromised host. By offloading network communication and backdoor tasks to discrete modules, PipeMagic maintains a modular, stealthy, and highly extensible architecture, making detection and analysis significantly challenging.\n\nMicrosoft Threat Intelligence encountered PipeMagic as part of research on an attack chain involving the [exploitation of CVE-2025-29824](https://www.microsoft.com/en-us/security/blog/2025/04/08/exploitation-of-clfs-zero-day-leads-to-ransomware-activity/), an elevation of privilege vulnerability in Windows Common Log File System (CLFS). We attributed PipeMagic to the financially motivated threat actor Storm-2460, who leveraged the backdoor in targeted attacks to exploit this zero-day vulnerability and deploy ransomware. The observed targets of Storm-2460 span multiple sectors and geographies, including the information technology (IT), financial, and real estate sectors in the United States, Europe, South America, and Middle East. While the impacted organizations remain limited, the use of a zero-day exploit, paired with a sophisticated modular backdoor for ransomware deployment, makes this threat particularly notable.\n\nThis blog provides a comprehensive technical deep dive that adds to public reporting, including by ESET Research and Kaspersky. Our analysis reveals the wide-ranging scope of PipeMagic’s internal architecture, modular payload delivery and execution mechanisms, and encrypted inter-process communication via named pipes.\n\nThe blog aims to equip defenders and incident responders with the knowledge needed to detect, analyze, and respond to this threat with confidence. As malware continues to evolve and become more sophisticated, we believe that understanding threats such as PipeMagic is essential for building resilient defenses for any organization. By exposing the inner workings of this malware, we also aim to disrupt adversary tooling and increase the operational cost for the threat actor, making it more difficult and expensive for them to sustain their campaigns.\n\n## PipeMagic: Technical analysis\n\nPipeMagic has been used by Storm-2460 in multiple instances as part of pre-exploitation activity for attack chains involving CVE-2025-29824. Microsoft Threat Intelligence observed Storm-2460 using the certutil utility to download a file from a legitimate website that was previously compromised to host the threat actor’s malware. The downloaded payload is a malicious MSBuild file that ultimately drops and executes PipeMagic in memory. Once PipeMagic is running, the threat actor performs the CLFS exploit to escalate privileges before launching their ransomware.\n\nThe first stage of the PipeMagic infection execution begins with a malicious in-memory dropper disguised as the open-source [ChatGPT Desktop Application](https://github.com/lencx/ChatGPT) project. The threat actor uses a modified version of the GitHub project that includes malicious code to decrypt and launch an embedded payload in memory.\n\nThe embedded payload is the PipeMagic malware, a modular backdoor that communicates with its C2 server over TCP. Once active, PipeMagic receives payload modules through a named pipe and its C2 server. The malware self-updates by storing these modules in memory using a series of doubly linked lists. These lists serve distinct purposes for staging, execution, and communication, enabling the threat actor to interact and manage the backdoor’s capabilities throughout its lifecycle.\n\n### Internal linked list structures\n\nIn our analysis, we identified the use of four distinct doubly linked list structures, each serving a unique function within the backdoor’s architecture:\n\n- Payload linked list: Stores raw payload modules in each node, representing the initial stage of modular deployment.\n- Execute linked list: Contains payload modules that have been successfully loaded into memory and are ready for execution.\n- Network linked list: Contains networking modules responsible for C2 communication.\n- Unknown linked list: This structure lacks an immediately observable function. Based on behavioral analysis, we hypothesize it is leveraged dynamically by loaded payloads rather than the core backdoor logic itself.\n\nIn the next sections, we will detail how each of these linked lists is populated and utilized as we walk through the malware’s execution flow and capabilities.\n\n### Populating the payload linked list\n\nThe malware uses a doubly linked list structure to manage its payload modules, with each node encapsulating a payload in its raw Windows Portable Executable (PE) format. Before initializing this list, the malware generates a 16-byte random bot identifier unique to the infected host.\n\n![Screenshot of code for bot ID generation](https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/08/Figure1-Bot-ID-generation.webp)*Figure 1. Bot ID generation*\n\nIt then spawns a dedicated thread to establish a named pipe for payload delivery. The pipe is created using the format ‘*\\\\.\\pipe\\1.&lt;Bot ID hex string&gt;*‘, where the bot ID is the randomly generated ID above.\n\n![](https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/08/Figure2-Pipe-name-generation.webp)*Figure 2. Pipe name generation*\n\nA bidirectional named pipe is established, enabling both read and write operations between the malware (acting as the pipe client) and the payload delivery mechanism (pipe server). The malware continuously listens on this pipe, reading incoming payload modules in a loop. For each module, the malware reads the payload’s length from the pipe, allocates memory accordingly, reads the payload content, and adds it to the payload module linked list.\n\n![](https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/08/Figure3-Connecting-and-reading-pipe-data.webp)*Figure 3. Connecting and reading pipe data*\n\nThe structure below represents the layout of the pipe data being delivered to the malware from the pipe server.\n\n```\n\nstruct pipe_data_struct { DWORD module_setup_flag; // add module node (1) or stop reading pipe (2) DWORD module_index; // module index DWORD module_name; // module name DWORD module_body_len; // length of module data DWORD module_body_SHA1_hash; // SHA1 hash of module data BYTE module_body[]; // pointer to module data }; ```\n\nAfter the pipe data is read, the malware extracts the module body and decrypts it using RC4 with the following hardcoded 32-byte key:\n\n```\n\n00000000 7b c6 ea 4b 9d 82 ec d5 fb 31 05 87 b9 8c be 3b |{ÆêK..ìÕû1..¹.¾;| 00000010 b8 f7 c9 f7 29 fa 9e 87 27 41 a9 e3 be 34 4d fa |¸÷É÷)ú..'A©ã¾4Mú| ```\n\nThe malware then computes the SHA-1 hash of the decrypted data and compares it against the hash provided in the pipe data to verify integrity.\n\n![](https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/08/Figure4-Decrypting-module-data-performing-hash-validation.webp)*Figure 4. Decrypting module data and performing hash validation*\n\nUpon successful validation, the malware constructs the following node structure representing the payload module and inserts it at the head of the payload linked list. This same structure is also used later in the execute linked list.\n\n```\n\nstruct __declspec(align(8)) module_node { module_node *next; // next node module_node *prev; // previous node DWORD module_index; // module index DWORD exec_ll_module_index; // module index in the execute linked list BYTE *module_data_ptr; // module pointer DWORD module_data_len; // module length DWORD module_name; // module name int module_entry; // module entrypoint int module_attribute; // attribute (4: aPLib compressed, 8: RC4 encrypted, 12: both) BYTE module_initialized_flag; // initialized flag BYTE *module_hash_ptr; // module SHA1 hash DWORD module_hash_len; // module SHA1 hash length }; ```\n\n![](https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/08/Figure5-Populating-payload-module-with-pipe-data.webp)*Figure 5. Populating payload module with pipe data*\n\nThe malware communicates the result of this operation back to the pipe server using the following response codes:\n\n| **Code** | **Description** | | --- | --- | | 0x0 | Success – module node created and inserted | | 0x1 | Invalid pipe data size | | 0x3 | Failed to create a payload module node | | 0xA | SHA-1 hashing of module data failed | | 0xB | Hash mismatch – integrity check failed |\n\nThis thread remains active throughout the backdoor’s lifecycle, allowing the threat actor to continuously deliver new payloads through the named pipe. The thread only terminates when the malware receives a module setup flag value of *2* in the pipe data, signaling the end of payload delivery.\n\n### Malware configuration\n\nThe malware uses a well-defined configuration structure to manage its operational parameters.\n\nThe outermost configuration is represented by the following structure. It consists of a length field followed by a data buffer of that length:\n\n```\n\nstruct backdoor_config { DWORD config_len; BYTE config_data[config_len]; } ```\n\nIf the *config\\_len* field is the constant *0x5A*, the hardcoded configuration is deemed invalid, and the malware simply operates in local execution mode, communicating exclusively with the loopback interface at *127.0.0[.]1:8082*. This mode is likely used for testing or staging purposes, allowing the malware to simulate C2 interactions without external network dependencies.\n\nThe *config\\_data* field itself contains multiple configuration blocks. Each block follows a consistent internal format:\n\n```\n\nstruct config_block { DWORD block_index; DWORD block_data_len; BYTE block_data[block_data_len]; } ```\n\nThe malware uses the *block\\_index* field to identify and retrieve specific configuration blocks as needed. Below is a breakdown of the known block indices and their corresponding data:\n\n| **Block index** | **Block Description** | **Block data** | | --- | --- | --- | | 1 | C2 config block | aaaaabbbbbbb.eastus.cloudapp.azure[.]com:443 | | 2 | Unknown | 43 | | 3 | Backdoor’s max up time | 172800 | | 4 | Unknown | 120 |\n\nIt’s currently unclear how blocks with indices *2* and *4* are used. These values do not appear to influence the malware’s core functionality. However, they are transmitted to the C2 server alongside system information during the initial connection.\n\nThe data in block index *1* is itself another configuration block. It contains the actual C2 address used by the malware, which is *aaaaabbbbbbb.eastus[.]cloudapp.azure[.]com:443*. This domain has been [disabled by Microsoft](https://www.microsoft.com/en-us/security/blog/2025/04/08/exploitation-of-clfs-zero-day-leads-to-ransomware-activity/).\n\n![](https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/08/Figure6-Extracting-configuration.webp)*Figure 6. Extracting configuration*\n\n### Launching networking module\n\nThe backdoor does not communicate with C2 directly. Instead, it delegates this task to a network module in the network linked list.\n\nFirst, it populates the network linked list with module nodes. Each node contains an executable module responsible for handling C2 communication.\n\nIn the sample analyzed, the network module data is embedded within the backdoor binary. This data is first XOR-decrypted using the following hardcoded 32-byte key, then decompressed using the aPLib compression algorithm.\n\n```\n\n00000000 91 df 5d 0e 9c 64 cd bd c2 46 f2 4b 6b ce 4a dc |.ß]..dÍ½ÂFòKkÎJÜ| 00000010 aa 38 f9 60 0f e4 e4 98 ed 05 46 f1 ca d9 54 c5 |ª8ù`.ää.í.FñÊÙTÅ| ```\n\n![](https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/08/Figure7-Decrypting-network-module-data.webp)*Figure 7. Decrypting network module data*\n\nUsing the decrypted module data, the malware populates the following structure representing a module node in the network linked list.\n\n```\n\nstruct network_module_node { __int64 module_index; // module index in network linked list BYTE *module_base; // pointer to module base __int64 module_size; // module size __int64 module_main_func; // pointer to the main function BYTE *module_entrypoint; // pointer to the module's entry point BYTE terminate_flag; // terminate flag }; ```\n\nOnce the node is initialized and the module is loaded into memory, the malware executes the module’s entry point, passing a pointer to its own main function as a parameter.\n\n![](https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/08/Figure8-Launching-network-modules-entry-point.webp)*Figure 8. Launching network module’s entry point*\n\nIn the network module’s entry point, the module sets its third argument to its actual main function. This allows the backdoor to assign the module’s main function to the *module\\_main\\_func* field in the node structure, allowing the backdoor to call this function directly.\n\n![](https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/08/Figure9-Network-modules-entry-point.webp)*Figure 9. Network module’s entry point*\n\nFinally, the backdoor inserts the module node into the network linked list and invokes its main function, passing the C2 address extracted from the configuration.\n\n![](https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/08/Figure10-Launching-network-modules-main-function.webp)*Figure 10. Launching network module’s main function*\n\n### Network module: Establishing C2 connection\n\nWhen launched by the backdoor, the network module first exports and registers three of its internal functions for use by the backdoor:\n\n- A function to send data to the C2 server over TCP\n- A function that returns the constant value *0x8ca*\n- A function to set a stop signal, instructing both the backdoor and the network module to terminate all C2 communications\n\nThe backdoor uses the first exported function to send data to the C2 server through the network module, rather than handling communication directly.\n\n![](https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/08/Figure11-Network-modules-exported-functions.webp)*Figure 11. Network module’s exported functions*\n\nAfter initialization, the network module begins its communication routine with the C2 server. On each execution, it limits itself to a maximum of five communication attempts with the C2.\n\nOnce a TCP connection is established, the module sends the following HTTP GET request to initiate communication with the C2 server. The path includes a randomly generated 16-character hexadecimal string that is unique for each connection.\n\n```\n\nGET /<random 16 hex characters> HTTP/1.1 Host: aaaaabbbbbbb.eastus.cloudapp.azure[.]com Connection: Upgrade Pragma: no-cache Cache-Control: no-cache User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Upgrade: websocket Origin: aaaaabbbbbbb.eastus.cloudapp.azure[.]com Sec-WebSocket-Version: 13 Accept-Encoding: gzip, deflate, br Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7 Sec-WebSocket-Key: 4nnwIaDMxE5LZ6iNQ4XE3w== Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits ```\n\n![](https://www.microsoft.com/en-us/security/blog/wp-content/uploads/2025/08/Figure12-Setting-up-and-sending-initial-GET-request.webp)*Figure 12. Setting up and sending initial GET request*\n\nOnce a valid response is received from the C2 server, the network module transfers execution back to the backdoor. At this point, the backdoor collects system information and sends it to the C2 server using the network module’s communication function (annotated as *C2\\_send\\_request* in Figure 11).\n\n### System information collection\n\nAfter the C2 connection is successfully established by the network module, the backdoor collects a comprehensive set of system and internal state information to send back to the C2 server:\n\n- Generated bot ID\n- Network module’s index in the network linked list\n- Operating system version\n- Computer name\n- Malware executable name\n- Malware process ID\n- Whether the host belongs to the Network Configuration Operators SID group\n- Domain NetBIOS name\n- Whether the malware is running as a 64-bit process\n- List of all LAN domain groups the host belongs to\n- Integrity level of the malware process\n- User domain name\n- Session ID of the malware process\n- Host’s IP address\n- Malware’s current working directory\n- Data from all nodes in the execute linked list\n- Data from all nodes in the unknown linked list\n\nThis host information is commonly collected by backdoors to be used as the host’s unique identifier when the malware attempts to establish a connection with its C2 server. Once this information is gathered, the PipeMagic backdoor invokes the network module’s communication function to transmit the data to the C2 server over the established TCP socket.\n\nAfter the data is sent, execution is handed back to the network module, which waits for and receives the C2 response.\n\nFinally, the network module transfers control back to the backdoor, passing along the C2 response so the backdoor can proceed with executing its core malicious capabilities.\n\n### Processing C2 response\n\nOnce the backdoor receives a response from the C2 server, it parses the data to extract the outer processing command. This command determines how the backdoor should handle the response and what actions to take next.\n\nBelow is a list of known processing codes and their corresponding functionalities:\n\n| **Processing code** | **Processing data** | **Functionality** | | --- | --- | --- | | 0x1 | Backdoor code and data | Executes core backdoor functionality using modules from the execute and payload linked lists | | 0x3 | Module index | Looks up a module node with the provided index and execute the module code | | 0x5 | A message | Sends the received message back to the C2 server as an acknowledgment or echo | | 0x7 | N/A | Shuts down the network module and stops all C2 communication | | 0x8 | Backdoor code and data | Executes backdoor functionality using modules from the unknown linked list | | 0xA | Module node argument | Invokes all modules in the execute linked list with the specified argument |\n\n### Backdoor capabilities: Execute and payload linked list\n\nAmong all the outer processing commands, processing code *0x1* is the most significant. When this code is received, the associated processing data contains inner backdoor commands and arguments that enable PipeMagic to perform a wide range of backdoor operations.\n\nBelow is a list of known backdoor codes and their corresponding functionalities:\n\n| **Backdoor code** | **Backdoor arguments** | **Functionality** | | --- | --- | --- | | 0x1 | N/A | Retrieves metadata from all module nodes in the payload linked list | | 0x2 | **arg1:** Module index <br>**arg2:** Module data length <br>**arg3:** Module name <br>**arg4:** Module attribute <br>**arg5:** Module SHA1 hash | Inserts a new module node into the payload linked list and initializes it with the provided data; Skips insertion if a matching module (by index and hash) already exists | | 0x3 | **arg1:** Module index <br>**arg2:** Hash flag <br>**arg3:** Write offset <br>**arg4:** Write length <br>**arg5:** Payload data | Locates a module node in the payload linked list using the provided index and writes data at the specified offset; if the hash flag is provided, recomputes and updates the SHA-1 hash after RC4 encryption and aPLib compression (depending on the module’s attribute) | | 0x4 | **arg1:** Module index <br>**arg2:** Read offset <br>**arg3:** Read length | Reads a segment of data from a module node in the payload linked list | | 0x5 | **arg1:** Module index | Deletes a module node from the payload linked list | | 0x6 | **arg1:** Module index <br>**arg2:** Write offset <br>**arg3:** Payload data <br>**arg4:** Write length | Writes data to a module node without updating the SHA-1 hash | | 0x7 | **arg1:** Module index | Retrieves the SHA-1 hash of a module node in the payload linked list | | 0x9 | N/A | Retrieves data from all module nodes in the execute linked list | | 0xA | **arg1:** Module index | Retrieves data from a specific module node in the execute linked list | | 0xB | **arg1:** Payload module index **arg2:** Execute module index **arg3:** Initialization flag | Loads a payload module into memory and binds it to a node in the execute linked list, then invokes its entry point | | 0xC | **arg1:** Module index | Executes the entry point of a module node in the execute linked list | | 0xD | N/A | Retrieves the user’s domain name | | 0xE | N/A | Retrieves the current C2 processing code and data | | 0xF | N/A | Renames the malware executable to “:fuckit” and marks it for self-deletion | | 0x10 | **arg1:** Lower index <br>**arg2:** Upper index | Deletes all module nodes in the payload linked list within the specified index range | | 0x11 | **arg1:** Module name | Deletes a module node in the payload linked list by name instead of index | | 0x13 | N/A | Enumerates all running processes and collects session ID, PID, PPID, creation time, executable path, user domain, and architecture (32-bit or 64-bit) | | 0x14 | **arg1:** Module index <br>**arg2:** New module name <br>**arg3:** Module hash length <br>**arg4:** Module hash <br>**arg5:** Pipe data to send <br>**arg6:** Pipe name <br>**arg7:** Max elapsed time | Replaces a module node in the payload linked list; sends data to a named pipe and parses the response to receive the payload module data | | 0x15 | **arg1:** Module index <br>**arg2:** New module name <br>**arg3:** New module attribute <br>**arg4:** Module hash length <br>**arg5:** Module hash <br>**arg6:** Module data length <br>**arg7:** Module data | Replaces a module node in the payload linked list with a new one; the provided data is RC4-decrypted, aPLib-decompressed, and validated by SHA-1 hash before being added to the payload module node | | 0x16 | N/A | Recollects system information (same as the initial C2 handshake) | | 0x17 | **arg1:** Module index <br>**arg2:** Pipe data 1 <br>**arg3:** Pipe data 2 <br>**arg4:** Max elapsed time <br>**arg5:** Pipe name | Extracts and RC4-encrypts data from a module in the payload linked list; sends it to a named pipe along with the provided pipe data. |\n\nBackdoor results are delivered to C2 over TCP. These inner backdoor codes provide the threat actor with granular control over module management, execution, and system reconnaissance, making PipeMagic a highly modular and extensible backdoor.\n\n### Backdoor capabilities: Unknown linked list\n\nProcessing code *0x8* functions similarly to processing code *0x1* in that it also contains inner backdoor code and data. However, this command is specifically designed to interact with the unknown linked list.\n\nThe purpose of this linked list remains unclear. It does not appear to play a critical role in the malware’s core functionality on the infected system. Below is a list of known backdoor codes associated with this processing command and their corresponding functionalities:\n\n| **Backdoor code** | **Backdoor arguments** | **Functionality** | | --- | --- | --- | | 0x1 | N/A | Retrieves metadata from all module nodes in the unknown linked list | | 0x2 | **arg1:** Module index | Looks up a module node in the unknown linked list and extract its data | | 0x3 | **arg1:** Module index | Deletes a module node from the unknown linked list using the specified index | | 0x7 | **arg1:** Module index <br>**arg2:** New module size | Resizes the data buffer of a module node in the unknown linked list, either expanding or shrinking it based on the provided size |\n\nWhile the exact role of this list remains unclear, its structure and command handling mirror those of the payload and execute linked lists, suggesting it may serve as a staging area or auxiliary buffer for dynamically loaded modules.\n\n## Mitigation and protection guidance\n\nMicrosoft recommends the following mitigations to reduce the impact of activity associated with PipeMagic and Storm-2460:\n\n- Ensure that [tamper protection](https://learn.microsoft.com/defender-endpoint/prevent-changes-to-security-settings-with-tamper-protection#how-do-i-configure-or-manage-tamper-protection) is enabled in Microsoft Defender for Endpoint.\n- Enable [network protection](https://learn.microsoft.com/defender-endpoint/enable-network-protection) in Microsoft Defender for Endpoint.\n- Run [endpoint detection and response (EDR) in block mode](https://learn.microsoft.com/microsoft-365/security/defender-endpoint/edr-in-block-mode) so that Microsoft Defender for Endpoint can block malicious artifacts, even when your non-Microsoft antivirus does not detect the threat or when Microsoft Defender Antivirus is running in passive mode. EDR in block mode works behind the scenes to remediate malicious artifacts that are detected post-breach.\n- Configure [investigation and remediation](https://learn.microsoft.com/microsoft-365/security/defender-endpoint/automated-investigations) in full automated mode to let Microsoft Defender for Endpoint take immediate action on alerts to resolve breaches, significantly reducing alert volume. Use [Microsoft Defender Vulnerability Management](https://security.microsoft.com/vulnerabilities) to assess your current status and deploy any updates that might have been missed.\n- Turn on [cloud-delivered protection](https://learn.microsoft.com/microsoft-365/security/defender-endpoint/configure-block-at-first-sight-microsoft-defender-antivirus) in Microsoft Defender Antivirus or the equivalent for your antivirus product to cover rapidly evolving attacker tools and techniques. Cloud-based machine learning protections block a majority of new and unknown variants.\n\n## Microsoft Defender XDR detections\n\nMicrosoft Defender XDR customers can refer to the list of applicable detections below. Microsoft Defender XDR coordinates detection, prevention, investigation, and response across endpoints, identities, email, apps to provide integrated protection against attacks like the threat discussed in this blog.\n\nCustomers with provisioned access can also use [Microsoft Security Copilot in Microsoft Defender](https://learn.microsoft.com/en-us/defender-xdr/security-copilot-in-microsoft-365-defender) to investigate and respond to incidents, hunt for threats, and protect their organization with relevant threat intelligence.\n\n### Microsoft Defender Antivirus\n\nMicrosoft Defender Antivirus detects this threat as the following malware:\n\n- PipeMagic (Win32/64)\n\n### Microsoft Defender for Endpoint\n\nThe following Microsoft Defender for Endpoint alerts can indicate associated threat activity:\n\n- ‘PipeMagic’ malware was detected\n- ‘PipeMagic’ malware was prevented\n- An active ‘PipeMagic’ malware was blocked\n- An active ‘PipeMagic’ malware process was detected while executing and terminated\n\nThe following alerts might also indicate threat activity related to this threat. Note, however, that these alerts can be also triggered by unrelated threat activity.\n\n- A file or network connection related to a ransomware-linked emerging threat activity group detected\n\n### Microsoft Defender Vulnerability Management\n\nMicrosoft Defender Vulnerability Management surfaces devices that may be affected by the following vulnerabilities used in this threat:\n\n- CVE-2025-29824\n\n## Microsoft Security Copilot\n\nSecurity Copilot customers can use the standalone experience to [create their own prompts](https://learn.microsoft.com/en-us/copilot/security/prompting-security-copilot#create-your-own-prompts) or run the following [pre-built promptbooks](https://learn.microsoft.com/en-us/copilot/security/using-promptbooks) to automate incident response or investigation tasks related to this threat:\n\n- Incident investigation\n- Microsoft User analysis\n- Threat actor profile\n- Threat Intelligence 360 report based on MDTI article\n- Vulnerability impact assessment\n\nNote that some promptbooks require access to plugins for Microsoft products such as Microsoft Defender XDR or Microsoft Sentinel.\n\n## Threat intelligence reports\n\nMicrosoft customers can use the following reports in Microsoft products to get the most up-to-date information about the threat actor, malicious activity, and techniques discussed in this blog. These reports provide the intelligence, protection information, and recommended actions to prevent, mitigate, or respond to associated threats found in customer environments.\n\n### Microsoft Defender XDR Threat analytics\n\n- [Exploitation of CLFS zero-day leads to ransomware activity | Microsoft Security Blog](https://www.microsoft.com/en-us/security/blog/2025/04/08/exploitation-of-clfs-zero-day-leads-to-ransomware-activity/)\n\nMicrosoft Security Copilot customers can also use the [Microsoft Security Copilot integration](https://learn.microsoft.com/defender/threat-intelligence/security-copilot-and-defender-threat-intelligence?bc=%2Fsecurity-copilot%2Fbreadcrumb%2Ftoc.json&amp;toc=%2Fsecurity-copilot%2Ftoc.json#turn-on-the-security-copilot-integration-in-defender-ti) in Microsoft Defender Threat Intelligence, either in the Security Copilot standalone portal or in the [embedded experience](https://learn.microsoft.com/defender/threat-intelligence/using-copilot-threat-intelligence-defender-xdr) in the Microsoft Defender portal to get more information about this threat actor.\n\n## Indicators of compromise\n\n| **Indicator** | **Type** | **Description** | | --- | --- | --- | | aaaaabbbbbbb.eastus.cloudapp.azure[.]com:443 | Domain | PipeMagic’s C2 domain | | dc54117b965674bad3d7cd203ecf5e7fc822423a3f692895cf5e96e83fb88f6a | File SHA-256 hash | In-memory dropper (trojanized ChatGPT desktop application) | | 4843429e2e8871847bc1e97a0f12fa1f4166baa4735dff585cb3b4736e3fe49e | File SHA-256 hash | PipeMagic backdoor (unpacked in memory) | | 297ea881aa2b39461997baf75d83b390f2c36a9a0a4815c81b5cf8be42840fd1 | File SHA-256 hash | PipeMagic network module (unpacked in memory) |\n\n## References\n\n- [https://www.kaspersky.com/about/press-releases/kaspersky-uncovers-pipemagic-backdoor-attacks-businesses-through-fake-chatgpt-application](https://www.kaspersky.com/about/press-releases/kaspersky-uncovers-pipemagic-backdoor-attacks-businesses-through-fake-chatgpt-application)\n- [https://x.com/ESETresearch/status/1899508656258875756](https://x.com/ESETresearch/status/1899508656258875756)\n\n## Learn more\n\nFor the latest security research from the Microsoft Threat Intelligence community, check out the Microsoft Threat Intelligence Blog: [https://aka.ms/threatintelblog](https://aka.ms/threatintelblog).\n\nTo get notified about new publications and to join discussions on social media, follow us on LinkedIn at [https://www.linkedin.com/showcase/microsoft-threat-intelligence](https://www.linkedin.com/showcase/microsoft-threat-intelligence), and on X (formerly Twitter) at [https://x.com/MsftSecIntel](https://x.com/MsftSecIntel).\n\nTo hear stories and insights from the Microsoft Threat Intelligence community about the ever-evolving threat landscape, listen to the Microsoft Threat Intelligence podcast: [https://thecyberwire.com/podcasts/microsoft-threat-intelligence](https://thecyberwire.com/podcasts/microsoft-threat-intelligence).",
  "Title": "Dissecting PipeMagic: Inside the architecture of a modular backdoor framework",
  "PubDate": "2025-08-18T15:00:00+00:00",
  "FeedUrl": "https://www.microsoft.com/en-us/security/blog/feed/",
  "Description": "A comprehensive technical deep dive on PipeMagic, a highly modular backdoor used by Storm-2460 masquerading as a legitimate open-source ChatGPT Desktop Application. Beneath its disguise, PipeMagic is a sophisticated malware framework designed for flexibility and persistence. Once deployed, it can dynamically execute payloads while maintaining robust command and control (C2) communication via a dedicated networking module.\n\nThe post [Dissecting PipeMagic: Inside the architecture of a modular backdoor framework](https://www.microsoft.com/en-us/security/blog/2025/08/18/dissecting-pipemagic-inside-the-architecture-of-a-modular-backdoor-framework/) appeared first on [Microsoft Security Blog](https://www.microsoft.com/en-us/security/blog).",
  "Author": "Microsoft Threat Intelligence",
  "OutputDir": "_news",
  "FeedName": "Microsoft Security Blog"
}
