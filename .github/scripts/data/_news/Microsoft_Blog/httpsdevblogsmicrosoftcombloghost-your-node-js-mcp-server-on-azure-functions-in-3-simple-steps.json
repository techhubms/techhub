{
  "OutputDir": "_news",
  "FeedLevelAuthor": "Microsoft for Developers",
  "Description": "Building AI agents with the Model Context Protocol (MCP) is powerful, but when it comes to hosting your MCP server in production, you need a solution that‚Äôs reliable, scalable, and cost-effective. What if you could deploy your regular Node.js MCP server to a serverless platform that handles scaling automatically while you only pay for what [‚Ä¶]\n\nThe post [Host Your Node.js MCP Server on Azure Functions in 3 Simple Steps](https://devblogs.microsoft.com/blog/host-your-node-js-mcp-server-on-azure-functions-in-3-simple-steps) appeared first on [Microsoft for Developers](https://devblogs.microsoft.com).",
  "ProcessedDate": "2025-12-08 18:03:09",
  "FeedName": "Microsoft Blog",
  "Author": "Yohan Lasorsa",
  "Tags": [
    "Azure",
    "MCP"
  ],
  "PubDate": "2025-12-08T18:00:54+00:00",
  "EnhancedContent": "Building AI agents with the Model Context Protocol (MCP) is powerful, but when it comes to hosting your MCP server in production, you need a solution that‚Äôs reliable, scalable, and cost-effective. What if you could deploy your regular Node.js MCP server to a serverless platform that handles scaling automatically while you only pay for what you use?\n\nLet‚Äôs explore how Azure Functions now supports hosting MCP servers built with the official Anthropic MCP SDK, giving you serverless scaling with almost no changes in your code.\n\nGrab your favorite hot beverage, and let‚Äôs dive in!\n\n## TL;DR key takeaways\n\n- Azure Functions now supports hosting Node.js MCP servers using the official Anthropic SDK\n- Only 3 simple configurations needed: `host.json`\n, port configuration, and `function.json`\n- Currently supports HTTP Streaming protocol with stateless servers\n- Serverless hosting means automatic scaling and pay-per-use pricing\n- Deploy with one command using Infrastructure as Code\n\n## What will you learn here?\n\n- Understand how MCP servers work on Azure Functions\n- Configure a Node.js MCP server for Azure Functions hosting\n- Test your MCP server locally and with real AI agents\n- Deploy your MCP server with Infrastructure as Code and AZD\n\n## Reference links for everything we use\n\n- [Model Context Protocol](https://modelcontextprotocol.io/) ‚Äì Official MCP documentation\n- [Azure Functions](https://learn.microsoft.com/azure/azure-functions/functions-overview) ‚Äì Serverless compute platform\n- [Anthropic MCP SDK](https://github.com/modelcontextprotocol/typescript-sdk) ‚Äì Official TypeScript SDK\n- [Azure Developer CLI](https://learn.microsoft.com/azure/developer/azure-developer-cli/overview) ‚Äì One-command deployment tool\n- [Full sample project](https://github.com/Azure-Samples/mcp-agent-langchainjs) ‚Äì Complete burger ordering system with MCP\n- [Simple example](https://github.com/Azure-Samples/mcp-sdk-functions-hosting-node) ‚Äì Minimal MCP server starter\n- [GitHub Copilot prompt helper](https://github.com/anthonychu/create-functions-mcp-server) ‚Äì Automated setup by Anthony Chu\n\n## Requirements\n\n- Node.js 22 or higher\n- [Azure account](https://azure.microsoft.com/free) (free signup, or if you‚Äôre a student, [get free credits here](https://azure.microsoft.com/free/students))\n- [Azure Developer CLI](https://aka.ms/azure-dev/install) (for deployment)\n- [GitHub account](https://github.com/signup) (optional, for using Codespaces)\n\n## What is MCP and why does it matter?\n\nModel Context Protocol is an open standard that enables AI models to securely interact with external tools and data sources. Instead of hardcoding tool integrations, you build an MCP server that exposes capabilities (like browsing a menu, placing orders, or querying a database) as tools that any MCP-compatible AI agent can discover and use. MCP is model-agnostic, meaning it can work with any LLM that supports the protocol, including models from Anthropic, OpenAI, and others. It‚Äôs also worth noting that MCP supports more than just tool calls, though that‚Äôs its most common use case.\n\n[![mcp schema image](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAtAAAAGkAQMAAAAiwoCVAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAPElEQVR4nO3BgQAAAADDoPlTH+ECVQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8A5VMAAH9kv9VAAAAAElFTkSuQmCC)](https://devblogs.microsoft.com/wp-content/uploads/2025/12/mcp-schema-1.webp)\n\nThe challenge? **Running MCP servers in production requires infrastructure**. You need to handle scaling, monitoring, and costs. That‚Äôs where Azure Functions comes in.\n\n>\n> **üö® Free course alert!** If you‚Äôre new to MCP, check out the [MCP for Beginners](https://github.com/microsoft/mcp-for-beginners) course to get up to speed quickly.\n>\n\n## Why Azure Functions for MCP servers?\n\nAzure Functions is a serverless compute platform that‚Äôs perfect for MCP servers:\n\n- **Zero infrastructure management**: No servers to maintain\n- **Automatic scaling**: Handles traffic spikes seamlessly\n- **Cost-effective**: Pay only for actual execution time (with generous free tier)\n- **Built-in monitoring**: Application Insights integration out of the box\n- **Global distribution**: Deploy to regions worldwide\n\nThe new Azure Functions support means you can take your existing Node.js MCP server and deploy it to a production-ready serverless environment with minimal changes. This comes up as an additional option for native Node.js MCP hosting, but you can still use the [Azure Functions MCP bindings](https://learn.microsoft.com/azure/azure-functions/functions-bindings-mcp?pivots=programming-language-typescript) that were available before.\n\n## 3 simple steps to enable Functions hosting\n\nLet‚Äôs break down what you need to add to your existing Node.js MCP server to run it on Azure Functions. I‚Äôll use a [real-world example](https://github.com/Azure-Samples/mcp-agent-langchainjs/tree/main/packages/burger-mcp) from our burger ordering system.\n\nIf you already have a working Node.js MCP server, you can just follow these three steps to make it compatible with Azure Functions hosting.\n\n### Step 1: Add the `host.json`\nconfiguration\n\nCreate a `host.json` file at the root of your Node.js project:\n\n```json { \"version\": \"2.0\", \"extensions\": { \"http\": { \"routePrefix\": \"\" } }, \"customHandler\": { \"description\": { \"defaultExecutablePath\": \"node\", \"workingDirectory\": \"\", \"arguments\": [\"lib/server.js\"] }, \"enableForwardingHttpRequest\": true, \"enableHttpProxyingRequest\": true } } ```\n\n>\n> **Note:** Adjust the `arguments`\n> array to point to your compiled server file (e.g., `lib/server.js`\n> or `dist/server.js`\n> ), depending on your build setup.\n>\n\nThe `hosts.json` file holds [metadata configuration](https://learn.microsoft.com/azure/azure-functions/functions-host-json) for the Functions runtime. The most important part here is the `customHandler` section. It configures the Azure Functions runtime to run your Node.js MCP server as a *custom handler*, which allows you to use any HTTP server framework (like Express, Fastify, etc.) without modification (**tip: it can do more than MCP servers!** üòâ).\n\n### Step 2: Configure the port correctly\n\nIn your server code, use the special environment variable that Azure Functions provides:\n\n```typescript const PORT = process.env.FUNCTIONS_CUSTOMHANDLER_PORT || process.env.PORT || 3000;\n\napp.listen(PORT, () => { console.log(`MCP server listening on port ${PORT}`); }); ```\n\nWhile most applications use the `PORT` environment variable, Azure Functions requires `FUNCTIONS_CUSTOMHANDLER_PORT` for custom handlers. This can usually be easily accommodated with a fallback, so you‚Äôre not breaking compatibility with local development or other hosting environments.\n\n**Note:** This is the only code change you need to make to your existing MCP server!\n\n### Step 3: Add the `handler/function.json`\nfile\n\nCreate a `handler` directory with a `function.json` file and add the following content:\n\n```json { \"bindings\": [ { \"authLevel\": \"anonymous\", \"type\": \"httpTrigger\", \"direction\": \"in\", \"name\": \"req\", \"methods\": [\"get\", \"post\", \"put\", \"delete\", \"patch\", \"head\", \"options\"], \"route\": \"{*route}\" }, { \"type\": \"http\", \"direction\": \"out\", \"name\": \"res\" } ] } ```\n\nThis file tells Azure Functions to route **all** HTTP requests to your MCP server. No configuration needed here, and this boilerplate file might even not be necessary in future versions.\n\nAaand you‚Äôre done with the configuration. That‚Äôs it! üòé\n\n>\n> **Note:** We‚Äôre not covering the authentication and authorization aspects of Azure Functions here, but you can easily [add those later if needed](https://learn.microsoft.com/azure/app-service/overview-authentication-authorization).\n>\n\n### Automated setup with GitHub Copilot\n\nWhile these changes are pretty straightforward, you might want to automate this (boring) process. That‚Äôs why we have AI tools for, right?\n\nMy friend Anthony Chu created an awesome GitHub Copilot prompt that automates this entire setup process. Just ask Copilot to use the prompt from [create-functions-mcp-server](https://github.com/anthonychu/create-functions-mcp-server) and it will:\n\n- Add the necessary configuration files\n- Update the code where needed for the port configuration\n- Set up the Infrastructure as Code\n\nIf you‚Äôre not using Copilot, you can also copy the prompt instructions from the repo in your favorite AI coding assistant.\n\n## Real-world example: Burger MCP Server\n\nLet‚Äôs look at how this works in practice with a [burger ordering MCP server](https://github.com/Azure-Samples/mcp-agent-langchainjs/tree/main/packages/burger-mcp). This server exposes 9 tools for AI agents to interact with a burger API:\n\n- `get_burgers`\n‚Äì Browse the menu\n- `get_burger_by_id`\n‚Äì Get burger details\n- `place_order`\n‚Äì Place an order\n- `get_orders`\n‚Äì View order history\n- And more‚Ä¶\n\nHere‚Äôs the complete server implementation using Express and the MCP SDK:\n\n```typescript import express, { Request, Response } from 'express'; import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js'; import { getMcpServer } from './mcp.js';\n\nconst app = express(); app.use(express.json());\n\n// Handle all MCP Streamable HTTP requests app.all('/mcp', async (request: Request, response: Response) => { const transport = new StreamableHTTPServerTransport({ sessionIdGenerator: undefined, });\n\n// Connect the transport to the MCP server const server = getMcpServer(); await server.connect(transport);\n\n// Handle the request with the transport await transport.handleRequest(request, response, request.body);\n\n// Clean up when the response is closed response.on('close', async () => { await transport.close(); await server.close(); });\n\n// Note: error handling not shown for brevity });\n\n// The magic port configuration const PORT = process.env.FUNCTIONS_CUSTOMHANDLER_PORT || process.env.PORT || 3000; app.listen(PORT, () => { console.log(`Burger MCP server listening on port ${PORT}`); }); ```\n\nThe MCP tools are defined using the official SDK:\n\n```typescript import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'; import { z } from 'zod';\n\nexport function getMcpServer() { const server = new McpServer({ name: 'burger-mcp', version: '1.0.0', });\n\nserver.registerTool( 'get_burgers', { description: 'Get a list of all burgers in the menu' }, async () => { const response = await fetch(`${burgerApiUrl}/burgers`); const burgers = await response.json(); return { content: [{ type: 'text', text: JSON.stringify(burgers, null, 2) }] }; } );\n\n// ... more tools return server; } ```\n\nAs you can see, the actual implementation of the tool is forwarding an HTTP request to the burger API and returning the result in the MCP response format. This is a common pattern for MCP tools in enterprise contexts, that act as wrappers around one or more existing APIs.\n\n### Current limitations\n\nNote that this Azure Functions MCP hosting currently has some limitations: **it only supports stateless servers using the HTTP Streaming protocol**. The legacy SSE protocol is not supported as it requires stateful connections, so you‚Äôll either have to migrate your client to use HTTP Streaming or use another hosting option, like using containers for example.\n\nFor most use cases, HTTP Streaming is the recommended approach anyway as it‚Äôs more scalable and doesn‚Äôt require persistent connections. Stateful MCP servers comes with additional complexity challenges and have limited scalability if you need to handle many concurrent connections.\n\n## Testing the MCP server locally\n\nFirst let‚Äôs run the MCP server locally and play a bit with it.\n\nIf you don‚Äôt want to bother with setting up a local environment, you can use the following link or open it in a new tab to launch a GitHub Codespace:\n\n- [Create Codespace](https://codespaces.new/Azure-Samples/mcp-agent-langchainjs?hide_repo_select=true&amp;ref=main&amp;quickstart=true)\n\nThis will open a VS Code environment in your browser with the repo already cloned and all the tools installed and ready to go. Otherwise you can just [clone the repo](https://github.com/Azure-Samples/mcp-agent-langchainjs).\n\nOnce you have the code ready, open a terminal and run:\n\n```sh\n# Install dependencies\nnpm install\n\n# Start the burger MCP server and API\nnpm start ```\n\nThis will start multiple services locally, including the Burger API and the MCP server, which will be available at `http://localhost:3000/mcp` . This may take a few seconds, wait until you see this message in the terminal:\n\n``` üöÄ All services ready üöÄ ```\n\nWe‚Äôre only interested in the MCP server for now, so let‚Äôs focus on that.\n\n### Using MCP Inspector\n\nThe easiest way to test the MCP server is with the MCP Inspector tool:\n\n```sh npx -y @modelcontextprotocol/inspector ```\n\nOpen the URL shown in the console in your browser, then:\n\n1. Set transport type to **Streamable HTTP**\n2. Enter your local server URL: `http://localhost:3000/mcp`\n3. Click **Connect**\n\nAfter you‚Äôre connected, go to the **Tools** tab to list available tools. You can then try the `get_burgers` tool to see the burger menu.\n\n[![mcp inspector image](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABAAAAAGAAQMAAAAJW4K/AAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAARklEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7wbBgAABSpssbwAAAABJRU5ErkJggg==)](https://devblogs.microsoft.com/wp-content/uploads/2025/12/mcp-inspector-scaled.webp)\n\n### Using GitHub Copilot (with remote MCP)\n\nConfigure GitHub Copilot to use your deployed MCP server by adding this to your project‚Äôs `.vscode/mcp.json` :\n\n```json { \"servers\": { \"burger-mcp\": { \"type\": \"http\", \"url\": \"http://localhost:3000/mcp\" } } } ```\n\nClick on ‚ÄúStart‚Äù button that will appear in the JSON file to activate the MCP server connection.\n\nNow you can use Copilot in agent mode and ask things like:\n\n- ‚ÄúWhat spicy burgers do you have?‚Äù\n- ‚ÄúPlace an order for two cheeseburgers‚Äù\n- ‚ÄúShow my recent orders‚Äù\n\nCopilot will automatically discover and use the MCP tools! üéâ\n\n>\n> **Tip:** If Copilot doesn‚Äôt call the burger MCP tools, try checking if it‚Äôs enabled by clicking on the tool icon in the chat input box and ensuring that ‚Äúburger-mcp‚Äù is selected. You can also force tool usage by adding `#burger-mcp`\n> in your prompt.\n>\n\n## (Bonus) Deploying to Azure with Infrastructure as Code\n\nDeploying an application to Azure is usually not the fun part, especially when it involves multiple resources and configurations. With the [Azure Developer CLI (AZD)](https://learn.microsoft.com/azure/developer/azure-developer-cli/overview), you can define your entire application infrastructure and deployment process as code, and deploy everything with a single command.\n\nIf you‚Äôve used the automated setup with GitHub Copilot, you should already have the necessary files. Our burger example also comes with these files pre-configured. The MCP server is defined as a service in `azure.yaml` , and the files under the `infra` folder defines the Azure Functions app and related resources.\n\nHere‚Äôs the relevant part of `azure.yaml` that defines the burger MCP service:\n\n```yaml name: mcp-agent-langchainjs\n\nservices: burger-mcp: project: ./packages/burger-mcp language: ts host: function ```\n\nWhile the infrastructure files can look intimidating at first, you don‚Äôt need to understand all the details to get started. There are tons of templates and examples available to help you get going quickly, the important part is that everything is defined as code, so you can version control it and reuse it.\n\nNow let‚Äôs deploy:\n\n```sh\n# Login to Azure\nazd auth login\n\n# Provision resources and deploy\nazd up ```\n\nPick your preferred Azure region when prompted (if you‚Äôre not sure, choose **East US2**), and voil√†! In a few minutes, you‚Äôll have a fully deployed MCP server running on Azure Functions.\n\nOnce the deployment is finished, the CLI will show you the URL of the deployed resources, including the MCP server endpoint.\n\n![AZD deployment output for the burger MCP example app](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAACRwAAAMWAQMAAACj/UqpAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAA90lEQVR4nO3BgQAAAADDoPlTX+EAVQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8BuIWwABavVX4QAAAABJRU5ErkJggg==)\n\n## Example projects\n\nThe burger MCP server is actually part of a larger example project that demonstrates building an AI agent with LangChain.js, that uses the burger MCP server to place orders. If you‚Äôre interested in the next steps of building an AI agent on top of MCP, this is a great resource as it includes:\n\n- AI agent web API using LangChain.js\n- Web app interface built with Lit web components\n- MCP server on Functions (the one we just saw)\n- Burger ordering API (used by the MCP server)\n- Live order visualization\n- Complete Infrastructure as Code, to deploy everything with one command\n\nBut if you‚Äôre only interested in the MCP server part, then you might want to look at this simpler example that you can use as a starting point for your own MCP servers: [mcp-sdk-functions-hosting-node](https://github.com/Azure-Samples/mcp-sdk-functions-hosting-node) is a server template for a Node.js MCP server using TypeScript and MCP SDK.\n\n## What about the cost?\n\nAzure Functions Flex Consumption pricing is attractive for MCP servers:\n\n- **Free tier**: 1 million requests and 400,000 GB-s execution time per month\n- **After free tier**: Pay only for actual execution time\n- **Automatic scaling**: From zero to hundreds of instances\n\nThe free tier is generous enough to allow running a typical MCP server with moderate usage, and all the experimentation you might need. It‚Äôs easy to configure the scaling limits to control costs as needed, with an option to scale down to zero when idle. This flexibility is why Functions is my personal go-to choice for TypeScript projects on Azure.\n\n## Wrap up\n\nHosting MCP servers on Azure Functions gives you the best of both worlds: the simplicity of serverless infrastructure and the power of the official Anthropic SDK. With just **three simple configuration steps**, you can take your existing Node.js MCP server and deploy it to a production-ready, auto-scaling platform.\n\nThe combination of MCP‚Äôs standardized protocol and Azure‚Äôs serverless platform means you can focus on building amazing AI experiences instead of managing infrastructure. Boom. üòé\n\nStar the repos ‚≠êÔ∏è if you found this helpful! Try deploying your own MCP server and share your experience in the comments. If you run into any issues or have questions, you can reach for help on the [Azure AI community on Discord](https://aka.ms/foundry/discord).",
  "Link": "https://devblogs.microsoft.com/blog/host-your-node-js-mcp-server-on-azure-functions-in-3-simple-steps",
  "Title": "Host Your Node.js MCP Server on Azure Functions in 3 Simple Steps",
  "FeedUrl": "https://devblogs.microsoft.com/feed"
}
