{
  "PubDate": "2025-03-19T16:00:24+00:00",
  "EnhancedContent": "Software development is filled with repetitive tasks‚Äîmanaging issues, handling approvals, triggering CI/CD workflows, and more. But what if you could automate these types of tasks directly within GitHub Issues? That‚Äôs the promise of **IssueOps**, a methodology that turns GitHub Issues into a command center for automation.\n\nWhether you‚Äôre a solo developer or part of an engineering team, IssueOps helps you streamline operations without ever leaving your repository.\n\nIn this article, I‚Äôll explore the concept of IssueOps using state-machine terminology and strategies to help you work more efficiently on GitHub. After all, who doesn‚Äôt love automation?\n\n## What is IssueOps?\n\nIssueOps is the practice of using GitHub Issues, GitHub Actions, and pull requests (PR) as an interface for automating workflows. Instead of switching between tools or manually triggering actions, you can use issue comments, labels, and state changes to kick off CI/CD pipelines, assign tasks, and even deploy applications.\n\nMuch like the various other *\\*Ops* paradigms ([ChatOps](https://github.blog/engineering/infrastructure/using-chatops-to-help-actions-on-call-engineers/), ClickOps, and so on), IssueOps is a collection of tools, workflows, and concepts that, when applied to [GitHub Issues](https://github.com/features/issues), can automate mundane, repetitive tasks. The flexibility and power of issues, along with their relationship to pull requests, create a near limitless number of possibilities, such as managing approvals and deployments. All of this can really help to simplify your workflows on GitHub. I‚Äôm speaking from personal experience here.\n\nIt‚Äôs important to note that IssueOps isn‚Äôt just a DevOps thing! Where DevOps offers a methodology to bring developers and operations into closer alignment, IssueOps is a workflow automation practice centered around GitHub Issues. IssueOps lets you run anything from [complex CI/CD pipelines](https://github.blog/engineering/engineering-principles/enabling-branch-deployments-through-issueops-with-github-actions/) to a [bed and breakfast reservation system](https://github.com/issue-ops/bear-creek-honey-farm). If you can interact with it via an API, there‚Äôs a good chance you can build it with IssueOps!\n\n## So, why use IssueOps?\n\nThere are lots of benefits to utilizing IssueOps. Here‚Äôs how it‚Äôs useful in practice:\n\n- **It‚Äôs event driven, so you can automate the boring stuff:** IssueOps lets you automate workflows directly from GitHub Issues and pull requests, turning everyday interactions‚Äîfrom kicking off a CI/CD pipeline and managing approvals to updating project boards‚Äîinto powerful triggers for GitHub Actions.\n- **It‚Äôs customizable, so you can tailor workflows to your needs:** No two teams work the same way, and IssueOps is flexible enough to adapt. Whether you‚Äôre automating bug triage or triggering deployments, you can customize workflows based on event type and data provided.\n- **It‚Äôs transparent, so you can keep a record:** All actions taken on an issue are logged in its timeline, creating an easy-to-follow record of what happened and when.\n- **It‚Äôs immutable, so you can audit whenever you need:** Because IssueOps uses GitHub Issues and pull requests as a source of truth, every action leaves a record. No more chasing approvals in Slack or manually triggering workflows: IssueOps keeps everything structured, automated, and auditable right inside GitHub.\n\n## Defining IssueOps workflows and how they‚Äôre like finite-state machines\n\nMost IssueOps workflows follow the same basic pattern:\n\n1. A user opens an issue and provides information about a request\n2. The issue is validated to ensure it contains the required information\n3. The issue is submitted for processing\n4. Approval is requested from an authorized user or team\n5. The request is processed and the issue is closed\n\nSuppose you‚Äôre an administrator of an organization and want to reduce the overhead of managing team members. In this instance, you could use IssueOps to build an automated membership request and approval process. Within a workflow like this, you‚Äôd have several core steps:\n\n1. A user creates a request to be added to a team\n2. The request is validated\n3. The request is submitted for approval\n4. An administrator approves or denies this request\n5. The request is processed\n1. If *approved*, the user is added to the team\n2. If *denied*, the user is not added to the team\n6. The user is notified of the outcome\n\nWhen designing your own IssueOps workflows, it can be very helpful to think of them as a [finite-state machine](https://web.stanford.edu/class/cs123/lectures/CS123_lec07_Finite_State_Machine.pdf): a model for how objects move through a series of states in response to external events. Depending on certain rules defined within the state machine, a number of different actions can take place in response to state changes. If this is a little too complex, you can also think of it like a flow chart.\n\nTo apply this comparison to IssueOps, an issue is the *object* that is processed by a state machine. It changes *state* in response to *events*. As the object changes state, certain *actions* may be performed as part of a *transition*, provided any required conditions (*guards*) are met. Once an *end state* is reached, the issue can be closed.\n\nThis breaks down into a few key concepts:\n\n- **State**: A point in an object‚Äôs lifecycle that satisfies certain condition(s).\n- **Event**: An external occurrence that triggers a state change.\n- **Transition**: A link between two states that, when traversed by an object, will cause certain action(s) to be performed.\n- **Action**: An atomic task that is performed when a transition is taken.\n- **Guard**: A condition that is evaluated when a trigger event occurs. A transition is taken only if all associated guard condition(s) are met.\n\nHere‚Äôs a simple state diagram for the example I discussed above.\n\n![A state diagram featuring a request approval process driven by an IssueOps workflow on GitHub. This workflow uses a combination of GitHub Issues and GitHub Actions to automate how team members are added to a given project. ](https://github.blog/wp-content/uploads/2025/03/state-machine.png?resize=916%2C1588)\n\nNow, let‚Äôs dive into the state machine in more detail!\n\n## Key concepts behind state machines\n\nThe benefit of breaking your workflow down into these components is that you can look for edge cases, enforce conditions, and create a robust, reliable result.\n\n### **States**\n\nWithin a state machine, a *state* defines the current status of an object. As the object transitions through the state machine, it will change states in response to external events. When building IssueOps workflows, common states for issues include opened, submitted, approved, denied, and closed.\n\nThese should suffice as the core states to consider when building our workflows in our team membership example above.\n\n### **Events**\n\nIn a state machine, an *event* can be any form of interaction with the object and its current state. When building your own IssueOps, you should consider events from both the user and GitHub points of view.\n\nIn our team membership request example, there are several events that can trigger a change in state. The request can be created, submitted, approved, denied, or processed.\n\nIn this example, a user interacting with an issue‚Äîsuch as adding labels, commenting, or updating milestones‚Äîcan also change its state. In GitHub Actions, there are many events that can trigger your workflows (see [events that trigger workflows](https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows)).\n\nHere are a few interactions, or events, that would affect our example IssueOps workflow when it comes to managing team members:\n\n| **Request** | **Event** | **State** | | --- | --- | --- | | Request is created | `issues` | `opened` | | Request is approved | `issue_comment` | `created` | | Request is denied | `issue_comment` | `created` |\n\nAs you can see, the same GitHub workflow trigger can apply to multiple events in our state machine. Because of this, validation is key. Within your workflows, you should check both the type of event and the information provided by the user. In this case, we can conditionally trigger different workflow steps based on the content of the `issue_comment` event.\n\n```plaintext jobs: approve: name: Process Approval runs-on: ubuntu-latest\n\nif: ${{ startsWith(github.event.comment.body, '.approve') }}\n\n# ...\n\ndeny: name: Process Denial runs-on: ubuntu-latest\n\nif: ${{ startsWith(github.event.comment.body, '.deny') }}\n\n# ...\n\n```\n\n### Transitions\n\nA *transition* is simply the change from one state to another. In our example, for instance, a transition occurs when someone opens an issue. When a request meets certain conditions, or guards, the change in state can take place. When the transition occurs, some actions or processing may take place, as well.\n\nWith our example workflow, you can think of the transitions themselves as the lines connecting different nodes in the state diagram. Or the lines connecting boxes in a flow chart.\n\n### Guards\n\n*Guards* are conditions that must be verified before an event can trigger a transition to a different state. In our case, we know the following guards must be in place:\n\n- A request should not transition to an Approved state unless an administrator comments `.approve`\non the issue.\n- A request should not transition to a Denied state unless an administrator comments `.deny`\non the issue.\n\nWhat about after the request is approved and the user is added to the team? This is referred to as an *unguarded transition*. There are no conditions that must be met, so the transition happens immediately!\n\n### **Actions**\n\nLastly, *actions* are specific tasks that are performed during a transition. They may affect the object itself, but this is not a requirement in our state machine. In our example, the following actions may take place at different times:\n\n- Administrators are notified that a request has been submitted\n- The user is added to the requested team\n- The user is notified of the outcome\n\n## A real-world example: Building a team membership workflow with IssueOps\n\nNow that all of the explanation is out of the way, let‚Äôs dive into building our example! For reference, we‚Äôll focus on the GitHub Actions workflows involved in building this automation. There are some additional repository and permissions settings involved that are discussed in more detail [in these IssueOps docs](https://issue-ops.github.io/docs/setup).\n\n### Step 1: Issue form template\n\n[GitHub issue forms](https://docs.github.com/en/communities/using-templates-to-encourage-useful-issues-and-pull-requests/syntax-for-issue-forms) let you create standardized, formatted issues based on a set of form fields. Combined with the [issue-ops/parser](https://github.com/issue-ops/parser) action, you can get reliable, machine-readable JSON from issue body Markdown. For our example, we are going to create a simple form that accepts a single input: the team where we want to add the user.\n\n```plaintext name: Team Membership Request description: Submit a new membership request title: New Team Membership Request labels:\n- team-membership\nbody:\n- type: input\nid: team attributes: label: Team Name description: The team name you would like to join placeholder: my-team validations: required: true\n\n```\n\nWhen issues are created using this form, they will be parsed into JSON, which can then be passed to the rest of the IssueOps workflow.\n\n```plaintext { \"team\": \"my-team\" }\n\n```\n\n### Step 2: Issue validation\n\nWith a machine-readable issue body, we can run additional validation checks to ensure the information provided follows any rules we might have in place. For example, we can‚Äôt automatically add a user to a team if the team doesn‚Äôt exist yet! That is where the [issue-ops/validator](https://github.com/issue-ops/validator) action comes into play. Using an issue form template and a custom validation script, we can confirm the existence of the team ahead of time.\n\n```javascript module.exports = async (field) =&gt; { const { Octokit } = require('@octokit/rest') const core = require('@actions/core')\n\nconst github = new Octokit({ auth: core.getInput('github-token', { required: true }) })\n\ntry { // Check if the team exists core.info(`Checking if team '${field}' exists`)\n\nawait github.rest.teams.getByName({ org: process.env.GITHUB_REPOSITORY_OWNER ?? '', team_slug: field })\n\ncore.info(`Team '${field}' exists`) return 'success' } catch (error) { if (error.status === 404) { // If the team does not exist, return an error message core.error(`Team '${field}' does not exist`) return `Team '${field}' does not exist` } else { // Otherwise, something else went wrong... throw error } } }\n\n```\n\nWhen included in our IssueOps workflow, this adds any validation error(s) to the comment on the issue.\n\n### Step 3: Issue workflows\n\nThe main ‚Äúentrypoint‚Äù of this workflow occurs when a user creates or edits their team membership request issue. This workflow should focus heavily on validating any user inputs! For example, what should happen if the user inputs a team that does not exist?\n\nIn our state machine, this workflow is responsible for handling everything up to the *opened* state. Any time an issue is created, edited, or updated, it will re-run validation to ensure the request is ready to be processed. In this case, an additional guard condition is introduced. Before the request can be submitted, the user must comment with `.submit` after validation has passed.\n\n```plaintext name: Process Issue Open/Edit\n\non: issues: types:\n- opened\n- edited\n- reopened\n\npermissions: contents: read id-token: write issues: write\n\njobs: validate: name: Validate Request runs-on: ubuntu-latest\n\n# This job should only be run on issues with the `team-membership` label.\nif: ${{ contains(github.event.issue.labels.*.name, 'team-membership') }}\n\nsteps:\n# This is required to ensure the issue form template and any validation\n# scripts are included in the workspace.\n- name: Checkout\nid: checkout uses: actions/checkout@v4\n\n# Since this workflow includes custom validation scripts, we need to\n# install Node.js and any dependencies.\n- name: Setup Node.js\nid: setup-node uses: actions/setup-node@v4\n\n# Install dependencies from `package.json`.\n- name: Install Dependencies\nid: install run: npm install\n\n# GitHub App authentication is required if you want to interact with any\n# resources outside the scope of the repository this workflow runs in.\n- name: Get GitHub App Token\nid: token uses: actions/create-github-app-token@v1 with: app-id: ${{ vars.ISSUEOPS_APP_ID }} private-key: ${{ secrets.ISSUEOPS_APP_PRIVATE_KEY }} owner: ${{ github.repository_owner }}\n\n# Remove any labels and start fresh. This is important because the\n# issue may have been closed and reopened.\n- name: Remove Labels\nid: remove-label uses: issue-ops/labeler@v2 with: action: remove github_token: ${{ steps.token.outputs.token }} labels: | validated approved denied issue_number: ${{ github.event.issue.number }} repository: ${{ github.repository }}\n\n# Parse the issue body into machine-readable JSON, so that it can be\n# processed by the rest of the workflow.\n- name: Parse Issue Body\nid: parse uses: issue-ops/parser@v4 with: body: ${{ github.event.issue.body }} issue-form-template: team-membership.yml workspace: ${{ github.workspace }}\n\n# Validate early and often! Validation should be run any time an issue is\n# interacted with, to ensure that any changes to the issue body are valid.\n- name: Validate Request\nid: validate uses: issue-ops/validator@v3 with: add-comment: true github-token: ${{ steps.token.outputs.token }} issue-form-template: team-membership.yml issue-number: ${{ github.event.issue.number }} parsed-issue-body: ${{ steps.parse.outputs.json }} workspace: ${{ github.workspace }}\n\n# If validation passes, add the validated label to the issue.\n- if: ${{ steps.validate.outputs.result == 'success' }}\nname: Add Validated Label id: add-label uses: issue-ops/labeler@v2 with: action: add github_token: ${{ steps.token.outputs.token }} labels: | validated issue_number: ${{ github.event.issue.number }} repository: ${{ github.repository }}\n\n# The `issue-ops/validator` action will automatically notify the user that\n# the request was validated. However, you can optionally add instruction\n# on what to do next.\n- if: ${{ steps.validate.outputs.result == 'success' }}\nname: Notify User (Success) id: notify-success uses: peter-evans/create-or-update-comment@v4 with: issue-number: ${{ github.event.issue.number }} body: | Hello! Your request has been validated successfully!\n\nPlease comment with `.submit` to submit this request.\n\n```\n\n### Step 4: Issue comment workflows\n\nOnce the issue is created, any further processing is triggered using issue comments‚Äîand this can be done with one workflow. However, to make things a bit easier to follow, we‚Äôll break this into a few separate workflows.\n\n#### Submit workflow\n\nThe first workflow handles the user submitting the request. The main task it performs is validating the issue body against the form template to ensure it hasn‚Äôt been modified.\n\n```plaintext name: Process Submit Comment\n\non: issue_comment: types:\n- created\n\npermissions: contents: read id-token: write issues: write\n\njobs: submit: name: Submit Request runs-on: ubuntu-latest\n\n# This job should only be run when the following conditions are true:\n#\n# - A user comments `.submit` on the issue.\n# - The issue has the `team-membership` label.\n# - The issue has the `validated` label.\n# - The issue does not have the `approved` or `denied` labels.\n# - The issue is open.\nif: | startsWith(github.event.comment.body, '.submit') &amp;&amp; contains(github.event.issue.labels.*.name, 'team-membership') == true &amp;&amp; contains(github.event.issue.labels.*.name, 'approved') == false &amp;&amp; contains(github.event.issue.labels.*.name, 'denied') == false &amp;&amp; github.event.issue.state == 'open'\n\nsteps:\n# First, we are going to re-run validation. This is important because\n# the issue body may have changed since the last time it was validated.\n\n# This is required to ensure the issue form template and any validation\n# scripts are included in the workspace.\n- name: Checkout\nid: checkout uses: actions/checkout@v4\n\n# Since this workflow includes custom validation scripts, we need to\n# install Node.js and any dependencies.\n- name: Setup Node.js\nid: setup-node uses: actions/setup-node@v4\n\n# Install dependencies from `package.json`.\n- name: Install Dependencies\nid: install run: npm install\n\n# GitHub App authentication is required if you want to interact with any\n# resources outside the scope of the repository this workflow runs in.\n- name: Get GitHub App Token\nid: token uses: actions/create-github-app-token@v1 with: app-id: ${{ vars.ISSUEOPS_APP_ID }} private-key: ${{ secrets.ISSUEOPS_APP_PRIVATE_KEY }} owner: ${{ github.repository_owner }}\n\n# Remove the validated label. This will be re-added if validation passes.\n- name: Remove Validated Label\nid: remove-label uses: issue-ops/labeler@v2 with: action: remove github_token: ${{ steps.token.outputs.token }} labels: | validated issue_number: ${{ github.event.issue.number }} repository: ${{ github.repository }}\n\n# Parse the issue body into machine-readable JSON, so that it can be\n# processed by the rest of the workflow.\n- name: Parse Issue Body\nid: parse uses: issue-ops/parser@v4 with: body: ${{ github.event.issue.body }} issue-form-template: team-membership.yml workspace: ${{ github.workspace }}\n\n# Validate early and often! Validation should be run any time an issue is\n# interacted with, to ensure that any changes to the issue body are valid.\n- name: Validate Request\nid: validate uses: issue-ops/validator@v3 with: add-comment: false # Don't add another validation comment. github-token: ${{ steps.token.outputs.token }} issue-form-template: team-membership.yml issue-number: ${{ github.event.issue.number }} parsed-issue-body: ${{ steps.parse.outputs.json }} workspace: ${{ github.workspace }}\n\n# If validation passed, add the validated and submitted labels to the issue.\n- if: ${{ steps.validate.outputs.result == 'success' }}\nname: Add Validated Label id: add-label uses: issue-ops/labeler@v2 with: action: add github_token: ${{ steps.token.outputs.token }} labels: | validated submitted issue_number: ${{ github.event.issue.number }} repository: ${{ github.repository }}\n\n# If validation succeeded, alert the administrator team so they can\n# approve or deny the request.\n- if: ${{ steps.validate.outputs.result == 'success' }}\nname: Notify Admin (Success) id: notify-success uses: peter-evans/create-or-update-comment@v4 with: issue-number: ${{ github.event.issue.number }} body: | üëã @issue-ops/admins! The request has been validated and is ready for your review. Please comment with `.approve` or `.deny` to approve or deny this request.\n\n```\n\n#### Deny workflow\n\nIf the request is denied, the user should be notified and the issue should close.\n\n```plaintext name: Process Denial Comment\n\non: issue_comment: types:\n- created\n\npermissions: contents: read id-token: write issues: write\n\njobs: submit: name: Deny Request runs-on: ubuntu-latest\n\n# This job should only be run when the following conditions are true:\n#\n# - A user comments `.deny` on the issue.\n# - The issue has the `team-membership` label.\n# - The issue has the `validated` label.\n# - The issue has the `submitted` label.\n# - The issue does not have the `approved` or `denied` labels.\n# - The issue is open.\nif: | startsWith(github.event.comment.body, '.deny') &amp;&amp; contains(github.event.issue.labels.*.name, 'team-membership') == true &amp;&amp; contains(github.event.issue.labels.*.name, 'submitted') == true &amp;&amp; contains(github.event.issue.labels.*.name, 'validated') == true &amp;&amp; contains(github.event.issue.labels.*.name, 'approved') == false &amp;&amp; contains(github.event.issue.labels.*.name, 'denied') == false &amp;&amp; github.event.issue.state == 'open'\n\nsteps:\n# This time, we do not need to re-run validation because the request is\n# being denied. It can just be closed.\n\n# However, we do need to confirm that the user who commented `.deny` is\n# a member of the administrator team.\n# GitHub App authentication is required if you want to interact with any\n# resources outside the scope of the repository this workflow runs in.\n- name: Get GitHub App Token\nid: token uses: actions/create-github-app-token@v1 with: app-id: ${{ vars.ISSUEOPS_APP_ID }} private-key: ${{ secrets.ISSUEOPS_APP_PRIVATE_KEY }} owner: ${{ github.repository_owner }}\n\n# Check if the user who commented `.deny` is a member of the\n# administrator team.\n- name: Check Admin Membership\nid: check-admin uses: actions/github-script@v7 with: github-token: ${{ steps.token.outputs.token }} script: | try { await github.rest.teams.getMembershipForUserInOrg({ org: context.repo.owner, team_slug: 'admins', username: context.actor, }) core.setOutput('member', 'true') } catch (error) { if (error.status === 404) { core.setOutput('member', 'false') } throw error }\n\n# If the user is not a member of the administrator team, exit the\n# workflow.\n- if: ${{ steps.check-admin.outputs.member == 'false' }}\nname: Exit run: exit 0\n\n# If the user is a member of the administrator team, add the denied label.\n- name: Add Denied Label\nid: add-label uses: issue-ops/labeler@v2 with: action: add github_token: ${{ steps.token.outputs.token }} labels: | denied issue_number: ${{ github.event.issue.number }} repository: ${{ github.repository }}\n\n# Notify the user that the request was denied.\n- name: Notify User\nid: notify uses: peter-evans/create-or-update-comment@v4 with: issue-number: ${{ github.event.issue.number }} body: | This request has been denied and will be closed.\n\n# Close the issue as not planned.\n- name: Close Issue\nid: close uses: actions/github-script@v7 with: script: | await github.rest.issues.update({ issue_number: ${{ github.event.issue.number }}, owner: context.repo.owner, repo: context.repo.repo, state: 'closed', state_reason: 'not_planned' })\n\n```\n\n#### Approve workflow\n\nFinally, we need to handle request approval. In this case, we need to add the user to the team, notify them, and close the issue.\n\n```plaintext name: Process Approval Comment\n\non: issue_comment: types:\n- created\n\npermissions: contents: read id-token: write issues: write\n\njobs: submit: name: Approve Request runs-on: ubuntu-latest\n\n# This job should only be run when the following conditions are true:\n#\n# - A user comments `.approve` on the issue.\n# - The issue has the `team-membership` label.\n# - The issue has the `validated` label.\n# - The issue has the `submitted` label.\n# - The issue does not have the `approved` or `denied` labels.\n# - The issue is open.\nif: | startsWith(github.event.comment.body, '.approve') &amp;&amp; contains(github.event.issue.labels.*.name, 'team-membership') == true &amp;&amp; contains(github.event.issue.labels.*.name, 'submitted') == true &amp;&amp; contains(github.event.issue.labels.*.name, 'validated') == true &amp;&amp; contains(github.event.issue.labels.*.name, 'approved') == false &amp;&amp; contains(github.event.issue.labels.*.name, 'denied') == false &amp;&amp; github.event.issue.state == 'open'\n\nsteps:\n# This time, we do not need to re-run validation because the request is\n# being approved. It can just be processed.\n\n# This is required to ensure the issue form template is included in the\n# workspace.\n- name: Checkout\nid: checkout uses: actions/checkout@v4\n\n# We do need to confirm that the user who commented `.approve` is a member\n# of the administrator team. GitHub App authentication is required if you\n# want to interact with any resources outside the scope of the repository\n# this workflow runs in.\n- name: Get GitHub App Token\nid: token uses: actions/create-github-app-token@v1 with: app-id: ${{ vars.ISSUEOPS_APP_ID }} private-key: ${{ secrets.ISSUEOPS_APP_PRIVATE_KEY }} owner: ${{ github.repository_owner }}\n\n# Check if the user who commented `.approve` is a member of the\n# administrator team.\n- name: Check Admin Membership\nid: check-admin uses: actions/github-script@v7 with: github-token: ${{ steps.token.outputs.token }} script: | try { await github.rest.teams.getMembershipForUserInOrg({ org: context.repo.owner, team_slug: 'admins', username: context.actor, }) core.setOutput('member', 'true') } catch (error) { if (error.status === 404) { core.setOutput('member', 'false') } throw error }\n\n# If the user is not a member of the administrator team, exit the\n# workflow.\n- if: ${{ steps.check-admin.outputs.member == 'false' }}\nname: Exit run: exit 0\n\n# Parse the issue body into machine-readable JSON, so that it can be\n# processed by the rest of the workflow.\n- name: Parse Issue body\nid: parse uses: issue-ops/parser@v4 with: body: ${{ github.event.issue.body }} issue-form-template: team-membership.yml workspace: ${{ github.workspace }}\n\n- name: Add to Team\nid: add uses: actions/github-script@v7 with: github-token: ${{ steps.token.outputs.token }} script: | const parsedIssue = JSON.parse('${{ steps.parse.outputs.json }}')\n\nawait github.rest.teams.addOrUpdateMembershipForUserInOrg({ org: context.repo.owner, team_slug: parsedIssue.team, username: '${{ github.event.issue.user.login }}', role: 'member' })\n\n- name: Notify User\nid: notify uses: peter-evans/create-or-update-comment@v4 with: issue-number: ${{ github.event.issue.number }} body: | This request has been processed successfully!\n\n- name: Close Issue\nid: close uses: actions/github-script@v7 with: script: | await github.rest.issues.update({ issue_number: ${{ github.event.issue.number }}, owner: context.repo.owner, repo: context.repo.repo, state: 'closed', state_reason: 'completed' })\n\n```\n\n## Take this with you\n\nAnd there you have it! With a handful of standardized workflows, you have an end-to-end, issue-driven process in place to manage team membership. This can be extended as far as you want, including support for removing users, auditing access, and more. With IssueOps, the sky is the limit!\n\nHere‚Äôs the best thing about IssueOps: It brings another level of automation to a surface I‚Äôm constantly using‚Äîand that‚Äôs GitHub. By using issues and pull requests as control centers for workflows, teams can reduce friction, improve efficiency, and keep everything transparent. Whether you want to automate deployments, approvals, or bug triage, IssueOps makes it all possible, without ever leaving your repo.\n\nFor more information and examples, check out the open source [IssueOps documentation repository](https://github.com/issue-ops/docs), and if you want a deeper dive, you can head over to the open source [IssueOps documentation](https://issue-ops.github.io/docs/).\n\nIn my experience, it‚Äôs always best to start small and experiment with what works best for you. With just a bit of time, you‚Äôll see your workflows get smoother with every commit (I know I have). Happy coding! ‚ú®",
  "FeedUrl": "https://github.blog/engineering/feed/",
  "Title": "IssueOps: Automate CI/CD (and more!) with GitHub Issues and Actions",
  "FeedLevelAuthor": "The latest from GitHub's engineering team - The GitHub Blog",
  "Link": "https://github.blog/engineering/issueops-automate-ci-cd-and-more-with-github-issues-and-actions/",
  "Tags": [
    "Engineering",
    "GitHub Issues",
    "IssueOps",
    "pull requests"
  ],
  "OutputDir": "_news",
  "Author": "Nick Alteen",
  "ProcessedDate": "2025-08-05 11:15:30",
  "Description": "A look into building IssueOps workflows on GitHub to do everything from CI/CD to handling approvals and more.\n\nThe post [IssueOps: Automate CI/CD (and more!) with GitHub Issues and Actions](https://github.blog/engineering/issueops-automate-ci-cd-and-more-with-github-issues-and-actions/) appeared first on [The GitHub Blog](https://github.blog).",
  "FeedName": "GitHub Engineering Blog"
}
