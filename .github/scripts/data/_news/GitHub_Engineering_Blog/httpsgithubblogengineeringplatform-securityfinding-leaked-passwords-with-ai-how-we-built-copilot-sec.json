{
  "PubDate": "2025-03-04T17:00:24+00:00",
  "EnhancedContent": "In October 2024, we announced the [general availability of Copilot secret scanning](https://github.blog/changelog/2024-10-21-copilot-secret-scanning-for-generic-passwords-is-generally-available/), leveraging AI to detect generic passwords in users’ codebases. This post describes how Copilot secret scanning works under the hood, the challenges we ran into when developing it, and the framework we use for testing and iteration.\n\n## What is Copilot secret scanning?\n\nCopilot secret scanning is a feature of [GitHub Secret Protection](https://resources.github.com/evolving-github-advanced-security), which protects millions of repositories on GitHub by detecting hundreds of pattern types through [our partner program](https://docs.github.com/en/code-security/secret-scanning/secret-scanning-partnership-program/secret-scanning-partner-program). The precision of these detections is paramount for security teams and developers when dealing with security alerts. Historically, our detection approach has relied on regular expressions, which is an effective method for identifying secrets with strict, provider-minted formats. However, this method struggles with the nuanced and varied structures of generic passwords, often generating excessive noise for security teams and developers.\n\nWe now detect generic passwords with GitHub Copilot, using AI to analyze context—such as the usage and location of a potential secret—to limit noise and deliver relevant alerts that are critical to the health and security of your repositories.\n\n![A secret scanning alert for a password detected by Copilot secret scanning.](https://github.blog/wp-content/uploads/2025/03/password.png?resize=1024%2C691)\n\nGetting to the point where we were confident in our password precision was a journey over many test cases, prompt iterations, and model changes. Let’s dive in to explore what we learned along the way and find out where we’re going.\n\n## The private preview highlighted a problem early on: unconventional file types and structures\n\nAt the core of Copilot secret scanning lies a request to a large language model (LLM), expressed through an LLM prompt consisting of:\n\n- General information about the type of vulnerability, in this case passwords.\n- The source code location and contents of the file where we believe the vulnerability may exist.\n- A strict JSON format specification for the model output, to allow for automated processing.\n\nOur first iteration of the prompt used the few-shot prompting technique, which provides the LLM with example inputs and outputs to demonstrate how to perform the task. We wanted a resource-effective model to run the detections at scale and landed on GPT-3.5-Turbo. In parallel, we developed a basic offline evaluation framework, including manually curated test cases with both positive and negative findings, to help us validate that our approach was sound before deploying it to customers.\n\nWe deployed this first iteration to our private preview participants and immediately noticed a problem. While it worked reasonably well at identifying credentials in our offline evaluation, it would fail spectacularly in some customer repositories. The model had difficulty interpreting file types and structures not typically seen in the conventional coding languages and patterns that LLMs train on.\n\nThis experience revealed the complexity of the problem and the limiting nature of LLMs. We had to reevaluate our approach.\n\n## The road to public preview: Improving offline evaluation and prompting\n\nIn response to these initial results, we enhanced the offline evaluation framework in a few key ways. First, we added reports from private preview participants to increase the diversity of our test cases. Next, we enhanced the framework so that we could visually identify and analyze deviations resulting from model or prompt changes. This allowed us to better see the impact of customizing different steps in our prompting strategy. Finally, we leveraged the GitHub Code Security team’s [evaluation processes](https://github.blog/engineering/platform-security/fixing-security-vulnerabilities-with-ai/#evaluation-and-iteration) to create a data collection pipeline, and used GPT-4 to create our own test cases based on learnings from existing secret scanning alerts in open source repositories.\n\nThis improved offline evaluation and gave us the breadth needed to measure both precision and recall. Precision is the ability to find secrets more accurately, with concerns to the false positive rate, while recall is the ability to find secrets more reliably, with concerns to the false negative rate.\n\n![A diagram illustrating the difference between precision and recall.](https://github.blog/wp-content/uploads/2025/03/positives.png?resize=422%2C768)[Walber](https://commons.wikimedia.org/wiki/File:Precisionrecall.svg), [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0), via Wikimedia Commons\n\nFrom here, we ran a series of experiments to evaluate detection quality:\n\n- What if we tried a different model?\n- What if we ran the prompt multiple times and somehow combined the responses?\n- What if we ran two different prompts on two different models in sequence?\n- How do we better handle the nondeterministic nature of LLM responses?\n\nMore specifically, we started experimenting with a few different mechanisms to improve our detection with the LLM.\n\nWe tried voting (asking the model the same question many times), which allowed for more deterministic responses but had no material impact on our precision.\n\nWe also tried using a larger model (GPT-4) trained on a larger set of parameters as a confirming scanner, to validate the accuracy of candidates found by GPT-3.5-Turbo. This helped improve precision without reducing our recall, but was also more resource intensive.\n\nWe also tried a few different prompting strategies, such as Fill-in-the-Middle, Zero-Shot, and Chain-of-Thought. We ended up collaborating with our colleagues at Microsoft and used [their MetaReflection technique](https://www.microsoft.com/en-us/research/publication/metareflection-learning-instructions-for-language-agents-using-past-reflections/), a novel offline reinforcement learning technique that allows experiential learnings from past trials to come up with a hybrid Chain of Thought (CoT) and few-shot prompt that improves precision with a small penalty in recall.\n\nWe ultimately ended up using a combination of all these techniques and moved Copilot secret scanning into public preview, opening it widely to all GitHub Secret Protection customers. This brings us to our next hurdle: scale.\n\n## Scaling out capacity for a public preview\n\nSecret scanning not only scans incoming Git pushes, but also your entire Git history on all branches. With each new customer, the necessary resources increase linearly. Rather than simply expanding LLM capacity, we focused on striking the most effective balance between value and cost to ensure optimal performance and efficiency. Before tackling how we managed the resources, we tried to find ways to reduce resource usage itself by:\n\n- Identifying and excluding a class of changes from scanning (such as media files or language files that contain “test,” “mock,” or “spec” in the filepath), because we expected they would never contain credentials or they would be incomprehensible to the model.\n- Experimenting with newer models, such as GPT-4-Turbo and GPT-4o-mini, that were expected to be less resource intensive without compromising on performance and latency.\n- Experimenting with different context windows to find one that reduced resources without significantly increasing latency for the LLM to respond to our queries.\n- Making improvements to how we tokenize the content we want to scan, including retaining some memory of previous tokenizations while processing new parts of a file.\n\nWhile some of these efforts proved fruitful, such as limiting the content we scanned, other efforts were less effective. For example, breaking down content into smaller pieces didn’t have much of an impact, while using a more powerful model did.\n\nUltimately, the most impactful change came from creating a workload-aware request management system that allowed us to maximize and equitably share LLM capacity against the variety of different workloads we run during scans.\n\nIn building the system, we noticed a fundamental problem that needed addressing in our capacity management: assigning specific rate limits to individual workloads (such as scanning incoming Git commits or scanning the full history) was suboptimal. As each workload was tied to specific traffic patterns—Git commits, for example, tend to correlate with working hours, while full history scanning correlates with discrete events like a security manager or administrator enabling the feature on a new organization—it was easy to land in a situation where an individual workload could run into rate limits within its operational context, leaving additional resources available elsewhere unused.\n\nWe drew significant inspiration from existing solutions in this space, such as [Doorman](https://github.com/youtube/doorman), GitHub’s own [Freno](https://github.com/github/freno), and various other weighted, fair-priority, queue-related algorithms. We came up with an algorithm that allows us to set a range of limits for each workload, preventing the workload from completely overwhelming the LLM, while allowing it to tap into resources from other workloads going unused at the moment. This strategy was so effective at maximizing utilization that we ended up using it within [Copilot Autofix](https://github.blog/changelog/2024-08-14-copilot-autofix-for-codeql-code-scanning-alerts-is-now-generally-available/) and [security campaigns](https://github.blog/changelog/2024-10-29-security-campaigns-with-copilot-autofix-are-now-in-public-preview/) as well.\n\n## Mirror testing our way to general availability\n\nAchieving confidence in detection quality was crucial for moving Copilot secret scanning to general availability. We implemented a mirror testing framework that ran our prompt and filtering changes against a subset of repositories that participated in our public preview. Rescanning these repositories with our latest improvements allowed us to assess the change in real alert volumes and false positive resolutions, without impacting users.\n\nWe found a huge drop in detections and false positives with very few missing real passwords. In some cases, we saw a **94% reduction in false positives across organizations**! This before-and-after comparison indicated that all the different changes we made during private and public preview led to increased precision without sacrificing recall, and that we were ready to provide a reliable and efficient detection mechanism to all GitHub Secret Protection customers.\n\n## Lessons for the future\n\nCopilot secret scanning is now detecting passwords on nearly 35% of all GitHub Secret Protection repositories. We’re continuing to monitor performance and apply lessons learned as we leverage the tooling we created along the way:\n\n- **A focus on precision:** Security and development teams need accurate and actionable alerts without the noise—this is always our primary goal.\n- **Including diverse test cases:** We continue to incorporate examples based on learnings from customer feedback into our test bed as we refine our detection capabilities.\n- **Effective resource management:** We always need to balance scalability with performance.\n- **Collaborative innovation:** Partnering with other GitHub and Microsoft teams helps us push the boundaries of what Copilot can achieve.\n\nThese learnings are also shared across Copilot Autofix, which continues to expand coverage for code scanning alerts and helps development teams remediate code scanning alerts quickly.\n\nSince our general availability launch, enablement for Copilot secret scanning has been included in security configurations, allowing you to control which repositories are detecting secrets across your organizations or enterprise. We’re dedicated to continuous improvement through ongoing monitoring, mirror testing, and approach refinement based on customer feedback and detection trends. Copilot secret scanning serves as a critical component for robust application security and will evolve to meet the dynamic needs of our users.\n\n>\n> Copilot secret scanning is a feature of **[GitHub Secret Protection](https://github.blog/changelog/2025-03-04-introducing-github-secret-protection-and-github-code-security)**, which offers enterprise-ready solutions for preventing accidental secret exposure in your repositories. **GitHub Secret Protection** is available to purchase starting April 1, 2025.\n>",
  "FeedUrl": "https://github.blog/engineering/feed/",
  "Title": "Finding leaked passwords with AI: How we built Copilot secret scanning",
  "FeedLevelAuthor": "The latest from GitHub's engineering team - The GitHub Blog",
  "Link": "https://github.blog/engineering/platform-security/finding-leaked-passwords-with-ai-how-we-built-copilot-secret-scanning/",
  "Tags": [
    "Engineering",
    "GitHub Advanced Security",
    "GitHub Copilot",
    "Platform security",
    "Secret Scanning"
  ],
  "OutputDir": "_news",
  "Author": "Ashwin Mohan",
  "ProcessedDate": "2025-08-05 11:15:30",
  "Description": "Passwords are notoriously difficult to detect with conventional programming approaches. AI can help us find passwords better because it understands context. This blog post will explore the technical challenges we faced with building the feature and the novel and creative ways we solved them.\n\nThe post [Finding leaked passwords with AI: How we built Copilot secret scanning](https://github.blog/engineering/platform-security/finding-leaked-passwords-with-ai-how-we-built-copilot-secret-scanning/) appeared first on [The GitHub Blog](https://github.blog).",
  "FeedName": "GitHub Engineering Blog"
}
