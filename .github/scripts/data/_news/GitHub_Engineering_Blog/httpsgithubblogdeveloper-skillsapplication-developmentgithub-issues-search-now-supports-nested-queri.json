{
  "PubDate": "2025-05-13T16:00:00+00:00",
  "EnhancedContent": "Originally, Issues search was limited by a simple, flat structure of queries. But with [advanced search syntax](https://github.blog/changelog/2025-04-09-evolving-github-issues-and-projects/#%f0%9f%95%b5%ef%b8%8f%e2%99%80%ef%b8%8f-finding-what-you-need-with-advanced-search), you can now construct searches using logical AND/OR operators and nested parentheses, pinpointing the exact set of issues you care about.\n\nBuilding this feature presented significant challenges: ensuring backward compatibility with existing searches, maintaining performance under high query volume, and crafting a user-friendly experience for nested searches. We’re excited to take you behind the scenes to share how we took this long-requested feature from idea to production.\n\n## Here’s what you can do with the new syntax and how it works behind the scenes\n\nIssues search now supports building queries with logical AND/OR operators across *all* fields, with the ability to nest query terms. For example `is:issue state:open author:rileybroughten (type:Bug OR type:Epic)` finds all *issues* that are *open* AND were *author*ed by *rileybroughten* AND are either of type *bug* or *epic*.\n\n![Screenshot of an Issues search query involving the logical OR operator.](https://github.blog/wp-content/uploads/2025/05/3_issues_search_screenshot.png?resize=1024%2C411)\n\n## How did we get here?\n\nPreviously, as mentioned, Issues search only supported a flat list of query fields and terms, which were implicitly joined by a logical AND. For example, the query `assignee:@me label:support new-project` translated to “give me all issues that are assigned to me AND have the label *support* AND contain the text *new-project.*”\n\nBut the developer community has been [asking for more flexibility in issue search](https://github.com/isaacs/github/issues/660), [repeatedly](https://github.com/orgs/community/discussions/4507), for nearly a decade now. They wanted to be able to find all issues that had *either* the label `support` or the label `question` , using the query `label:support OR label:question` . So, we shipped an [enhancement towards this request](https://github.blog/changelog/2021-08-02-search-issues-by-label-using-logical-or/) in 2021, when we enabled an OR style search using a comma-separated list of values.\n\nHowever, they still wanted [the flexibility to search this way across *all* issue fields](https://github.com/orgs/community/discussions/4507#discussioncomment-3076699), and not just the *labels* field. So we got to work.\n\n## Technical architecture and implementation\n\n![The architecture of the Issues search system (and the changes needed to build this feature).](https://github.blog/wp-content/uploads/2025/05/1_architecture.png?resize=1024%2C486)\n\nFrom an architectural perspective, we swapped out the existing search module for Issues (IssuesQuery), with a new search module (ConditionalIssuesQuery), that was capable of handling nested queries while continuing to support existing query formats.\n\nThis involved rewriting IssueQuery, the search module that parsed query strings and mapped them into Elasticsearch queries.\n\n![Search Architecture](https://github.blog/wp-content/uploads/2025/05/2_search_architecture.png?resize=1024%2C376)\n\nTo build a new search module, we first needed to understand the existing search module, and how a single search query flowed through the system. At a high level, when a user performs a search, there are three stages in its execution:\n\n1. **Parse**: Breaking the user input string into a structure that is easier to process (like a list or a tree)\n2. **Query**: Transforming the parsed structure into an Elasticsearch query document, and making a query against Elasticsearch.\n3. **Normalize:** Mapping the results obtained from Elasticsearch (JSON) into Ruby objects for easy access and pruning the results to remove records that had since been removed from the database.\n\nEach stage presented its own challenges, which we’ll explore in more detail below. The *Normalize* step remained unchanged during the re-write, so we won’t dive into that one.\n\n### Parse stage\n\nThe user input string (the search phrase) is first parsed into an intermediate structure. The search phrase could include:\n\n- **Query terms:** The relevant words the user is trying to find more information about (ex: “models”)\n- **Search filters:** These restrict the set of returned search documents based on some criteria (ex: “assignee:Deborah-Digges”)\n\nExample search phrase:\n\n- Find all issues assigned to me that contain the word “codespaces”:\n- `is:issue assignee:@me codespaces`\n- Find all issues with the label *documentation*that are assigned to me:\n- `assignee:@me label:documentation`\n\n#### The old parsing method: flat list\n\nWhen only flat, simple queries were supported, it was sufficient to parse the user’s search string into a list of search terms and filters, which would then be passed along to the next stage of the search process.\n\n#### The new parsing method: abstract syntax tree\n\nAs nested queries may be recursive, parsing the search string into a list was no longer sufficient. We changed this component to parse the user’s search string into an Abstract Syntax Tree (AST) using the parsing library [parslet](https://github.com/kschiess/parslet).\n\nWe defined a grammar (a PEG or Parsing Expression Grammar) to represent the structure of a search string. The grammar supports both the existing query syntax and the new nested query syntax, to allow for backward compatibility.\n\nA [simplified grammar](https://github.com/kschiess/parslet/blob/master/example/boolean_algebra.rb) for a boolean expression described by a PEG grammar for the parslet parser is shown below:\n\n``` class Parser < Parslet::Parser rule(:space) { match[\" \"].repeat(1) } rule(:space?) { space.maybe }\n\nrule(:lparen) { str(\"(\") >> space? } rule(:rparen) { str(\")\") >> space? }\n\nrule(:and_operator) { str(\"and\") >> space? } rule(:or_operator) { str(\"or\") >> space? }\n\nrule(:var) { str(\"var\") >> match[\"0-9\"].repeat(1).as(:var) >> space? }\n\n# The primary rule deals with parentheses.\nrule(:primary) { lparen >> or_operation >> rparen | var }\n\n# Note that following rules are both right-recursive.\nrule(:and_operation) { (primary.as(:left) >> and_operator >> and_operation.as(:right)).as(:and) | primary }\n\nrule(:or_operation) { (and_operation.as(:left) >> or_operator >> or_operation.as(:right)).as(:or) | and_operation }\n\n# We start at the lowest precedence rule.\nroot(:or_operation) end ```\n\nFor example, this user search string: `is:issue AND (author:deborah-digges OR author:monalisa )`\n\nwould be parsed into the following AST:\n\n``` { \"root\": { \"and\": { \"left\": { \"filter_term\": { \"attribute\": \"is\", \"value\": [ { \"filter_value\": \"issue\" } ] } }, \"right\": { \"or\": { \"left\": { \"filter_term\": { \"attribute\": \"author\", \"value\": [ { \"filter_value\": \"deborah-digges\" } ] } }, \"right\": { \"filter_term\": { \"attribute\": \"author\", \"value\": [ { \"filter_value\": \"monalisa\" } ] } } } } } } } ```\n\n### Query\n\nOnce the query is parsed into an intermediate structure, the next steps are to:\n\n1. Transform this intermediate structure into a query document that Elasticsearch understands\n2. Execute the query against Elasticsearch to obtain results\n\nExecuting the query in step 2 remained the same between the old and new systems, so let’s only go over the differences in building the query document below.\n\n#### The old query generation: linear mapping of filter terms using filter classes\n\nEach filter term (Ex: `label:documentation` ) has a class that knows how to convert it into a snippet of an Elasticsearch query document. During query document generation, the correct class for each filter term is invoked to construct the overall query document.\n\n#### The new query generation: recursive AST traversal to generate Elasticsearch bool query\n\nWe recursively traversed the AST generated during parsing to build an equivalent Elasticsearch query document. The nested structure and boolean operators map nicely to Elasticsearch’s [boolean query](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html) with the AND, OR, and NOT operators mapping to the *must*, *should*, and *should\\_not* clauses.\n\nWe re-used the building blocks for the smaller pieces of query generation to recursively construct a nested query document during the tree traversal.\n\nContinuing from the example in the parsing stage, the AST would be transformed into a query document that looked like this:\n\n``` { \"query\": { \"bool\": { \"must\": [ { \"bool\": { \"must\": [ { \"bool\": { \"must\": { \"prefix\": { \"_index\": \"issues\" } } } }, { \"bool\": { \"should\": { \"terms\": { \"author_id\": [ \"<DEBORAH_DIGGES_AUTHOR_ID>\", \"<MONALISA_AUTHOR_ID>\" ] } } } } ] } } ] } // SOME TERMS OMITTED FOR BREVITY } } ```\n\nWith this new query document, we execute a search against Elasticsearch. This search now supports logical AND/OR operators and parentheses to search for issues in a more fine-grained manner.\n\n## Considerations\n\nIssues is one of the oldest and most heavily -used features on GitHub. Changing core functionality like Issues search, a feature with an average of  nearly 2000 queries per second (QPS)—that’s almost 160M queries a day!—presented a number of challenges to overcome.\n\n### Ensuring backward compatibility\n\nIssue searches are often bookmarked, shared among users, and linked in documents, making them important artifacts for developers and teams. Therefore, we wanted to introduce this new capability for nested search queries without breaking existing queries for users.\n\nWe validated the new search system before it even reached users by:\n\n- **Testing extensively**: We ran our new search module against all unit and integration tests for the existing search module. To ensure that the GraphQL and REST API contracts remained unchanged, we ran the tests for the search endpoint both with the feature flag for the new search system enabled and disabled.\n- **Validating correctness in production with dark-shipping:** For 1% of issue searches, we ran the user’s search against both the existing and new search systems in a background job, and logged differences in responses. By analyzing these differences we were able to fix bugs and missed edge cases before they reached our users.\n- We weren’t sure at the outset how to define “differences,” but we settled on “number of results” for the first iteration. In general, it seemed that we could determine whether a user would be surprised by the results of their search against the new search capability if a search returned a different number of results when they were run within a second or less of each other.\n\n### Preventing performance degradation\n\nWe expected more complex nested queries to use more resources on the backend than simpler queries, so we needed to establish a realistic baseline for nested queries, while ensuring no regression in the performance of existing, simpler ones.\n\nFor 1% of Issue searches, we ran equivalent queries against both the existing and the new search systems. We used [scientist](https://github.com/github/scientist), GitHub’s open source Ruby library, for carefully refactoring critical paths, to compare the performance of equivalent queries to ensure that there was no regression.\n\n### Preserving user experience\n\nWe didn’t want users to have a worse experience than before just because more complex searches were *possible*.\n\nWe collaborated closely with product and design teams to ensure usability didn’t decrease as we added this feature by:\n\n- **Limiting the number of nested levels** in a query to five. From customer interviews, we found this to be a sweet spot for both utility and usability.\n- **Providing helpful UI/UX cues**: We highlight the AND/OR keywords in search queries, and provide users with the same auto-complete feature for filter terms in the UI that they were accustomed to for simple flat queries.\n\n### Minimizing risk to existing users\n\nFor a feature that is used by millions of users a day, we needed to be intentional about rolling it out in a way that minimized risk to users.\n\nWe built confidence in our system by:\n\n- **Limiting blast radius**: To gradually build confidence, we only integrated the new system in the GraphQL API and the Issues tab for a repository in the UI to start. This gave us time to collect, respond to, and incorporate feedback without risking a degraded experience for all consumers. Once we were happy with its performance, we rolled it out to the [Issues dashboard](https://github.blog/changelog/2025-04-02-github-issues-dashboard-updates/) and the [REST API](https://github.blog/changelog/2025-03-06-github-issues-projects-api-support-for-issues-advanced-search-and-more/).\n- **Testing internally and with trusted partners**: As with every feature we build at GitHub, we tested this feature internally for the entire period of its development by shipping it to our own team during the early days, and then gradually rolling it out to all GitHub employees. We then shipped it to trusted partners to gather initial user feedback.\n\nAnd there you have it, that’s how we built, validated, and shipped the new and improved Issues search!\n\n## Feedback\n\nWant to try out this exciting new functionality? Head to our docs to learn about how to use [boolean operators](https://docs.github.com/en/issues/tracking-your-work-with-issues/using-issues/filtering-and-searching-issues-and-pull-requests#using-boolean-operators) and [parentheses](https://docs.github.com/en/issues/tracking-your-work-with-issues/using-issues/filtering-and-searching-issues-and-pull-requests#using-parentheses-for-more-complicated-filters) to search for the issues you care about!\n\nIf you have any feedback for this feature, please drop us a note on our [community discussions](https://github.com/orgs/community/discussions/categories/announcements).\n\n## Acknowledgements\n\nSpecial thanks to AJ Schuster, Riley Broughten, Stephanie Goldstein, Eric Jorgensen Mike Melanson and Laura Lindeman for the feedback on several iterations of this blog post!",
  "FeedUrl": "https://github.blog/engineering/feed/",
  "Title": "GitHub Issues search now supports nested queries and boolean operators: Here’s how we (re)built it",
  "FeedLevelAuthor": "The latest from GitHub's engineering team - The GitHub Blog",
  "Link": "https://github.blog/developer-skills/application-development/github-issues-search-now-supports-nested-queries-and-boolean-operators-heres-how-we-rebuilt-it/",
  "Tags": [
    "Application development",
    "Architecture & optimization",
    "Developer skills",
    "Engineering",
    "Engineering principles",
    "GitHub Issues",
    "Issues search"
  ],
  "OutputDir": "_news",
  "Author": "Deborah Digges",
  "ProcessedDate": "2025-08-05 11:15:29",
  "Description": "Plus, considerations in updating one of GitHub's oldest and most heavily used features.\n\nThe post [GitHub Issues search now supports nested queries and boolean operators: Here’s how we (re)built it](https://github.blog/developer-skills/application-development/github-issues-search-now-supports-nested-queries-and-boolean-operators-heres-how-we-rebuilt-it/) appeared first on [The GitHub Blog](https://github.blog).",
  "FeedName": "GitHub Engineering Blog"
}
