{
  "FeedName": "The Azure Blog",
  "Title": "Agent Factory: From prototype to production—developer tools and rapid agent development",
  "FeedLevelAuthor": "Microsoft Azure Blog",
  "Link": "https://azure.microsoft.com/en-us/blog/agent-factory-from-prototype-to-production-developer-tools-and-rapid-agent-development/",
  "Tags": [
    "Agent Factory",
    "AI",
    "AI + machine learning",
    "DevOps"
  ],
  "Author": "Yina Arenas",
  "PubDate": "2025-09-03T15:00:00+00:00",
  "Description": "It's no longer whether you can build an agent—it’s how fast and seamlessly you can go from idea to enterprise-ready deployment.\n\nThe post [Agent Factory: From prototype to production—developer tools and rapid agent development](https://azure.microsoft.com/en-us/blog/agent-factory-from-prototype-to-production-developer-tools-and-rapid-agent-development/) appeared first on [Microsoft Azure Blog](https://azure.microsoft.com/en-us/blog).",
  "EnhancedContent": "It's no longer whether you can build an agent—it’s how fast and seamlessly you can go from idea to enterprise-ready deployment.\n\n*This blog post is the fourth out of a six-part blog series called*[*Agent Factory*](https://azure.microsoft.com/en-us/blog/tag/agent-factory/)*which will share best practices, design patterns, and tools to help guide you through adopting and building agentic AI.*\n\n## Developer experiences as the key to scale\n\nAI agents are moving quickly from experimentation to real production systems. Across industries, we see developers testing prototypes in their Integrated Development Environment (IDE) one week and deploying production agents to serve thousands of users the next. The key differentiator is no longer *whether* you can build an agent—it’s how fast and seamlessly you can go from idea to enterprise-ready deployment.\n\n[Deploy AI agents quickly with Azure AI Foundry](https://azure.microsoft.com/en-us/products/ai-foundry)\n\nIndustry trends reinforce this shift:\n\n- **In-repo AI development:** Models, prompts, and evaluations are now first-class citizens in GitHub repos—giving developers a unified space to build, test, and iterate on AI features.\n- **More capable coding agents:** GitHub Copilot’s new coding agent can open pull requests after completing tasks like writing tests or fixing bugs, acting as an asynchronous teammate.\n- **Open frameworks maturing:** Communities around LangGraph, LlamaIndex, CrewAI, AutoGen, and Semantic Kernel are rapidly expanding, with “agent templates” on GitHub repos becoming common.\n- **Open protocols emerging:** Standards like the Model Context Protocol (MCP) and Agent-to-Agent (A2A) are creating interoperability across platforms.\n\nDevelopers increasingly expect to stay in their existing workflow—GitHub, VS Code, and familiar frameworks—while tapping into enterprise-grade runtimes and integrations. The platforms that win will be those that **meet developers where they are**—with openness, speed, and trust.\n\n## What a modern agent platform should deliver\n\nFrom our work with customers and the open-source community, we’ve seen a clear picture emerge of what developers really need. A modern agent platform must go beyond offering models or orchestration—it has to empower teams across the entire lifecycle:\n\n![A presentation slide titled &ldquo;Modern Agent Platform&rdquo; with six boxes, each representing a key capability: Local-first prototyping, Frictionless transition to production, Open by design, Interop by design, One-stop integration fabric, and Built-in guardrails.](https://azure.microsoft.com/en-us/blog/wp-content/uploads/2025/09/Modern-Agent-Platform.webp)\n1. **Local-first prototyping:** Developers want to stay in their flow. That means designing, tracing, and evaluating AI agents directly in their IDE with the same ease as writing and debugging code. If building an agent requires jumping into a separate UI or unfamiliar environment, iteration slows and adoption drops.\n2. **Frictionless transition to production:** A common frustration we hear is that an agent that runs fine locally becomes brittle or requires heavy rewrites in production. The right platform provides a *single, consistent API surface* from experimentation to deployment, so what works in development works in production—with scale, security, and governance layered in automatically.\n3. **Open by design:** No two organizations use the exact same stack. Developers may start with LangGraph for orchestration, LlamaIndex for data retrieval, or CrewAI for coordination. Others prefer Microsoft’s first-party frameworks like Semantic Kernel or AutoGen. A modern platform must support this diversity without forcing lock-in, while still offering enterprise-grade pathways for those who want them.\n4. **Interop by design:** Agents are rarely self-contained. They must talk to tools, databases, and even other agents across different ecosystems. Proprietary protocols create silos and fragmentation. Open standards like the Model Context Protocol (MCP) and Agent-to-Agent (A2A) unlock collaboration across platforms, enabling a marketplace of interoperable tools and reusable agent skills.\n5. **One-stop integration fabric:** An agent’s real value comes when it can take meaningful action: updating a record in Dynamics 365, triggering a workflow in ServiceNow, querying a SQL database, or posting to Teams. Developers shouldn’t have to rebuild connectors for every integration. A robust agent platform provides a broad library of prebuilt connectors and simple ways to plug into enterprise systems.\n6. **Built-in guardrails:** Enterprises cannot afford agents that are opaque, unreliable, or non-compliant. Observability, evaluations, and governance must be woven into the development loop—not added as an afterthought. The ability to trace agent reasoning, run continuous evaluations, and enforce identity, security, and compliance policies is as critical as the models themselves.\n\n## How Azure AI Foundry delivers this experience\n\n[Azure AI Foundry](https://azure.microsoft.com/en-us/products/ai-foundry) is designed to meet developers where they are, while giving enterprises the trust, security, and scale they need. It connects the dots across IDEs, frameworks, protocols, and business channels—making the path from prototype to production seamless.\n\n### Build where developers live: VS Code, GitHub, and Foundry\n\nDevelopers expect to design, debug, and iterate AI agents in their daily tools—not switch into unfamiliar environments. Foundry integrates deeply with both **VS Code** and **GitHub** to support this flow.\n\n- [**VS Code extension for Foundry**](https://learn.microsoft.com/en-us/azure/ai-foundry/how-to/develop/get-started-projects-vs-code)**:** Developers can create, run, and debug agents locally with direct connection to Foundry resources. The extension scaffolds projects, provides integrated tracing and evaluation, and enables one-click deployment to Foundry Agent Service—all inside the IDE they already use.\n\n![A split-screen interface showing Azure AI Foundry agent configuration in VS Code. On the left, a UI panel for &ldquo;Agent Preferences&rdquo; displays fields for agent ID, name, model selection, instructions, and tool connections, with sliders for temperature and top-p. On the right, the corresponding YAML schema defines the agent properties, model parameters, and tool configuration. A blue button at the bottom reads &ldquo;Update Agent on Azure AI Foundry.&rdquo;](https://azure.microsoft.com/en-us/blog/wp-content/uploads/2025/09/Foundry-Agent-Service-VS-Code-extension.webp)\n- [**Model Inference API**](https://learn.microsoft.com/en-us/rest/api/aifoundry/modelinference/)**:** With a single, unified inference endpoint, developers can evaluate performance across models and swap them without rewriting code. This flexibility accelerates experimentation while future-proofing applications against a fast-moving model ecosystem.\n- [**GitHub Copilot and the coding agent**](https://github.blog/news-insights/product-news/github-copilot-meet-the-new-coding-agent/)**:** Copilot has grown beyond autocomplete into an autonomous coding agent that can take on issues, spin up a secure runner, and generate a pull request, signaling how agentic AI development is becoming a normal part of the developer loop. When used alongside Azure AI Foundry, developers can accelerate agent development by having Copilot generate agent code while pulling in the **models, agent runtime, and observability tools from Foundry** needed to build, deploy, and monitor production-ready agents.\n\n### Use your frameworks\n\nAgents are not one-size-fits-all, and developers often start with the frameworks they know best. Foundry embraces this diversity:\n\n- **First-party frameworks:** Foundry supports both **Semantic Kernel** and **AutoGen**, with a convergence into a [**modern unified framework**](https://devblogs.microsoft.com/semantic-kernel/semantic-kernel-and-autogen-part-2/) coming soon. This future-ready framework is designed for modularity, enterprise-grade reliability, and seamless deployment to Foundry Agent Service.\n- **Third-party frameworks:** Foundry Agent Service integrates directly with **CrewAI, LangGraph, and LlamaIndex**, enabling developers to orchestrate multi-turn, multi-agent conversations across platforms. This ensures you can work with your preferred OSS ecosystem while still benefiting from Foundry’s enterprise runtime.\n\n### Interoperability with open protocols\n\nAgents don’t live in isolation—they need to interoperate with tools, systems, and even other agents. Foundry supports open protocols by default:\n\n- **MCP:** [Foundry Agent Service](https://devblogs.microsoft.com/foundry/announcing-model-context-protocol-support-preview-in-azure-ai-foundry-agent-service/) allows agents to call any MCP-compatible tools directly, giving developers a simple way to connect external systems and reuse tools across platforms.\n- **A2A:** [**Semantic Kernel**](https://devblogs.microsoft.com/semantic-kernel/guest-blog-building-multi-agent-solutions-with-semantic-kernel-and-a2a-protocol/) supports A2A, implementing the protocol to enable agents to collaborate across different runtimes and ecosystems. With A2A, multi-agent workflows can span vendors and frameworks, unlocking scenarios like specialist agents coordinating to solve complex problems.\n\n### Ship where the business runs\n\nBuilding an agent is just the first step—impact comes when users can access it where they work. Foundry makes it easy to publish agents to both Microsoft and custom channels:\n\n- **Microsoft 365 and Copilot:** Using the [**Microsoft 365 Agents SDK**](https://learn.microsoft.com/en-us/microsoft-365/agents-sdk/), developers can publish Foundry agents directly to Teams, Microsoft 365 Copilot, BizChat, and other productivity surfaces.\n\n- **Custom apps and APIs:** Agents can be exposed as REST APIs, embedded into web apps, or integrated into workflows using **Logic Apps** and **Azure Functions**—with thousands of prebuilt connectors to SaaS and enterprise systems.\n\n### Observe and harden\n\nReliability and safety can’t be bolted on later—they must be integrated into the development loop. As we explored in [the previous blog](https://azure.microsoft.com/en-us/blog/agent-factory-top-5-agent-observability-best-practices-for-reliable-ai/), observability is essential for delivering AI that is not only effective, but also trustworthy. Foundry builds these capabilities directly into the developer workflow:\n\n- **Tracing and evaluation** tools to debug, compare, and validate agent behavior before and after deployment.\n- **CI/CD integration** with GitHub Actions and Azure DevOps, enabling continuous evaluation and governance checks on every commit.\n- **Enterprise guardrails**—from networking and identity to compliance and governance—so that prototypes can scale confidently into production.\n\n## Why this matters now\n\nDeveloper experience is the new productivity moat. Enterprises need to enable their teams to build and deploy AI agents quickly, confidently, and at scale. Azure AI Foundry delivers an open, modular, and enterprise-ready path—meeting developers in GitHub and VS Code, supporting both open-source and first-party frameworks, and ensuring agents can be deployed where users and data already live.\n\nWith Foundry, the path from prototype to production is smoother, faster, and more secure—helping organizations innovate at the speed of AI.\n\n## What’s next\n\nIn **Part 5 of the Agent Factory series**, we’ll explore how agents connect and collaborate at scale. We’ll demystify the integration landscape—from **agent-to-agent collaboration with A2A**, to **tool interoperability with MCP**, to the role of **open standards** in ensuring agents can work across apps, frameworks, and ecosystems. Expect practical guidance and reference patterns for building truly connected agent systems.\n\nDid you miss these posts in the series?\n\n- [Agent Factory: The new era of agentic AI—common use cases and design patterns](https://azure.microsoft.com/en-us/blog/agent-factory-the-new-era-of-agentic-ai-common-use-cases-and-design-patterns/).\n- [Agent Factory: Building your first AI agent with the tools to deliver real-world outcomes](https://azure.microsoft.com/en-us/blog/agent-factory-building-your-first-ai-agent-with-the-tools-to-deliver-real-world-outcomes/).\n- [Agent Factory: Top 5 agent observability best practices for reliable AI](https://azure.microsoft.com/en-us/blog/agent-factory-top-5-agent-observability-best-practices-for-reliable-ai/).",
  "FeedUrl": "https://azure.microsoft.com/en-us/blog/feed/",
  "ProcessedDate": "2025-09-25 23:11:41",
  "OutputDir": "_news"
}
