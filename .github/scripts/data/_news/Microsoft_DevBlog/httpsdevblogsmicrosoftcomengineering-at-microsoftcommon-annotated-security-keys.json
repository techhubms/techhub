{
  "Tags": [
    "1ES",
    "ADO Azure DevOps GHAS",
    "Engineering@Microsoft",
    "GitHub Advanced Security",
    "sdl",
    "security",
    "Static analysis"
  ],
  "OutputDir": "_news",
  "FeedLevelAuthor": "Engineering@Microsoft",
  "ProcessedDate": "2025-08-05 14:12:28",
  "FeedUrl": "https://devblogs.microsoft.com/engineering-at-microsoft/feed/",
  "Title": "Common annotated security keys",
  "Description": "In April 2021, GitHub announced changes to their security token format that significantly enhanced security. The improvement leveraged two straightforward techniques: a fixed signature in the generated token and a checksum – both of which are highly effective in eliminating false positives (noise) and false negatives (missed findings). Microsoft also implements these techniques widely in […]\n\nThe post [Common annotated security keys](https://devblogs.microsoft.com/engineering-at-microsoft/common-annotated-security-keys/) appeared first on [Engineering@Microsoft](https://devblogs.microsoft.com/engineering-at-microsoft).",
  "Link": "https://devblogs.microsoft.com/engineering-at-microsoft/common-annotated-security-keys/",
  "FeedName": "Microsoft DevBlog",
  "Author": "Michael C. Fanning",
  "EnhancedContent": "In April 2021, GitHub announced [changes to their security token format](https://github.blog/engineering/platform-security/behind-githubs-new-authentication-token-formats/) that significantly enhanced security. The improvement leveraged two straightforward techniques: a fixed signature in the generated token and a checksum – both of which are highly effective in eliminating false positives (noise) and false negatives (missed findings).\n\nMicrosoft also implements these techniques widely in our service providers. Internally, we refer to any key format that incorporates both techniques as ‘identifiable’ (a term also used in GitHub’s blog post). Identifiable secrets super-power open-source scan tools and more sophisticated systems (such as[GitHub Advanced Security for Azure DevOps](https://azure.microsoft.com/en-us/products/devops/github-advanced-security)), improving the security posture of engineering teams without compromising engineer productivity. Within Microsoft, for example, we hard-block any identifiable keys from being persisted to source code, work items, etc. Because there’s no real chance of a false positive, we can be confident we haven’t wasted anyone’s time.\n\nAs Microsoft has applied these techniques, we’ve designed improvements to further enhance detection and response. One technique is to specify a fixed signature that signals conformance to a common key format standard (distinct from the signature that identifies the service provider that minted the key). This simple idea allows scanners to author a single detection to find any key conforming to our format. Scan tools may be updated over time to further classify a secret once discovered, but doing so isn’t required.\n\nBy implementing a shared standard for all of our key formats, Microsoft minimizes costs for scanners to secure our full ecosystem of service providers. Any other service provider, of course, is free to opt into these security features by also implementing the core format.\n\nTo encourage adoption, Microsoft will release a detailed technical document for the Common Annotated Security Standard (CASK) as open source. This standard defines a core set of requirements for minted keys. It also reserves space for platforms/service providers to encode their own metadata into minted tokens. (Microsoft has defined its own Azure-specific use of these reserved bits).\n\nEssential elements of the platform-agnostic (‘common’) security features include the following.\n\n## Free of Special Characters\n\nA CASK key consists solely of alphanumeric characters (i.e., the BASE62 alphabet). This allows a key to be transmitted in all contexts without any escaping or encoding.\n\n## Strong Entropy\n\nCASK keys contain 52 encoded characters of randomized data, each of which provide log(62)/log(2) of entropy. Every generated key therefore has ~310 bits of entropy; strong enough (and then some) to prevent brute-forcing, even in a post-quantum world.\n\n## Fixed Signatures\n\nCASK keys incorporate fixed signatures for the CASK standard itself and for the specific service provider that minted the secret. The core signature for CASK is `JQQJ` , a pattern that Microsoft has empirically observed is rare in source code (both public OSS and Microsoft’s own internal code). It is possible to implement accurate and extremely high-performance detection strictly by looking for this signature. Service providers additionally provide their own signature that further classifies the minted secret. Azure DevOps, for example, reserves the signature `AZDO` for its allocations.\n\n## Other Features\n\nThe CASK standard includes other useful features as well:\n\n- **Creation timestamps**. Every CASK key includes a timestamp of its creation data (month and year). This information has utility in security response and enables enforcement of rotation policies.\n- **Dedicated test keys**. CASK specifies a set of reserved test keys that allow tool developers and users to explore product functionality and ensure security controls are working – without putting valid secrets into the clear.\n\nMicrosoft encodes other useful metadata for Azure security keys in the platform-reserved component of its CASK keys. We will share more details on this soon.\n\nWe encourage service providers to review this standard and to consider implementing the format. We also welcome comments and suggestions to improve the standard (which can be versioned).",
  "PubDate": "2024-09-25T18:50:15+00:00"
}
