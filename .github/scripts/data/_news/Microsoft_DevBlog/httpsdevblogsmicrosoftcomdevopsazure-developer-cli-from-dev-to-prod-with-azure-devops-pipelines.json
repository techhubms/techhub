{
  "ProcessedDate": "2025-08-15 14:26:58",
  "PubDate": "2025-08-13T18:29:24+00:00",
  "Link": "https://devblogs.microsoft.com/devops/azure-developer-cli-from-dev-to-prod-with-azure-devops-pipelines/",
  "FeedUrl": "https://devblogs.microsoft.com/devops/feed/",
  "Author": "PuiChee (PC) Chan, Kristen Womack",
  "FeedName": "Microsoft DevBlog",
  "EnhancedContent": "Building on our previous [post](https://devblogs.microsoft.com/devops/azure-developer-cli-from-dev-to-prod-with-one-click/) about implementing dev-to-prod promotion with GitHub Actions, this follow-up demonstrates the same ‚Äúbuild once, deploy everywhere‚Äù pattern using Azure DevOps Pipelines. You‚Äôll learn how to leverage Azure DevOps YAML pipelines with [Azure Developer CLI (azd)](https://learn.microsoft.com/azure/developer/azure-developer-cli/overview). This approach ensures consistent, reliable deployments across environments.\n\n## Environment-Specific Infrastructure\n\nThe infrastructure approach is identical to our [previous GitHub Actions implementation](https://devblogs.microsoft.com/devops/azure-developer-cli-from-dev-to-prod-with-one-click/). It uses conditional Bicep deployment with a single `envType` parameter. This drives environment-specific resource configuration. The same Bicep templates work seamlessly across both CI/CD platforms.\n\nFor the complete infrastructure setup details, refer to the [GitHub Actions post](https://devblogs.microsoft.com/devops/azure-developer-cli-from-dev-to-prod-with-one-click/#set-up-resources-based-on-an-environment-variable).\n\n## From File Backup to Pipeline Artifacts\n\nThe original approach used local file backups (copying zip files within the same job). However, the community pointed out that using native CI/CD artifact systems is more idiomatic. This provides several key advantages:\n\n- **Cross-job compatibility**: Artifacts work seamlessly across multiple jobs and stages.\n- **Automatic cleanup**: The platform handles retention policies automatically.\n- **Better traceability**: Artifacts are visible in the platform UI with download history.\n- **Platform integration**: Native features with built-in security and access controls.\n\nThis artifact-based approach represents the industry standard for ‚Äúbuild once, deploy everywhere‚Äù patterns. It works across modern CI/CD platforms. We have updated the original GitHub Actions implementation to use the same pattern demonstrated in this Azure DevOps version.\n\n## Azure DevOps Pipeline Enhancement\n\nAzure DevOps pipelines require a different approach than GitHub Actions. However, they achieve the same outcome. We‚Äôll demonstrate a **multi-stage pipeline** that provides proper separation of concerns and enterprise-ready deployment patterns. This staged approach offers better isolation, approval workflows, and traceability compared to single-job pipelines.\n\nThe enhanced pipeline follows a three-stage structure:\n\n**1. Pipeline Structure**\n\nThe multi-stage pipeline uses separate stages for build, development deployment, and production promotion:\n\n```\n# Run when commits are pushed to main\ntrigger:\n- main\n\npool: vmImage: ubuntu-latest\n\nstages:\n- stage: build_and_test\n- stage: deploy_development\ndependsOn: build_and_test\n- stage: promote_to_Prod\ndependsOn: deploy_development\n\n```\n\n**2. Build and Package Stage**\n\nThe first stage focuses solely on building and packaging the application for deployment:\n\n```\n- stage: build_and_test\njobs:\n- job: buildAndPackage\npool: vmImage: ubuntu-latest steps:\n- task: Bash@3\ndisplayName: Install azd inputs: targetType: 'inline' script: | curl -fsSL https://aka.ms/install-azd.sh | bash\n\n- task: PowerShell@2\ndisplayName: Configure AZD to Use AZ CLI Authentication. inputs: targetType: inline script: | azd config set auth.useAzCliAuth \"true\" pwsh: true\n\n- task: AzureCLI@2\ndisplayName: Package Application inputs: azureSubscription: azconnection scriptType: bash scriptLocation: inlineScript keepAzSessionActive: true inlineScript: | mkdir -p ./dist azd package app --output-path ./dist/app-package.zip --no-prompt echo \"‚úÖ Application packaged successfully\"\n\n- task: PublishPipelineArtifact@1\ndisplayName: Upload Package Artifact inputs: targetPath: './dist/app-package.zip' artifact: 'app-package' publishLocation: 'pipeline'\n\n```\n\n**3. Deploy to Development Stage**\n\nThe second stage provisions development infrastructure and deploys the packaged application:\n\n```\n- stage: deploy_development\ndependsOn: build_and_test jobs:\n- job: deployToDevelopment\npool: vmImage: ubuntu-latest steps:\n- task: Bash@3\ndisplayName: Install azd inputs: targetType: 'inline' script: | curl -fsSL https://aka.ms/install-azd.sh | bash\n\n- task: PowerShell@2\ndisplayName: Configure AZD to Use AZ CLI Authentication. inputs: targetType: inline script: | azd config set auth.useAzCliAuth \"true\" pwsh: true\n\n- task: AzureCLI@2\ndisplayName: Provision DEV Infrastructure inputs: azureSubscription: azconnection scriptType: bash scriptLocation: inlineScript keepAzSessionActive: true inlineScript: | azd provision --no-prompt\n\n- task: DownloadPipelineArtifact@2\ndisplayName: Download Package Artifact inputs: buildType: 'current' artifactName: 'app-package' targetPath: './artifacts'\n\n- task: AzureCLI@2\ndisplayName: Deploy to Development inputs: azureSubscription: azconnection scriptType: bash scriptLocation: inlineScript keepAzSessionActive: true inlineScript: | azd deploy app --from-package ./artifacts/app-package.zip --no-prompt\n\n```\n\n**4. Validation Gate**\n\nAdd validation checks before promotion to production:\n\n```\n- task: AzureCLI@2\ndisplayName: Validate Application inputs: azureSubscription: azconnection scriptType: bash scriptLocation: inlineScript keepAzSessionActive: true inlineScript: | echo \"üîç Validating application in development environment...\"\n# TODO: Add actual validation here\n# Examples:\n# - Health checks and integration tests\n# - Security and compliance scanning\n# - Performance validation\nsleep 3 # Simulate validation time echo \"‚úÖ Application validation passed\"\n\n```\n\n**5. Promote to Production Stage**\n\nThe final stage uses environment-specific variables to deploy to production:\n\n```\n- stage: promote_to_Prod\ndependsOn: deploy_development jobs:\n- job: deployProduction\n# use prod settings to override default environment variables\n# this variables become ENV VARS for all tasks in this job\nvariables: AZURE_ENV_NAME: $(AZURE_PROD_ENV_NAME) AZURE_ENV_TYPE: $(AZURE_PROD_ENV_TYPE) AZURE_LOCATION: $(AZURE_PROD_LOCATION) AZURE_SUBSCRIPTION_ID: $(AZURE_PROD_SUBSCRIPTION_ID) pool: vmImage: ubuntu-latest steps:\n- task: Bash@3\ndisplayName: Install azd inputs: targetType: 'inline' script: | curl -fsSL https://aka.ms/install-azd.sh | bash\n\n- task: PowerShell@2\ndisplayName: Configure AZD to Use AZ CLI Authentication. inputs: targetType: inline script: | azd config set auth.useAzCliAuth \"true\" pwsh: true\n\n- task: DownloadPipelineArtifact@2\ndisplayName: Download Package Artifact inputs: buildType: 'current' artifactName: 'app-package' targetPath: './artifacts'\n\n- task: AzureCLI@2\ndisplayName: Deploy to PROD inputs: azureSubscription: azconnection scriptType: bash scriptLocation: inlineScript keepAzSessionActive: true inlineScript: | azd deploy app --from-package ./artifacts/app-package.zip --no-prompt\n\n```\n\n## Try It Out\n\nYou can try this approach using the complete implementation [here](https://github.com/puicchan/azd-dev-prod-appservice-storage.)\n\nWatch the walkthrough:\n\n### Prerequisites\n\nYou‚Äôll need a Personal Access Token (PAT) to set up Azure DevOps pipelines with azd. For detailed guidance on PAT creation and pipeline setup, refer to the [Microsoft Learn documentation](https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/pipeline-azure-pipelines).\n\n### Setup Steps\n\n**1. Initialize Project**\n\n``` azd init -t https://github.com/puicchan/azd-dev-prod-appservice-storage\n\n```\n\nUse environment name like `projazdo-dev` .\n\n**2. Edit azure.yaml**\n\nMake sure you configure Azure DevOps as the CICD tool and add these pipeline variables:\n\n``` pipeline: provider: azdo variables:\n- AZURE_PROD_ENV_NAME\n- AZURE_PROD_ENV_TYPE\n- AZURE_PROD_LOCATION\n- AZURE_PROD_SUBSCRIPTION_ID\n\n```\n\n**3. Set Up Development Environment**\n\n``` azd up\n\n```\n\n**4. Set Up Production Environment**\n\nWe will run `azd provision` and rely on Azure Pipeline to deploy the app to production:\n\n``` azd env new projazdo-prod azd env set AZURE_ENV_TYPE prod azd provision\n\n```\n\n**5. Test the Flow**\n\nSwitch back to Development:\n\n``` azd env select projazdo-dev\n\n```\n\nEdit your application code and make sure you run `azd env set` to configure the following environment variables the pipeline requires:\n\n- AZURE\\_PROD\\_ENV\\_NAME\n- AZURE\\_PROD\\_ENV\\_TYPE\n- AZURE\\_PROD\\_LOCATION\n- AZURE\\_PROD\\_SUBSCRIPTION\\_ID\n\n**6. Configure CI/CD Pipeline**\n\n``` azd pipeline config\n\n```\n\nGo to your Azure Pipelines Organization and check out the pipeline run.\n\n## Pro Tip: Enhance Your Pipeline with AI\n\nNeed help with Azure DevOps and azd? [GitHub Copilot for Azure](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-azure-github-copilot) with [Azure MCP](https://learn.microsoft.com/azure/developer/azure-mcp-server/overview) can help you enhance your `azure-dev.yml` file directly in VS Code.\n\nWith the GitHub Copilot for Azure extension installed, and the GitHub Copilot for Azure and Azure MCP tools enabled in Agent mode, GitHub Copilot can:\n\n- **Debug pipeline issues**: Analyze YAML syntax errors and configuration problems.\n- **Add validation steps**: Suggest health checks, security scans, or integration tests.\n- **Optimize deployment strategies**: Recommend blue-green deployments or canary releases.\n- **Configure environment-specific logic**: Help set up conditional steps for different environments.\n\nSimply ask GitHub Copilot questions like:\n\n- ‚ÄúAdd a health check validation step to my Azure DevOps pipeline‚Äù\n- ‚ÄúHow can I add manual approval gates before production deployment?‚Äù\n\nAgent mode with GitHub Copilot for Azure provides contextual understanding of your Azure resources. It can suggest pipeline improvements based on your specific infrastructure setup.\n\n## Conclusion\n\nThis Azure DevOps implementation demonstrates how the ‚Äúbuild once, deploy everywhere‚Äù pattern translates seamlessly across different CI/CD platforms. The core azd and Bicep logic remains identical. Meanwhile, platform-specific features like service connections and task definitions provide the Azure DevOps-native experience.\n\nWhether you choose GitHub Actions or Azure DevOps, the fundamental approach remains consistent. Conditional infrastructure deployment and package promotion ensure reliable deployments across your development lifecycle.\n\nQuestions about implementation or want to share your Azure DevOps approach? Join the discussion [here](https://github.com/Azure/azure-dev/discussions/5447).",
  "Title": "Azure Developer CLI: From Dev to Prod with Azure DevOps Pipelines",
  "FeedLevelAuthor": "Azure DevOps Blog",
  "OutputDir": "_news",
  "Description": "Building on our previous post about implementing dev-to-prod promotion with GitHub Actions, this follow-up demonstrates the same ‚Äúbuild once, deploy everywhere‚Äù pattern using Azure DevOps Pipelines. You‚Äôll learn how to leverage Azure DevOps YAML pipelines with Azure Developer CLI (azd). This approach ensures consistent, reliable deployments across environments. Environment-Specific Infrastructure The infrastructure approach is identical [‚Ä¶]\n\nThe post [Azure Developer CLI: From Dev to Prod with Azure DevOps Pipelines](https://devblogs.microsoft.com/devops/azure-developer-cli-from-dev-to-prod-with-azure-devops-pipelines/) appeared first on [Azure DevOps Blog](https://devblogs.microsoft.com/devops).",
  "Tags": [
    "azd",
    "Azure & Cloud",
    "Azure Developer CLI",
    "Azure Developer CLI (azd)",
    "CI/CD",
    "DevOps"
  ]
}
