{
  "Tags": [
    "Azure SDK",
    "java",
    "Spring",
    "Spring Cloud Azure"
  ],
  "OutputDir": "_news",
  "FeedLevelAuthor": "Azure SDK Blog",
  "ProcessedDate": "2025-08-05 14:10:14",
  "FeedUrl": "https://devblogs.microsoft.com/azure-sdk/feed/",
  "Title": "Introducing Spring Cloud Azure Starter Key Vault JCA: Streamlined TLS and mTLS for Spring Boot",
  "Description": "This blog post shows the Spring Cloud Azure Starter Key Vault Java Crypto Architecture (JCA).\n\nThe post [Introducing Spring Cloud Azure Starter Key Vault JCA: Streamlined TLS and mTLS for Spring Boot](https://devblogs.microsoft.com/azure-sdk/introducing-spring-cloud-azure-starter-key-vault-jca-streamlined-tls-and-mtls-for-spring-boot/) appeared first on [Azure SDK Blog](https://devblogs.microsoft.com/azure-sdk).",
  "Link": "https://devblogs.microsoft.com/azure-sdk/introducing-spring-cloud-azure-starter-key-vault-jca-streamlined-tls-and-mtls-for-spring-boot/",
  "FeedName": "Microsoft DevBlog",
  "Author": "Moary Chen",
  "EnhancedContent": "We’re excited to unveil **Spring Cloud Azure Starter Key Vault Java Crypto Architecture (JCA)**, a new addition to the Spring Cloud Azure family, arriving with version **5.21.0**. Designed for **Spring Boot 3.1+**, this starter applies the **Spring SSL Bundles** abstraction and the **JCA Provider for Azure Key Vault** to simplify secure communication in your Spring Boot applications. Whether you’re enabling TLS for your server or setting up mutual TLS (mTLS) for client-server authentication, this starter integrates Azure Key Vault’s certificate management with Spring’s modern security framework.\n\nIn this blog post, we dive into the starter’s capabilities and demonstrate its usage with practical examples for enabling embedded server TLS, securing `RestTemplate` , securing `WebClient` , and configuring mTLS communication. Let’s get started!\n\n## What is Spring Cloud Azure Starter Key Vault JCA?\n\nThe Spring Cloud Azure Starter Key Vault JCA combines the power of Spring Boot’s SSL Bundles (introduced in Spring Boot 3.1) with Azure Key Vault’s JCA provider. This integration allows developers to use certificates stored in Key Vault directly within Spring applications, eliminating the complexity of traditional keystore management seen in older configurations. For example, [Securing Spring Boot applications based on older version](https://learn.microsoft.com/azure/developer/java/spring-framework/configure-spring-boot-starter-java-app-with-azure-key-vault-certificates). For a deeper dive into Spring SSL Bundles, see [Spring SSL Bundles](https://docs.spring.io/spring-boot/reference/features/ssl.html).\n\n## Get started\n\nAdd the following dependency to your `pom.xml` file:\n\n```xml <dependency> <groupId>com.azure.spring</groupId> <artifactId>spring-cloud-azure-starter-keyvault-jca</artifactId> <version>5.21.0</version> </dependency> ```\n\nComplete the following steps to prepare the Azure resources:\n\n1. Create two self-signed certificates in two Key Vault resources by following the steps at [Add a self-signed certificate to Key Vault](https://learn.microsoft.com/azure/key-vault/certificates/quick-create-portal#add-a-certificate-to-key-vault). The certificate names are `server`\nand `client` , respectively. Assume that `keyvault1` stores the `server` certificate and `keyvault2` stores the `client` certificate.\n2. Create a Service Principal for accessing Key Vault by following the steps at [Create a Service Principal](https://learn.microsoft.com/entra/identity-platform/howto-create-service-principal-portal).\n3. Grant role `Key Vault Certificate User`\nto the Service Principal for each Key Vault instance by following the steps at [Role assignment](https://learn.microsoft.com/azure/key-vault/general/rbac-guide).\n\n>\n> Note:\n> Environment variables prefixed with `KEY_VAULT_SSL_BUNDLES`\n> represent the connection information for your Key Vault instances and Service Principal.\n>\n\n## Enable embedded server TLS\n\nSecure inbound HTTP calls for the embedded server. The embedded server applies the Key Vault SSL Bundle to enable Server TLS and that applies to all web servers supported by Spring Boot.\n\nUpdate your `application.yml` file:\n\n```yaml spring: application: name: ssl-bundles-server ssl: bundle: keyvault: tlsServerBundle: key: alias: server keystore: keyvault-ref: keyvault1 cloud: azure: keyvault: jca: vaults: keyvault1: endpoint: ${KEY_VAULT_SSL_BUNDLES_KEYVAULT_URI_01} profile: tenant-id: ${KEY_VAULT_SSL_BUNDLES_TENANT_ID} credential: client-id: ${KEY_VAULT_SSL_BUNDLES_CLIENT_ID} client-secret: ${KEY_VAULT_SSL_BUNDLES_CLIENT_SECRET} server: ssl: bundle: tlsServerBundle ```\n\n## Secure RestTemplate\n\nSecure outbound HTTP calls with `RestTemplate` using a Key Vault SSL Bundle.\n\n1. Update your `application.yml`\nfile:\n\n```yaml spring: ssl: bundle: keyvault: tlsClientBundle: truststore: keyvault-ref: keyvault1 cloud: azure: keyvault: jca: vaults: keyvault1: endpoint: ${KEY_VAULT_SSL_BUNDLES_KEYVAULT_URI_01} profile: tenant-id: ${KEY_VAULT_SSL_BUNDLES_TENANT_ID} credential: client-id: ${KEY_VAULT_SSL_BUNDLES_CLIENT_ID} client-secret: ${KEY_VAULT_SSL_BUNDLES_CLIENT_SECRET} ```\n2. Update your `RestTemplate`\nconfiguration to set the Key Vault SSL Bundle:\n\n```java @Bean RestTemplate restTemplateWithTLS(RestTemplateBuilder restTemplateBuilder, SslBundles sslBundles) { return restTemplateBuilder.sslBundle(sslBundles.getBundle(\"tlsClientBundle\")).build(); } ```\n\nThen you can use bean `restTemplateWithTLS` to access the HTTPS resource owned by app `ssl-bundles-server` .\n\n## Secure WebClient\n\nSecure outbound HTTP calls with `WebClient` using a Key Vault SSL Bundle.\n\n1. Update your `application.yml`\nfile according to the configuration of the `Secure RestTemplate` scenario.\n2. Update your `WebClient`\nbean configuration to apply the Key Vault SSL Bundle:\n\n```java @Bean WebClient webClientWithTLS(WebClientSsl ssl) { return WebClient.builder().apply(ssl.fromBundle(\"tlsClientBundle\")).build(); } ```\n\nThen you can use bean `webClientWithTLS` to access the HTTPS resource owned by app `ssl-bundles-server` .\n\n## Enable mTLS communication\n\nSet up mTLS for two-way authentication between client and server.\n\n### Server side\n\nUpdate your `application.yml` file to trust the client certificates in Key Vault `keyvault2` , and enable the client authentication:\n\n```yaml spring: application: name: ssl-bundles-server ssl: bundle: keyvault: tlsServerBundle: key: alias: server keystore: keyvault-ref: keyvault1 truststore: keyvault-ref: keyvault2 cloud: azure: keyvault: jca: vaults: keyvault1: endpoint: ${KEY_VAULT_SSL_BUNDLES_KEYVAULT_URI_01} profile: tenant-id: ${KEY_VAULT_SSL_BUNDLES_TENANT_ID} credential: client-id: ${KEY_VAULT_SSL_BUNDLES_CLIENT_ID} client-secret: ${KEY_VAULT_SSL_BUNDLES_CLIENT_SECRET} keyvault2: endpoint: ${KEY_VAULT_SSL_BUNDLES_KEYVAULT_URI_02} profile: tenant-id: ${KEY_VAULT_SSL_BUNDLES_TENANT_ID} credential: client-id: ${KEY_VAULT_SSL_BUNDLES_CLIENT_ID} client-secret: ${KEY_VAULT_SSL_BUNDLES_CLIENT_SECRET} server: ssl: bundle: tlsServerBundle client-auth: NEED ```\n\n### Client side\n\nComplete the following steps:\n\n1. Update your `application.yml`\nfile to provide keystore for client authentication in Key Vault `keyvault2` :\n\n```yaml spring: ssl: bundle: keyvault: mtlsClientBundle: key: alias: client for-client-auth: true keystore: keyvault-ref: keyvault2 truststore: keyvault-ref: keyvault1 cloud: azure: keyvault: jca: vaults: keyvault1: endpoint: ${KEY_VAULT_SSL_BUNDLES_KEYVAULT_URI_01} profile: tenant-id: ${KEY_VAULT_SSL_BUNDLES_TENANT_ID} credential: client-id: ${KEY_VAULT_SSL_BUNDLES_CLIENT_ID} client-secret: ${KEY_VAULT_SSL_BUNDLES_CLIENT_SECRET} keyvault2: endpoint: ${KEY_VAULT_SSL_BUNDLES_KEYVAULT_URI_02} profile: tenant-id: ${KEY_VAULT_SSL_BUNDLES_TENANT_ID} credential: client-id: ${KEY_VAULT_SSL_BUNDLES_CLIENT_ID} client-secret: ${KEY_VAULT_SSL_BUNDLES_CLIENT_SECRET} ```\n2. Register another `RestTemplate`\nbean for mTLS connection, and the same if you use `WebClient` :\n\n```java @Bean RestTemplate restTemplateWithMTLS(RestTemplateBuilder restTemplateBuilder, SslBundles sslBundles) { return restTemplateBuilder.sslBundle(sslBundles.getBundle(\"mtlsClientBundle\")).build(); }\n\n// or you can use WebClient instead @Bean WebClient webClientWithMTLS(WebClientSsl ssl) { return WebClient.builder().apply(ssl.fromBundle(\"mtlsClientBundle\")).build(); } ```\n\nNow you can use beans `restTemplateWithMTLS` or `webClientWithMTLS` to access the HTTPS resource owned by app `ssl-bundles-server` .\n\n## Feedback\n\nYour feedback and contributions are always welcome on [StackOverflow](https://stackoverflow.com/questions/tagged/spring-cloud-azure) or [GitHub](https://github.com/Azure/azure-sdk-for-java/issues?q=is%3Aissue+is%3Aopen+label%3Aazure-spring).\n\n## Resources\n\nTo learn more about Spring Cloud Azure, visit the following links:\n\n- [Enable HTTPS in Spring Boot application (Legacy)](https://learn.microsoft.com/azure/developer/java/spring-framework/configure-spring-boot-starter-java-app-with-azure-key-vault-certificates).\n- [Sign and verify jar files](https://techcommunity.microsoft.com/blog/appsonazureblog/seamlessly-integrating-azure-keyvault-with-jarsigner-for-enhanced-security/4125770).\n- [Use Azure Key Vault to deliver TLS/SSL certificates to the Java Virtual Machine](https://learn.microsoft.com/azure/developer/java/fundamentals/java-azure-keyvault-ssl-integration-jvm).\n- [Use Azure Key Vault to deliver TLS/SSL certificates to Apache Tomcat](https://learn.microsoft.com/azure/developer/java/fundamentals/java-azure-keyvault-tomcat-integration?tabs=windows).\n- [Reference Documentation](https://aka.ms/spring/docs)\n- [Conceptual Documentation](https://aka.ms/spring/msdocs)\n- [Code Samples](https://aka.ms/spring/samples)\n- [Spring Version Mapping](https://aka.ms/spring/versions)\n- [CHANGELOGs of Spring Cloud Azure](https://github.com/Azure/azure-sdk-for-java/blob/main/sdk/spring/CHANGELOG.md)",
  "PubDate": "2025-04-11T21:11:34+00:00"
}
