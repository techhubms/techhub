{
  "Tags": [
    "Azure SDK",
    "java",
    "Spring",
    "Spring Cloud Azure"
  ],
  "OutputDir": "_news",
  "FeedLevelAuthor": "Azure SDK Blog",
  "ProcessedDate": "2025-08-05 14:10:15",
  "FeedUrl": "https://devblogs.microsoft.com/azure-sdk/feed/",
  "Title": "Spring Cloud Azure updates and troubleshooting tips for Java on AKS",
  "Description": "This post shows the latest Spring Cloud Azure updates.\n\nThe post [Spring Cloud Azure updates and troubleshooting tips for Java on AKS](https://devblogs.microsoft.com/azure-sdk/spring-cloud-azure-updates-and-troubleshooting-tips-for-java-on-aks/) appeared first on [Azure SDK Blog](https://devblogs.microsoft.com/azure-sdk).",
  "Link": "https://devblogs.microsoft.com/azure-sdk/spring-cloud-azure-updates-and-troubleshooting-tips-for-java-on-aks/",
  "FeedName": "Microsoft DevBlog",
  "Author": "Moary Chen",
  "EnhancedContent": "In this post, we explore the newest features, improvements, and bug fixes in Spring Cloud Azure and Java on Azure. We cover versions 5.16.0 to 5.19.0 of Spring Cloud Azure and provide troubleshooting tips for Java processes on Azure Kubernetes Service (AKS). This comprehensive overview shows you what’s new and how it can benefit your projects.\n\n## Fresh capabilities to explore\n\nDiscover the latest features and enhancements in Spring Cloud Azure, designed to address common user scenarios and improve your development experience.\n\n### Full support for Spring Boot 3.4\n\nSpring Cloud Azure 5.19.0 now fully supports Spring Boot 3.4.0 and later versions. This means you can apply the latest Spring Boot features in your applications. For more information, see the [release notes](https://github.com/Azure/azure-sdk-for-java/blob/main/sdk/spring/CHANGELOG.md).\n\n### Enhanced configuration of authentication mechanism\n\nSpring Cloud Azure offers flexible configuration properties, prefixed with `spring.cloud.azure.credential.` , to manage several types of credentials, such as service principals and managed identities. With the latest enhancement, you can now use `spring.cloud.azure.credential.token-credential-bean-name` to further customize your authentication beans, providing even greater control over your application’s security.\n\nFirst, define a `TokenCredential` bean in your application:\n\n```java @Bean TokenCredential myTokenCredential() { // Your concrete TokenCredential instance } ```\n\nNext, add one property entry for it:\n\n```yaml spring: cloud: azure: credential: token-credential-bean-name: myTokenCredential ```\n\n#### Configuration for Azure SDK clients\n\nNot only can the `token-credential-bean-name` property be configured at the `spring.cloud.azure` level, but it can also be configured for each service client. For example, you could configure it for the Azure Storage blob client:\n\n```yaml spring: cloud: azure: storage: blob: account-name: <your-azure-storage-account-name> container-name: <your-blob-container-name> credential: token-credential-bean-name: myTokenCredential ```\n\n#### Configuration for passwordless connections\n\nApart from configuring the token credential for Azure SDK clients, you could also configure it for other Azure services like Azure Database for MySQL – Flexible Server, Azure Database for PostgreSQL – Flexible Server, Azure Cache for Redis, and Service Bus. The following configuration is an example for the Redis passwordless connection:\n\n```yaml spring: data: redis: host: <your-azure-redis-name>.redis.cache.windows.net port: 6380 ssl: enabled: true azure: passwordless-enabled: true credential: token-credential-bean-name: myTokenCredential ```\n\nAnd the following configuration is an example for a Service Bus JMS passwordless connection:\n\n```yaml spring: jms: servicebus: pricing-tier: <your-service-bus-pricing-tier> namespace: <your-service-bus-namespace> topic-client-id: <topic-client-id> passwordless-enabled: true credential: token-credential-bean-name: myTokenCredential ```\n\n#### Configuration for Key Vault property source\n\nSince the Key Vault property source authenticates at an earlier initialization stage, the `token-credential-bean-name` property doesn’t take effect on it. But you can still configure a customized `TokenCredential` for it. For example, before the Spring Boot application runs, register a token credential object for authentication to Key Vault:\n\n```java public static void main(String[] args) { SpringApplication application = new SpringApplication(YourSpringApplication.class); application.addBootstrapRegistryInitializer(registry -> registry.register(TokenCredential.class, context -> { // Your concrete TokenCredential instance })); application.run(args); } ```\n\n### New Java Diagnostic Tool on AKS\n\nThe Java Diagnostic Tool (diag4j) is a lightweight, nonintrusive monitoring and diagnostic solution for Java applications running on AKS.\n\nKey features of the tool include:\n\n- Lightweight and noninvasive: By using Spring Boot Admin (SBA) and the Java Attach Agent, the tool is resource-efficient and doesn’t require extensive modifications to applications.\n- Automatic Kubernetes Integration: The tool automatically discovers pods with exposed actuator endpoints, listing them on the SBA dashboard.\n- Real-time metrics and diagnostics: The tool displays real-time application metrics, garbage collection (GC) status, and environment variables. You can also adjust log levels dynamically for deeper insights into specific issues.\n- Advanced diagnostics: The tool offers enhanced diagnostic features. These features include:\n- Inspection of stack traces\n- Viewing of local variables\n- Generation of heap and thread dumps\n- Injection of logs dynamically for troubleshooting\n- IDE compatibility: The tool integrates with JetBrains IntelliJ to enable debugging without needing to rebuild or redeploy the application, enabling streamlined troubleshooting.\n\nFor a detailed guide on getting started with diag4j, see [Get started with Java Diagnostic Tool](https://learn.microsoft.com/azure/developer/java/fundamentals/java-diagnostic-tools-on-aks-overview). Here’s a [video](https://youtu.be/srysxWp2tak) about using diag4j.\n\nYou can provide feedback or create an issue in [this GitHub repository](https://github.com/microsoft/diag4j).\n\n## Common scenarios\n\nIn the following sections, we iterate through several common scenarios.\n\n### Dead-lettering a message using Service Bus JMS\n\nService Bus JMS provides a way to consume Dead Letter Queue (DLQ) messages from a Service Bus queue in the same way as consuming a queue using the `@JmsListener` annotation.\n\nFirst, use the following configuration:\n\n```yaml spring: jms: listener: session: acknowledge-mode: CLIENT transacted: false servicebus: pricing-tier: <your-service-bus-pricing-tier> namespace: <your-service-bus-namespace> passwordless-enabled: true ```\n\nUse the following sample code to consume messages from the Service Bus queue. If the message is invalid, move it to the DLQ of the queue:\n\n```java @Component public class QueueReceiveService { private final Logger LOGGER = LoggerFactory.getLogger(QueueReceiveService.class); private static final String QUEUE_NAME = \"<your-queue-name>\";\n\n@JmsListener(destination = QUEUE_NAME, containerFactory = \"jmsListenerContainerFactory\") public void receiveMessage(JmsObjectMessage message) throws JMSException { User user = (User) message.getObject(); LOGGER.info(\"Received message from queue: {}.\", user); if (user.getName().toLowerCase().contains(\"invalid\")) { message.setIntProperty(JmsMessageSupport.JMS_AMQP_ACK_TYPE, REJECTED); message.acknowledge(); LOGGER.info(\"Move message into dead letter queue: {}.\", user); } } } ```\n\nUse the following sample code to consume DLQ messages from the Service Bus queue:\n\n```java @Component public class DeadLetterQueueReceiveService { private final Logger LOGGER = LoggerFactory.getLogger(DeadLetterQueueReceiveService.class); private static final String QUEUE_NAME = \"<your-queue-name>\"; private static final String DEAD_LETTER_QUEUE_NAME_SUFFIX = \"/$deadletterqueue\"; private static final String DEAD_LETTER_QUEUE_NAME = QUEUE_NAME + DEAD_LETTER_QUEUE_NAME_SUFFIX;\n\n@JmsListener(destination = DEAD_LETTER_QUEUE_NAME, containerFactory = \"jmsListenerContainerFactory\") public void receiveDeadLetterMessage(JmsObjectMessage message) throws JMSException { User user = (User) message.getObject(); LOGGER.info(\"Received message from dead letter queue: {}.\", user); } } ```\n\n### Refresh Key Vault property sources\n\nKey Vault property sources support automatic refresh. For example, use the following configuration to refresh the secret keys. Then each property source can use a different refresh internal:\n\n```yaml spring: cloud: azure: keyvault: secret: property-source-enabled: true property-sources:\n- endpoint: ${KEY_VAULT_ENDPOINT_1}\nname: KeyVault1 refresh-interval: 10s secret-keys:\n- one-minutes-available-username\n- one-minutes-available-password\n- endpoint: ${KEY_VAULT_ENDPOINT_2}\nname: KeyVault2 refresh-interval: 30s secret-keys: game-rules ```\n\n### Configure passwordless connections with multiple data sources\n\nSpring Data supports registering multiple data sources. As of Spring Cloud Azure JDBC Starter `5.18.0` , it also supports multiple data sources with passwordless connections. For example, use the following configuration to define two database sources for different operation permissions. One source is for read operations and the other is for write operations:\n\n```yaml spring: datasource: read: url: <your-azure-database-jdbc-url> username: <your-database-user-name-for-read> azure: passwordless-enabled: true write: url: <your-azure-database-jdbc-url> username: <your-database-user-name-for-write> azure: passwordless-enabled: true credential: token-credential-bean-name: myTokenCredential ```\n\nThis configuration uses different authentication methods for each data source. The first data source uses the Azure Identity library’s `DefaultAzureCredential` to authenticate with Microsoft Entra ID. The second data source uses the customized token credential bean.\n\n## Protect your applications with efficiency\n\nEnhance your app’s security and performance with the latest updates in Key Vault JCA and Azure Identity Extensions. These updates include support for intermediate certificates and caching `TokenCredential` instances.\n\n### Key Vault JCA supports loading of intermediate certificates\n\nSince version 2.10.0, the Key Vault Java Cryptography Architecture (JCA) can [read intermediate certificates in certificate chains](https://github.com/Azure/azure-sdk-for-java/pull/41303). With the new version of `azure-security-keyvault-jca` , such kinds of certificates can be used too:\n\n1. [Enable HTTPS in Spring Boot application](https://learn.microsoft.com/azure/developer/java/spring-framework/configure-spring-boot-starter-java-app-with-azure-key-vault-certificates).\n2. [Sign and verify jar files](https://techcommunity.microsoft.com/blog/appsonazureblog/seamlessly-integrating-azure-keyvault-with-jarsigner-for-enhanced-security/4125770).\n3. [Use Azure Key Vault to deliver TLS/SSL certificates to the Java Virtual Machine](https://learn.microsoft.com/azure/developer/java/fundamentals/java-azure-keyvault-ssl-integration-jvm).\n4. [Use Azure Key Vault to deliver TLS/SSL certificates to Apache Tomcat](https://learn.microsoft.com/azure/developer/java/fundamentals/java-azure-keyvault-tomcat-integration?tabs=windows).\n\n### Azure Identity Extensions now supports caching of token credential instances\n\nAs of Azure Identity Extensions version 1.2.0, the library supports caching of `TokenCredential` objects across multiple authentication invocations by default via the property `azure.tokenCredentialCacheEnabled` . This capability reduces the number of Microsoft Entra access token requests. For example, when using the Azure Identity library’s `WorkloadIdentityCredential` , more pressure is placed on the internal authorization server for access token acquisition if the token credential caching disabled. To disable token credential caching and to customize the access token acquisition timeout, use the following code:\n\n```java Properties properties = new Properties(); properties.setProperty(\"user\", \"<your-database-username>\"); properties.setProperty(\"authenticationPluginClassName\", \"com.azure.identity.extensions.jdbc.postgresql.AzurePostgresqlAuthenticationPlugin\"); properties.setProperty(\"azure.tokenCredentialCacheEnabled\", \"false\"); String url = \"<your-database-jdbc-url>\"; Connection connection = DriverManager.getConnection(url, properties); // use connection to execute SQL ```\n\n## Known issues\n\nIn the following section, note the known issues to be resolved as soon as possible after upgrading the newer version.\n\n### Use global managed identity credential\n\nAs of Spring Cloud Azure version 5.18.0, a defect in merging the global credential properties bean to each SDK properties bean is fixed. If you upgrade from version 5.18.0 to 5.19.0 and use global managed identity credential, you should encounter regression test failures. For more information, see the following GitHub issues:\n\n- [#42979](https://github.com/Azure/azure-sdk-for-java/issues/42979)\n- [#43787](https://github.com/Azure/azure-sdk-for-java/issues/43787)\n\n## Feedback\n\nYour feedback and contributions are always welcome on [StackOverflow](https://stackoverflow.com/questions/tagged/spring-cloud-azure) or [GitHub](https://github.com/Azure/azure-sdk-for-java/issues?q=is%3Aissue+is%3Aopen+label%3Aazure-spring).\n\n## Resources\n\nTo learn more about Spring Cloud Azure, we invite you to visit the following links:\n\n- [Reference Documentation](https://aka.ms/spring/docs)\n- [Conceptual Documentation](https://aka.ms/spring/msdocs)\n- [Code Samples](https://aka.ms/spring/samples)\n- [Spring Version Mapping](https://aka.ms/spring/versions)\n- [CHANGELOGS of Spring Cloud Azure](https://github.com/Azure/azure-sdk-for-java/blob/main/sdk/spring/CHANGELOG.md)",
  "PubDate": "2025-02-17T17:05:08+00:00"
}
