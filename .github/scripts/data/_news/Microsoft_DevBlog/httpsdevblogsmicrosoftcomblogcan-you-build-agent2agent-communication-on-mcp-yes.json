{
  "Tags": [
    "AI",
    "MCP"
  ],
  "OutputDir": "_news",
  "FeedLevelAuthor": "Microsoft for Developers",
  "ProcessedDate": "2025-08-05 14:17:15",
  "FeedUrl": "https://devblogs.microsoft.com/feed",
  "Title": "Can You Build Agent2Agent Communication on MCP? Yes!",
  "Description": "MCP has evolved significantly beyond its original goal of ‚Äúproviding context to LLMs.‚Äù With recent enhancements including resumable streams, elicitation, sampling, and notifications (progress and resources), MCP now provides a robust foundation for building complex agent-to-agent communication systems. In this article, you‚Äôll learn: How to build agent-to-agent communication with MCP capabilities where MCP hosts and tools [‚Ä¶]\n\nThe post [Can You Build Agent2Agent Communication on MCP? Yes!](https://devblogs.microsoft.com/blog/can-you-build-agent2agent-communication-on-mcp-yes) appeared first on [Microsoft for Developers](https://devblogs.microsoft.com).",
  "Link": "https://devblogs.microsoft.com/blog/can-you-build-agent2agent-communication-on-mcp-yes",
  "FeedName": "Microsoft DevBlog",
  "Author": "Victor Dibia, Mike Kistler, Maria Naggaga",
  "EnhancedContent": "MCP has evolved significantly beyond its original goal of ‚Äúproviding context to LLMs.‚Äù With recent enhancements including [resumable streams](https://modelcontextprotocol.io/docs/concepts/transports#resumability-and-redelivery), [elicitation](https://modelcontextprotocol.io/specification/2025-06-18/client/elicitation), [sampling](https://modelcontextprotocol.io/specification/2025-06-18/client/sampling), and notifications ([progress](https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/progress) and [resources](https://modelcontextprotocol.io/specification/2025-06-18/schema#resourceupdatednotification)), MCP now provides a robust foundation for building complex agent-to-agent communication systems.\n\nIn this article, you‚Äôll learn:\n\n- **How to build agent-to-agent communication with MCP capabilities** where MCP hosts and tools both act as intelligent agents\n- **Four key capabilities that make MCP tools ‚Äúagentic‚Äù** ‚Äì streaming, resumability, durability, and multi-turn interactions\n- **How to build long-running agents** with a complete Python implementation (an MCP server with a travel agent and research agents that stream updates, request input and are resumable.)\n\n[![The MCP spec now supports agentic capabilities ‚Äì specifically, tools are now resumable, can stream progress update notifications to clients, can request user input, and support the ability to poll for results (by returning resource links). These capabilities can be composed to build complex agent-to-agent systems. ](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAACcQAAAVxAQMAAACZGo/MAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABv0lEQVR4nO3BMQEAAADCoPVPbQo/oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICfAaz0AAF+1G4CAAAAAElFTkSuQmCC)](https://devblogs.microsoft.com/wp-content/uploads/2025/07/mcp_agent_1-1-scaled.png)The MCP spec now supports agentic capabilities ‚Äì specifically, tools are now resumable, can stream progress update notifications to clients, can request user input, and support the ability to poll for results (by returning resource links). These capabilities can be composed to build complex agent-to-agent systems.\n\n**TLDR; Can You Build Agent-to-Agent Communication on MCP?**\n\nYes ‚Äì you can compose features such as resumable streams (for session continuity), elicitation (for requesting user input), sampling (for requesting AI assistance), and progress notifications (for real-time updates) to build complex agent interactions! Check out the full code used for this article on [GitHub](http://aka.ms/mcp-agent-tutorial).\n\n[![GitHub](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAyAQMAAACQ++z9AAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAD0lEQVQokWNgGAWjYGgCAAK8AAGBAoNpAAAAAElFTkSuQmCC)](http://aka.ms/mcp-agent-tutorial)\n\n## **The Agent/Tool Misconception**\n\nAs more developers explore tools with agentic behaviors (run for long periods, may require additional input mid-execution, etc.), a common misconception is that MCP is unsuitable primarily because early examples of its [tools](https://modelcontextprotocol.io/docs/concepts/tools) primitive focused on simple request-response patterns.\n\nThis perception is outdated. The MCP specification has been significantly enhanced over the past few months with capabilities that *narrow* the gap for building long-running agentic behavior:\n\n- **Streaming & Partial Results**: Real-time progress updates during execution (with proposals supporting partial results). See docs on [progress updates](https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/progress#progress).\n- **Resumability**: Clients can reconnect and continue after disconnection. See docs on [resumability and redelivery](https://modelcontextprotocol.io/docs/concepts/transports#resumability-and-redelivery) on streamable HTTP transport.\n- **Durability**: Results survive server restarts. Tools can now return Resource Links which clients can poll or subscribe to. See docs on [Resource Links](https://modelcontextprotocol.io/specification/2025-06-18/server/tools#resource-links)\n- **Multi-turn**: Interactive input mid-execution via elicitation (requesting user input mid-execution) and sampling (requesting LLM completions from client/host application). See docs on [elicitation](https://modelcontextprotocol.io/docs/concepts/elicitation) and [sampling](https://modelcontextprotocol.io/docs/concepts/sampling).\n\nThese features can be composed to enable complex agentic and multi-agent applications; all deployed on the MCP protocol.\n\nFor simplicity, in this article we will refer to an ‚Äúagent‚Äù as a tool that meets certain enhanced capabilities rather than introducing an entirely new concept. In turn, these agents are tools available on MCP servers and can be invoked by host applications through standard MCP client connections. **Importantly, the host applications themselves are also agents** ‚Äì they coordinate tasks, maintain state, and make intelligent routing decisions. This creates true agent-to-agent communication: orchestrator agents (hosts) communicating with specialist agents (tools). What distinguishes these tools as ‚Äúagentic‚Äù is their ability to satisfy the infrastructure requirements we will outline below.\n\n## **What Makes an MCP Tool ‚ÄúAgentic‚Äù?**\n\nWe define an agent as an entity that can operate autonomously over extended periods, handling complex tasks that may require multiple interactions or adjustments based on real-time feedback. To support these behaviors, MCP tools need four key infrastructure capabilities which are discussed below with use cases and how MCP supports each:\n\n### **1. Streaming & Partial Results**\n\nAgents need mechanisms for real-time *progress updates* to keep users informed (observability, debugging, trust building) and streaming intermediate results that allow systems to react and adjust execution based on partial outputs. MCP supports this through [progress notifications](https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/progress#progress) that stream status updates in real-time, with proposals underway to enhance partial result streaming capabilities\n\n| **Feature** | **Use Case** | **MCP Support** | | --- | --- | --- | | Real-time Progress Updates | User requests a codebase migration task. The agent streams progress: ‚Äú10% ‚Äì Analyzing dependencies‚Ä¶ 25% ‚Äì Converting TypeScript files‚Ä¶ 50% ‚Äì Updating imports‚Ä¶‚Äù | ‚úÖ Progress notifications | | Partial Results | ‚ÄúGenerate a book‚Äù task streams partial results, e.g., 1) Story arc outline, 2) Chapter list, 3) Each chapter as completed. Host can inspect, cancel, or redirect at any stage. | ‚ö†Ô∏è Notifications can be ‚Äúextended‚Äù to include partial results e.g., by including them in the [message payload](https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/progress#progress-flow). There are open proposals to improve on this ‚Äì [383](https://github.com/modelcontextprotocol/modelcontextprotocol/pull/383), [776](https://github.com/modelcontextprotocol/modelcontextprotocol/pull/776) |\n\n[![mcp streaming image](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAACcQAAAGtAQMAAAAIqXeLAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAmUlEQVR4nO3BgQAAAADDoPlT3+AEVQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAMw5QAAGnqqtIAAAAAElFTkSuQmCC)](https://devblogs.microsoft.com/wp-content/uploads/2025/07/mcp_streaming-1-scaled.png)MCP tools (agent) can stream real-time progress update notifications to the host application during a long-running task, enabling the user to monitor execution in real time. Today, the message payload of the update notifications can be ‚Äùextended‚Äù to include partial results ‚Äì however there are a few open proposals to improve the partial results behavior in the MCP spec.\n\n### **2. Resumability**\n\nLong-running agents benefit from maintaining task continuity across network interruptions, allowing clients to reconnect and resume where they left off rather than losing progress or restarting complex operations. The MCP StreamableHTTP transport today supports [session resumption and message redelivery](https://modelcontextprotocol.io/docs/concepts/transports#resumability-and-redelivery) which enables this capability.\n\n**Implementation Note**\n\nTo enable session resumption, servers must implement an EventStore to enable event replays on client reconnection. The community is also exploring transport-agnostic resumable streams (see PR [PR #975](https://github.com/modelcontextprotocol/modelcontextprotocol/issues/975)) to extend this capability beyond StreamableHTTP.\n\n| **Feature** | **Use Case** | **MCP Support** | | --- | --- | --- | | Resumability | Client disconnects during long-running tool calls. Upon reconnection, session resumes with missed events replayed, continuing seamlessly from where it left off. | ‚úÖ StreamableHTTP transport with session IDs, event replay, and EventStore |\n\n[![mcp resumption image](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAACcQAAAL1AQMAAADZnOeMAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAA/UlEQVR4nO3BMQEAAADCoPVPbQlPoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+BqgrwABHrPwTAAAAABJRU5ErkJggg==)](https://devblogs.microsoft.com/wp-content/uploads/2025/07/mcp_resumption-1-scaled.png)MCP‚Äôs StreamableHTTP transport and event store enable seamless session resumption: if the client disconnects, it can reconnect, provide session details (session id, last event id) and the server replays missed events, continuing the task without loss of progress.\n\n### **3. Durability**\n\nLong-running agents need persistent state that survives server restarts and enables out-of-band status/result checking, allowing progress tracking across sessions. This can be implemented with MCP through [Resource links](https://modelcontextprotocol.io/specification/2025-06-18/server/tools#resource-links) ‚Äî in response to a tool call, tools can create a resource, immediately return its link, then continue processing in the background while updating the associated resource. Clients can poll or subscribe to the returned resource for status updates and results.\n\n**Scalability Consideration**\n\nPolling resources or subscribing for updates can consume significant resources at scale. The MCP community is exploring webhook and trigger mechanisms (including [#992](https://github.com/modelcontextprotocol/modelcontextprotocol/issues/992)) that would allow servers to proactively notify clients of updates, reducing resource consumption in high-volume scenarios.\n\n| **Feature** | **Use Case** | **MCP Support** | | --- | --- | --- | | Durability | Client makes a tool call for data migration task. Server returns a resource link immediately and updates the resource (tied to a database) as the task progresses in the background. Client can check status of task by polling the resource or subscribing for resource updates. | ‚úÖ Resource links with persistent storage and status notifications |\n\n[![mcp durable image](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAACcQAAAKgAQMAAACF337IAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAA40lEQVR4nO3BAQ0AAADCoPdPbQ8HFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM8GOG0AATvgKe0AAAAASUVORK5CYII=)](https://devblogs.microsoft.com/wp-content/uploads/2025/07/mcp_durable-1-scaled.png)MCP tools can now return resource Links which a client can poll or subscribe to for notifications. This enables durable access to tool call results.\n\n### **4. Multi-Turn Interactions**\n\nAgents may need additional input mid-execution‚Äîhuman clarification or approval for critical decisions, and AI-generated content or completions for complex subtasks. MCP fully supports these interactions through [elicitation](https://modelcontextprotocol.io/specification/draft/client/elicitation) (requesting human input) and [sampling](https://modelcontextprotocol.io/specification/draft/client/sampling) (requesting LLM completions through the client), enabling agents to dynamically gather information needed during a tool call.\n\n| **Feature** | **Use Case** | **MCP Support** | | --- | --- | --- | | Multi-Turn Interactions | Travel booking agent requests price confirmation from user, then requests AI completions to summarize travel data before completing a booking transaction. | ‚úÖ Elicitation for human input, sampling for AI input |\n\n[![mcp multiturn image](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAACcQAAAL1AQMAAADZnOeMAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAA/UlEQVR4nO3BMQEAAADCoPVPbQlPoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+BqgrwABHrPwTAAAAABJRU5ErkJggg==)](https://devblogs.microsoft.com/wp-content/uploads/2025/07/mcp_multiturn-1-scaled.png)MCP tools can interactively request human input or request AI assistance mid-execution, supporting complex, multi-turn workflows such as confirmations and dynamic decision-making.\n\n## **Implementing Long-Running Agents on MCP ‚Äì Code Overview**\n\n[![GitHub](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAAAyAQMAAACQ++z9AAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAD0lEQVQokWNgGAWjYGgCAAK8AAGBAoNpAAAAAElFTkSuQmCC)](http://aka.ms/mcp-agent-tutorial)\n\nAs part of this article, we provide a [code repository](http://aka.ms/mcp-agent-tutorial) that contains a complete implementation of long-running agents using the MCP Python SDK with StreamableHTTP transport for session resumption and message redelivery. The implementation demonstrates how MCP capabilities can be composed to enable sophisticated agent-like behaviors.\n\n[![mcp agent 2 image](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAACcQAAAUDAQMAAADf8CMGAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABnUlEQVR4nO3BMQEAAADCoPVPbQwfoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPgZJggAAe6NwcAAAAAASUVORK5CYII=)](https://devblogs.microsoft.com/wp-content/uploads/2025/07/mcp_agent_2-scaled.png)Our code sample demonstrates how a host application can connect to a server with multiple tools; a travel Agent which simulates a travel booking service with price confirmation via elicitation ; a research agent that performs research tasks with AI-assisted summaries via sampling\n\nSpecifically, we implement a server with two primary agent tools:\n\n- **Travel Agent** ‚Äì Simulates a travel booking service with price confirmation via elicitation\n- **Research Agent** ‚Äì Performs research tasks with AI-assisted summaries via sampling\n\nBoth agents demonstrate real-time progress updates, interactive confirmations, and full session resumption capabilities.\n\n**Project structure:**\n\n- **server/server.py** ‚Äì Resumable MCP server with travel and research agents that demonstrate elicitation, sampling, and progress updates\n- **client/client.py** ‚Äì Interactive host application with resumption support, callback handlers, and token management\n- **server/event\\_store.py** ‚Äì Event store implementation enabling session resumption and message redelivery\n\n### **Key Implementation Concepts**\n\nThe following sections show server-side agent implementation and client-side host handling for each capability:\n\n#### Streaming & Progress Updates ‚Äì Real-time Task Status\n\nStreaming enables agents to provide real-time progress updates during long-running tasks, keeping users informed of task status and intermediate results.\n\n**Server Implementation (agent sends progress notifications):**\n\n```python\n# From server/server.py - Travel agent sending progress updates\nfor i, step in enumerate(steps): await ctx.session.send_progress_notification( progress_token=ctx.request_id, progress=i * 25, total=100, message=step, related_request_id=str(ctx.request_id) ) await anyio.sleep(2) # Simulate work\n\n# Alternative: Log messages for detailed step-by-step updates\nawait ctx.session.send_log_message( level=\"info\", data=f\"Processing step {current_step}/{steps} ({progress_percent}%)\", logger=\"long_running_agent\", related_request_id=ctx.request_id, )\n\n```\n\n**Client Implementation (host receives progress updates):**\n\n```python\n# From client/client.py - Client handling real-time notifications\nasync def message_handler(message) -> None: if isinstance(message, types.ServerNotification): if isinstance(message.root, types.LoggingMessageNotification): console.print(f\"üì° [dim]{message.root.params.data}[/dim]\") elif isinstance(message.root, types.ProgressNotification): progress = message.root.params console.print(f\"üîÑ [yellow]{progress.message} ({progress.progress}/{progress.total})[/yellow]\")\n\n# Register message handler when creating session\nasync with ClientSession( read_stream, write_stream, message_handler=message_handler ) as session:\n\n```\n\n#### **Elicitation ‚Äì Requesting User Input**\n\nElicitation enables agents to request user input mid-execution. This is essential for confirmations, clarifications, or approvals during long-running tasks.\n\n**Server Implementation (agent requests confirmation):**\n\n```py\n# From server/server.py - Travel agent requesting price confirmation\nelicit_result = await ctx.session.elicit( message=f\"Please confirm the estimated price of $1200 for your trip to {destination}\", requestedSchema=PriceConfirmationSchema.model_json_schema(), related_request_id=ctx.request_id, )\n\nif elicit_result and elicit_result.action == \"accept\":\n# Continue with booking\nlogger.info(f\"User confirmed price: {elicit_result.content}\") elif elicit_result and elicit_result.action == \"decline\":\n# Cancel the booking\nbooking_cancelled = True ```\n\n**Client Implementation (host provides elicitation callback):**\n\n```py\n# From client/client.py - Client handling elicitation requests\nasync def elicitation_callback(context, params): console.print(f\"üí¨ Server is asking for confirmation:\") console.print(f\" {params.message}\")\n\nresponse = console.input(\"Do you accept? (y/n): \").strip().lower()\n\nif response in ['y', 'yes']: return types.ElicitResult( action=\"accept\", content={\"confirm\": True, \"notes\": \"Confirmed by user\"} ) else: return types.ElicitResult( action=\"decline\", content={\"confirm\": False, \"notes\": \"Declined by user\"} )\n\n# Register the callback when creating the session\nasync with ClientSession( read_stream, write_stream, elicitation_callback=elicitation_callback ) as session: ```\n\n#### **Sampling ‚Äì Requesting AI Assistance**\n\nSampling allows agents to request LLM assistance for complex decisions or content generation during execution. This enables hybrid human-AI workflows.\n\n**Server Implementation (agent requests AI assistance):**\n\n```py\n# From server/server.py - Research agent requesting AI summary\nsampling_result = await ctx.session.create_message( messages=[ SamplingMessage( role=\"user\", content=TextContent(type=\"text\", text=f\"Please summarize the key findings for research on: {topic}\") ) ], max_tokens=100, related_request_id=ctx.request_id, )\n\nif sampling_result and sampling_result.content: if sampling_result.content.type == \"text\": sampling_summary = sampling_result.content.text logger.info(f\"Received sampling summary: {sampling_summary}\") ```\n\n**Client Implementation (host provides sampling callback):**\n\n```py\n# From client/client.py - Client handling sampling requests\nasync def sampling_callback(context, params): message_text = params.messages[0].content.text if params.messages else 'No message' console.print(f\"üß† Server requested sampling: {message_text}\")\n\n# In a real application, this could call an LLM API\n# For demo purposes, we provide a mock response\nmock_response = \"Based on current research, MCP has evolved significantly...\"\n\nreturn types.CreateMessageResult( role=\"assistant\", content=types.TextContent(type=\"text\", text=mock_response), model=\"interactive-client\", stopReason=\"endTurn\" )\n\n# Register the callback when creating the session\nasync with ClientSession( read_stream, write_stream, sampling_callback=sampling_callback, elicitation_callback=elicitation_callback ) as session: ```\n\n**Resumability ‚Äì Session Continuity Across Disconnections**\n\nResumability ensures that long-running agent tasks can survive client disconnections and continue seamlessly upon reconnection. This is implemented through event stores and resumption tokens (last event id).\n\n**Event Store Implementation (server holds session state):**\n\n```py\n# From server/event_store.py - Simple in-memory event store\nclass SimpleEventStore(EventStore): def __init__(self): self._events: list[tuple[StreamId, EventId, JSONRPCMessage]] = [] self._event_id_counter = 0\n\nasync def store_event(self, stream_id: StreamId, message: JSONRPCMessage) -> EventId: \"\"\"Store an event and return its ID.\"\"\" self._event_id_counter += 1 event_id = str(self._event_id_counter) self._events.append((stream_id, event_id, message)) return event_id\n\nasync def replay_events_after(self, last_event_id: EventId, send_callback: EventCallback) -> StreamId | None: \"\"\"Replay events after the specified ID for resumption.\"\"\"\n# Find events after the last known event and replay them\nfor _, event_id, message in self._events[start_index:]: await send_callback(EventMessage(message, event_id))\n\n# From server/server.py - Passing event store to session manager\ndef create_server_app(event_store: Optional[EventStore] = None) -> Starlette: server = ResumableServer()\n\n# Create session manager with event store for resumption\nsession_manager = StreamableHTTPSessionManager( app=server, event_store=event_store, # Event store enables session resumption json_response=False, security_settings=security_settings, )\n\nreturn Starlette(routes=[Mount(\"/mcp\", app=session_manager.handle_request)])\n\n# Usage: Initialize with event store\nevent_store = SimpleEventStore() app = create_server_app(event_store) ```\n\n**Client Metadata with Resumption Token (client reconnects using stored state):**\n\n```py\n# From client/client.py - Client resumption with metadata\nif existing_tokens and existing_tokens.get(\"resumption_token\"):\n# Use existing resumption token to continue where we left off\nmetadata = ClientMessageMetadata( resumption_token=existing_tokens[\"resumption_token\"], ) else:\n# Create callback to save resumption token when received\ndef enhanced_callback(token: str): protocol_version = getattr(session, 'protocol_version', None) token_manager.save_tokens(session_id, token, protocol_version, command, args)\n\nmetadata = ClientMessageMetadata( on_resumption_token_update=enhanced_callback, )\n\n# Send request with resumption metadata\nresult = await session.send_request( types.ClientRequest( types.CallToolRequest( method=\"tools/call\", params=types.CallToolRequestParams(name=command, arguments=args) ) ), types.CallToolResult, metadata=metadata, ) ```\n\nThe host application maintains session IDs and resumption tokens locally, enabling it to reconnect to existing sessions without losing progress or state.\n\nThe video below shows an MCP host application UI ([AutoGen Studio](https://microsoft.github.io/autogen/dev/user-guide/autogenstudio-user-guide/index.html) MCP Playground) connects to our server, lists the agents, calls them with interactions for streaming updates, providing user input and sampling. See the [code repository](http://aka.ms/mcp-agent-tutorial) on GitHub for instructions on how to run a local command line host application.\n\n[https://devblogs.microsoft.com/wp-content/uploads/2025/07/mcpapp.webm](https://devblogs.microsoft.com/wp-content/uploads/2025/07/mcpapp.webm)\n\n## **Extending to Multi-Agent Communication on MCP**\n\n**Architecture Note**\n\nOur implementation already demonstrates agent-to-agent communication. The host application acts as an ‚ÄúOrchestrator Agent‚Äù that interfaces with users and routes requests to specialist agents (travel agent, research agent) on the MCP server.\n\nWhile our example connects to a single server for simplicity, the same orchestrator agent can coordinate tasks across multiple MCP servers, with each server exposing different specialist agents.\n\nTo scale the host agent (orchestrator) to remote MCP agent pattern to multiple servers, the host agent can be enhanced with:\n\n- **Intelligent Task Decomposition**: Analyze complex user requests and break them into subtasks for different specialized agents\n- **Multi-Server Coordination**: Maintain connections to multiple MCP servers, each exposing different agent capabilities\n- **Task State Management**: Track progress across multiple concurrent agent tasks, handle dependencies and manage in-flight requests\n- **User Context Preservation**: Maintain interaction context while coordinating between specialist agents\n- **Resilience & Retries**: Handle failures, implement retry logic, and reroute tasks when agents become unavailable\n- **Result Synthesis**: Combine outputs from multiple agents into coherent responses\n\nWith these capabilities, a single orchestrator agent can coordinate multiple specialist agents across different servers using the same MCP protocol primitives demonstrated in our single-server example.\n\n## **Conclusion**\n\nMCP‚Äôs enhanced capabilities ‚Äì resource notifications, elicitation/sampling, resumable streams, and persistent resources ‚Äì enable complex agent-to-agent interactions while maintaining protocol simplicity. See the code repository for more information.\n\nOverall, the MCP protocol spec is evolving rapidly; the reader is encouraged to review the official documentation website for the most recent updates ‚Äì [https://modelcontextprotocol.io/introduction](https://modelcontextprotocol.io/introduction)\n\nAcknowledgement: Huge thanks to **Caitie McCaffrey**, Marius de Vogel, Donald Thompson, Adam Kaplan, Toby Padilla, Marc Baiza, Harald Kirschner and many others for discussions, feedback and insights while writing this article.",
  "PubDate": "2025-07-23T17:00:19+00:00"
}
