{
  "Link": "https://devblogs.microsoft.com/devops/from-manual-testing-to-ai-generated-automation-our-azure-devops-mcp-playwright-success-story/",
  "ProcessedDate": "2025-08-24 16:24:32",
  "PubDate": "2025-07-25T06:47:36+00:00",
  "FeedLevelAuthor": "Azure DevOps Blog",
  "Title": "From Manual Testing to AI-Generated Automation: Our Azure DevOps MCP + Playwright Success Story",
  "FeedUrl": "https://devblogs.microsoft.com/devops/feed/",
  "EnhancedContent": "In today’s fast-paced software development cycles, manual testing often becomes a significant bottleneck. Our team was facing a growing backlog of test cases that required repetitive manual execution—running the entire test suite every sprint. This consumed valuable time that could be better spent on exploratory testing and higher-value tasks.\n\nWe set out to solve this by leveraging Azure DevOps’ new [MCP server](https://devblogs.microsoft.com/devops/azure-devops-mcp-server-public-preview/) integration with GitHub Copilot to automatically generate and run end-to-end tests using [Playwright](https://playwright.dev/). This powerful combination has transformed our testing process:\n\n- **Faster test creation** with AI-assisted code generation\n- **Broader test coverage** across critical user flows\n- **Seamless CI/CD integration**, allowing hundreds of tests to run automatically\n- **On-demand test execution** directly from the Azure Test Plans experience (associating Playwright JS/TS tests with manual test cases is coming soon. Keep an eye on our [release notes](https://learn.microsoft.com/en-us/azure/devops/release-notes/2025/testplans/sprint-258-update) for the announcement.).\n\nBy automating our testing pipeline, we’ve significantly reduced manual effort, improved test reliability, and accelerated our release cycles. In this post, we’ll share how we did it.\n\n# How We Turn Test Cases into Automated Scripts (Step-by-Step)\n\nEnabling this AI-driven workflow required a few pieces to come together. Here’s how the process works from start to finish: [![Screenshot showing the steps to generate automated Playwright tests.](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA6IAAAPsAQMAAABlZJPYAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAiklEQVR4nO3BMQEAAADCoPVPbQZ/oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIDXAM7XAAHIj88jAAAAAElFTkSuQmCC)](https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2025/06/Screenshot-2025-06-26-at-8.58.38.png)\n\nBy following the above loop for each test case (and you can do it in bulk, by passing an entire Test Suite to GitHub Copilot), we gradually turned an entire manual test suite into an automated one (we have hundreds of test cases only for our own domain and over a thousand test cases for the entire project). The MCP server and Copilot essentially handled the heavy lifting of writing code, while our team oversaw the process and made minor adjustments. It felt almost like magic – describing a test in plain English and getting a runnable automated script in return!\n\n# Challenges and Lessons Learned\n\n- **Prompt is the king!** Goes without saying – how you prompt the AI matters. A clear, specific prompt yields better results. In our case, breaking the task into two prompts (“fetch test case” then “generate script”) produced more reliable code than a single combined prompt. We also sometimes had to experiment with phrasing – e.g. using the exact wording “convert the above test case steps to Playwright script” worked better than a vaguer command. In addition to this, make sure to point the model to relevant code/files where you have existing tests. The more references you give, the more accurate the newly generated script it will be. It’s a bit of an art, but the more we used it, the more we developed a feel for what phrasing GitHub Copilot responds best to. Thankfully, our test case descriptions were usually detailed and structured, which made it easier for the AI to identify the sequence of actions.\n- **Quality of context:** You’ll need to spend extra time on one of two things:\n\n1. Either improve your test cases in Azure DevOps by writing clearer, more detailed steps,\n2. Or spend more time fixing the generated scripts later.\n\nIf you choose to improve the test cases, make sure they are specific. Some examples of vague and specific steps:\n\n![A table with examples of vague and specific test case steps.](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABNAAAAJUAQMAAADuDUlSAAAAA1BMVEXW1taWrGEgAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAcElEQVR4nO3BMQEAAADCoPVP7W0HoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4A1o6wABrZzjRAAAAABJRU5ErkJggg==)\n\n- **Handling of Non-Textual Steps:** Some test scenarios involve graphics or media (for example, “verify the chart looks correct” or checking an image). The current Copilot agent cannot interpret images or visual assertions – its domain is text. Our POCs confirmed that if a test step said “compare screenshot,” the AI would not magically do image comparison. The workaround is to adjust such steps to something verifiable via DOM or data (or handle those cases manually for now). In practice, this was a minor limitation – the vast majority of our test steps were things like “click this” or “enter that,” which AI handles well. But it’s good to be aware: for purely visual verifications, you’ll need to supplement with traditional methods, or use Playwright’s screenshot assertions with predefined baseline images.\n\n# Appendix\n\n## Prompts\n\nBelow you can find the 2 prompts that can help you get started. After you generate the scripts, you can tweak them until the point that you can execute them successfully locally. Once you are happy with the scripts, you can create an [Azure Pipeline](https://learn.microsoft.com/en-us/azure/playwright-testing/quickstart-automate-end-to-end-testing) to execute them as part of it, on regular basis.\n\nMake sure to tailor the prompts to your specific needs and context – this will help Copilot generate higher-quality scripts.\n\n**Prompt 1:**\n\n``` Get me the details of the test cases (do not action anything yet, just give me the details of each test case).\n\nTest Information:\n\n* ADO Organization: Org_Name\n\n* Project: Project_Name\n\n* Test Plan ID: Test_Plan_ID\n\n* Test Suite ID: Test_Suite_ID\n\n```\n\nAfter Copilot gets the details for each test case, via the MCP server, use the following prompt:\n\n**Prompt 2:**\n\n``` Imagine you are an experienced Software Engineer helping me write high-quality Playwright test scripts in TypeScript based on the test cases I provided. Please go over the task twice to make sure the scripts are accurate and reliable. Avoid making things up and do no hallucinate. Use all the extra information outlined below, to write the best possible scripts, tailored for my project.\n\n# Project Context\n\nLook at the \"Project_name\" folder, to get more insights (if your project is quite large, use the below section to be more concrete and reference specific folders/files).\n\nMy project structure includes:\n\n* Authentication helpers: //*Add/folder/path*\n\n* Existing sample tests: //*Add/folder/path*\n\n* Playwright config: //*Add/folder/path*\n\n* Test Structure: //*Add/folder/path/test-1656280.spec.ts*\n\n* The project’s UX components are in the following folder: //*Add/folder/path*.\n\n# Test Structure Requirements\n\nFor each test, please follow this structure:\n\n1. Clear test description using *'test.describe()'* blocks\n\n2. Proper authentication setup before any page navigation\n\n3. Robust selector strategies with multiple fallbacks\n\n4. Detailed logging for debugging\n\n5. Screenshot captures at key points for verification\n\n6. Proper error handling with clear error messages\n\n7. Appropriate timeouts and wait strategies\n\n8. Verification/assertion steps that match the test case acceptance criteria\n\n# Robustness Requirements\n\nEach test should include:\n\n1. Retry mechanisms for flaky UI elements\n\n2. Multiple selector strategies to find elements\n\n3. Explicit waits for network idle and page load states\n\n4. Clear logging of each test step\n\n5. Detailed error reporting and screenshots on failure\n\n6. Handling of unexpected dialogs or notifications\n\n7. Timeout handling with clear error messages\n\n# Environmental Considerations\n\nThe tests will run in:\n\n* CI/CD pipeline environments\n\n* Headless mode by default\n\n* Potentially with network latency\n\n* Different viewport sizes\n\n# Example Usage\n\nPlease provide a complete implementation with:\n\n1. Helper functions for authentication and common operations\n\n2. Full test implementation for each test case\n\n3. Comments explaining complex logic\n\n4. Guidance on test execution\n\n# Authentication Approach\n\nIn order for the tests to be executed, we need to authenticate the application. Use the below auth approach:\n\n//{you need to define the authentication steps – if this is already defined for your project, instruct Copilot how to use it. If your scenarios do not require auth, you can remove this part from the prompt.}\n\n# Configuration Reference\n\nFor timeouts, screenshot settings, and other configuration options, please refer to:\n\n//{Add a reference to a specific file, etc. for better context}\n\nI want these tests to be maintainable, reliable, and provide clear feedback when they fail. ```",
  "Tags": [
    "Automated Testing",
    "Azure DevOps",
    "DevOps",
    "Test"
  ],
  "Description": "In today’s fast-paced software development cycles, manual testing often becomes a significant bottleneck. Our team was facing a growing backlog of test cases that required repetitive manual execution—running the entire test suite every sprint. This consumed valuable time that could be better spent on exploratory testing and higher-value tasks. We set out to solve this […]\n\nThe post [From Manual Testing to AI-Generated Automation: Our Azure DevOps MCP + Playwright Success Story](https://devblogs.microsoft.com/devops/from-manual-testing-to-ai-generated-automation-our-azure-devops-mcp-playwright-success-story/) appeared first on [Azure DevOps Blog](https://devblogs.microsoft.com/devops).",
  "OutputDir": "_news",
  "FeedName": "Microsoft DevOps Blog",
  "Author": "Igor Najdenovski"
}
