{
  "Tags": [
    "#Azure",
    "#DevOps",
    "Azure & Cloud",
    "Azure Developer CLI",
    "Azure Developer CLI (azd)",
    "CI/CD",
    "DevOps",
    "GitHub"
  ],
  "FeedName": "Microsoft DevOps Blog",
  "ProcessedDate": "2025-11-04 23:03:11",
  "OutputDir": "_news",
  "Description": "This post walks through how to implement “build once, deploy everywhere” patterns using Azure Container Apps with the new azd publish and layered infrastructure features in Azure Developer CLI v1.20.0. You’ll learn how to deploy the same containerized application across multiple environments with proper separation of concerns. This is the third installment in our Azure […]\n\nThe post [Azure Developer CLI: Azure Container Apps Dev-to-Prod Deployment with Layered Infrastructure](https://devblogs.microsoft.com/devops/azure-developer-cli-azure-container-apps-dev-to-prod-deployment-with-layered-infrastructure/) appeared first on [Azure DevOps Blog](https://devblogs.microsoft.com/devops).",
  "FeedUrl": "https://devblogs.microsoft.com/devops/feed/",
  "EnhancedContent": "This post walks through how to implement “build once, deploy everywhere” patterns using Azure Container Apps with the new `azd publish` and layered infrastructure features in Azure Developer CLI v1.20.0. You’ll learn how to deploy the same containerized application across multiple environments with proper separation of concerns.\n\nThis is the third installment in our Azure Developer CLI series, building on our previous explorations: – [Azure App Service and GitHub Actions](https://devblogs.microsoft.com/devops/azure-developer-cli-from-dev-to-prod-with-one-click/) – [Azure DevOps Pipelines](https://devblogs.microsoft.com/devops/azure-developer-cli-from-dev-to-prod-with-azure-devops-pipelines/)\n\n## Build once, deploy everywhere\n\n### The challenge we’re solving\n\nIf you’ve worked with containers in production, you’ve probably run into this: `azd deploy` bundles everything together—building your container, pushing to a registry, and deploying—all in one go. While this is super convenient for development, it creates some headaches for production scenarios:\n\n- You want to use a **single Azure Container Registry (ACR)** across all your environments\n- You need to **build once and deploy everywhere** without rebuilding containers\n- You want **security controls** around which specific container versions get deployed to production\n- You need the **flexibility** to deploy the same container with different configurations per environment\n\n### Learning from our previous posts in this series\n\nAfter writing about dev-to-prod patterns with Azure App Service in our first two blog posts, we realized that Azure Container Apps support in azd had some limitations that prevented teams from implementing the same “build once, deploy everywhere” patterns effectively. The azd team addressed these gaps in the recent releases.\n\nAzure Developer CLI v1.20.0 introduces two capabilities that solve these challenges:\n\n#### 1. **Separated Container Operations**\n\n- **`azd publish`**: Builds and pushes containers to your registry\n- **`azd deploy --from-package`**: Deploys specific container versions to environments (without rebuilding)\n\n#### 2. **Layered Infrastructure (Alpha Feature)**\n\n- Deploy infrastructure in **sequential layers** with proper dependency management\n- Share resources like ACR across environments while keeping environment-specific stuff separate\n- Outputs from earlier layers automatically become inputs for later layers\n\nI’ll show you how this works using a [Flask application example](https://github.com/puicchan/azd-dev-prod-aca-storage) that I migrated from Azure App Service to Azure Container Apps.\n\n## The sample application\n\n### What we’re building\n\nThe sample application is a simple Flask-based file manager that demonstrates the key concepts:\n\n- **What it does**: Upload files, list them, and view them (all backed by Azure Blob Storage)\n- **Security approach**: Uses Azure Managed Identity (no connection strings stored anywhere)\n\n### How the infrastructure is organized\n\nRather than cramming everything into one big template, I’ve organized this using a layered approach that keeps shared stuff separate from environment-specific resources:\n\n``` ┌─────────────────────────────────────────────────────────────────┐ │ Shared Resources │ │ ┌─────────────────────────────────────────────────────────────┐│ │ │ Resource Group: rg-acr-shared ││ │ │ ┌─────────────────────────────────────────────────────────┐ ││ │ │ │ Azure Container Registry (Basic SKU) │ ││ │ │ │ - Stores container images for all environments │ ││ │ │ │ - Single source of truth for application containers │ ││ │ │ └─────────────────────────────────────────────────────────┘ ││ │ └─────────────────────────────────────────────────────────────┘│ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ Development Environment │ │ ┌─────────────────────────────────────────────────────────────┐│ │ │ Resource Group: rg-dev-environment ││ │ │ ┌─────────────────────────────────────────────────────────┐ ││ │ │ │ Container Apps Environment │ ││ │ │ │ ┌─────────────────────────────────────────────────────┐ │ ││ │ │ │ │ Container App (Flask Application) │ │ ││ │ │ │ │ - Managed Identity for ACR access │ │ ││ │ │ │ │ - Auto-scaling enabled │ │ ││ │ │ │ └─────────────────────────────────────────────────────┘ │ ││ │ │ └─────────────────────────────────────────────────────────┘ ││ │ │ Azure Storage Account | Key Vault | Application Insights ││ │ └─────────────────────────────────────────────────────────────┘│ └─────────────────────────────────────────────────────────────────┘ ┌─────────────────────────────────────────────────────────────────┐ │ Production Environment │ │ ┌─────────────────────────────────────────────────────────────┐│ │ │ Resource Group: rg-prod-environment ││ │ │ ┌─────────────────────────────────────────────────────────┐ ││ │ │ │ Container Apps Environment (VNET-integrated) │ ││ │ │ │ ┌─────────────────────────────────────────────────────┐ │ ││ │ │ │ │ Container App (Same Image as Dev) │ │ ││ │ │ │ │ - Enhanced security configuration │ │ ││ │ │ │ │ - Production-grade scaling rules │ │ ││ │ │ │ └─────────────────────────────────────────────────────┘ │ ││ │ │ └─────────────────────────────────────────────────────────┘ ││ │ │ VNET | Storage | Key Vault | App Insights | Monitoring ││ │ └─────────────────────────────────────────────────────────────┘│ └─────────────────────────────────────────────────────────────────┘\n\n```\n\n### Layered infrastructure configuration\n\nHere’s how the sequence is defined in the `azure.yaml` file:\n\n```\n# Azure Container Apps Demo: \"Build Once, Deploy Everywhere\" with Shared ACR\nname: dev-prod\n\n# Layered Infrastructure Deployment Strategy\ninfra: layers:\n# Layer 1: Foundation - Core infrastructure for each environment\n- name: foundation\npath: infra/foundation\n\n# Layer 2: Shared ACR - Single registry for all environments\n- name: shared-acr\npath: infra/shared-acr\n\n# Layer 3: ACR Role Assignment - Security configuration\n- name: acr-role\npath: infra/acr-role\n\n# Layer 4: Container App - Application deployment\n- name: container-app\npath: infra/container-app\n\nservices: app: project: . host: containerapp language: python\n\n```\n\nThis layered approach solves the classic “chicken-and-egg” problem you run into with container deployments. Both dev and prod need to share the same ACR. Your prod Container App needs permissions to pull from ACR, but you can’t assign those permissions until both the Container App identity and the ACR actually exist. By provisioning things in the right sequence, we ensure everything gets the permissions it needs.\n\nHere’s how the layers work:\n\n1. **Foundation layer**: Sets up core resources based on your `AZURE_ENV_TYPE`\n– this includes the Container Apps Environment and Managed Identity\n2. **Shared ACR layer**: Creates your centralized container registry (unless you already have one)\n3. **ACR Role Assignment layer**: This is where the magic happens – gives your Managed Identity the right permissions (dev gets push+pull, prod gets pull-only)\n4. **Container App layer**: Finally deploys your application, which now has proper ACR access\n\nEach layer outputs the stuff that later layers need – resource IDs, endpoints, you name it – and azd automatically pipes those outputs as inputs to the next layer.\n\nFor example, if you peek at `infra/acr-role/main.parameters.json` , you’ll see how `AZURE_CONTAINER_REGISTRY_NAME` flows from the shared-acr layer into the ACR role assignment layer:\n\n`\"AZURE_CONTAINER_REGISTRY_NAME\": { \"value\": \"${AZURE_CONTAINER_REGISTRY_NAME}\"``\n\n## Try it out\n\n> >\n> ⚠️ **Production Reality Check**\n>\n> While I’m showing you how to deploy locally with `azd up`\n> , **please use CI/CD pipelines for production deployments**. The local workflow I’m demonstrating here is great for rapid prototyping and development, but you’ll want proper CI/CD controls for anything that matters.\n> >\n\n### Prerequisites\n\n- Azure Developer CLI v1.20.0 or later ([download here](https://aka.ms/azd-install))\n- Docker (for local container testing)\n\n### 1. Clone the Sample Repository\n\n``` azd init -t https://github.com/puicchan/azd-dev-prod-aca-storage\n\n```\n\n### 2. Set up your development environment\n\nDevelopment environment setup uses the familiar `azd up` workflow you’re probably already comfortable with:\n\n```\n# Enable alpha feature for layered infrastructure\nazd config set alpha.layers on\n\n# Create and configure development environment\nazd env new myapp-dev azd env set AZURE_ENV_TYPE dev\n\n# Deploy everything: infrastructure + build + push + deploy\nazd up\n\n```\n\n### 3. Prepare your production infrastructure\n\nNow you’ll want to set up your production environment infrastructure. This is typically a one-time thing you do before setting up your CI/CD pipelines:\n\n```\n# Create production environment\nazd env new myapp-prod azd env set AZURE_ENV_TYPE prod\n\n# Reference existing shared ACR (replace with actual values from dev deployment)\nazd env set ACR_RESOURCE_GROUP_NAME rg-shared-acr-resource-group-name azd env set AZURE_CONTAINER_REGISTRY_ENDPOINT shared-acr-endpoint\n\n# Provision infrastructure only (no build/push/deploy)\nazd provision\n\n```\n\n> >\n> ⚠️ **Critical note about infrastructure**\n>\n> – I’m using `azd provision`\n> locally here to set up the infrastructure BEFORE going live. **In your CI/CD pipelines, you should NEVER run `azd provision`** – stick to `azd deploy`\n> only. Infrastructure changes in production should go through proper approval processes because accidental modifications can cause outages.\n>\n> – When `envType = 'prod'`\n> , the infrastructure automatically includes VNET integration. For demo purposes (easier testing), I’ve set `internal: false`\n> in `aca-environment.bicep`\n> line 42, so your app stays publicly accessible while the compute is isolated. For truly private environments, you’d flip that to `internal: true`\n> and add a reverse proxy.\n> >\n\n### 4. Set up your CI/CD pipeline\n\nNow for the fun part – let’s see the pipeline in action! Make a simple code change and commit it.\n\nFor example, modify the `<h1>` tag in `index.html` , then run:\n\n```\n# Select your dev environment and configure pipeline\nazd env select myapp-dev\n# Make sure you select GitHub as the pipeline provider when prompted\nazd pipeline config\n\n```\n\nHere’s what to watch for:\n\n1. **GitHub Actions tab**: Head to your repository’s Actions tab\n2. **Build stage**: Watch the container get built with a unique tag\n3. **Dev deployment**: See it automatically deploy to development\n4. **Same container everywhere**: Check both environments – they’re running the exact same container image\n\n![GitHub Actions workflow in action](https://devblogs.microsoft.com/devops/wp-content/uploads/sites/6/2025/10/aca-gh-action.gif)\n\n## How the GitHub Actions workflow works\n\nThe workflow follows a clean three-stage pattern: **Build → Deploy-Dev → Deploy-Prod**\n\n``` ┌─────────────────────────────────────────────────────────────────┐ │ GitHub Actions Workflow │ └─────────────────────────────────────────────────────────────────┘\n\n┌─────────────────────────────────────────────────────────────────┐ │ Job 1: BUILD │ │ ┌─────────────────────────────────────────────────────────────┐ │ │ │ 1. Enable alpha features (layered infrastructure) │ │ │ │ 2. Set environment names (dev/prod) │ │ │ │ 3. Log in with Azure (Federated Credentials) │ │ │ │ 4. Provision Infrastructure (dev environment) │ │ │ │ 5. Build & Publish Container to ACR │ │ │ │ └─ azd publish app │ │ │ │ └─ Get image: azd env get-value SERVICE_APP_IMAGE_NAME │ │ │ └─────────────────────────────────────────────────────────────┘ │ │ │ │ Outputs: │ │ • container-image: crXXXX.azurecr.io/app:azd-deploy-123456 │ │ • dev-env-name: myapp-dev │ │ • prod-env-name: myapp-prod │ └──────────────────────────────┬──────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │ Job 2: DEPLOY-DEV │ │ ┌─────────────────────────────────────────────────────────────┐ │ │ │ 1. Enable alpha features (layered infrastructure) │ │ │ │ 2. Log in with Azure (Federated Credentials) │ │ │ │ 3. Deploy to Development │ │ │ │ └─ azd deploy app --from-package <container-image> │ │ │ │ 4. Validate Application │ │ │ │ └─ Run validation tests, smoke tests │ │ │ └─────────────────────────────────────────────────────────────┘ │ └──────────────────────────────┬──────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │ Job 3: DEPLOY-PROD │ │ ┌─────────────────────────────────────────────────────────────┐ │ │ │ 1. Enable alpha features (layered infrastructure) │ │ │ │ 2. Log in with Azure (Federated Credentials) │ │ │ │ 3. Deploy to Production │ │ │ │ └─ azd deploy app --from-package <same container-image> │ │ │ │ └─ Uses shared ACR from environment variables │ │ │ └─────────────────────────────────────────────────────────────┘ │ └─────────────────────────────────────────────────────────────────┘\n\nKey: Same container image (built once) deployed to both environments\n\n```\n\nYou can see the complete workflow implementation in the [azure-dev.yml](https://github.com/puicchan/azd-dev-prod-aca-storage/blob/main/.github/workflows/azure-dev.yml) file in the repository.\n\n**The key things to notice:**\n\n- Container gets built **once** in the build stage\n- `azd env get-value SERVICE_APP_IMAGE_NAME`\ngrabs the published image name\n- Both dev and prod deploy the **exact same container image**\n- Validation steps act as quality gates between stages\n\n> >\n> **Note:** This workflow uses GitHub Actions job outputs to pass the container image name between jobs. That only works on GitHub-hosted runners. If you’re using self-hosted runners, you’ll need a different approach – maybe store the image name in an artifact or use another method to share data between jobs.\n> >\n\n## Wrapping up\n\nThis post walks through how to implement “build once, deploy everywhere” patterns using Azure Container Apps with the new features in Azure Developer CLI v1.20.0. Building on our previous posts about Azure App Service, this Container Apps approach shows how the same core principles work across different Azure compute services.\n\nThe combination of layered infrastructure and separated container operations (`azd publish`\n+ `azd deploy --from-package`\n) gives you a solid foundation when you’re ready to move beyond the simplicity of `azd up` but still want to keep that familiar azd developer experience.\n\n**What we covered:**\n\n- **Container Apps integration**: How azd works with Azure Container Apps out of the box\n- **Layered infrastructure**: Sequential deployment with proper dependency management\n- **Environment separation**: Keep the dev convenience while adding production-ready controls\n\nThere is no one way to deploy to production, and even more sophisticated approaches depending on the organization’s needs. Advanced networking, complex compliance requirements, different deployment strategies, etc.; the specific implementation is going to vary based on your team’s situation. We hope this gives you a starting point and an example to follow.\n\nWe’re continuing to explore and validate production deployment scenarios with the Azure Developer CLI, making sure azd provides reliable patterns as your applications grow from development to production.\n\nQuestions about the implementation or want to share your own approach? Join the discussion [here](https://github.com/azure/azure-dev/discussions/5447).\n\n*For more Azure Developer CLI content, follow the [Azure Developer CLI blog](https://aka.ms/azd-blog/) and check out the [official documentation](https://aka.ms/azd).*",
  "Link": "https://devblogs.microsoft.com/devops/azure-developer-cli-azure-container-apps-dev-to-prod-deployment-with-layered-infrastructure/",
  "Author": "PuiChee (PC) Chan",
  "FeedLevelAuthor": "Azure DevOps Blog",
  "Title": "Azure Developer CLI: Azure Container Apps Dev-to-Prod Deployment with Layered Infrastructure",
  "PubDate": "2025-11-04T22:45:46+00:00"
}
