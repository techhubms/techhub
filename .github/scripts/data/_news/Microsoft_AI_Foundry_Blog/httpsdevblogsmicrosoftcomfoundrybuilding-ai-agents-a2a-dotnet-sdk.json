{
  "Link": "https://devblogs.microsoft.com/foundry/building-ai-agents-a2a-dotnet-sdk/",
  "ProcessedDate": "2025-08-24 16:29:13",
  "PubDate": "2025-07-31T10:08:49+00:00",
  "FeedLevelAuthor": "Azure AI Foundry Blog",
  "Title": "Building AI Agents with the A2A .NET SDK",
  "FeedUrl": "https://devblogs.microsoft.com/foundry/feed/",
  "EnhancedContent": "# Building AI Agents with the A2A .NET SDK\n\nThe AI development landscape is rapidly evolving. Autonomous agents are becoming increasingly sophisticated, specialized, and capable of handling complex tasks across diverse domains. From customer service bots to data analysis agents, from content creation assistants to workflow orchestrators ‚Äì AI agents are proliferating at an unprecedented pace.\n\nBut what happens when these agents need to work together? How do specialized agents discover each other, communicate effectively, and collaborate on complex tasks that require multiple capabilities?\n\nToday, we‚Äôre excited to announce the release of the [A2A .NET SDK](https://github.com/a2aproject/a2a-dotnet) ‚Äì an implementation of the Agent2Agent (A2A) protocol that enables .NET developers to build both A2A servers and clients. With this SDK, you can now create agents that seamlessly communicate and collaborate with other agents in the ecosystem, whether they‚Äôre built with .NET or any other technology that supports the A2A protocol.\n\nThis release strengthens the broader exisitng AI ecosystem, particularly for developers working with Azure AI Foundry and Semantic Kernel. Semantic Kernel already includes A2A agent capabilities through its Python and .NET implementations, and this community-driven .NET SDK enables the Semantic Kernel team to adopt the latest A2A protocol features more rapidly while maintaining the framework‚Äôs enterprise-grade stability.\n\n>\n> **Note**: This SDK is currently in preview. While we strive for stability, the API may change as we continue to refine and improve the implementation based on community feedback and protocol evolution.\n>\n\n## What is the Agent2Agent (A2A) Protocol?\n\nThe [Agent2Agent (A2A) Protocol](https://a2a-protocol.org) is an open standard designed to solve a fundamental challenge in the AI ecosystem: **how do independent AI agents discover, communicate, and collaborate with each other?**\n\nIn today‚Äôs world, AI agents are often isolated systems built with different frameworks, by different vendors, and with varying capabilities. A2A provides a common language that allows these agents to:\n\n- **Discover each other‚Äôs capabilities**\n- **Negotiate interaction modalities** (text, forms, media)\n- **Securely collaborate on long-running tasks**\n- **Operate without exposing their internal state, memory, or tools**\n\n## Key Features of the A2A .NET SDK\n\n### üîç **Agent Capability Discovery**\n\nThe SDK includes the `A2ACardResolver` class for retrieving agent capabilities described in standardized Agent Cards. These cards provide essential information about agent capabilities (streaming, push notifications, extensions), agent host URL, image, supported modalities, and other details.\n\n```csharp A2ACardResolver cardResolver = new A2ACardResolver(new Uri(\"http://localhost:5100/\")); AgentCard agentCard = await cardResolver.GetAgentCardAsync(); ```\n\n### üí¨ **Flexible Communication Patterns**\n\n**Message-based Communication**: Direct, synchronous messaging for immediate responses\n\n```csharp A2AClient client = new A2AClient(new Uri(agentCard.Url));\n\n// Send a message that the agent can handle promptly and will respond with a message. Message response = (Message)await client.SendMessageAsync(new MessageSendParams { Message = new Message { Role = MessageRole.User, Parts = [new TextPart { Text = \"What is the current weather in Settle\" }] } });\n\nConsole.WriteLine($\"Received: {((TextPart)response.Parts[0]).Text}\"); ```\n\n**Task-based Communication**: Persistent, long-running agent tasks for asynchronous workflows\n\n```csharp A2AClient client = new A2AClient(new Uri(agentCard.Url));\n\n// Send a message that will require the agent to process it asynchronously and the agent will answer with a task. AgentTask agentTask = (AgentTask)await client.SendMessageAsync(new MessageSendParams { Message = new Message { Role = MessageRole.User, Parts = [new TextPart { Text = \"Generate an image of a sunset over the mountains\" }] } });\n\nConsole.WriteLine(\"Received task details:\"); Console.WriteLine($\" ID: {agentTask.Id}\"); Console.WriteLine($\" Status: {agentTask.Status.State}\"); Console.WriteLine($\" Artifact: {(agentTask.Artifacts?[0].Parts?[0] as TextPart)?.Text}\");\n\n// Poll the task progress agentTask = await client.GetTaskAsync(agentTask.Id); switch (agentTask.Status.State) { case TaskState.Running: // Handle running task break; case TaskState.Completed: // Process completed task break; case TaskState.Failed: // Handle task failure break; default: Console.WriteLine($\"Task status: {agentTask.Status.State}\"); break; } ```\n\nFor more details about these communication patterns, see [Message or a Task](https://github.com/a2aproject/A2A/blob/main/docs/topics/life-of-a-task.md#agent-message-or-a-task).\n\n### üåä **Real-time Streaming Support**\n\nFor scenarios requiring real-time updates, the SDK provides comprehensive streaming support using Server-Sent Events:\n\n```csharp A2AClient client = new A2AClient(new Uri(agentCard.Url));\n\nawait foreach (SseItem<A2AEvent> sseItem in client.SendMessageStreamAsync(new MessageSendParams { Message = userMessage })) { Message agentResponse = (Message)sseItem.Data; // Process streaming response chunks as they arrive Console.WriteLine($\"Received: {((TextPart)agentResponse.Parts[0]).Text}\"); } ```\n\n### üèóÔ∏è **ASP.NET Core Integration**\n\nBuilding A2A-compatible agents is straightforward with the included ASP.NET Core extensions:\n\n```csharp WebApplicationBuilder builder = WebApplication.CreateBuilder(args); WebApplication app = builder.Build();\n\nTaskManager taskManager = new TaskManager(); EchoAgent agent = new EchoAgent(); agent.Attach(taskManager);\n\n// Single line to expose your agent via A2A protocol app.MapA2A(taskManager, \"/agent\"); app.Run(); ```\n\n## Getting Started with A2A Agent\n\nTo see how the A2A protocol works in practice, we‚Äôll build a simple echo agent that demonstrates the core concepts. This agent will receive messages and respond by echoing them back, providing a clear example of how A2A communication flows.\n\n### Prerequisites\n\nBefore we start building our A2A agent, make sure you have the following installed on your development machine:\n\n- **.NET 8.0 SDK or later** ‚Äì Download from [dotnet.microsoft.com](https://dotnet.microsoft.com/download)\n- **A code editor** ‚Äì Visual Studio, Visual Studio Code, or your preferred .NET IDE\n- **Basic familiarity with C# and ASP.NET Core** ‚Äì We‚Äôll be creating web applications and working with async/await patterns\n\nYou can verify your .NET installation by running:\n\n```bash dotnet --version ```\n\n### Setting Up Our Agent Project\n\nWe start by creating a new web application that will host our agent. This hosting app provides the foundation where our agent will live and communicate with the outside world:\n\n```bash dotnet new webapp -n A2AAgent -f net9.0 cd A2AAgent ```\n\nWith our project created, we need to add the A2A packages that will handle the protocol communication for us:\n\n```bash dotnet add package A2A --prerelease # Core A2A protocol support dotnet add package A2A.AspNetCore --prerelease # A2A protocol integration with ASP.NET Core dotnet add package Microsoft.Extensions.Hosting # Hosting services ```\n\n### Building Our Echo Agent\n\nNow comes the interesting part ‚Äì creating our actual agent. We‚Äôll build a simple echo agent that takes any message it receives and sends it right back. While this might seem basic, it demonstrates all the fundamental concepts you‚Äôll need for more sophisticated agents.\n\nLet‚Äôs create a new file called `EchoAgent.cs` with our agent implementation:\n\n```csharp using A2A;\n\nnamespace A2AAgent;\n\npublic class EchoAgent { public void Attach(ITaskManager taskManager) { taskManager.OnMessageReceived = ProcessMessageAsync; taskManager.OnAgentCardQuery = GetAgentCardAsync; }\n\nprivate async Task<Message> ProcessMessageAsync(MessageSendParams messageSendParams, CancellationToken ct) { // Get incoming message text string request = messageSendParams.Message.Parts.OfType<TextPart>().First().Text;\n\n// Create and return an echo message return new Message() { Role = MessageRole.Agent, MessageId = Guid.NewGuid().ToString(), ContextId = messageSendParams.Message.ContextId, Parts = [new TextPart() { Text = $\"Echo: {request}\" }] }; }\n\nprivate async Task<AgentCard> GetAgentCardAsync(string agentUrl, CancellationToken cancellationToken) { return new AgentCard() { Name = \"Echo Agent\", Description = \"An agent that will echo every message it receives.\", Url = agentUrl, Version = \"1.0.0\", DefaultInputModes = [\"text\"], DefaultOutputModes = [\"text\"], Capabilities = new AgentCapabilities() { Streaming = true }, Skills = [], }; } } ```\n\nLooking at this code, you can see how our agent comes to life through three key pieces. The `Attach()` method is where we connect our agent to the A2A framework ‚Äì think of it as plugging our agent into the communication network. When messages arrive, they flow through the `ProcessMessageAsync()` method, which is the heart of our agent where all the thinking happens. In our case, we‚Äôre simply echoing messages back, but this is where you‚Äôd integrate your LLM or other AI processing logic. The `GetAgentCardAsync()` method serves as our agent‚Äôs business card, telling other agents who we are and what we can do.\n\nNotice that our agent declares streaming capability, which means other agents can choose to communicate with us in real-time for immediate responses.\n\n### Bringing Our Agent Online\n\nWith our agent implementation ready, we need to connect it to the web so other agents can find and talk to it. This is where the magic of the A2A .NET SDK really shines ‚Äì we only need a few lines of code to make our agent discoverable.\n\nLet‚Äôs update our `Program.cs` to host our agent:\n\n```csharp using A2A; using A2A.AspNetCore; using A2AAgent; using Microsoft.AspNetCore.Builder;\n\nWebApplicationBuilder builder = WebApplication.CreateBuilder(args); WebApplication app = builder.Build();\n\n// Create and attach the EchoAgent to the TaskManager EchoAgent agent = new EchoAgent(); TaskManager taskManager = new TaskManager(); agent.Attach(taskManager);\n\n// Expose agent via A2A protocol app.MapA2A(taskManager, \"/agent\"); await app.RunAsync(); ```\n\nThis simple setup creates our web application, connects our EchoAgent to a TaskManager (which handles the A2A protocol details), and exposes everything through the ‚Äú/agent‚Äù endpoint. The `MapA2A` extension method does all the heavy lifting, automatically handling agent discovery, message routing, and protocol compliance.\n\nOnce we run our agent with `dotnet run` , it becomes available at `http://localhost:5000` and ready to communicate with any other A2A-compatible agent or client.\n\n## Testing Our Agent\n\nNow that our agent is running, we need a way to talk to it. Let‚Äôs create a simple client application that will demonstrate how agents communicate with each other. This client will discover our agent, learn about its capabilities, and then send it some messages to see the echo in action.\n\nWe‚Äôll start by creating a new console application:\n\n```bash dotnet new console -n A2AClient -f net9.0 cd A2AClient dotnet add package A2A --prerelease dotnet add package System.Net.ServerSentEvents --prerelease ```\n\nWith our client project ready, we can create a program that connects to our echo agent and demonstrates both regular and streaming communication:\n\n```csharp using A2A; using System.Net.ServerSentEvents;\n\n// 1. Get the agent card A2ACardResolver cardResolver = new(new Uri(\"http://localhost:5000/\")); AgentCard echoAgentCard = await cardResolver.GetAgentCardAsync();\n\nConsole.WriteLine($\"Connected to agent: {echoAgentCard.Name}\"); Console.WriteLine($\"Description: {echoAgentCard.Description}\"); Console.WriteLine($\"Streaming support: {echoAgentCard.Capabilities?.Streaming}\");\n\n// 2. Create an A2A client to communicate with the agent using url from the agent card A2AClient agentClient = new(new Uri(echoAgentCard.Url));\n\n// 3. Create a message to send to the agent Message userMessage = new() { Role = MessageRole.User, MessageId = Guid.NewGuid().ToString(), Parts = [new TextPart { Text = \"Hello from the A2A client!\" }] };\n\n// 4. Send the message using non-streaming API Console.WriteLine(\"\\n=== Non-Streaming Communication ===\"); Message agentResponse = (Message)await agentClient.SendMessageAsync(new MessageSendParams { Message = userMessage }); Console.WriteLine($\"Received response: {((TextPart)agentResponse.Parts[0]).Text}\");\n\n// 5. Send the message using streaming API Console.WriteLine(\"\\n=== Streaming Communication ===\"); await foreach (SseItem<A2AEvent> sseItem in agentClient.SendMessageStreamAsync(new MessageSendParams { Message = userMessage })) { Message streamingResponse = (Message)sseItem.Data; Console.WriteLine($\"Received streaming chunk: {((TextPart)streamingResponse.Parts[0]).Text}\"); } ```\n\nThis client demonstrates the complete A2A communication flow. First, we discover our agent by fetching its agent card, which tells us what the agent can do and how to reach it. Then we create an A2A client using the agent‚Äôs URL and send it a friendly message. The beautiful thing about A2A is that it supports both streaming and non-streaming communication patterns, allowing us to choose the approach that best fits our needs.\n\nWhen we run our client with `dotnet run` , we can see our echo agent in action:\n\n![A2A Client Output](https://devblogs.microsoft.com/foundry/wp-content/uploads/sites/89/2025/07/a2a-client-output.png)\n\n## Exploring Further\n\nWith our echo agent working, you might want to explore what it can do using the A2A Inspector. This web-based tool connects to any A2A agent and lets you examine its capabilities, send test messages, and see how it responds. The inspector is also invaluable for debugging purposes, as it shows you the raw request and response messages being exchanged, helping you understand exactly what‚Äôs happening under the hood. Simply point the inspector at the running agent at `http://localhost:5000` and start experimenting.\n\nYou can find the A2A Inspector and installation instructions at the [A2A Inspector repository](https://github.com/a2aproject/a2a-inspector).\n\nWhat we‚Äôve built here is just the beginning. Our simple echo agent demonstrates the core concepts, but you can easily extend it by replacing the echo logic with calls to AI models or even to other AI agents to create truly intelligent and collaborative systems.\n\nFor developers already using Semantic Kernel, this community-driven A2A .NET SDK offers a path to keep pace with the evolving A2A protocol. Semantic Kernel‚Äôs existing A2A agent implementation can leverage improvements and features from this SDK, ensuring your multi-agent orchestration remains current with the latest protocol developments while maintaining the production-ready stability that Semantic Kernel provides.\n\n## Where Your Agent Journey Continues\n\nNow that you‚Äôve created your first A2A agent, you‚Äôre ready to explore more. The echo agent is your foundation ‚Äì here‚Äôs where to go next:\n\n- üìö **[Explore the samples](https://github.com/a2aproject/a2a-dotnet/tree/main/samples)** ‚Äì See real-world examples and different agent patterns\n- üìñ **[Browse the GitHub repository](https://github.com/a2aproject/a2a-dotnet)** ‚Äì Dive into the source code and connect with other developers\n- üåê **[Master the A2A Protocol](https://a2a-protocol.org)** ‚Äì Learn the full specification behind what we built\n- ‚òÅÔ∏è **[Discover AI Foundry](https://azure.microsoft.com/en-us/products/ai-foundry/)** ‚Äì Build and deploy agent solutions with enterprise-grade security and compliance\n- üó®Ô∏è **[Join the AI Foundry Developer Forum](https://aka.ms/azureaifoundry/forum)** ‚Äì Connect with like-minded individuals using Azure AI Foundry\n- üí¨ **[Join A2A discussions and ask questions](https://github.com/a2aproject/a2a-dotnet/discussions/landing)** ‚Äì Connect with the community and get help with A2A development\n- ü§ñ **[Learn about Semantic Kernel](https://learn.microsoft.com/en-us/semantic-kernel/)** ‚Äì Explore Microsoft‚Äôs enterprise-ready AI orchestration framework with A2A support\n- üîó **[See A2A in Semantic Kernel](https://github.com/markwallace-microsoft/semantic-kernel/blob/main/dotnet/samples/GettingStartedWithAgents/A2A/Step01_A2AAgent.cs)** ‚Äì View a working A2A agent implementation using Semantic Kernel\n\n*The A2A .NET SDK is open source and available under the Apache 2.0 License. Contributions, feedback, and community involvement are welcome!*",
  "Tags": [
    "A2A",
    "agents",
    "ai-applications",
    "Azure AI Foundry",
    "protocol"
  ],
  "Description": "Learn how to build collaborative AI agents using the new A2A .NET SDK, enabling seamless communication and discovery between autonomous agents in the AI ecosystem.\n\nThe post [Building AI Agents with the A2A .NET SDK](https://devblogs.microsoft.com/foundry/building-ai-agents-a2a-dotnet-sdk/) appeared first on [Azure AI Foundry Blog](https://devblogs.microsoft.com/foundry).",
  "OutputDir": "_news",
  "FeedName": "Microsoft AI Foundry Blog",
  "Author": "Sergey Menshykh, Adam Sitnik, Brandon H"
}
