{
  "Author": "Microsoft Fabric Blog",
  "FeedLevelAuthor": "Microsoft Fabric Blog",
  "PubDate": "2025-10-06T11:00:00+00:00",
  "Tags": [],
  "Title": "Introducing Optimized Compaction in Fabric Spark",
  "Link": "https://blog.fabric.microsoft.com/en-US/blog/announcing-optimized-compaction-in-fabric-spark/",
  "EnhancedContent": "## End Write Amplification and Automate Your Table Maintenance\n\nCompaction is one the most necessary but also challenging aspects of managing a Lakehouse architecture. Similar to file systems and even relational databases, unless closely managed, data will get fragmented over time, and can lead to excessive compute costs. The OPTIMIZE command exists to solve for this challenge: small files are grouped into bins targeting a specific *ideal* file size and then rewritten to blob storage. The result is the same data, but contained in fewer files that are larger.\n\nHowever, imagine this scenario: you have a nightly OPTIMIZE job which runs to keep your tables, all under 1GB, nicely compacted. Upon inspection of the Delta table transaction log, you find that most of your data is being rewritten after every ELT cycle, leading to expensive OPTIMIZE jobs, even though you are only changing a small portion of the overall data every night. Meanwhile, as business requirements lead to more frequent Delta table updates, in between ELT cycles, it appears that jobs get slower and slower until the next scheduled OPTIMIZE job is run. Sound familiar?\n\nIf you’ve felt like OPTIMIZE is too slow, rewrites too much data, or in general should be automatically triggered, you’re not alone. We’re introducing three features that will transform the efficiency, efficacy, and performance impact of compaction jobs: Fast Optimize, File Level Compaction Targets, **** and Auto Compaction.\n\n### The Hidden Costs of Traditional Compaction\n\nTraditional Delta table maintenance carries hidden costs that tend to compound over time:\n\n**Write Amplification:** Files can get recompacted repeatedly as target file size configs change or as optimize jobs produce suboptimal files that still qualify as being ‘uncompacted’. Tables that have files smaller than 1GB might be recompacted hundreds or even many thousands of times in its lifetime, wasting compute resources and storage I/O.\n\n**Manual Intervention Required**: Teams spend valuable time scheduling, monitoring, and troubleshooting compaction jobs instead of focusing on business logic.\n\n**Performance Degradation**: Small files accumulate between maintenance windows, causing query performance to degrade until the next scheduled optimization.\n\n**Unpredictable Costs**: Without intelligent short-circuiting, users need to self-code logic to evaluate if compaction might be beneficial and without doing so, compaction jobs can run longer than expected, impacting both performance and cost predictability.\n\n## Fast Optimize: Skip the Suboptimal Work\n\n![Diagram showing that fast optimize adds additional checks to evaluate if a bin of files should be compacted.](//dataplatformblogwebfd-d3h9cbawf0h8ecgf.b01.azurefd.net/wp-content/uploads/2025/09/image-78-963x1024.png)\n\nFast Optimize intelligently analyzes your Delta table’s files and short-circuits compaction operations that aren’t estimated to meaningfully improve performance.\n\nInstead of blindly proceeding to compact files anytime more than 1 small file exists, Fast Optimize evaluates whether each candidate bin (group of small files) is estimated to meets your compaction goals or if too many small files exist. If the compaction job isn’t estimated to produce compacted files meeting the defined minimum target file size (i.e. *delta.databricks.delta.optimize.minFileSize*) and doesn’t have too many small files (*delta.microsoft.delta.optimize.fast.minNumFiles*), the operation short-circuits or reduces the compaction scope.\n\n*While Fast Optimize is disabled by default in Runtime 1.3, Microsoft recommends enabling it at the session level:*\n\n``` spark.conf.set('spark.microsoft.delta.optimize.fast.enabled', True) ```\n\nWith the Fast Optimize session configuration enabled, all existing `OPTIMIZE` code paths are supported, with the following limitations:\n\n1. Liquid Clustering and Z-Order are not impacted by Fast Optimize.\n2. Auto Compaction has it’s own internal calculation and is not impacted by Fast Optimize to prevent compounding logic that can make it difficult to discern why compaction was or was not run.\n\nIn a study mimicking a real-world scenario where `OPTIMIZE` was run at the end of every ELT cycle, Fast Optimize reduced the time spent doing compaction by 80% over 200 ELT cycles without even the slightest regression in performance.\n\n![Fast optimize resulted in 5x faster compaction over 200 ELT iterations.](//dataplatformblogwebfd-d3h9cbawf0h8ecgf.b01.azurefd.net/wp-content/uploads/2025/09/image-79.png)\n\nThe magic of Fast Optimize is in the long-term avoidance of write amplification.\n\nExample: Illustrates suboptimal bin skipping:\n\n![Diagram showing how fast optimize resulted in suboptimal bins being skipped.](//dataplatformblogwebfd-d3h9cbawf0h8ecgf.b01.azurefd.net/wp-content/uploads/2025/09/image-80.png)\n\n## File Level Compaction Target: Remember What’s Already Compacted\n\n**What it does**: This feature tags files with the compaction target used when they were created, preventing already-optimized files from being unnecessarily recompacted if the target file size changes over time.\n\n**The problem it solves**: Imagine you compact a table with a 128MB target, then later as the table gets bigger, you change your target to 512MB. Without this feature, those perfectly good 128MB files would be recompacted again, despite being well-sized when they were originally compacted.\n\n**How it works**: Delta automatically stores metadata about the compaction target alongside file statistics (OPTIMIZE\\_TARGET\\_SIZE). Future OPTIMIZE operations use this tag to determine if the file is compacted or not. If the files size is at least one half of the OPTIMIZE\\_TARGET\\_SIZE value, it is considered compacted.\n\n**The result**: Dramatic  reduction in write-amplification and more predictable compaction job performance as the target file size changes over time.\n\nFile level targets are enabled by default but can be disabled via the following session configuration:\n\n*While disabled by default in Runtime 1.3, Microsoft recommends enabling file level targets at the session level:*\n\n``` spark.conf.set('spark.microsoft.delta.optimize.fileLevelTarget.enabled', True) ```\n\n## Auto Compaction: Fix Small File Problems Before They Hurt\n\n*While this feature isn’t new, we recently revamped the OSS Delta implementation and now recommend Auto Compaction for Spark customers wanting a hands-off approach to table maintenance.*\n\n**What it does**: Auto Compaction monitors your table’s file distribution as part of every write operation and automatically triggers compaction when small file accumulation crosses defined thresholds.\n\n**Why it matters**: Instead of waiting for scheduled maintenance windows, your tables maintain optimal performance automatically. Small files get compacted before they impact query performance.\n\n**Smart triggering**: The feature uses table-specific heuristics to determine when a table is bordering on having too many small files, thus eliminating the necessity to manually trigger or scheduled compaction jobs.\n\n### How to Enable Auto Compaction\n\nSession level:\n\n``` spark.conf.set('spark.databricks.delta.autoCompact.enabled', True) ```\n\nTable level:\n\n``` CREATE TABLE dbo.ac_enabled_table TBLPROPERTIES ('delta.autoOptimize.autoCompact' = 'true') ```\n\nIt can also be enabled on existing tables with:\n\n``` ALTER TABLE dbo.ac_enabled_table SET TBLPROPERTIES ('delta.autoOptimize.autoCompact' = 'true') ```\n\n**Performance benefit**: Queries maintain consistent performance without the traditional sawtooth pattern of degradation between maintenance windows.\n\n**Cost benefit:** Auto compaction utilizes the same amount of compute as scheduled optimize operations, but it automatically runs at precisely the right intervals. For most customers who do not schedule optimize at the optimal frequency for each table, auto compaction can lead to substantial cost savings by reducing unnecessary compute usage and minimizing manual intervention.\n\nIn a study comparing the performance impact of running 200 small-file-generating merge operations into a table, auto compaction was 5x faster by the last iteration. This was a result of a growing ‘small-file problem’ being mitigated via the automatically triggered synchronous compaction operations.\n\n![Chart showing that after 200 iterations, merge executed 5x faster when auto compaction was enabled. ](//dataplatformblogwebfd-d3h9cbawf0h8ecgf.b01.azurefd.net/wp-content/uploads/2025/09/image-81.png)\n\n## Putting It All Together: Approaching a Maintenance-Free Future\n\nThese features work together to create a compaction strategy that’s both intelligent and hands-off:\n\n1. **Auto Compaction** prevents small file accumulation without dedicated maintenance jobs.\n2. **Fast Optimize** makes your ad-hoc or scheduled OPTIMIZE operations complete quickly by avoiding suboptimal compaction work.\n3. **File Level Compaction Target** prevents redundant work when you adjust optimization strategies over time.\n\nThe result? Tables that maintain optimal performance with minimal operational overhead and predictable resource usage.\n\nAll features mentioned are compatible with tables created with other Delta writers.\n\nReady to eliminate write amplification and automate your compaction strategy? These features are available now in Microsoft Fabric Spark. Check out the [Compacting Delta tables](https://learn.microsoft.com/fabric/data-engineering/table-compaction?tabs=sparksql) documentation for detailed configuration options and best practices.",
  "Description": "End Write Amplification and Automate Your Table Maintenance Compaction is one the most necessary but also challenging aspects of managing a Lakehouse architecture. Similar to file systems and even relational databases, unless closely managed, data will get fragmented over time, and can lead to excessive compute costs. The OPTIMIZE command exists to solve for this …\n\n[Continue reading “Introducing Optimized Compaction in Fabric Spark”](https://blog.fabric.microsoft.com/en-us/blog/announcing-optimized-compaction-in-fabric-spark/)",
  "FeedUrl": "https://blog.fabric.microsoft.com/en-us/blog/feed/",
  "ProcessedDate": "2025-10-06 18:03:09",
  "OutputDir": "_news",
  "FeedName": "Microsoft Fabric Blog"
}
