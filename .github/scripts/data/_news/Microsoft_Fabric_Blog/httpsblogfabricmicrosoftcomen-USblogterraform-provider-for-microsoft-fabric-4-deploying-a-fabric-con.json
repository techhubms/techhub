{
  "FeedUrl": "https://blog.fabric.microsoft.com/en-us/blog/feed/",
  "Link": "https://blog.fabric.microsoft.com/en-US/blog/terraform-provider-for-microsoft-fabric-4-deploying-a-fabric-config-with-terraform-in-github-actions/",
  "Tags": [],
  "OutputDir": "_news",
  "FeedName": "Microsoft Fabric Blog",
  "ProcessedDate": "2025-08-08 15:34:09",
  "Title": "Terraform Provider for Microsoft Fabric: #4 Deploying a Fabric config with Terraform in GitHub Actions",
  "FeedLevelAuthor": "Microsoft Fabric Blog",
  "EnhancedContent": "If you have been following this blog post series then you should have a working Terraform config from the first two posts, plus a managed identity from the third post that has the correct authorizations as a workload identity for use in deployment pipelines. In this last post we will configure OpenID Connect for the managed identity and run the GitHub Actions workflow.\n\nThis is the fourth and last post in the series\n\n1. [Accelerating first steps using the CLIs](https://blog.fabric.microsoft.com/blog/terraform-provider-for-microsoft-fabric-1-accelerating-first-steps-using-the-clis).\n2. [Using MCP servers and Fabric CLI to help define your fabric resources](https://blog.fabric.microsoft.com/blog/terraform-provider-for-microsoft-fabric-2-using-the-terraform-mcp-server-and-fabric-cli-to-help-define-your-fabric-resources).\n3. [Creating a workload identity with Fabric permissions](https://blog.fabric.microsoft.com/blog/terraform-provider-for-microsoft-fabric-3-creating-a-workload-identity-with-fabric-permissions).\n4. **[Deploying a fabric config with Terraform in GitHub Actions](https://blog.fabric.microsoft.com/blog/terraform-provider-for-microsoft-fabric-4-deploying-a-fabric-config-with-terraform-in-github-actions)**.\n\nThe primary CI/CD platforms commonly support OpenID Connect —now the de facto authentication standard, removing the risks of leaked secrets—and YAML pipelines with support for variables and secrets. In this post we will provide and example steps to plumb your workload identity into GitHub Actions and deploy the Terraform config:\n\n1. Add a pipeline file and a .gitignore file to your repo.\n2. Sync your Git repo with the cloud Git provider.\n3. Define pipeline variables for the identity and backend.\n4. Add an OpenID Connect federated credential.\n5. Run the pipeline.\n\nEven if you are not using GitHub Actions then this page can still serve as a reference point for you to transpose the logic to your chose cloud Git platform.\n\n**Note:** A more advanced setup would involve GitHub branch protection rules and multiple environments—each with its own variables and dedicated managed identity. However, this post focuses on the essentials: creating the federated credential and setting the correct environment variables to ensure the workflow runs successfully.\n\n## Configure for use in GitHub\n\n**Step one:** Ensure you are in the root folder for your Terraform config and have authenticated into GitHub CLI using `gh auth login` .\n\n### Add a workflow YAML file\n\nExample YAML file for running a Terraform deploy workflow on GitHub Actions. Create a .github/workflows/terraform.yml file in your repo and paste in the contents.\n\n``` --- name: Terraform GitHub Actions Workflow on: workflow_dispatch: inputs: terraform_action: description: 'Terraform Apply - choose action' required: true default: 'apply' type: choice options:\n- 'apply'\n- 'destroy'\n\nrun-name: Terraform ${{ github.event.inputs.terraform_action == 'destroy' && 'Destroy' || 'Apply' }}\n\njobs: plan: name: Terraform Plan runs-on: ubuntu-latest permissions: id-token: write contents: read concurrency: \"${{vars.BACKEND_AZURE_STORAGE_ACCOUNT_NAME}}-${{vars.BACKEND_AZURE_STORAGE_ACCOUNT_CONTAINER_NAME}}\" env: ARM_TENANT_ID: \"${{ vars.ARM_TENANT_ID }}\" ARM_SUBSCRIPTION_ID: \"${{ vars.ARM_SUBSCRIPTION_ID }}\" ARM_CLIENT_ID: \"${{ vars.ARM_CLIENT_ID }}\" ARM_USE_AZUREAD: true ARM_USE_OIDC: true FABRIC_USE_OIDC: true FABRIC_TENANT_ID: \"${{ vars.ARM_TENANT_ID }}\" FABRIC_CLIENT_ID: \"${{ vars.ARM_CLIENT_ID }}\" TF_VAR_subscription_id: \"${{ vars.ARM_SUBSCRIPTION_ID }}\" TFVARS_FILE: \"${{ vars.TFVARS_FILE }}\"\n\nsteps:\n- name: Checkout Code\nuses: actions/checkout@v4\n\n- name: Install Terraform\nuses: hashicorp/setup-terraform@v3\n\n- name: Terraform Init\nrun: | terraform init \\ -backend-config=\"storage_account_name=${{vars.BACKEND_AZURE_STORAGE_ACCOUNT_NAME}}\" \\ -backend-config=\"container_name=${{vars.BACKEND_AZURE_STORAGE_ACCOUNT_CONTAINER_NAME}}\" \\ -backend-config=\"key=terraform.tfstate\"\n\n- name: Terraform Plan for ${{ github.event.inputs.terraform_action == 'destroy' && 'Destroy' || 'Apply' }}\nrun: | if [ -n \"${{ env.TFVARS_FILE }}\" ]; then echo \"Using tfvars file: ${{ env.TFVARS_FILE }}\" terraform plan -out=tfplan -input=false ${{ github.event.inputs.terraform_action == 'destroy' && '-destroy' || '' }} -var-file=${{ env.TFVARS_FILE }} else echo \"No tfvars file specified. Running terraform plan without -var-file.\" terraform plan -out=tfplan -input=false ${{ github.event.inputs.terraform_action == 'destroy' && '-destroy' || '' }} fi\n\n- name: Create Module Artifact\nrun: | stagingDirectory=\"staging\" mkdir -p \"$stagingDirectory\" rsync -av --exclude=\".git\" --exclude=\".terraform\" --exclude=\".github\" --exclude=\"$stagingDirectory\" ./ \"$stagingDirectory/\" cp .terraform.lock.hcl \"$stagingDirectory/\" tree -an \"$stagingDirectory\" shell: bash\n\n- name: Publish Module Artifact\nuses: actions/upload-artifact@v4 with: name: module path: ./staging/ include-hidden-files: true\n\n- name: Show the Plan for Review\nrun: terraform show tfplan\n\napply: needs: plan name: Terraform ${{ github.event.inputs.terraform_action == 'destroy' && 'Destroy' || 'Apply' }} runs-on: ubuntu-latest concurrency: \"${{vars.BACKEND_AZURE_STORAGE_ACCOUNT_NAME}}-${{vars.BACKEND_AZURE_STORAGE_ACCOUNT_CONTAINER_NAME}}\" permissions: id-token: write contents: read env: ARM_TENANT_ID: \"${{ vars.ARM_TENANT_ID }}\" ARM_SUBSCRIPTION_ID: \"${{ vars.ARM_SUBSCRIPTION_ID }}\" ARM_CLIENT_ID: \"${{ vars.ARM_CLIENT_ID }}\" ARM_USE_AZUREAD: true ARM_USE_OIDC: true FABRIC_USE_OIDC: true FABRIC_TENANT_ID: \"${{ vars.ARM_TENANT_ID }}\" FABRIC_CLIENT_ID: \"${{ vars.ARM_CLIENT_ID }}\"\n\nsteps:\n- name: Download a Build Artifact\nuses: actions/download-artifact@v4 with: name: module\n\n- name: Install Terraform\nuses: hashicorp/setup-terraform@v3\n\n- name: List the Build Artifact\nrun: | tree -an -I .terraform shell: bash\n\n- name: Terraform Init\nrun: | terraform init \\ -backend-config=\"resource_group_name=${{vars.BACKEND_AZURE_RESOURCE_GROUP_NAME}}\" \\ -backend-config=\"storage_account_name=${{vars.BACKEND_AZURE_STORAGE_ACCOUNT_NAME}}\" \\ -backend-config=\"container_name=${{vars.BACKEND_AZURE_STORAGE_ACCOUNT_CONTAINER_NAME}}\" \\ -backend-config=\"key=terraform.tfstate\"\n\n- name: Terraform ${{ github.event.inputs.terraform_action == 'destroy' && 'Destroy' || 'Apply' }}\nrun: terraform apply -input=false -auto-approve tfplan ```\n\nThe workflow needs a few variables that will be created soon. The pipeline will work even if your Terraform config makes use of the azurerm, azapi, and azuread providers in addition to the fabric provider as it has both `ARM_` and `FABRIC_` prefixed environment variables.\n\nThe `ARM_USE_AZUREAD` boolean forces terraform init to use RBAC authentication for accessing the blob storage for the remote state as the storage account has been configured to disable the access keys which are otherwise used by default.\n\nThe `terraform init` command also uses [environment variables](https://developer.hashicorp.com/terraform/language/backend/azurerm#configuration-variables) to configure the remote state. Having a full set of `--backend-config` switches remove the need for an azurerm [backend](https://developer.hashicorp.com/terraform/language/backend/azurerm)[block](https://developer.hashicorp.com/terraform/language/backend/azurerm#azure-active-directory) in the config.\n\n### Add a .gitignore file\n\nIf you don’t already have a .gitignore file in your repo then create one and add the following.\n\n``` *.tfstate *.tfstate.* crash.log .terraform/ terraform.tfvars *.override.tf *.override.tf.json *.tfplan .env *.backup ```\n\nThe .gitignore file will ensure that git will not track files that match any of these files.\n\n### Push to GitHub\n\nIf you are already synced with a GitHub repo then commit and push.\n\n``` git add .github/workflows/terraform.yml git commit -m \"Added Terraform workflow\" git push ```\n\nIf you have not initialised your repo yet then the following example commands will initialise your local git repo, create a new GitHub repo and then push up to sync.\n\n``` owner=\"<my_github_organisation_or_user>\" repo=\"<my_repo_name>\" git init git add --all git commit -a -m \"Initial commit\" gh repo create $owner/$repo --private --source=. --remote=origin git push --set-upstream origin main ```\n\nView the GitHub repo.\n\n``` gh repo view --web ```\n\n### Add GitHub Actions variables\n\nThe GitHub Actions workflow expects a number of GitHub Actions variables. None of the values are sensitive so there is no need to define them as secrets.\n\nSet the variable values.\n\n``` terraform_resource_group_name=\"rg-terraform\" managed_identity_name=\"mi-terraform\" storage_account_prefix=\"saterraform\" management_subscription_id=\"<subscription_guid>\" workload_subscription_id=\"<subscription_guid>\"\n\nmanaged_identity_client_id=$(az identity show --name $managed_identity_name --resource-group $terraform_resource_group_name --query clientId -otsv) storage_account_name=\"saterraform$(az group show --name $terraform_resource_group_name --query id -otsv | sha1sum | cut -c1-8)\" ```\n\nCreate the GitHub Actions variables\n\n``` gh variable set ARM_TENANT_ID --body \"$(az account show --query tenantId -otsv)\" gh variable set ARM_CLIENT_ID --body \"$managed_identity_client_id\" gh variable set ARM_SUBSCRIPTION_ID --body \"${workload_subscription_id:-$management_subscription_id}\" gh variable set BACKEND_AZURE_SUBSCRIPTION_ID --body \"$management_subscription_id\" gh variable set BACKEND_AZURE_RESOURCE_GROUP_NAME --body \"$terraform_resource_group_name\" gh variable set BACKEND_AZURE_STORAGE_ACCOUNT_NAME --body \"$storage_account_name\" gh variable set BACKEND_AZURE_STORAGE_ACCOUNT_CONTAINER_NAME --body \"prod\" ```\n\n![GitHub showing the GitHub Actions variables for a repo following the successful creation of 7 variables. ](//dataplatformblogwebfd-d3h9cbawf0h8ecgf.b01.azurefd.net/wp-content/uploads/2025/06/GitHubActionsVariables-2-1024x843.png)GitHub Actions variables\n\nThe repo is ready, but the workflow cannot yet authenticate to the managed identity until OpenID Connect is configured.\n\n### Create an OpenID Connect federated credential\n\nOpenID Connect is the recommended way for a pipeline to authenticate to a workload identity as it avoids the risk of leaked secrets and operational issues with secret management. This federated credential configures the subject field to the specific repo and branch.\n\nThe example is configured to:\n\n``` repo:azurecitadel/fabric_terraform_provider:ref:refs/heads/main . ```\n\n``` subject=$(gh repo view --json nameWithOwner --template '{{printf \"repo:%s:ref:refs/heads/main\" .nameWithOwner}}') az identity federated-credential create --name github --identity-name $managed_identity_name --resource-group $terraform_resource_group_name --audiences \"api://AzureADTokenExchange\" --issuer \"https://token.actions.githubusercontent.com\" --subject \"$subject\" echo \"Added federated credential.\" ```\n\n![Azure Portal showing the newly created federated credential for the managed identity. The subject identifier is repo:azurecitadel/fabric_terraform_provider:ref:refs/heads/main](//dataplatformblogwebfd-d3h9cbawf0h8ecgf.b01.azurefd.net/wp-content/uploads/2025/06/ManagedIdentityFederatedCredential-1-1024x645.png)Federated credential for the managed identity\n\n**Note:** While a managed identity can support up to twenty federated credentials, it’s common practice to maintain a one-to-one relationship between a workload identity and its workflow. This approach helps enforce least privilege by assigning only the necessary permissions.\n\n## Run the workflow\n\nThe workflow uses a workflow\\_dispatch trigger, i.e. it is manually triggered (there are a number of other trigger options). Use the GitHub CLI to initiate the run.\n\n``` gh workflow run terraform.yml ```\n\nFollow the progress on GitHub.\n\n``` gh workflow view terraform.yml --web ```\n\n![GitHub showing a successful run for the terraform.yml GitHub workflow.](//dataplatformblogwebfd-d3h9cbawf0h8ecgf.b01.azurefd.net/wp-content/uploads/2025/06/GitHubWorkflow-1024x606.png)Successful GitHub Workflow\n\nThe workflow should complete successfully and you can click on the individual jobs to view the logs against each step.\n\n## Summary\n\nMicrosoft Fabric brings all of your most important data to one place for analytics and to fuel your Agentic AI.\n\nThe Fabric CLI and Terraform Provider for Microsoft Fabric offer a wealth of new options for automation and now administrators familiar with Terraform can declaratively automate fabric administration tasks.",
  "Author": "Microsoft Fabric Blog",
  "PubDate": "2025-08-07T07:00:00+00:00",
  "Description": "If you have been following this blog post series then you should have a working Terraform config from the first two posts, plus a managed identity from the third post that has the correct authorizations as a workload identity for use in deployment pipelines. In this last post we will configure OpenID Connect for the …\n\n[Continue reading “Terraform Provider for Microsoft Fabric: #4 Deploying a Fabric config with Terraform in GitHub Actions”](https://blog.fabric.microsoft.com/en-us/blog/terraform-provider-for-microsoft-fabric-4-deploying-a-fabric-config-with-terraform-in-github-actions/)"
}
