{
  "ProcessedDate": "2025-10-08 14:03:03",
  "Author": "Microsoft Fabric Blog",
  "FeedUrl": "https://blog.fabric.microsoft.com/en-us/blog/feed/",
  "Link": "https://blog.fabric.microsoft.com/en-US/blog/concurrency-control-and-conflict-resolution-in-microsoft-fabric-data-warehouse/",
  "OutputDir": "_news",
  "PubDate": "2025-10-08T07:00:00+00:00",
  "Description": "Fabric Data Warehouse (DW) supports ACID-compliant transactions using standard T-SQL (BEGIN TRANSACTION, COMMIT, ROLLBACK) and uses Snapshot Isolation (SI) as its exclusive concurrency control model. All operations within a transaction are treated atomically—either all succeed or all fail. This ensures that each transaction operates on a consistent snapshot of the data as it existed at …\n\n[Continue reading “Resolving Write Conflicts in Microsoft Fabric Data Warehouse”](https://blog.fabric.microsoft.com/en-us/blog/concurrency-control-and-conflict-resolution-in-microsoft-fabric-data-warehouse/)",
  "FeedLevelAuthor": "Microsoft Fabric Blog",
  "Tags": [],
  "EnhancedContent": "Fabric Data Warehouse (DW) supports ACID-compliant transactions using standard` T-SQL (BEGIN TRANSACTION, COMMIT, ROLLBACK) ` and uses Snapshot Isolation (SI) as its exclusive concurrency control model. All operations within a transaction are treated atomically—either all succeed or all fail. This ensures that each transaction operates on a consistent snapshot of the data as it existed at the start of the transaction, which means.\n\n- **Read Consistency:** All reads within a transaction reflect the state of all attached databases as of the first read or write operation following the `BEGIN TRANSACTION`\nstatement, aligning with SQL Server’s snapshot isolation behavior.\n- **Optimistic Concurrency:** Conflicts are detected at commit time, not during execution. This avoids locking overhead but introduces rollback risks.\n\nWhile this model enables high concurrency for reads, it introduces the possibility of write-write conflicts which are common under SI when multiple transactions attempt to modify the same data concurrently.\n\nWrite-write conflicts in Fabric Data Warehouse are fundamentally different from lock-based conflicts. For more information on lock conflicts, refer to [Understanding Locking and DDL Blocking in Microsoft Fabric Data Warehouse](https://aka.ms/LockingandDDLBlockingBehaviorinMicrosoftFabricDW) blog post.\n\n## Write-Write Conflict\n\nA write-write conflict (aka update conflict) occurs when two or more concurrent transactions attempt to perform conflicting operations such as `UPDATE, DELETE, MERGE or TRUNCATE ` on the same table. Under SI, only the first transaction to commit will succeed; others will be aborted with a conflict error.\n\n### Common Error Messages surfaced:\n\n- **Error 24556:** Snapshot isolation transaction aborted due to update conflict. Using snapshot isolation to access table ‘%.\\*ls’ directly or indirectly in database ‘%.\\*ls’ can cause update conflicts if rows in that table have been deleted or updated by another concurrent transaction. Retry the transaction.\n- **Error 24706:** Snapshot isolation transaction aborted due to update conflict. You cannot use snapshot isolation to access table ‘%.\\*ls’ directly or indirectly in database ‘%.\\*ls’ to update, delete, or insert the row that has been modified or deleted by another transaction. Please retry the transaction.\n\nUsers should treat the two error messages the same – retry the operation.\n\n### Operations Participating in Write-Write Conflict\n\n- UPDATE\n- DELETE\n- MERGE\n- TRUNCATE\n\n***MERGE Behavior****: Even when MERGE transactions only result in append-only changes, they are still subject to write-write conflict detection. When MERGE transaction affects different rows than other concurrent DML transactions, it may encounter this error if MERGE is not the first transaction to commit: ‘Snapshot isolation transaction aborted due to update conflict*.’\n\nThis granularity means that even if two transactions touch different rows, they will conflict if they target the same table. Only the first transaction to commit will succeed. Others will be rolled back with errors such as: ‘Snapshot isolation transaction aborted due to update conflict…’\n\nThis behavior is by design and ensures consistency, but it can be disruptive in high-throughput pipelines.\n\n## What causes Write – Write conflicts\n\nFabric DW currently tracks write-write conflicts at the table level, meaning even if two transactions modify different rows in the same table, they can still conflict. Conflicts arise from two primary sources:\n\n1. **User-Induced Workload Conflicts**\n- Multiple users or processes concurrently modifying the same table.\n- Common in ETL pipelines, batch updates, or overlapping transactions.\n2. **System-Induced Conflicts (Compaction)**\n- Background system tasks like automatic data compaction rewrites files with poor quality.\n- These can conflict with user transactions such as `UPDATE, DELETE, MERGE`\neven if the user is modifying different rows.\n\n**Example:** A user updates a table while compaction rewrites it. If compaction commits first, the user’s transaction fails due to a write-write conflict.\n\nRefer to [Data Compaction documentation](https://learn.microsoft.com/fabric/data-warehouse/guidelines-warehouse-performance#data-compaction) to learn more about compaction.\n\nConflicts can impact performance, reliability, and user experience, especially in high-concurrency environments. Understanding how they work and how to mitigate them is essential for building resilient data pipelines and applications in Fabric DW.\n\n## Best Practices to Avoid Conflicts\n\n1. Avoid concurrent `UPDATE, DELETE, MERGE`\non the same table.\n2. Use Retry Logic for DML Statements for `UPDATE`\n,` DELETE, MERGE`\n- Fabric DW uses Snapshot Isolation (SI), which detects conflicts at commit time. If a transaction fails due to a conflict, retrying the statement is often successful.\n- Recommended for `UPDATE`\n, `DELETE` , `MERGE` , and `TRUNCATE` statements.\n- Especially effective for single-statement transactions.\n- Customers are advised to implement retry logic in stored procedures or ETL pipelines or tools like Qlik replicate. This is the most effective short-term workaround.\n\n## In-Product Capabilities\n\nAs part of our ongoing investments to improve concurrency and reliability in Fabric Data Warehouse, we’re introducing Compaction Preemption, a new capability that intelligently avoids write-write conflicts between background compaction tasks and user operations. As of October 2025, Compaction preemption is enabled and is handled entirely by the system to reduce write-write conflicts between user workloads and system compaction tasks in Fabric DW, which uses snapshot isolation for concurrency control.\n\n### Problem Compaction Preemption Solves\n\nFabric DW uses Snapshot Isolation (SI), where write-write conflicts occur if two transactions modify the same table concurrently. Background compaction, which rewrites table files to optimize storage can silently conflict with user operations like `UPDATE` , `DELETE` , or `MERGE` , causing failures.\n\n###  How Compaction Preemption Works\n\nCompaction Preemption introduces a shared lock mechanism:\n\n- User transactions take a shared lock on a preemption-specific sub resource.\n- Compaction checks for this lock:\n- Before execution: If the lock is held, compaction aborts immediately.\n- Before commit: If the lock is held, compaction aborts again to avoid conflict.\n\nCompaction does not take a lock, ensuring it never blocks user workloads.\n\nUsers can still create write-write conflicts through their own workload; this feature only addresses conflicts involving compaction, not user-initiated conflicts. If users use explicit transactions and perform non-conflicting work (like inserts) before a conflicting operation (update, delete, merge), compaction may still commit successfully, and a subsequent user operation could still fail due to a conflict.\n\n## What’s Next\n\nWe are actively investing in improvements to improve concurrency –\n\n- Currently, conflicts are detected at the table level. Introducing more granularity such as file-level conflict detection / row- level conflict detection to improve concurrency.",
  "FeedName": "Microsoft Fabric Blog",
  "Title": "Resolving Write Conflicts in Microsoft Fabric Data Warehouse"
}
