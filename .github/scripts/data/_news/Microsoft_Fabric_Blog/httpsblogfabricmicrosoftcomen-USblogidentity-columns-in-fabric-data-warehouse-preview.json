{
  "Author": "Microsoft Fabric Blog",
  "OutputDir": "_news",
  "Description": "IDENTITY columns in Fabric Data Warehouse are a feature shaped by direct customer feedback and requests. Across the data community, the need for simple, automatic key generation has been a recurring theme. We are closing that gap, providing you with a tool to streamline your workflow and accelerate analytics capabilities. What Are IDENTITY Columns? Unlike …\n\n[Continue reading “IDENTITY Columns in Fabric Data Warehouse (Preview)”](https://blog.fabric.microsoft.com/en-us/blog/identity-columns-in-fabric-data-warehouse-preview/)",
  "PubDate": "2025-11-20T02:30:00+00:00",
  "Tags": [],
  "FeedLevelAuthor": "Microsoft Fabric Blog",
  "FeedName": "Microsoft Fabric Blog",
  "Link": "https://blog.fabric.microsoft.com/en-US/blog/identity-columns-in-fabric-data-warehouse-preview/",
  "EnhancedContent": "IDENTITY columns in Fabric Data Warehouse are a feature shaped by direct customer feedback and requests. Across the data community, the need for simple, automatic key generation has been a recurring theme. We are closing that gap, providing you with a tool to streamline your workflow and accelerate analytics capabilities.\n\n## What Are IDENTITY Columns?\n\nUnlike natural keys, surrogate keys have no business meaning – they exist solely to ensure row uniqueness and to allow relationships between tables when a natural key is not available. IDENTITY columns automatically generate unique numeric values for new rows in a table, removing the need to manually assign surrogate keys or build custom logic to populate those columns. For example, in a table called ‘Orders’, you could define an ‘OrderID’ column as an IDENTITY column, and each time a new record is added ‘OrderID’ will automatically be assigned with a new unique value.\n\nUsing IDENTITY columns in Fabric Data Warehouse provides a significant advantage over manual mechanisms for generating surrogate keys. Unlike approaches that rely on custom logic, such as computing *MAX(ID)+1*, using *ROW\\_NUMBER()*, generating hashes or GUIDs, IDENTITY columns offer a system-managed, automatic process for creating unique keys during data ingestion.\n\nThis eliminates the need for additional ETL steps or application-side scripts, reducing complexity and operational overhead. By delegating key generation to the Warehouse engine, IDENTITY columns ensure data integrity and key uniqueness at scale, even in a distributed architecture where parallel ingestion occurs. It also eliminates the risk of key duplication errors that can arise from concurrent loads when using other approaches, without impacting data ingestion throughout.\n\n## How Do IDENTITY Columns Work in Fabric Data Warehouse?\n\nWhile IDENTITY columns in Fabric Data Warehouse are modeled after SQL Server, there are fundamental differences arising from the massively parallel, distributed architecture in the Warehouse engine. In SQL Server, data ingestion happens within a single instance. Fabric Data Warehouse’s implementation of IDENTITY columns is designed for a distributed architecture, which means values are generated across multiple backend nodes in parallel during ingestion.\n\nTo maximize scalability and performance, each node receives a range of unique values to allocate to rows it will process for ingestion. However, because ranges are assigned independently, the sequence of values is not guaranteed to be continuous or ordered, and gaps may occur in between ranges. As an example, two concurrent ingestion jobs might consume different ranges for the IDENTITY column, leaving unused values between them. Despite these gaps, uniqueness is always guaranteed for the lifetime of the table.\n\n### Why does this design matter?\n\nFabric Data Warehouse implements IDENTITY columns with a distributed, massively parallel architecture, unlike the single-node approach of SQL Server. This design allows multiple compute nodes to generate surrogate keys concurrently without contention, ensuring scalability and high ingestion throughput for cloud-scale workloads. While this model sacrifices strict sequential ordering and reseeding options found in traditional systems, it delivers the performance and reliability required for modern analytics. For scenarios demanding ordered sequences, alternative strategies may still be needed, but for most analytics use cases, Fabric Data Warehouse’s IDENTITY implementation is optimized for efficiency and massive parallelism.\n\n## Example\n\nThe following table is a subset of the NY Taxi trip data sample. We will add a new column to the table definition, which will be an IDENTITY column:\n\n``` CREATE TABLE dbo.TripData ( tripID BIGINT IDENTITY, vendorID VARCHAR(50), tpepPickupDateTime DATETIME2(6), tpepDropoffDateTime DATETIME2(6), passengerCount INT, tripDistance FLOAT ); ```\n\nNext, we will ingest data into the new TripData table. Notice that COPY INTO uses a column list to avoid attempting to ingest data into the IDENTITY column:`` ``\n\n``` COPY INTO dbo.TripData (vendorID 1, tpepPickupDateTime 2, tpepDropoffDateTime 3, passengerCount 4, tripDistance 5) FROM 'https://azureopendatastorage.blob.core.windows.net/nyctlc/yellow/puYear=2013/' WITH ( FILE_TYPE = 'PARQUET' ) ```\n\nFinally, let’s have a look at the data:`` ``\n\n``` SELECT TOP 10 * FROM TripData ORDER BY tripID ```\n\nWe can observe that even though a value was not passed to the tripID column, a unique value was assigned to each new row: ![Table showing taxi trip data with columns for trip ID, vendor ID, pickup and dropoff timestamps, passenger count, and trip distance. All visible rows share the same trip ID and vendor ID ('VTS'), with varying times, passenger counts from 1 to 6, and trip distances ranging from 0.00 to 7.04 miles. The tripID column is highlighted by a red rectangle around it ](https://dataplatformblogwebfd-d3h9cbawf0h8ecgf.b01.azurefd.net/wp-content/uploads/2025/10/word-image-29280-1.png) Notice that the value is an exceptionally large number. In Fabric Data Warehouse, IDENTITY columns are of type BIGINT to ensure we can produce a unique value every time, no matter how many ingestion tasks are running in parallel.\n\n### Can I run out of IDENTITY values?\n\nAs discussed, IDENTITY column will produce a unique integer of type BIGINT. In T-SQL, the BIGINT data type accommodates 8 bytes, with a range from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807. However, IDENTITY columns in Fabric Data Warehouse will produce only positive values. This means you still have about 9.22 quintillion distinct values (263 to be exact) that IDENTITY can assign to your column, making the range limitless in practice for any modern dataset. Once a value is used on a table, it will never be reused by IDENTITY again on the same table.\n\n### Is IDENTITY\\_INSERT supported?\n\nDuring Preview IDENTITY\\_INSERT is not supported, but we are looking into enabling user ingestion of negative values into IDENTITY columns in a future release. This approach is designed for scenarios where a ‘missing member’ placeholder is required in dimension tables, allowing you to explicitly insert a negative surrogate key while preserving the integrity of the automatically generated positive identity sequence, offering flexibility for specialized cases without compromising the distributed identity allocation model.\n\n## Ready to get started?\n\nTry defining IDENTITY columns today and experience seamless key generation firsthand. Explore our tutorial [Using IDENTITY Columns in T-SQL to Create Surrogate Keys in Fabric Data Warehouse](https://aka.ms/identitydwdocs) and the documentation for more details.\n\nYour feedback is important to us. As this feature continues to evolve in Preview, we invite you to share your experiences, report any issues, and suggest improvements on [Ideas.](https://ideas.fabric.microsoft.com/)\n\nHelp us make Fabric Data Warehouse even better for everyone!",
  "Title": "IDENTITY Columns in Fabric Data Warehouse (Preview)",
  "ProcessedDate": "2025-11-20 11:03:00",
  "FeedUrl": "https://blog.fabric.microsoft.com/en-us/blog/feed/"
}
