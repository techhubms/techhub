{
  "EnhancedContent": "As with every [release](https://devblogs.microsoft.com/dotnet/announcing-dotnet-10/), we publish a blog post about the new and interesting changes and additions in .NET networking space. This time, we are writing about HTTP improvements, new web sockets APIs, security changes and many distinct additions in networking primitives.\n\n## HTTP\n\nThe following section introduces improvements and additions in HTTP space. Among them are a performance optimization in `WinHttpHandler` , a new HTTP verb and small addition in cookies.\n\n### WinHttpHandler\n\nOne of the performance improvements in .NET 10 is an optimization of server certificate validation in [`WinHttpHandler`](https://learn.microsoft.com/dotnet/api/system.net.http.winhttphandler). Normally, the validation is left to the native [*WinHTTP*](https://learn.microsoft.com/windows/win32/winhttp) implementation, which is expected to do the right thing. But sometimes, user code needs more control over the process and `WinHttpHandler` offers [`ServerCertificateValidationCallback`](https://learn.microsoft.com/dotnet/api/system.net.http.winhttphandler.servercertificatevalidationcallback) for exactly that reason. Once the user code registers the callback, `WinHttpHandler` skips the internal *WinHTTP* validation. Unfortunately, there‚Äôs no exact event raised by the native *WinHTTP* that would correspond to connection establishment and would also provide the server certificate for validation. As a result, the managed layer within `WinHttpHandler` is forced to invoke the custom `ServerCertificateValidationCallback` on each and every request. To avoid this, a cache of already validated certificates by server IP address was put in place. Every time a new request is being sent, `WinHttpHandler` skips building the whole certificate chain and invoking the custom callback if the certificate was previously validated. On top of that, each new connection clears up the cached certificate for that particular server IP to re-validate on connection recreation. To stay prudent from a security perspective, this feature ([dotnet/runtime#111791](https://github.com/dotnet/runtime/pull/111791)) is opt-in and hidden behind an [`AppContext`](https://learn.microsoft.com/dotnet/api/system.appcontext) switch:\n\n```c AppContext.SetSwitch(\"System.Net.Http.UseWinHttpCertificateCaching\", true); ```\n\nThe following example illustrates the effect of the switch:\n\n```c using System.Net.Security;\n\nAppContext.SetSwitch(\"System.Net.Http.UseWinHttpCertificateCaching\", true);\n\nusing var client = new HttpClient(new WinHttpHandler() { ServerCertificateValidationCallback = static (req, cert, chain, errors) => { Console.WriteLine(\"Server certificate validation invoked\"); return errors == SslPolicyErrors.None; } });\n\nConsole.WriteLine((await client.GetAsync(\"https://github.com\")).StatusCode); Console.WriteLine((await client.GetAsync(\"https://github.com\")).StatusCode); Console.WriteLine((await client.GetAsync(\"https://github.com\")).StatusCode); ```\n\nThe callback is invoked only once, with output like the following:\n\n```txt Server certificate validation invoked OK OK OK ```\n\nWhereas without the switch, the callback is invoked with each request:\n\n```txt Server certificate validation invoked OK Server certificate validation invoked OK Server certificate validation invoked OK ```\n\nThe following graph shows the cumulative time saved with the certificate caching per increasing number of requests: ![Cumulative time saved with certificate caching](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/12/winhttphandler.webp \"Cumulative time saved with certificate caching\")\n\n### QUERY\n\nAnother addition is a new HTTP verb `QUERY` . The purpose of the verb is to allow sending details for the query in the request body while still using a safe, idempotent request. In other words, being able to execute multiple times without affecting server data. One of the use cases is when the details of the query might not fit into URI length limits and using body in `GET` request is not supported by the server. The verb is still in process of standardization in [The HTTP QUERY Method](https://www.ietf.org/archive/id/draft-ietf-httpbis-safe-method-w-body-08.html) proposal. For that reason, we have decided to postpone the full implementation of the helper methods in [dotnet/runtime#113522](https://github.com/dotnet/runtime/issues/113522) until the RFC is published. And we only added the string constant in [dotnet/runtime#114489](https://github.com/dotnet/runtime/issues/114489), which can be used this way:\n\n```c using var client = new HttpClient(); var response = await client.SendAsync(new HttpRequestMessage(HttpMethod.Query, \"https://api.example.com/resource\")); ```\n\n### Cookies\n\nA very small change was requested: making the [`CookieException`](https://learn.microsoft.com/dotnet/api/system.net.cookieexception) constructor public in [dotnet/runtime#95965](https://github.com/dotnet/runtime/issues/95965). The change was made by a community contributor [@deeprobin](https://github.com/deeprobin) in [dotnet/runtime#109026](https://github.com/dotnet/runtime/pull/109026). `CookieException` can now be manually thrown to avoid unexpected visits from *Cookie Monster*:\n\n```c throw new CookieException(\"üç™\"); ```\n\n## WebSockets\n\nWorking with raw `WebSocket` APIs means dealing with low-level details‚Äîbuffering, framing, encoding, and custom wrappers to integrate with streams or channels. This complexity makes building transport layers and streaming protocols harder.\n\n.NET 10 introduces [`WebSocketStream`](https://learn.microsoft.com/dotnet/api/system.net.websockets.websocketstream), a stream-based abstraction over WebSockets that makes reading, writing, and parsing data for text and binary protocols much simpler.\n\nKey advantages:\n\n- **Stream-first design**: Works seamlessly with `StreamReader`\n, `JsonSerializer` , compressors, serializers, etc.\n- **No manual plumbing**: Eliminates message framing and leftover handling.\n- **Supports multiple scenarios**: JSON-based protocols, text-based protocols like STOMP, and binary protocols like AMQP.\n\n### Common usage patterns\n\n1. **Read a complete JSON message (text)**\n\nUse [`CreateReadableMessageStream`](https://learn.microsoft.com/dotnet/api/system.net.websockets.websocketstream.createreadablemessagestream) with `JsonSerializer.DeserializeAsync<T>()` . You don‚Äôt need a manual receive loop or a `MemoryStream` buffer. The stream ends exactly at the message boundary, so `DeserializeAsync` completes naturally when the message is fully read.\n2. **Stream a text protocol (e.g., STOMP-like, line oriented)**\n\nUse [`Create`](https://learn.microsoft.com/dotnet/api/system.net.websockets.websocketstream.create) to get a transport stream, and layer a `StreamReader` on top. You can parse **line-by-line** while the stream stays open across frames. This pattern leverages automatic UTF‚Äë8 handling and keeps reads composable with standard text parsers.\n3. **Write a single binary message (e.g., AMQP payload)**\n\nUse [`CreateWritableMessageStream`](https://learn.microsoft.com/dotnet/api/system.net.websockets.websocketstream.createwritablemessagestream) and write chunk-by-chunk; `Dispose` sends end-of-message (EOM) for you. The one‚Äëmessage write semantics avoid manual `EndOfMessage` handling and make your send path look like any other stream write.\n\nIn other words,\n\n- Prefer `CreateReadableMessageStream`\n/ `CreateWritableMessageStream` for message-oriented workflows.\n- For continuous protocols, use `Create`\nwith appropriate `leaveOpen` /`ownsWebSocket` semantics in layered readers/writers.\n- Dispose streams to complete EOM and close gracefully. Use `closeTimeout`\nto limit how long Dispose will wait for a graceful close handshake completion.\n\n### Before vs After (JSON example)\n\nSee the snippet below for the comparison between using a raw WebSocket loop and using a WebSocketStream to read a complete JSON message.\n\n```csharp // BEFORE: manual buffering static async Task<AppMessage?> ReceiveJsonManualAsync(WebSocket ws, CancellationToken ct) { var buffer = new byte[8192]; using var mem = new MemoryStream(); while (ws.State == WebSocketState.Open) { var result = await ws.ReceiveAsync(buffer, ct); if (result.MessageType == WebSocketMessageType.Close) { return null; } await mem.WriteAsync(buffer.AsMemory(0, result.Count), ct); if (result.EndOfMessage) { break; } } mem.Position = 0; return await JsonSerializer.DeserializeAsync<AppMessage>(mem, cancellationToken: ct); }\n\n// AFTER: message stream static async Task<AppMessage?> ReceiveJsonAsync(WebSocket ws, CancellationToken ct) { using Stream message = WebSocketStream.CreateReadableMessageStream(ws); return await JsonSerializer.DeserializeAsync<AppMessage>(message, cancellationToken: ct); } ```\n\nThe ‚Äúafter‚Äù version eliminates buffering, copies, and `EndOfMessage` checks via the `Stream` abstraction.\n\n## Security\n\nIn this release, there were two changes in the networking security space that are worth calling out. One of them is a long-standing request for TLS 1.3 support on OSX. And the second one is unifying how we expose TLS cipher suite details.\n\n### Client-side TLS 1.3 on OSX\n\nTLS 1.3 support on OSX was highly requested issue [dotnet/runtime#1979](https://github.com/dotnet/runtime/issues/1979) for several releases. It was a non-trivial effort because it required switching to a different set of native OSX APIs. On top of that, the new APIs combine TLS together with TCP whereas .NET exposes these two layers independently from each other as [`SslStream`](https://learn.microsoft.com/dotnet/api/system.net.security.sslstream) and [`Socket`](https://learn.microsoft.com/dotnet/api/system.net.sockets.socket). Furthermore, the new APIs support only TLS 1.2 and TLS 1.3 and, despite other [`SslProtocols`](https://learn.microsoft.com/dotnet/api/system.security.authentication.sslprotocols) being deprecated, .NET still supports them. All of this combined led to a decision to expose this functionality only as an opt-in feature behind an [`AppContext`](https://learn.microsoft.com/dotnet/api/system.appcontext) switch ([dotnet/runtime#117428](https://github.com/dotnet/runtime/pull/117428)). Client application can take advantage of this new support by either setting the switch in their code:\n\n```c AppContext.SetSwitch(\"System.Net.Security.UseNetworkFramework\", true); ```\n\nor with an environment variable:\n\n```bash export DOTNET_SYSTEM_NET_SECURITY_USENETWORKFRAMEWORK=1 ```\n\nNote that this will switch the backend `SslStream` uses for client operations on OSX, so only TLS 1.3 and TLS 1.2 will be supported. But it has no effect on server-side usage of `SslStream` .\n\n### Negotiated Cipher Suite\n\n[`SslStream`](https://learn.microsoft.com/dotnet/api/system.net.security.sslstream) provides several properties with details about negotiated cipher suite. Among them belong [`KeyExchangeAlgorithm`](https://learn.microsoft.com/dotnet/api/system.net.security.sslstream.keyexchangealgorithm), [`HashAlgorithm`](https://learn.microsoft.com/dotnet/api/system.net.security.sslstream.hashalgorithm) and [`CipherAlgorithm`](https://learn.microsoft.com/dotnet/api/system.net.security.sslstream.cipheralgorithm). However, the underlying enums for these properties weren‚Äôt updated for a while and therefore not providing accurate information. For example, mapping multiple algorithms from the same family into the single enum value, losing important information in the process. Instead of expanding the enums, we decided to obsolete them and leave only [`NegotiatedCipherSuite`](https://learn.microsoft.com/dotnet/api/system.net.security.sslstream.negotiatedciphersuite) as the only source of truth ([dotnet/runtime#100361](https://github.com/dotnet/runtime/issues/100361)). The underlying enum [`TlsCipherSuite`](https://learn.microsoft.com/dotnet/api/system.net.security.tlsciphersuite) follows IANA specification for [TLS Cipher Suites](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4) and encompasses all the information needed. The obsoleted properties were only derived from `NegotiatedCipherSuite` and didn‚Äôt convey any additional information. The whole change can be examined in [dotnet/runtime#105875](https://github.com/dotnet/runtime/pull/105875).\n\nOn top of that, we have introduced the same [`NegotiatedCipherSuite`](https://learn.microsoft.com/dotnet/api/system.net.quic.quicconnection.negotiatedciphersuite) property to `QuicConnection` in [dotnet/runtime#106391](https://github.com/dotnet/runtime/pull/106391). Also being the only source of truth for the negotiated TLS details for the established connection. Discussion for the API addition can be found in [dotnet/runtime#70184](https://github.com/dotnet/runtime/issues/70184).\n\n## Networking Primitives\n\nThis section introduces changes in `System.Net` namespace which contains several additions to server-sent events helpers, IP address, URI and similar types.\n\n### Server-Sent Events Formatter\n\nIn the previous release of .NET, we have added support for parsing server-sent events, mentioned in the last year‚Äôs blog post chapter [Server-Sent Events Parser](https://devblogs.microsoft.com/dotnet/dotnet-9-networking-improvements/#server-sent-events-parser). This release introduces the opposite side, formatter for server-sent events ([dotnet/runtime#109294](https://github.com/dotnet/runtime/issues/109294)). In the most simple scenario, with `string` typed data, the new API can be used like in the following example:\n\n```c using var stream = new MemoryStream();\n\n// Only pass in source of items and stream to serialize into. await SseFormatter.WriteAsync(GetStringItems(), stream);\n\nstatic async IAsyncEnumerable<SseItem<string>> GetStringItems() { yield return new SseItem<string>(\"data 1\"); yield return new SseItem<string>(\"data 2\"); yield return new SseItem<string>(\"data 3\"); yield return new SseItem<string>(\"data 4\"); } ```\n\nThe content of the stream for this code will look like:\n\n```text data: data 1\n\ndata: data 2\n\ndata: data 3\n\ndata: data 4\n\n```\n\nAnd the following example illustrates the case when the data payload is not a simple `string` :\n\n```c var stream = new MemoryStream();\n\n// The third argument is a delegate taking in SseItem and IBufferWriter into which the item is serialized. await SseFormatter.WriteAsync<int>(GetItems(), stream, (item, writer) => { // The data of the item should be converted to a string and that string then converted to corresponding UTF-8 bytes. writer.Write(Encoding.UTF8.GetBytes(item.Data.ToString())); });\n\nstatic async IAsyncEnumerable<SseItem<int>> GetItems() { yield return new SseItem<int>(1) { ReconnectionInterval = TimeSpan.FromSeconds(1) }; yield return new SseItem<int>(2); yield return new SseItem<int>(3); yield return new SseItem<int>(4); } ```\n\nFor this example, the content of the stream will look like:\n\n```text data: 1 retry: 1000\n\ndata: 2\n\ndata: 3\n\ndata: 4\n\n```\n\nAs the examples show, this addition ([dotnet/runtime#109832](https://github.com/dotnet/runtime/pull/109832)) introduced two overloads for writing the events:\n\n- simple one for `string`\ntyped data, without formatting delegate: [`WriteAsync(IAsyncEnumerable<SseItem<String>>, Stream, CancellationToken)`](https://learn.microsoft.com/dotnet/api/system.net.serversentevents.sseformatter.writeasync#system-net-serversentevents-sseformatter-writeasync%28system-collections-generic-iasyncenumerable%28%28system-net-serversentevents-sseitem%28%28system-string%29)))-system-io-stream-system-threading-cancellationtoken))\n- generic one for any data, with formatting delegate: [`WriteAsync<T>(IAsyncEnumerable<SseItem<T>>, Stream, Action<SseItem<T>,IBufferWriter<Byte>>, CancellationToken)`](https://learn.microsoft.com/dotnet/api/system.net.serversentevents.sseformatter.writeasync#system-net-serversentevents-sseformatter-writeasync-1%28system-collections-generic-iasyncenumerable%28%28system-net-serversentevents-sseitem%28%28-0%29)))-system-io-stream-system-action((system-net-serversentevents-sseitem((-0))-system-buffers-ibufferwriter((system-byte))))-system-threading-cancellationtoken))\n\nOn top of that, [`SseItem<T>`](https://learn.microsoft.com/dotnet/api/system.net.serversentevents.sseitem-1) was expanded with two new properties for writing:\n\n- [`EventId`](https://learn.microsoft.com/dotnet/api/system.net.serversentevents.sseitem-1.eventid): to send the `id`\nfield\n- [`ReconnectionInterval`](https://learn.microsoft.com/dotnet/api/system.net.serversentevents.sseitem-1.reconnectioninterval): to send the `retry`\nfield\n\nBoth of these fields control the behavior of the client when the connection needs to be re-established. The last parsed `EventId` will map to [`LastEventId`](https://learn.microsoft.com/dotnet/api/system.net.serversentevents.sseparser-1.lasteventid) on the parser side and eventually will be used in [`Last-Event-ID`](https://html.spec.whatwg.org/multipage/server-sent-events.html#the-last-event-id-header) header if the connection is re-created. And `ReconnectionInterval` will map to [`ReconnectionInterval`](https://learn.microsoft.com/dotnet/api/system.net.serversentevents.sseparser-1.reconnectioninterval) and will control the time before a new connection is attempted.\n\nWith all of this together, `System.Net.ServerSentEvents` provides a complete set of helpers for both sides of the communication and can be used to round-trip the data back and forth:\n\n```c var stream = new MemoryStream();\n\nawait SseFormatter.WriteAsync<int>(GetItems(), stream, (item, writer) => { writer.Write(Encoding.UTF8.GetBytes(item.Data.ToString())); });\n\nstream.Seek(0, SeekOrigin.Begin);\n\nvar parser = SseParser.Create(stream, (type, data) => { var str = Encoding.UTF8.GetString(data); return Int32.Parse(str); });\n\nawait foreach (var item in parser.EnumerateAsync()) { Console.WriteLine($\"{item.EventType}: {item.Data} {item.EventId} {item.ReconnectionInterval} [{parser.LastEventId};{parser.ReconnectionInterval}]\"); }\n\nstatic async IAsyncEnumerable<SseItem<int>> GetItems() { yield return new SseItem<int>(1) { ReconnectionInterval = TimeSpan.FromSeconds(1) }; yield return new SseItem<int>(2) { EventId = \"2\" }; yield return new SseItem<int>(3); yield return new SseItem<int>(4); } ```\n\n### IP Address\n\nThere were two new additions for [`IPAddress`](https://learn.microsoft.com/dotnet/api/system.net.ipaddress) class. The first one is a static method to validate whether a string is a valid IP address ([dotnet/runtime#111282](https://github.com/dotnet/runtime/issues/111282)). It can be used as:\n\n```c if (IPAddress.IsValid(\"10.0.0.1\")) { ... } if (IPAddress.IsValid(\"::1\")) { ... } if (IPAddress.IsValid(\"10.0.1\")) { ... } if (IPAddress.IsValidUtf8(\"::192.168.0.1\"u8)) { ... } if (IPAddress.IsValidUtf8(\"fe80::9656:d028:8652:66b6\"u8)) { ... } ```\n\nThe other change follows up on a change adding [`IUtf8SpanFormattable`](https://learn.microsoft.com/dotnet/api/system.iutf8spanformattable) in .NET 8. Both [`IPAddress`](https://learn.microsoft.com/dotnet/api/system.net.ipaddress) and [`IPNetwork`](https://learn.microsoft.com/dotnet/api/system.net.ipnetwork) now also implement [`IUtf8SpanParsable<T>`](https://learn.microsoft.com/dotnet/api/system.iutf8spanparsable-1). The API proposal [dotnet/runtime#103111](https://github.com/dotnet/runtime/issues/103111) as well as the implementation itself [dotnet/runtime#102144](https://github.com/dotnet/runtime/pull/102144) were done by a community contributor [@edwardneal](https://github.com/edwardneal).\n\n### Miscellaneous\n\nThe last changes in `System.Net` namespace worth mentioning are removing the length limit on [`Uri`](https://learn.microsoft.com/dotnet/api/system.uri) in [dotnet/runtime#117287](https://github.com/dotnet/runtime/pull/117287). The main reason for this change was to support `data` URI scheme ([dotnet/runtime#96544](https://github.com/dotnet/runtime/issues/96544)) as specified in [RFC 2397](https://datatracker.ietf.org/doc/html/rfc2397). Instead of linking a resource, `data` URI carries the data for the resource in itself. For example as base64 encoded image:\n\n```text data:image/jpeg;base64,[base64 encoded data of the image] ```\n\nAnd with the original limit of slightly under 64 KB, this was not enough for many such data URIs.\n\nThe last small change was adding a new media type for `yml` files ([dotnet/runtime#105809](https://github.com/dotnet/runtime/issues/105809)). The change adds a new constant [`MediaTypesName.Yaml`](https://learn.microsoft.com/dotnet/api/system.net.mime.mediatypenames.application.yaml) in [dotnet/runtime#117211](https://github.com/dotnet/runtime/pull/117211) and was done by a community contributor [@martincostello](https://github.com/martincostello).\n\n## Final Notes\n\nIt has become a tradition to publish this article every year and as in the past years, the article cannot cover all the changes that have been made. We pick things that might have a direct impact on our customers, whether it‚Äôs a new API, feature or performance improvement. And of course, many of such performance improvements are already covered by Stephen‚Äôs great article about [Performance Improvements in .NET 10](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-10/#networking). We‚Äôd also like to encourage you to reach out to us in [our GitHub repo](https://github.com/dotnet/runtime/issues) in case you have any questions, requests for new features or discover any bugs. And lastly, I‚Äôd like to thank my co-author [@CarnaViire](https://github.com/CarnaViire) for writing the WebSockets section.",
  "Tags": [
    ".NET",
    ".NET 10",
    "http",
    "net-security",
    "Networking",
    "web-sockets"
  ],
  "ProcessedDate": "2025-12-08 19:02:44",
  "FeedLevelAuthor": ".NET Blog",
  "FeedName": "Microsoft .NET Blog",
  "Link": "https://devblogs.microsoft.com/dotnet/dotnet-10-networking-improvements/",
  "Author": "M√°≈àa",
  "OutputDir": "_news",
  "Description": "Introducing new networking features in .NET 10 including HTTP space, WebSockets, security and more!\n\nThe post [.NET 10 Networking Improvements](https://devblogs.microsoft.com/dotnet/dotnet-10-networking-improvements/) appeared first on [.NET Blog](https://devblogs.microsoft.com/dotnet).",
  "FeedUrl": "https://devblogs.microsoft.com/dotnet/feed/",
  "PubDate": "2025-12-08T18:05:00+00:00",
  "Title": ".NET 10 Networking Improvements"
}
