{
  "ProcessedDate": "2025-08-25 18:17:16",
  "Description": "A look at how the Model-View-Update pattern can complement the .NET MAUI ecosystem\n\nThe post [MauiReactor: An MVU Approach for .NET MAUI](https://devblogs.microsoft.com/dotnet/mauireactor-mvu-for-dotnet-maui/) appeared first on [.NET Blog](https://devblogs.microsoft.com/dotnet).",
  "Tags": [
    ".NET",
    ".NET MAUI",
    "C#",
    "MVU"
  ],
  "PubDate": "2025-08-25T17:15:00+00:00",
  "FeedLevelAuthor": ".NET Blog",
  "FeedUrl": "https://devblogs.microsoft.com/dotnet/feed/",
  "Title": "MauiReactor: An MVU Approach for .NET MAUI",
  "FeedName": "Microsoft .NET Blog",
  "Link": "https://devblogs.microsoft.com/dotnet/mauireactor-mvu-for-dotnet-maui/",
  "Author": "David Ortinau",
  "EnhancedContent": "*This is a guest blog from [Adolfo Marinucci](https://github.com/adospace).*\n\nI’m a full-stack developer from Italy, primarily focused on Microsoft technologies ranging from cross-platform applications with .NET MAUI to ASP.NET Core backend services hosted on Azure. I’m the creator of MauiReactor, a UI library for .NET MAUI that brings the Model-View-Update (MVU) pattern to cross-platform development.\n\n![collage of sample apps made with MauiReactor](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/08/reactor-collage.png)\n\n## Background and Motivation\n\n[MauiReactor](https://adospace.gitbook.io/mauireactor/) is an open-source .NET library that brings the [Model-View-Update](https://guide.elm-lang.org/architecture/) (MVU) pattern to .NET MAUI development. While MVU has been discussed for years, it gained widespread attention through ReactJS and later influenced frameworks like React Native and Flutter.\n\n**Note**\n\nFor more details on MVU approach of MauiReactor [https://adospace.gitbook.io/mauireactor/components/stateful-components](https://adospace.gitbook.io/mauireactor/components/stateful-components).\n\n### Advantages of MVU\n\n- Predictable state management through immutable state\n- Simplified hot reload implementation\n- Full C# IDE support for UI development\n- Potentially better performance characteristics\n\nThe library started as an experiment with Xamarin.Forms nearly ten years ago. Over time, it evolved into what is now MauiReactor, incorporating lessons learned from real-world application development and the feedback from like-minded developers who wanted to explore MVU patterns within the .NET ecosystem. The library is designed as a thin layer over .NET MAUI, with much of the code being auto-generated. This approach keeps the codebase relatively simple and makes it easier to update when new versions of .NET MAUI are released.\n\nToday, MauiReactor is a mature open-source project with [over 650 stars on GitHub](https://github.com/adospace/reactorui-maui). I use and maintain it across dozens of production applications, and my clients have consistently expressed appreciation for the significantly reduced development time required to build applications with MauiReactor compared to standard .NET MAUI.\n\n## MVU vs MVVM\n\n.NET MAUI naturally supports the [MVVM pattern](https://learn.microsoft.com/dotnet/architecture/maui/mvvm), which many developers appreciate for its familiarity and the ability to reuse existing WPF knowledge. MVVM offers excellent separation of concerns, and good tooling support. For teams with existing MVVM expertise, this remains a valid choice.\n\nMauiReactor provides an alternative for developers who want to explore MVU patterns or those coming from React Native or Flutter backgrounds who are comfortable with declarative UI approaches written in code.\n\nMauiReactor’s MVU approach offers some key advantages over MVVM:\n\n### 1. Enhanced Productivity\n\nYou can write UI logic directly in the view component without requiring commands to handle user interactions or custom value converters to pass correct values to widgets. For example in MVVM, to implement a user login you need a LoginCommand object to handle the “Login” button click, specify a “CanExecute” callback to enable it only after the user has entered username/password strings, and additional code to show a busy indicator during command execution. In MVU, you can write a Button in C# and specify a callback for the OnClick event, then set the IsEnabled property to true when the username/password fields are filled.\n\n```csharp Button(\"Login\") .IsEnabled(!string.IsNullOrWhiteSpace(State.FirstName) && !string.IsNullOrWhiteSpace(State.LastName)) .OnClicked(OnLogin) ```\n\n### 2. More Flexible Conditional UI\n\nConsider a login component that displays two text entries and a login button, with a busy indicator during authentication. In MVVM, you need value converters to show or hide widgets. In MVU with MauiReactor, you can check a state property and use a simple evaluation statement to show different UI elements (similar to Blazor).\n\n```csharp ActivityIndicator() .IsVisible(State.IsBusy) ```\n\n```csharp State.IsBusy ? ActivityIndicator() : null ```\n\n### 3. True Hot Reload\n\nThanks to a different separation of concerns, MauiReactor enables superior hot reload capabilities. In MVVM, you typically have View separated from logic (ViewModel) and state (Model), though often developers keep logic and state in a single ViewModel class. In MVU (MauiReactor’s flavor), you have View+Logic separated from Model (State). Keeping state separate from view and logic allows hot reloading the application without losing context. For example, if you have a complex page with text entered in multiple text fields and decide to change some code, when the page is hot-reloaded, the same text remains in the text fields because the state is retained between iterations.\n\nBringing this all together, here is the typical counter app in MauiReactor.\n\n```csharp class CounterPageState { public int Counter { get; set; } }\n\nclass CounterPage : Component<CounterPageState> { public override VisualNode Render() => ContentPage(\"Counter Sample\", VStack( Label($\"Counter: {State.Counter}\"), Button(\"Click To Increment\", () => SetState(s => s.Counter++)) ) ); } ```\n\nTo put it in perspective, this is the counter in React Native which demonstrates a similar MVU implementation.\n\n```ts import React, { useState } from 'react'; import { View, Text, TouchableOpacity } from 'react-native';\n\nconst Counter = () => { const [count, setCount] = useState(0);\n\nreturn ( <View> <Text>Count: {count}</Text> <TouchableOpacity onPress={() => setCount(count + 1)}> <Text>+</Text> </TouchableOpacity> <TouchableOpacity onPress={() => setCount(count - 1)}> <Text>-</Text> </TouchableOpacity> <TouchableOpacity onPress={() => setCount(0)}> <Text>Reset</Text> </TouchableOpacity> </View> ); };\n\nexport default Counter; ```\n\n## Real-World Usage\n\nMauiReactor has been used in production applications across different domains. A notable example includes work with [Real Time Research, Inc.](https://realtimeresearch.com), a US company that provides data and analytics solutions for natural resources to government agencies conducting scientific research. Their applications allow researchers to collect field data in offline environments, synchronize with Microsoft Azure, and generate reports through Microsoft Power BI.\n\n### Demo application\n\nMauiReactor powers the Real Time Research application used by researchers to conduct fish surveys, collecting data about fish and habitat measurements. This application connects to a passive integrated transponder (PIT) tag reader, retrieves GPS location data, and reads barcodes.\n\n[https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/08/mauireactor.mp4](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/08/mauireactor.mp4)\n\nThese applications handle complex data workflows and need to work reliably in challenging field conditions. The choice to use MauiReactor was based on specific technical requirements around state management and offline synchronization patterns.\n\nHere’s an example of how state management works during synchronization.\n\n```c async Task OnSync() { SetState(s => { s.IsBusy = true; s.SyncProgress = null; });\n\ntry { _syncProviderService.SyncProgress += SyncProviderService_SyncProgress;\n\nawait _syncAgentService.Synchronize();\n\nPreferences.Set(\"LastSync\", DateTime.Now); } catch (Exception ex) { await ContainerPage.DisplayAlert(\"The application is unable to sync with the server.\", \"OK\"); } finally { _syncProviderService.SyncProgress -= SyncProviderService_SyncProgress;\n\nSetState(s => { s.IsBusy = false; s.SyncProgress = null; }); } }\n\nvoid SyncProviderService_SyncProgress(object? sender, SyncProgressEventArgs e) { SetState(_ => { _.SyncStage = e.Stage; _.SyncProgress = e.Progress; }); } ```\n\nBeyond enterprise applications, the library has been used in various consumer-oriented projects, showing its flexibility across different application types and requirements.\n\n## Technical Characteristics\n\nMauiReactor has several technical characteristics that may be relevant depending on your project needs:\n\n### Hot Reload Implementation\n\nThe MVU architecture makes hot reload more straightforward to implement. Since the UI is a function of state, reloading involves swapping the view and update functions while preserving the application state. This can lead to faster development cycles, particularly when working on complex UI interactions.\n\nMauiReactor’s hot reload works with the standard .NET CLI (with its limitations) or by installing a custom .NET tool (Reactor.Maui.HotReload). With the dedicated tool, MauiReactor supports almost any change you make to the code and operates quickly. For example, you can create new classes, remove or add methods, and change types and properties. Any time you modify a file, it’s compiled on the fly and sent to the application. It works with Android, iOS, Mac, and Windows, using the emulator or real device. You can develop in Visual Studio, VS Code, and Rider under Windows or Mac.\n\nThe hot reload function swaps the entire assembly running the app with the one containing the new code (not just the view of the current component). The entire application gets the new code, but the current page, component, and context are preserved because they’re linked to the state class that is copied over. You’ll rarely be required to restart the app, providing a great development experience.\n\n### Code-Based UI Development\n\nApplications are written entirely in C#, which means you can use all the IDE features you’re familiar with: IntelliSense, refactoring, debugging, and code analysis tools. This approach also works consistently across different development environments.\n\n#### Theming\n\nXAML styling continues to work, so you can port your existing XAML-based resources. However, MauiReactor also features a powerful theming system that allows you to declare styles directly in C# to customize any controls, standard or imported from other libraries.\n\n```c public class AppTheme : Theme { protected override void OnApply() { LabelStyles.Default = _ => _ .FontFamily(\"OpenSansRegular\") .FontSize(FontNormal) .TextColor(Black);\n\nLabelStyles.Themes[\"Title\"] = _ => _ .FontSize(20); } } ```\n\nFor more information about theming, visit the [MauiReactor theming documentation](https://adospace.gitbook.io/mauireactor/components/theming).\n\n#### Data Binding\n\nOne thing you won’t miss in MauiReactor is building value converters for everything. Coming from the XAML world, you’re used to creating value converters to transform data read from view models (like InverseBooleanConverter or BoolToVisibilityConverter).\n\n```xml <Label IsVisible=\"{Binding MyValue, Converter={StaticResource InvertedBoolConverter}}\"/> ```\n\nMauiReactor can set the property using normal C# code, allowing you to transform state property values or evaluate functions:\n\n```csharp Label().IsVisible(!MyValue)\n\nLabel().IsVisible(IsLabelVisible()) ```\n\n#### Conditional rendering\n\nConditional rendering of UI portions using plain XAML can be cumbersome: you probably need to use a converter and show/hide controls. Without worry over performance implications of creating controls that may never appear, MauiReactor allows you to simply declare your UI in C# with custom logic right in the component:\n\n```csharp class LoginPage : Component<LoginPageState> { public override VisualNode Render() => ContentPage( State.IsLoggingIn ? RenderBusyUI() : RenderLoginUI() ); } ```\n\n#### Readability\n\nLarge pages can be broken down into simpler render functions or arranged into simpler components. Readability over XAML is one of the core features of code-based UIs and becomes apparent as soon as you start integrating MauiReactor into an existing .NET MAUI application.\n\n```csharp class HomePage : Component { public override VisualNode Render() => ContentPage( Grid(\"Auto,*,Auto\", \"*\", RenderHeader(),\n\nRenderBody(),\n\nRenderFooter() ); } ```\n\n#### Testing\n\nMauiReactor fully supports integration testing by providing utility classes and functions that let you create components on the fly without requiring platform initialization. For example, this is how you can test the counter component shown above.\n\n```csharp [Test] public void CounterWithServicePage_Clicking_Button_Correctly_Increments_The_Counter() { using var serviceContext = new ServiceContext(services => services.AddSingleton<IncrementService>());\n\nvar mainPageNode = TemplateHost.Create(new CounterWithServicePage());\n\n// Check that the counter is 0 mainPageNode.Find<MauiControls.Label>(\"Counter_Label\") .Text .ShouldBe($\"Counter: 0\");\n\n// Click on the button mainPageNode.Find<MauiControls.Button>(\"Counter_Button\") .SendClicked();\n\n// Check that the counter is 1 mainPageNode.Find<MauiControls.Label>(\"Counter_Label\") .Text .ShouldBe($\"Counter: 1\"); } ```\n\nMauiReactor is test framework agnostic: continue to use MSTest, XUnit, NUnit, or any other testing framework you prefer.\n\n### Performance Considerations\n\nApplications built with MauiReactor avoid some of the overhead associated with XAML parsing and reflection-based data binding. In practice, this can result in better startup performance and runtime efficiency, though the actual impact depends on your specific application design.\n\nMauiReactor pages are compiled by default, while poorly designed XAML-based pages may contain performance bottlenecks related to reflection-based bindings and resource lookups. This usually results in faster page opening times and smoother transitions. On the other hand, MauiReactor may require more rendering passes every time you edit a state property.\n\nIn my experience, performance issues are rarely related to the framework itself (.NET MAUI vs MauiReactor) but more often to poorly designed pages or logic code (including hidden exceptions or abnormal thread context switches).\n\nIf you’re serious about performance optimizations and want to test differences between .NET MAUI and MauiReactor, I’ve prepared a [sample project](https://github.com/adospace/maui-reactor-profiling) that can help measure startup times of your application.\n\n**Note**\n\nThe library’s minimal use of reflection makes it well-suited for [Ahead-of-Time compilation](https://learn.microsoft.com/dotnet/maui/deployment/nativeaot) scenarios, which can be important for certain deployment requirements.\n\n### Easy Third-Party Component Integration\n\nMauiReactor can work with existing .NET MAUI component libraries from vendors like Syncfusion, Telerik, and DevExpress. Custom controls can be integrated with some additional wrapper code.\n\nUsing an existing control in MauiReactor usually requires adding this kind of code to your project:\n\n```csharp [Scaffold(typeof(Syncfusion.Maui.Buttons.ToggleButton))] partial class ToggleButton { } ```\n\nMauiReactor source generators will create the required layer of code. The imported widget can then be instantiated inside a component:\n\n```csharp VStack( new ToggleButton() .OnClicked(()=>...) ) ```\n\nFor certain, more complex controls, the integration may require additional code. I constantly create and update integration code for common libraries in [this repository](https://github.com/adospace/mauireactor-integration).\n\n## Looking Forward\n\nMauiReactor represents one approach to cross-platform development within the .NET ecosystem. It’s not intended to replace existing patterns, but rather to provide an alternative for developers who find MVU patterns better suited to their needs or development style. The library continues to evolve based on feedback from developers using it in production scenarios. As the .NET MAUI ecosystem grows, having different approaches available gives developers more options to choose what works best for their specific requirements.\n\nI’ve been in the software development industry since 2001, and I’ve witnessed the rise of the .NET platform over the years. I’ve enjoyed the beauty of the WPF architecture and MVVM pattern (I’m the original author of the AvalonDock library). Then came ReactJS with its unique MVU approach to writing UI for the web. I probably never wrote a Xamarin.Forms application in XAML and MVVM, but I soon started to think that it could be possible to write cross-platform .NET applications in MVU thanks to the flexibility of the C# language.\n\nOver the last 10 years, I’ve written many C#-based MauiReactor applications and loved their simplicity and productivity. I never looked back.\n\nThanks to the wonderful .NET community, I’ve received hints and bug fixes that have transformed what was my personal side project into an established open-source project known and enjoyed by many developers around the world to build their applications faster.\n\nBesides maintaining the core project, given the architecture of MauiReactor, I’m also experimenting with integration with other UI frameworks like WPF, Avalonia, or UNO, and also [DrawnUI](https://github.com/taublast/DrawnUi) and [Spice](https://github.com/adospace/spice).\n\n### Create your first MauiReactor app today\n\n1. Install the dotnet new template\n\n```bash dotnet new install Reactor.Maui.TemplatePack ```\n\n1. Create a new project\n\n```bash dotnet new maui-reactor-startup -o my-new-project ```\n\n1. Run the application\n\n```bash dotnet build -t:Run -f net9.0-android ```\n\nFor more info, documentation and samples please visit [MauiReactor Repo](https://github.com/adospace/reactorui-maui), [MauiReactor Samples Repository](https://github.com/adospace/mauireactor-samples), and [MauiReactor documentation](https://adospace.gitbook.io/mauireactor/getting-started).",
  "OutputDir": "_news"
}
