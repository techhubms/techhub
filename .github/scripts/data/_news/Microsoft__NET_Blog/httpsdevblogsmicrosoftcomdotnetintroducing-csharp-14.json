{
  "FeedName": "Microsoft .NET Blog",
  "Tags": [
    ".NET",
    ".NET 10",
    "C#",
    "compound assignment",
    "Csharp",
    "extension",
    "null conditional"
  ],
  "FeedLevelAuthor": ".NET Blog",
  "EnhancedContent": "C# 14 ships with .NET 10. The highlight is new `extension` members, but there’s a lot more features that make your life as a developer more productive. And, we’ve added new features that enable some of the performance improvements you can experience in .NET 10. Read on for a tour of all the new features, and find links to dive deeper and start using these features today.\n\n## Extension members\n\n[Extension members](https://learn.microsoft.com/dotnet/csharp/whats-new/csharp-14#extension-members) are the headline feature of C# 14. The new syntax is fully compatible with existing extension methods. Extension members enables extension properties, extension operators, and static extension members.\n\nThe following code shows an example extension block. The extension block contains two instance extensions followed by two static extensions for the same type. The receiver name, `source` , is optional if the extension only contains static extensions.\n\n```csharp public static class EnumerableExtensions { // Instance-style extension members: 'source' is the receiver variable extension<TSource>(IEnumerable<TSource> source) { // Extension property public bool IsEmpty => !source.Any();\n\n// Extension method (body elided for brevity) public IEnumerable<TSource> Where(Func<TSource, bool> predicate) { // Implementation would filter 'source' throw new NotImplementedException(); }\n\n// Static extension property public static IEnumerable<TSource> Identity => Enumerable.Empty<TSource>();\n\n// Static user-defined operator provided as an extension public static IEnumerable<TSource> operator +( IEnumerable<TSource> left, IEnumerable<TSource> right) => left.Concat(right); } } ```\n\nUsage examples:\n\n```csharp int[] data = ...; // access instance extension property: if (data.IsEmpty) { /* ... */ }\n\n// Access static extension operator + var combined = data + [ 4, 5 ];\n\n// Access static extension property: var empty = IEnumerable<int>.Identity; ```\n\nBecause extension blocks are source and binary compatible with existing extension methods, you can migrate one method at a time. Dependent assemblies don’t need to be recompiled and continue to bind to the original symbol.\n\nYou can learn more and explore extension members in the [C# Guide](https://learn.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/extension-methods) and the [`extension` keyword article](https://learn.microsoft.com/dotnet/csharp/language-reference/keywords/extension). You can also read all the details on the feature design in the [Extensions proposal](https://learn.microsoft.com/dotnet/csharp/language-reference/proposals/csharp-14.0/extensions).\n\n## More productivity for you\n\nThis set of language features share a common goal: reduce the syntactic friction for everyday tasks so you can focus on domain logic instead of ceremony. They eliminate boilerplate, remove common conditional blocks, simplify lambda declarations, enhance partial types for source generators, and make `nameof` more expressive in generic scenarios. Individually each saves a few lines and more typing. Together they translate into cleaner code, fewer trivial identifiers, and code that communicates intent more cleanly.\n\n- The `field`\nkeyword\n- Unbound generic types and `nameof`\n- Simple lambda parameters with modifiers\n- Null-conditional assignment\n- Partial events and constructors\n\n### The `field`\nkeyword\n\nMost properties start life as simple auto‑implemented properties. Later you discover you need small bits of logic — null coalescing, clamping, simple normalization, or raising a guard — on just one accessor. Before C# 14 that requirement forced you to convert to a fully hand‑written backing field pattern:\n\n```csharp // Before private string _message = \"\"; public string Message { get => _message; init => _message = value ?? throw new ArgumentNullException(nameof(value)); } ```\n\nThe contextual `field` keyword creates a middle step on that evolution path: keep the auto‑property terseness, inject minimal logic only where needed, and let the compiler synthesize and name the backing storage. You add just the accessor body that needs logic and refer to the compiler‑generated storage via `field` :\n\n```csharp // After (C# 14) public string Message { get; // auto get init => field = value ?? throw new ArgumentNullException(nameof(value)); } ```\n\nIt’s a bridge between auto‑implemented and fully hand‑written properties: start with `public string Message { get; init; }` , then when you need a quick guard, convert only the accessor that requires code and use `field` instead of introducing a private member and duplicating a trivial getter. This pattern scales when many properties each require a one‑line check—your class stays visually lightweight and diffs stay small. Another advantage of `field` is that it avoids creating a new named private field. All code in the type must use the property to access or modify the value of the property.\n\nThis feature was available as a preview in .NET 9. The [`field` contextual keyword](https://learn.microsoft.com/dotnet/csharp/language-reference/keywords/field) is now generally available in C# 14 (see [what’s new](https://learn.microsoft.com/dotnet/csharp/whats-new/csharp-14#the-field-keyword)).\n\n### Unbound generic types and `nameof`\n\nPreviously, to log or throw using just the generic type name you either hardcoded a string or used a closed constructed type:\n\n```csharp // Before var listTypeName = nameof(List<int>); // \"List\" // or: const string Expected = \"List\"; ```\n\nNow `nameof` accepts an unbound generic type. This feature removes the need to pick an arbitrary type argument just to retrieve the generic type’s name:\n\n```csharp // After (C# 14) var listTypeName = nameof(List<>); // \"List\" ```\n\nThis produces the generic type name once, without implying any specific instantiation. Learn more in the [`nameof` operator reference](https://learn.microsoft.com/dotnet/csharp/language-reference/operators/nameof).\n\n### Simple lambda parameters with modifiers\n\nIn earlier versions, parameter modifiers such as `out` in delegates required full type annotations on all parameters:\n\n```csharp // Before delegate bool TryParse<T>(string text, out T value); TryParse<int> parse = (string text, out int result) => int.TryParse(text, out result); ```\n\nNow you can keep the concise implicitly typed form while still using modifiers like `out` , `ref` , `in` , `scoped` on one or more parameters:\n\n```csharp // After (C# 14) TryParse<int> parse = (text, out result) => int.TryParse(text, out result); ```\n\nThe parameter types are still inferred, preserving the concise syntax of the lambda expression. Learn more in the C# language reference section on [lambda expression parameter modifiers](https://learn.microsoft.com/dotnet/csharp/language-reference/operators/lambda-expressions#input-parameters-of-a-lambda-expression). It keeps lambdas terse while still exposing flow semantics (`out` , `ref` , `in` , `scoped` ).\n\n### Null-conditional assignment\n\nGuarded assignments previously required an explicit null check:\n\n```csharp // Before if (customer is not null) { customer.Order = CreateOrder(); customer.Total += CalculateIncrement(); } ```\n\nNow you can assign (and use compound assignment) directly with null-conditional operators on the left side of the assignment. The right side is evaluated only when the receiver of the assignment isn’t null:\n\n```csharp // After (C# 14) customer?.Order = CreateOrder(); customer?.Total += CalculateIncrement(); ```\n\nThat trims indentation and visually centers the important work. The feature integrates directly with the existing [null-conditional operators](https://learn.microsoft.com/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-) so they can appear on the left side of an assignment. It evaluates the right-hand expression only when the receiver isn’t null, avoiding helper locals or duplicated checks. See [null-conditional assignment](https://learn.microsoft.com/dotnet/csharp/whats-new/csharp-14#null-conditional-assignment) and the [feature specification](https://learn.microsoft.com/dotnet/csharp/language-reference/proposals/csharp-14.0/null-conditional-assignment).\n\n### Partial events and constructors\n\nLarge generated or source‑generated partial types can now spread event and constructor logic across files, enabling generators or different files to contribute cleanly:\n\n```csharp public partial class Widget(int size, string name) // defining declaration of primary ctor { public partial event EventHandler Changed; // declaring event declaration (field-like) }\n\npublic partial class Widget { public partial event EventHandler Changed // Defining declaration for event. { add => _changed += value; remove => _changed -= value; }\n\nprivate EventHandler? _changed;\n\n// Implementing declaration can add constructor body logic public Widget { Initialize(); } } ```\n\nThis separation enables new source generation scenarios (e.g., a generator supplies the defining members, user code supplies behavior, or vice-versa). It simplifies the manually authored logic. It remains more focused on the algorithms you write by hand.\n\nSee the programming guide for [partial constructors](https://learn.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/constructors#partial-constructors) and the [`partial` member reference](https://learn.microsoft.com/dotnet/csharp/language-reference/keywords/partial-member) for syntax details.\n\n## More performance for your users\n\nMany of the raw throughput wins you’ll see after upgrading to .NET 10 come from the runtime and BCL adopting new C# 14 capabilities. Core libraries already use these features so your apps often get faster even if you never write this syntax yourself. The [.NET 10 performance improvements post](https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-10/) highlights span-heavy parsing, UTF-8 processing, and numeric routines that benefit. Two language additions in particular unlock cleaner, faster library implementations: [implicit span conversions](https://learn.microsoft.com/dotnet/csharp/whats-new/csharp-14#implicit-span-conversions) and [user-defined compound assignment](https://learn.microsoft.com/dotnet/csharp/whats-new/csharp-14#user-defined-compound-assignment).\n\n### Implicit span conversions\n\n`Span<T>` / `ReadOnlySpan<T>` are central to allocation-free APIs. C# 14 adds implicit conversions among arrays, spans, and read-only spans so you write less ceremony and the JIT sees simpler call graphs. That translates into fewer temporary variables, fewer bounds checks, and more aggressive inlining in the framework (as described in the performance blog’s sections covering text and parsing micro-benchmarks).\n\nEarlier C# versions required code like the following:\n\n```csharp // Before string line = ReadLine(); ReadOnlySpan<char> key = line.AsSpan(0, 5); // explicit AsSpan ProcessKey(key);\n\nint[] buffer = GetBuffer(); Span<int> head = new(buffer, 0, 8); // explicit Span ctor Accumulate(head); ```\n\nNow, you can write the following:\n\n```csharp // After (C# 14) string line = ReadLine(); ProcessKey(line[..5]); // substring slice implicitly converts\n\nint[] buffer = GetBuffer(); Accumulate(buffer[..8]); ```\n\nLibrary authors exploit these conversions to remove helper locals and express slice intent inline. The benefits include fewer explicit `AsSpan` or constructor calls, clearer slicing intent that encourages span-friendly overloads, and framework optimizations that reduce allocations through broader zero-allocation paths. Learn more by reading the [first-class span types spec](https://learn.microsoft.com/dotnet/csharp/language-reference/proposals/csharp-14.0/first-class-span-types).\n\n### User defined compound assignment\n\nHigh-performance numeric and vector types often accumulate values in tight loops. Without a dedicated compound assignment operator, code either repeated the left hand reference or created intermediate temporaries through an ordinary binary operator—both patterns can inhibit certain JIT optimizations. C# 14 lets you declare a compound assignment operator (`+=` , `-=` , etc.) explicitly so the compiler dispatches directly to your implementation. Libraries taking advantage of this (for example, SIMD-friendly helpers referenced in the performance blog) to avoid extra temporaries and can expose more idiomatic APIs.\n\nInstead of this:\n\n```csharp // Before BigVector sum = BigVector.Zero; foreach (var v in values) { sum = sum.Add(v); // intermediate result each iteration } ```\n\nAfter you provide a compound operator that can update the result in-place:\n\n```csharp // After (C# 14) BigVector sum = BigVector.Zero; foreach (var v in values) { sum += v; // calls user-defined operator += directly } ```\n\nDefining both the binary and compound operators:\n\n```csharp public struct BigVector(float x, float y, float z) { public float X { get; private set => value = field; } = x; public float Y { get; private set => value = field; } = y; public float Z { get; private set => value = field; } = z;\n\npublic static BigVector operator +(BigVector l, BigVector r) => new(l.X + r.X, l.Y + r.Y, l.Z + r.Z);\n\npublic void operator +=(BigVector r) { X += r.X; Y += r.Y; Z += r.Z; } } ```\n\nDetails appear in the [operator overloading article](https://learn.microsoft.com/dotnet/csharp/language-reference/operators/operator-overloading) in the C# guide and the [compound assignment spec](https://learn.microsoft.com/dotnet/csharp/language-reference/proposals/csharp-14.0/user-defined-compound-assignment). You should also consult the [compiler breaking changes article](https://learn.microsoft.com/dotnet/csharp/whats-new/breaking-changes/compiler%20breaking%20changes%20-%20dotnet%2010) for potential issues. You might encounter issues regarding [`Enumerable.Reverse`](https://learn.microsoft.com/dotnet/csharp/whats-new/breaking-changes/compiler%20breaking%20changes%20-%20dotnet%2010#enumerablereverse).\n\n## Summary\n\nThat’s a quick tour of what we’ve [delivered in C# 14](https://learn.microsoft.com/dotnet/csharp/whats-new/csharp-14): new extensions, a number of features that make you more productive, and enhancements that make your C# programs perform better. Download .NET 10 and try it on your apps. Participate in ongoing discussions to continue to make C# a great language choice for you.",
  "Title": "Introducing C# 14",
  "Description": "Learn what features are in C# 14, which ships as part of .NET 10.\n\nThe post [Introducing C# 14](https://devblogs.microsoft.com/dotnet/introducing-csharp-14/) appeared first on [.NET Blog](https://devblogs.microsoft.com/dotnet).",
  "OutputDir": "_news",
  "ProcessedDate": "2025-11-17 19:02:39",
  "FeedUrl": "https://devblogs.microsoft.com/dotnet/feed/",
  "Link": "https://devblogs.microsoft.com/dotnet/introducing-csharp-14/",
  "Author": "Bill Wagner",
  "PubDate": "2025-11-17T18:05:00+00:00"
}
