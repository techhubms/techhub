{
  "FeedLevelAuthor": ".NET Blog",
  "ProcessedDate": "2025-08-27 17:10:04",
  "PubDate": "2025-08-27T17:05:00+00:00",
  "OutputDir": "_news",
  "Description": "A Visual Studio extension that helps developers visualize and analyze Entity Framework Core query execution plans directly within their development environment.\n\nThe post [EFCore.Visualizer – View Entity Framework Core query plan inside Visual Studio](https://devblogs.microsoft.com/dotnet/ef-core-visualizer-view-entity-framework-core-query-plan-inside-visual-studio/) appeared first on [.NET Blog](https://devblogs.microsoft.com/dotnet).",
  "Tags": [
    ".NET",
    ".NET Data",
    "EF Core",
    "Entity Framework",
    "Visual Studio",
    "Visual Studio Extension"
  ],
  "FeedUrl": "https://devblogs.microsoft.com/dotnet/feed/",
  "Author": "Giorgi Dalakishvili",
  "FeedName": "Microsoft .NET Blog",
  "EnhancedContent": "> >\n> This is a guest blog from [Giorgi Dalakishvili](https://github.com/Giorgi), the developer of [EFCore.Visualizer](https://marketplace.visualstudio.com/items?itemName=GiorgiDalakishvili.EFCoreVisualizer).\n> >\n\nEntity Framework Core is a powerful, feature-rich ORM powering many of today’s applications. With EF Core, developers write strongly-typed LINQ queries that the framework translates into SQL queries for the target database. With advanced features such as including nested collections and lazy loading, Entity Framework Core frees developers from writing boilerplate data access code.\n\n## The Problem\n\nWhile LINQ queries are typically translated to well-performing SQL queries, as schemas become larger and queries more complex, the generated SQL can become suboptimal. Missing database indexes can also cause queries to execute slowly, leading to degraded application performance.\n\nEF Core provides an easy way to [log generated queries](https://learn.microsoft.com/ef/core/logging-events-diagnostics/#simple-logging) and [identify slow queries](https://learn.microsoft.com/ef/core/performance/performance-diagnosis?tabs=simple-logging%2Cload-entities#identifying-slow-database-commands-via-logging). This might be enough sometimes but to really get to the root of the problem and see how the database engine executes queries, it’s necessary to explore the [query execution plan](https://learn.microsoft.com/sql/relational-databases/performance/execution-plans?view=sql-server-ver17).\n\n## The Solution\n\n[EFCore.Visualizer](https://marketplace.visualstudio.com/items?itemName=GiorgiDalakishvili.EFCoreVisualizer) is a Visual Studio extension for viewing and analyzing query plans directly inside Visual Studio. The extension adds a debugger visualizer for `IQueryable<>` variables that shows both the generated query and its execution plan.\n\nWhen you hit a breakpoint and hover over any `IQueryable` variable, EFCore.Visualizer captures the query, requests the execution plan from your database, and shows a visual representation of the query plan. The visualizer works with any EF Core query, whether it’s a simple `Where` clause or a complex query with joins, includes, and aggregations. The extension supports every major RDBMS: SQL Server, PostgreSQL, MySQL, SQLite, and Oracle, automatically detecting your database provider.\n\nBy bringing the query plan directly inside Visual Studio, it removes the need to switch between Visual Studio and the database management tool for viewing query plans and shortens the developer inner loop. Instead of copying the query from Visual Studio to database management tool, analyzing the execution plan, switching back, tweaking the query and repeating the above steps again, developers can view the query plan in Visual Studio right where they write and debug their code.\n\n## Installation\n\nGetting started with EFCore.Visualizer is straightforward. You can install the extension directly from within Visual Studio by searching for “EFCore.Visualizer” in the Extension Manager. Alternatively, you can download it from the [Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=GiorgiDalakishvili.EFCoreVisualizer).\n\n## Usage\n\nTo demonstrate the extension usage, I will use the following model:\n\n```cs public class BloggingContext : DbContext { public DbSet<Blog> Blogs { get; set; } public DbSet<Post> Posts { get; set; }\n\nprotected override void OnModelCreating(ModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); modelBuilder.Entity<Post>().HasIndex(p => p.PublishedAt); } }\n\npublic class Blog { public int BlogId { get; set; } public string Url { get; set; }\n\npublic List<Post> Posts { get; } = new(); }\n\npublic class Post { public int PostId { get; set; } public string Title { get; set; } public string Content { get; set; }\n\npublic DateTimeOffset PublishedAt { get; set; }\n\npublic int BlogId { get; set; } public Blog Blog { get; set; } } ```\n\nThe sample database has a couple of thousand rows in the `Posts` table.\n\nOnce installed, start debugging and hover over any `IQueryable` instance. In the standard debugger tooltip click **Query Plan Visualizer** and view the generated SQL and the execution plan.\n\nLet’s start by writing a query to get all posts written in 2010 and examining its execution plan:\n\n```cs var postsQuery = bloggingContext.Posts.Where(post => post.PublishedAt.Year == 2010); ```\n\n![Screenshot showing the Query Plan Visualizer option in Visual Studio debugger tooltip](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/08/debugger-visualizer.png \"Debugger Tooltip\") ![SQL Server execution plan showing table scan without index usage](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/08/sql-server-plan.png \"SQL Server Plan\")\n\nYou can see that even though there is an index on the `PublishedAt` column, SQL Server doesn’t use it. If you look at the generated query, you will notice that the query is extracting the year from `PublishedAt` column making the query [non-sargable](https://en.wikipedia.org/wiki/Sargable).\n\nLet’s rewrite the query without changing the semantics and see what execution plan looks like:\n\n```cs var fromDate = new DateTime(2010, 1, 1); var toDate = new DateTime(2011, 1, 1);\n\npostsQuery = bloggingContext.Posts.Where(post => post.PublishedAt >= fromDate && post.PublishedAt < toDate); ```\n\n![SQL Server execution plan showing index seek used by sargable date filter](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/08/sql-server-plan-fixed.png \"SQL Server Plan with Sargable Query\")\n\nAs you can see, with a simple change to the query, the database is now utilizing the index on the `PublishedAt` .\n\n## How it works\n\nThe visualizer works by turning the LINQ queries into ADO.NET commands and fetching its plan from the database engine. The plan is then rendered using the [html-query-plan](https://github.com/JustinPealing/html-query-plan) library for SQL Server, [pev2](https://github.com/dalibo/pev2/) for Postgres or [treeflex](https://github.com/dumptyd/treeflex) for other databases.\n\n## Limitations\n\nThe visualizer doesn’t support queries when a reducing terminating operator is used (`Count()` , `Min()` , `First()` etc). Also, if the query is very complex or the network connection to the database engine is slow, fetching the query plan can exceed the 5 second limit for custom visualizers. Unfortunately, there is no way to extend the timeout but you can vote for the [issue](https://github.com/microsoft/VSExtensibility/issues/325).\n\n## Conclusion\n\nAs developers, we’ve all been there – staring at a slow query wondering what the database is actually doing. If you’re working with Entity Framework Core and want to better understand your query performance, give [EFCore.Visualizer](https://marketplace.visualstudio.com/items?itemName=GiorgiDalakishvili.EFCoreVisualizer) a try. The source code is available on [GitHub](https://github.com/Giorgi/EFCore.Visualizer) if you’d like to contribute or explore how it works.",
  "Link": "https://devblogs.microsoft.com/dotnet/ef-core-visualizer-view-entity-framework-core-query-plan-inside-visual-studio/",
  "Title": "EFCore.Visualizer – View Entity Framework Core query plan inside Visual Studio"
}
