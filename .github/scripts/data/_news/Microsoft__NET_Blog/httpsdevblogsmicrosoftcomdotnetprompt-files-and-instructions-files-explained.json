{
  "Author": "Wendy Breiding (SHE/HER)",
  "FeedLevelAuthor": ".NET Blog",
  "OutputDir": "_news",
  "Description": "Unlocking the Power of GitHub Copilot for .NET Developers with Instruction Files and Prompt Files\n\nThe post [Prompt Files and Instructions Files Explained](https://devblogs.microsoft.com/dotnet/prompt-files-and-instructions-files-explained/) appeared first on [.NET Blog](https://devblogs.microsoft.com/dotnet).",
  "EnhancedContent": "GitHub Copilot is transforming the way developers write code by acting as an intelligent coding agent directly in your editor. Whether you’re building ASP.NET web applications, working with C#, or reviewing code with your team, Copilot can help automate repetitive tasks, suggest entire functions, and streamline code reviews. In this guide, we’ll explore productivity tips, practical examples, and best practices for setting up instruction files and prompt files in Visual Studio, VS Code, and GitHub.com—making it easy for .NET developers to harness its full potential.\n\n## Instruction Files\n\nDo you wish Copilot knew more about your solution and your coding preferences? Instruction Files are here to help.\n\n### What are Instruction Files?\n\n- Instruction files (often named `copilot-instructions.md`\n) define the rules, coding standards, or guidelines Copilot should follow when generating code in your repository or workspace.\n- You can create a generic custom instructions file that is used for every request (copilot-instructions.md) and you can create instructions specific to certain scenarios (title.instructions.md) that are applied only to applicable requests.\n- Learn more about custom instructions.\n\n### When to Use Instruction Files\n\n- Use instruction files in team projects to ensure Copilot suggests code that aligns with your organization’s standards and naming conventions.\n- Great for open-source repositories where contributors might benefit from automated adherence to project-specific rules.\n\n### How to Use Instruction Files\n\n- Write your instructions file starting with a sample, from scratch, or using Copilot.\n- Place your copilot-instructions.md file in the `.github`\nfolder in your workspace. Place your file type specific instructions that only apply to `.cs` files or `.razor` files in your `.github/instructions` folder.\n- Copilot will automatically include the appropriate instructions files with each request sent via the chat.\n\n### What to include in Instruction Files\n\n- Purpose & scope: One sentence saying what this instruction file controls (e.g., “Guides automated assistants on safe repo edits and conventions for the Blazor UI”).\n- Location & scope rules: Where the file applies (paths, languages, file globs) and any cases it does NOT apply to.\n- Project overview: Short intent of the project (audience, main features, runtime/platform).\n- Tooling & versions: Exact commands and versions (e.g., .NET 8.0, dotnet command examples, Node, Python, SDKs).\n- Build / run / test commands: Minimal, copyable commands for dev and CI (PowerShell-friendly examples on Windows).\n- Coding conventions & linting: Formatter (e.g., dotnet format, prettier), style rules, naming patterns, Single Source of Truth for style.\n- API & data contracts: JSON shapes, DTO examples, DB schemas or important fields (avoid secrets).\n- Tests & E2E expectations: Which tests must pass before changes are accepted.\n- CI/CD & release rules: Branching model, required checks, versioning policy, deployment constraints.\n- Security & secrets policy: What must never be checked in, env var naming, secret storage guidance.\n- Allowed edits & risk tolerance: What the assistant can change autonomously (typo fixes, formatting, tests) vs what requires reviewer/PR (schema changes, DB migrations, infra).\n- Output format & diffs: How to present code changes (patch format, single-file edits vs multi-file), commit message style, PR description template.\n- Behavior & tone: Preferred assistant persona (concise, conservative, test-first), verbosity and what to ask the human about.\n- Failures & rollback: How to handle failing builds or tests, revert instructions, and who to notify.\n- Examples & snippets: Good examples of small accepted PRs and disallowed changes.\n- Maintenance notes: Where to update this doc and how often.\n\nFor more samples of instruction files, check out the many community-submitted examples at [awesome-copilot/instructions](https://github.com/github/awesome-copilot/tree/main/instructions).\n\n## Prompt Files\n\nDo you use Copilot to perform similar tasks on your repo? Do you wish Copilot knew better what it was allowed to change and what not? Prompt Files are here to help.\n\n### What are Prompt Files\n\n- Prompt files provide context for Copilot in a specific coding session or for a particular file. They can be added as context or dedicated prompt files to steer the AI’s output for a given task.\n\n### When to Use Prompt Files\n\n- Use prompt files when you need Copilot to generate code following specific requirements, such as for custom algorithms, integrations, or compliance needs.\n- Ideal for prototyping, documentation, or when onboarding new team members who need explicit guidance.\n\n### How to Use Prompt Files\n\n- Write the prompt starting with a sample, from scratch, or with the help of Copilot.\n- Place it in the `.github/prompts`\nfolder in your workspace with the filename format `[promptname].prompt.md` , for example CreateAnalyzer.prompt.md.\n- In VS Code, type `/[promptName]`\nin the chat to use it, and in VS, type `#[promptName]` in the chat to use it. For example, to create an analyzer that checks for weak hashing techniques using my CreateAnalyzer prompt, I would type “/CreateAnalyzer detect usage of MD5.Create(), SHA1.Create(), RijndaelManaged with insecure modes, new HMACSHA1(), or TripleDES and suggest using SHA256 or RandomNumberGenerator and point to library wrappers”.\n\n### What to include in Prompt Files\n\n- Header / Metadata\n- Name, version, last-updated, author/maintainer contact.\n- Scope globs (what paths / languages / components the prompt controls).\n- Purpose / One-line summary\n- Short statement of intent (what this prompt enables the assistant to do).\n- Persona & tone\n- How the assistant should speak (concise, conservative, ask clarifying Qs).\n- Allowed autonomous actions\n- Precise list (typo fixes, docs updates, single-file refactors with tests, formatting).\n- Include limits (e.g., max files changed, no infra changes).\n- Disallowed actions / require human review\n- DB schema/migrations, secrets, production config, large refactors, major dependency upgrades.\n- Build / Run / Test commands\n- Exact commands and environment notes (PowerShell examples for Windows workspaces).\n- Minimum smoke-check commands the assistant should run locally before proposing a change.\n- Lint/format commands\n- Tools and invocation (e.g., dotnet format, prettier –check).\n- CI rules & PR acceptance criteria\n- Must-pass checks, required labels, tests to run, PR title/body template.\n- File & path exceptions\n- List binary, generated, or vendor files that must not be changed.\n- Output format & patch conventions\n- Patch/PR format, commit message style, testing evidence to include.\n- Error handling & rollback\n- What to do if tests fail, how to revert, who to notify.\n- Examples\n- 2–3 short “good” and “bad” examples of edits the assistant might make.\n- Minimal machine-ready snippet (optional)\n- YAML or front-matter with apply-to globs, sdk versions so automation can parse it.\n- Maintenance notes\n- Who updates this file, and when to bump the version.\n\nFor samples of prompt files, check out the many community-submitted examples at [awesome-copilot/prompts](https://github.com/github/awesome-copilot/tree/main/prompts).\n\n## Choosing Between Instruction and Prompt Files\n\n- Instruction Files: Best for repository-wide guidance and long-term standards across multiple contributors and projects.\n- Prompt Files: Best for local, session-based guidance or for specific functionality in a single file or segment.\n- Combine Both: For maximum results, use instruction files for your overall project and supplement with prompt files in areas that need extra clarity or specificity.\n\n### Best Practices: Effective Prompt Writing and Collaboration\n\n- Be specific with prompts and instructions—clarity yields better suggestions.\n- Review all AI-generated code for accuracy, security, and compliance.\n- Use instruction files for consistency and prompt files for targeted guidance.\n- Check out the documentation at [Customize chat to your workflow](https://code.visualstudio.com/docs/copilot/customization/overview).\n- Share Copilot’s outputs in code reviews for collaborative improvement.\n\n## Conclusion: Experiment, Guide, and Collaborate with Copilot\n\nGitHub Copilot can supercharge your .NET projects when guided with clear instructions and prompts. By exploring Copilot’s many ways of helping you achieve more, you’ll maximize both productivity and code quality. Explore, refine, and share your Copilot experiences with the developer community!",
  "ProcessedDate": "2025-09-17 17:09:33",
  "Link": "https://devblogs.microsoft.com/dotnet/prompt-files-and-instructions-files-explained/",
  "FeedUrl": "https://devblogs.microsoft.com/dotnet/feed/",
  "Tags": [
    ".NET",
    "AI",
    "C#",
    "copilot",
    "GitHub Copilot",
    "productivity"
  ],
  "Title": "Prompt Files and Instructions Files Explained",
  "PubDate": "2025-09-17T17:05:00+00:00",
  "FeedName": "Microsoft .NET Blog"
}
