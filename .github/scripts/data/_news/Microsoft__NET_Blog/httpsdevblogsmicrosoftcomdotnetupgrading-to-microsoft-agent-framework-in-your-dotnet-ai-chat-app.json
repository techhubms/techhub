{
  "EnhancedContent": "The AI App Templates let you spin up a working chat application in minutes, complete with AI integration, custom data ingestion, and all the pieces you need to get started. It’s a cool and solid foundation.\n\nBut here’s the thing: what if you want to go beyond basic chat? What if you want to build AI agents that can actually *reason*, make decisions, use tools, and orchestrate complex workflows? That’s where **Microsoft Agent Framework** comes into play.\n\nIn this post, I’m going to show you how I took a standard AI chat app—generated using the .NET AI templates—and enhanced it with Microsoft Agent Framework. Let’s start!\n\n## What is Microsoft Agent Framework?\n\n[Microsoft Agent Framework](https://aka.ms/agent-framework) is Microsoft’s preview framework for building AI agents in .NET. Think of it as the next evolution beyond simple chatbots. An AI agent can:\n\n- **Reason and plan** through multi-step workflows\n- **Use tools and functions** to interact with your APIs, databases, and services\n- **Maintain context** across entire conversations\n- **Make autonomous decisions** based on instructions and data\n- **Coordinate with other agents** in multi-agent scenarios\n\nWhat I really like about it is that it’s built on patterns we already know and love as .NET developers: dependency injection, middleware, telemetry—all integrated with Microsoft.Extensions.AI. Check out [Luis’ great post about AgentFx](https://devblogs.microsoft.com/dotnet/introducing-microsoft-agent-framework-preview/) for all the details.\n\n## Prerequisites\n\nBefore we start, you’ll need:\n\n- [.NET 9 SDK](https://dotnet.microsoft.com/download/dotnet/9.0) installed\n- [Visual Studio](https://visualstudio.microsoft.com/) or [Visual Studio Code](https://code.visualstudio.com/) with C# Dev Kit\n- An [Azure account](https://azure.microsoft.com/free/) with access to Azure OpenAI, or use it with [GitHub Models](https://github.com/marketplace?type=models)\n- The .NET AI App Templates installed (we’ll do this in the next section)\n- Basic familiarity with .NET, Blazor, and AI concepts\n\n## Step 1: Creating the Base AI Chat Application\n\nLet’s start by creating a baseline chat app using the official .NET AI templates. First, we need to install the templates:\n\n```bash dotnet new install Microsoft.Extensions.AI.Templates ```\n\n### Creating the Project\n\nNow let’s create the app. You can do this through Visual Studio or the CLI:\n\n**Using Visual Studio:**\n\n1. Open Visual Studio 2022\n2. Select **Create a new project**\n3. Search for “AI Chat Web App”\n4. Configure your project name (e.g., `ChatApp20`\n) and location\n5. Select **Azure OpenAI** as your AI provider\n6. Choose **Local on-disk** for the vector store\n7. Choose .NET Aspire for the orchestration\n\n![Visual Studio project dialog with AI Chat Web App template](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/10/01-image-vs-template.png)\n\n**Using Visual Studio Code or the .NET CLI:**\n\nIf you prefer VS Code or the command line, check out the [official documentation](https://learn.microsoft.com/dotnet/ai/quickstarts/ai-templates?tabs=visual-studio-code%2Cconfigure-visual-studio-code%2Cconfigure-visual-studio-code-aspire&amp;pivots=azure-openai#create-the-net-ai-app) for step-by-step instructions. The process is similar—you’ll use `dotnet new` commands to scaffold the project with the same configuration options.\n\n### Understanding the Project Structure\n\nThe template generates a solution with three projects:\n\n```bash ChatApp20/ ├── ChatApp20.Web/ # Blazor Server app with chat UI ├── ChatApp20.AppHost/ # .NET Aspire orchestration └── ChatApp20.ServiceDefaults/ # Shared service configurations ```\n\n![Solution Explorer with project structure](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/10/02-image-solution-structure.png)\n\nWe’ll be working mainly in `ChatApp20.Web` , which includes:\n\n- **Components/Pages/Chat/** – The Blazor chat interface\n- **Services/** – Data ingestion and semantic search services\n- **Program.cs** – Where all the AI magic gets wired up\n- **wwwroot/Data/** – Sample PDF files (survival kit and GPS watch examples)\n\n### Initial Program.cs Configuration\n\nLet’s look at what the template sets up for us in `Program.cs` . This is where all the AI pieces come together:\n\n```csharp using Microsoft.Extensions.AI; using ChatApp20.Web.Components; using ChatApp20.Web.Services; using ChatApp20.Web.Services.Ingestion;\n\nvar builder = WebApplication.CreateBuilder(args); builder.AddServiceDefaults(); builder.Services.AddRazorComponents().AddInteractiveServerComponents();\n\n// Configure Azure OpenAI with chat client and embeddings var openai = builder.AddAzureOpenAIClient(\"openai\"); openai.AddChatClient(\"gpt-4o-mini\") .UseFunctionInvocation() .UseOpenTelemetry(configure: c => c.EnableSensitiveData = builder.Environment.IsDevelopment()); openai.AddEmbeddingGenerator(\"text-embedding-3-small\");\n\n// Configure vector storage for semantic search var vectorStorePath = Path.Combine(AppContext.BaseDirectory, \"vector-store.db\"); var vectorStoreConnectionString = $\"Data Source={vectorStorePath}\"; builder.Services.AddSqliteCollection<string, IngestedChunk>(\"data-chatapp20-chunks\", vectorStoreConnectionString); builder.Services.AddSqliteCollection<string, IngestedDocument>(\"data-chatapp20-documents\", vectorStoreConnectionString); builder.Services.AddScoped<DataIngestor>(); builder.Services.AddSingleton<SemanticSearch>();\n\nvar app = builder.Build();\n\n// ... middleware configuration ...\n\n// Ingest PDF files on startup await DataIngestor.IngestDataAsync( app.Services, new PDFDirectorySource(Path.Combine(builder.Environment.WebRootPath, \"Data\")));\n\napp.Run(); ```\n\n### The Basic Chat Component\n\nThe initial `Chat.razor` component uses `IChatClient` directly:\n\n```csharp @inject IChatClient ChatClient @inject SemanticSearch Search\n\n@code { private async Task AddUserMessageAsync(ChatMessage userMessage) { messages.Add(userMessage);\n\nvar responseText = new TextContent(\"\"); currentResponseMessage = new ChatMessage(ChatRole.Assistant, [responseText]);\n\nawait foreach (var update in ChatClient.GetStreamingResponseAsync( messages.Skip(statefulMessageCount), chatOptions, currentResponseCancellation.Token)) { messages.AddMessages(update, filter: c => c is not TextContent); responseText.Text += update.Text; ChatMessageItem.NotifyChanged(currentResponseMessage); }\n\nmessages.Add(currentResponseMessage); }\n\n[Description(\"Searches for information using a phrase or keyword\")] private async Task<IEnumerable<string>> SearchAsync( [Description(\"The phrase to search for.\")] string searchPhrase, [Description(\"If possible, specify the filename to search.\")] string? filenameFilter = null) { var results = await Search.SearchAsync(searchPhrase, filenameFilter, maxResults: 5); return results.Select(result => $\"<result filename=\\\"{result.DocumentId}\\\" page_number=\\\"{result.PageNumber}\\\">{result.Text}</result>\"); } } ```\n\nThis works great for getting started! But as your app grows, you’ll want more flexibility:\n\n- **Better separation of concerns** – Moving tool functions out of UI components\n- **Easier testing** – Testing agent behavior independently from the UI\n- **More sophisticated patterns** – Support for complex reasoning and multi-step workflows\n- **Agent orchestration** – Coordinating multiple specialized agents\n- **Richer telemetry** – Better observability into how your AI makes decisions\n\nThat’s exactly what Microsoft Agent Framework brings to the table. Let’s see how!\n\n## Step 2: Adding Microsoft Agent Framework\n\nNow for the fun part—let’s upgrade this chat app into a proper agent system!\n\n### Installing the Required Packages\n\nFirst, we need to add the Microsoft Agent Framework packages to `ChatApp20.Web.csproj` :\n\n![NuGet packages added to project](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/10/03-image-nuget-packages.png)\n\n```xml <ItemGroup> <!-- Keep existing packages --> <PackageReference Include=\"Aspire.Azure.AI.OpenAI\" Version=\"9.5.1-preview.1.25502.11\" /> <PackageReference Include=\"Microsoft.Extensions.AI.OpenAI\" Version=\"9.10.0-preview.1.25513.3\" /> <PackageReference Include=\"Microsoft.Extensions.AI\" Version=\"9.10.0\" /> <PackageReference Include=\"Microsoft.SemanticKernel.Core\" Version=\"1.66.0\" />\n\n<!-- Add Microsoft Agent Framework packages --> <PackageReference Include=\"Microsoft.Agents.AI\" Version=\"1.0.0-preview.251009.1\" /> <PackageReference Include=\"Microsoft.Agents.AI.Abstractions\" Version=\"1.0.0-preview.251009.1\" /> <PackageReference Include=\"Microsoft.Agents.AI.Hosting\" Version=\"1.0.0-preview.251009.1\" /> <PackageReference Include=\"Microsoft.Agents.AI.Hosting.OpenAI\" Version=\"1.0.0-alpha.251009.1\" /> <PackageReference Include=\"Microsoft.Agents.AI.OpenAI\" Version=\"1.0.0-preview.251009.1\" />\n\n<!-- Keep other existing packages --> <PackageReference Include=\"PdfPig\" Version=\"0.1.12-alpha-20251015-255e7\" /> <PackageReference Include=\"System.Linq.Async\" Version=\"7.0.0-preview.1.g24680b5469\" /> <PackageReference Include=\"Microsoft.SemanticKernel.Connectors.SqliteVec\" Version=\"1.66.0-preview\" /> </ItemGroup> ```\n\nThe key Agent Framework packages are:\n\n- **Microsoft.Agents.AI** – Core agent abstractions and implementations\n- **Microsoft.Agents.AI.Abstractions** – Base interfaces and types\n- **Microsoft.Agents.AI.Hosting** – Dependency injection and hosting extensions\n- **Microsoft.Agents.AI.Hosting.OpenAI** – OpenAI-specific hosting support\n- **Microsoft.Agents.AI.OpenAI** – OpenAI integration for agents\n\n### Creating a Dedicated Search Functions Service\n\nTo promote better separation of concerns and testability, create a new `SearchFunctions.cs` service that wraps the semantic search functionality:\n\n```csharp using System.ComponentModel;\n\nnamespace ChatApp20.Web.Services;\n\n/// <summary> /// Functions exposed to the AI Agent. Wraps SemanticSearch so we can inject dependencies via DI. /// </summary> public class SearchFunctions { private readonly SemanticSearch _semanticSearch;\n\npublic SearchFunctions(SemanticSearch semanticSearch) { _semanticSearch = semanticSearch; }\n\n[Description(\"Searches for information using a phrase or keyword\")] public async Task<IEnumerable<string>> SearchAsync( [Description(\"The phrase to search for.\")] string searchPhrase, [Description(\"If possible, specify the filename to search that file only. If not provided or empty, the search includes all files.\")] string? filenameFilter = null) { // Perform semantic search over ingested chunks var results = await _semanticSearch.SearchAsync(searchPhrase, filenameFilter, maxResults: 5);\n\n// Format results as XML for the agent return results.Select(result => $\"<result filename=\\\"{result.DocumentId}\\\" page_number=\\\"{result.PageNumber}\\\">{result.Text}</result>\"); } } ```\n\n**Why this is important:**\n\n- The `SearchFunctions`\nclass is now a dedicated service that can be injected into the agent\n- It’s testable in isolation from the UI\n- The `[Description]`\nattributes provide metadata that helps the AI understand when and how to use the tool\n- The agent can invoke this function automatically when it needs to search for information\n\n### Registering the AI Agent in Program.cs\n\nNow, let’s configure the AI agent in `Program.cs` using the Agent Framework’s hosting extensions:\n\n```csharp using ChatApp20.Web.Components; using ChatApp20.Web.Services; using ChatApp20.Web.Services.Ingestion; using Microsoft.Agents.AI; using Microsoft.Agents.AI.Hosting; using Microsoft.Extensions.AI; using System.ComponentModel;\n\nvar builder = WebApplication.CreateBuilder(args); builder.AddServiceDefaults(); builder.Services.AddRazorComponents().AddInteractiveServerComponents();\n\n// Configure Azure OpenAI var openai = builder.AddAzureOpenAIClient(\"openai\"); openai.AddChatClient(\"gpt-4o-mini\") .UseFunctionInvocation() .UseOpenTelemetry(configure: c => c.EnableSensitiveData = builder.Environment.IsDevelopment());\n\n// Register the AI Agent using the Agent Framework builder.AddAIAgent(\"ChatAgent\", (sp, key) => { // Get required services var logger = sp.GetRequiredService<ILogger<Program>>(); logger.LogInformation(\"Configuring AI Agent with key '{Key}' for model '{Model}'\", key, \"gpt-4o-mini\");\n\nvar searchFunctions = sp.GetRequiredService<SearchFunctions>(); var chatClient = sp.GetRequiredService<IChatClient>();\n\n// Create and configure the AI agent var aiAgent = chatClient.CreateAIAgent( name: key, instructions: \"You are a useful agent that helps users with short and funny answers.\", description: \"An AI agent that helps users with short and funny answers.\", tools: [AIFunctionFactory.Create(searchFunctions.SearchAsync)] ) .AsBuilder() .UseOpenTelemetry(configure: c => c.EnableSensitiveData = builder.Environment.IsDevelopment()) .Build();\n\nreturn aiAgent; });\n\n// Configure embeddings and vector storage openai.AddEmbeddingGenerator(\"text-embedding-3-small\");\n\nvar vectorStorePath = Path.Combine(AppContext.BaseDirectory, \"vector-store.db\"); var vectorStoreConnectionString = $\"Data Source={vectorStorePath}\"; builder.Services.AddSqliteCollection<string, IngestedChunk>(\"data-chatapp20-chunks\", vectorStoreConnectionString); builder.Services.AddSqliteCollection<string, IngestedDocument>(\"data-chatapp20-documents\", vectorStoreConnectionString); builder.Services.AddScoped<DataIngestor>(); builder.Services.AddSingleton<SemanticSearch>();\n\n// Register SearchFunctions for DI injection into the agent builder.Services.AddSingleton<SearchFunctions>();\n\nvar app = builder.Build();\n\n// ... rest of the configuration ... ```\n\n**Key points about the agent registration:**\n\n1. **Keyed Service Registration**: The agent is registered with the key `\"ChatAgent\"`\nusing `builder.AddAIAgent()` . This allows you to register multiple agents in the same application.\n2. **Agent Configuration**: The agent is created with:\n- A **name** for identification\n- **Instructions** (system prompt) that define its personality and behavior\n- A **description** that explains its purpose\n- **Tools** that the agent can use (in this case, the `SearchAsync`\nfunction)\n3. **Tool Binding**: The `AIFunctionFactory.Create()`\nmethod converts the `SearchAsync`method into a tool that the agent can invoke. The framework automatically handles:\n- Parameter validation based on the `[Description]`\nattributes\n- JSON serialization/deserialization\n- Error handling and retries\n4. **Telemetry**: The `UseOpenTelemetry()`\ncall ensures that all agent interactions are logged and can be observed through Application Insights or other monitoring tools.\n5. **Dependency Injection**: The agent factory receives an `IServiceProvider`\n, allowing it to resolve dependencies like `SearchFunctions` and `IChatClient` .\n\n### Updating the Chat Component\n\nFinally, we need to update `Chat.razor` to use our new AI agent. The changes are pretty straightforward:\n\n**Key changes in the code-behind:**\n\n1. **Inject the IServiceProvider** instead of IChatClient:\n\n```csharp @inject IServiceProvider ServiceProvider @using Microsoft.Agents.AI ```\n\n1. **Resolve the agent** in `OnInitialized()`\n:\n\n```csharp private AIAgent aiAgent = default!;\n\nprotected override void OnInitialized() { // Resolve the keyed AI agent registered as \"ChatAgent\" in Program.cs aiAgent = ServiceProvider.GetRequiredKeyedService<AIAgent>(\"ChatAgent\"); // ... rest of initialization ... } ```\n\n1. **Use agent streaming** in `AddUserMessageAsync()`\n:\n\n```csharp // Replace ChatClient.GetStreamingResponseAsync with agent streaming await foreach (var update in aiAgent.RunStreamingAsync( messages: messages.Skip(statefulMessageCount), cancellationToken: currentResponseCancellation.Token)) { var responseUpdate = update.AsChatResponseUpdate(); messages.AddMessages(responseUpdate, filter: c => c is not TextContent); responseText.Text += update.Text; chatOptions.ConversationId = responseUpdate.ConversationId; ChatMessageItem.NotifyChanged(currentResponseMessage); } ```\n\nThat’s it! The agent handles everything else—tool invocation, reasoning, and response generation.\n\n## Step 3: Running and Testing the Enhanced Application\n\n### Running with .NET Aspire\n\nOne of the best parts about using the AI templates is that everything runs through .NET Aspire. This gives you:\n\n- **Service discovery** between components\n- **Unified logging** and telemetry in the Aspire dashboard\n- **Health checks** for all services\n- **Easy configuration** for all your secrets and settings\n\nRun the app. The Aspire dashboard opens automatically in your browser\n\n![Aspire dashboard with running application](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/10/04-image-aspire-dashboard.png)\n\n### Configuring Azure OpenAI\n\nOn first run, you’ll be prompted to configure Azure OpenAI:\n\n1. **Azure Subscription**: Select your subscription\n2. **Resource Group**: Choose existing or create new\n3. **Azure OpenAI Resource**: Select or provision\n4. **Model Deployments**: Ensure you have:\n- A chat model (e.g., `gpt-4o-mini`\n)\n- An embedding model (e.g., `text-embedding-3-small`\n)\n\nThe configuration will be saved locally and reused for subsequent runs.\n\n### Testing the Agent\n\nOnce everything is running, click on the web endpoint in the Aspire dashboard (usually `https://localhost:7001` ).\n\n![Chat interface with documents](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/10/05-image-chat-ui.png)\n\nLet’s test it out:\n\n1. **Basic conversation:**\n\n```bash You: Hello! How are you? Agent: Hey! I'm great — fully charged, like an Emergency Survival Kit. ```\n2. **Tool invocation with semantic search:**\n\n```bash You: What should I include in an emergency survival kit? Agent: Short survival-kit checklist (funny edition) First aid supplies — bandages, gauze, antiseptics. <citation filename='Example_Emergency_Survival_Kit.pdf' page_number='1'>water and food supplies</citation> ```\n3. **File-specific queries:**\n\n```bash You: Tell me about the GPS watch features Agent: The GPS watch includes... <citation filename='Example_GPS_Watch.pdf' page_number='2'>real-time tracking</citation> ```\n\n![Agent response with citations](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/10/06-image-agent-response.png)\n\nHere’s the cool part: check out the Aspire dashboard while the agent is working. You can actually see:\n\n- When the agent decides to invoke the search tool\n- What parameters it passes\n- The search results it gets back\n- How it synthesizes everything into a response\n\n[https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/10/07-image-telemetry.webm](https://devblogs.microsoft.com/dotnet/wp-content/uploads/sites/10/2025/10/07-image-telemetry.webm)\n\nThis level of observability is invaluable when you’re debugging or optimizing your agent’s behavior.\n\n## Advanced Scenarios\n\n### Adding More Tools to Your Agent\n\nYou can easily extend your agent with additional capabilities:\n\n```csharp public class WeatherFunctions { [Description(\"Gets the current weather for a location\")] public async Task<string> GetWeatherAsync( [Description(\"The city and state/country\")] string location) { // Call weather API return $\"Weather for {location}: Sunny, 72°F\"; } }\n\n// In Program.cs builder.Services.AddSingleton<WeatherFunctions>();\n\nbuilder.AddAIAgent(\"ChatAgent\", (sp, key) => { var searchFunctions = sp.GetRequiredService<SearchFunctions>(); var weatherFunctions = sp.GetRequiredService<WeatherFunctions>(); var chatClient = sp.GetRequiredService<IChatClient>();\n\nreturn chatClient.CreateAIAgent( name: key, instructions: \"You can search documents and check weather...\", tools: [ AIFunctionFactory.Create(searchFunctions.SearchAsync), AIFunctionFactory.Create(weatherFunctions.GetWeatherAsync) ] ).Build(); }); ```\n\n**Note**\n\nYou can check out the full running sample in [Generative AI for Beginners – .NET](https://aka.ms/genainet).\n\n### Multi-Agent Scenarios\n\nThe Agent Framework makes it easy to coordinate multiple specialized agents:\n\n```csharp // Register a research agent builder.AddAIAgent(\"ResearchAgent\", (sp, key) => { var chatClient = sp.GetRequiredService<IChatClient>(); var searchFunctions = sp.GetRequiredService<SearchFunctions>();\n\nreturn chatClient.CreateAIAgent( name: \"ResearchAgent\", instructions: \"You are a research specialist. Find and summarize information from documents.\", tools: [AIFunctionFactory.Create(searchFunctions.SearchAsync)] ).Build(); });\n\n// Register a writing agent builder.AddAIAgent(\"WritingAgent\", (sp, key) => { var chatClient = sp.GetRequiredService<IChatClient>();\n\nreturn chatClient.CreateAIAgent( name: \"WritingAgent\", instructions: \"You are a writing specialist. Take information and create well-structured, engaging content.\", tools: [] ).Build(); });\n\n// Register a coordinator agent that uses both builder.AddAIAgent(\"CoordinatorAgent\", (sp, key) => { var chatClient = sp.GetRequiredService<IChatClient>(); var researchAgent = sp.GetRequiredKeyedService<AIAgent>(\"ResearchAgent\"); var writingAgent = sp.GetRequiredKeyedService<AIAgent>(\"WritingAgent\");\n\n// Create functions that delegate to other agents async Task<string> ResearchAsync(string topic) { var messages = new[] { new ChatMessage(ChatRole.User, topic) }; var result = await researchAgent.RunAsync(messages); return result.Text ?? \"\"; }\n\nasync Task<string> WriteAsync(string content) { var messages = new[] { new ChatMessage(ChatRole.User, $\"Write an article based on: {content}\") }; var result = await writingAgent.RunAsync(messages); return result.Text ?? \"\"; }\n\nreturn chatClient.CreateAIAgent( name: \"CoordinatorAgent\", instructions: \"Coordinate research and writing to create comprehensive articles.\", tools: [ AIFunctionFactory.Create(ResearchAsync), AIFunctionFactory.Create(WriteAsync) ] ).Build(); }); ```\n\n**Note**\n\nFor more examples of multi-agent coordination patterns, check out the [Generative AI for Beginners – .NET](https://aka.ms/genainet).\n\n### Custom Agent Middleware\n\nYou can add custom middleware to agents for logging, caching, or custom behavior:\n\n```csharp builder.AddAIAgent(\"ChatAgent\", (sp, key) => { var chatClient = sp.GetRequiredService<IChatClient>(); var searchFunctions = sp.GetRequiredService<SearchFunctions>(); var logger = sp.GetRequiredService<ILogger<Program>>();\n\nreturn chatClient.CreateAIAgent( name: key, instructions: \"...\", tools: [AIFunctionFactory.Create(searchFunctions.SearchAsync)] ) .AsBuilder() .Use(async (messages, options, next, cancellationToken) => { // Custom pre-processing logger.LogInformation(\"Agent processing {MessageCount} messages\", messages.Count());\n\n// Call next in pipeline var result = await next(messages, options, cancellationToken);\n\n// Custom post-processing logger.LogInformation(\"Agent generated response with {ContentCount} content items\", result.Contents.Count);\n\nreturn result; }) .UseOpenTelemetry(configure: c => c.EnableSensitiveData = true) .Build(); }); ```\n\n**Note**\n\nYou can find more examples of custom middleware patterns in the [Generative AI for Beginners – .NET](https://aka.ms/genainet).\n\n## Best Practices\n\n### 1. Design Clear Tool Descriptions\n\nThe quality of your agent’s tool invocations depends heavily on good descriptions:\n\n```csharp [Description(\"Searches for specific information in product documentation. \" + \"Use this when the user asks about features, specifications, or how to use products. \" + \"Returns relevant excerpts with filename and page numbers for citations.\")] public async Task<IEnumerable<string>> SearchAsync( [Description(\"The specific phrase, keyword, or question to search for. \" + \"Be specific and include relevant context.\")] string searchPhrase, [Description(\"Optional: The exact filename to search within (e.g., 'ProductManual.pdf'). \" + \"Leave empty to search all documents.\")] string? filenameFilter = null) { // Implementation } ```\n\n### 2. Test Agent Behavior\n\nCreate unit tests for your agent tools and integration tests for agent workflows:\n\n```csharp public class SearchFunctionsTests { [Fact] public async Task SearchAsync_WithValidQuery_ReturnsResults() { // Arrange var mockSemanticSearch = new Mock<SemanticSearch>(); mockSemanticSearch .Setup(s => s.SearchAsync(\"test\", null, 5)) .ReturnsAsync(new List<IngestedChunk> { new IngestedChunk { DocumentId = \"test.pdf\", PageNumber = 1, Text = \"test content\" } });\n\nvar searchFunctions = new SearchFunctions(mockSemanticSearch.Object);\n\n// Act var results = await searchFunctions.SearchAsync(\"test\");\n\n// Assert Assert.NotEmpty(results); Assert.Contains(\"test content\", results.First()); } } ```\n\n### 3. Monitor Agent Performance\n\nUse Application Insights or .NET Aspire’s dashboard to monitor:\n\n- **Token usage** per agent interaction\n- **Tool invocation patterns** (which tools are used, how often)\n- **Response times** for agent operations\n- **Error rates** for tool calls\n- **User satisfaction** through feedback mechanisms\n\n## Performance Considerations\n\n### Streaming vs. Non-Streaming\n\nThe Agent Framework supports both streaming and non-streaming responses:\n\n**Use streaming when:**\n\n- Building interactive chat interfaces\n- Users expect real-time feedback\n- Processing long-running queries\n\n**Use non-streaming when:**\n\n- Processing in the background\n- Batch operations\n- Simple API endpoints\n\n### Tool Call Optimization\n\nMinimize unnecessary tool calls:\n\n```csharp // Good: Specific instructions \"Use the search tool only when the user asks a specific question about the documents. Don't search if you can answer from general knowledge.\"\n\n// Bad: Vague instructions \"You have access to a search tool.\" ```\n\n## Deployment to Azure\n\nThe application is ready for deployment to Azure using .NET Aspire’s Azure provisioning:\n\n```bash\n# Login to Azure\naz login\n\n# Create Azure resources\ncd ChatApp20.AppHost azd init azd up ```\n\nThis will:\n\n1. Provision Azure OpenAI resources\n2. Deploy the web application to Azure Container Apps\n3. Set up Application Insights for monitoring\n4. Configure service connections and authentication\n\nFor detailed deployment instructions, see the [.NET Aspire Azure deployment documentation](https://learn.microsoft.com/dotnet/aspire/deployment/azd/aca-deployment-azd-in-depth?tabs=windows).\n\n## Summary\n\nAnd there you have it! We’ve taken a standard AI chat app and transformed it into a proper agent system using Microsoft Agent Framework. The upgrade gives you better architecture with clean separation of concerns, easier testing, and built-in observability—all while using the .NET patterns you already know.\n\nWhat I really appreciate is that Microsoft Agent Framework doesn’t force you to learn a completely new way of doing things. It builds on familiar concepts like dependency injection, middleware, and telemetry, making it feel natural for C# developers.\n\nIf you’re building AI applications with .NET, I highly recommend giving the Agent Framework a try. Start with the [AI templates](https://learn.microsoft.com/dotnet/ai/quickstarts/ai-templates), then layer on the agent capabilities as your needs grow. Check out the [official documentation](https://aka.ms/agent-framework) and [Luis’ announcement post](https://devblogs.microsoft.com/dotnet/introducing-microsoft-agent-framework-preview/) to learn more!",
  "FeedName": "Microsoft .NET Blog",
  "FeedLevelAuthor": ".NET Blog",
  "Title": "Upgrading to Microsoft Agent Framework in Your .NET AI Chat App",
  "OutputDir": "_news",
  "ProcessedDate": "2025-10-23 17:02:51",
  "Tags": [
    ".NET",
    ".NET Aspire",
    "AgentFx",
    "AI",
    "AIFoundry",
    "aspire",
    "C#"
  ],
  "FeedUrl": "https://devblogs.microsoft.com/dotnet/feed/",
  "PubDate": "2025-10-23T17:00:00+00:00",
  "Description": "Step-by-step review on how to upgrade your .NET AI chat app to Microsoft Agent Framework for better architecture, tool integration, and intelligent reasoning.\n\nThe post [Upgrading to Microsoft Agent Framework in Your .NET AI Chat App](https://devblogs.microsoft.com/dotnet/upgrading-to-microsoft-agent-framework-in-your-dotnet-ai-chat-app/) appeared first on [.NET Blog](https://devblogs.microsoft.com/dotnet).",
  "Link": "https://devblogs.microsoft.com/dotnet/upgrading-to-microsoft-agent-framework-in-your-dotnet-ai-chat-app/",
  "Author": "Bruno Capuano"
}
