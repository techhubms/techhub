{
  "FeedName": "Microsoft .NET Blog",
  "Tags": [
    ".NET",
    ".NET 10",
    "dotnet",
    "F#",
    "F# 10"
  ],
  "FeedLevelAuthor": ".NET Blog",
  "EnhancedContent": "F# 10 is now shipping with .NET 10 and Visual Studio 2026. This version is a refinement release focused on clarity, consistency, and performance, bringing small but meaningful improvements that make your everyday code more legible and robust.\n\nYou can get F# 10 today in a few ways:\n\n- [Install the latest .NET 10 SDK](https://dotnet.microsoft.com/download/dotnet/10.0)\n- [Install the latest Visual Studio 2026 preview](https://visualstudio.microsoft.com/vs/preview/)\n\nWith F# 10, weâ€™re continuing our journey to make the language simpler and more performant. Key ergonomic improvements include scoped warning suppression, more consistent syntax for computation expressions, and better support for auto property accessors. The release also includes an infrastructure upgrade to speed up compilation and interactive tooling in the form of the new type subsumption cache.\n\n## Language Improvements\n\n### 1. Scoped warning suppression\n\nThe first feature I want to introduce for F# 10 is a much-requested one: the ability to suppress warnings in arbitrary code sections. Our compiler now supports the `#warnon` directive, which pairs with `#nowarn` to enable or disable warnings within a specific code span.\n\nLetâ€™s take a look at a motivating example:\n\n```fsharp // We know f is never called with a None. let f (Some a) = // creates warning 25, which we want to suppress // 2000 loc, where the incomplete match warning is beneficial ```\n\nOf course, we can add a `#nowarn 25` directive right above the function definition, but without a matching `#warnon 25` , this will disable the FS0025 warning in the remainder of the file, risking the suppression of legitimate issues elsewhere.\n\nWith F# 10, you can delimit the section explicitly, applying the warning suppression to as narrow a scope as a single line:\n\n```fsharp #nowarn 25 let f (Some x) = // FS0025 suppressed #warnon 25 // FS0025 enabled again ```\n\nConversely, if a warning is disabled globally (e.g., via a compiler flag), you can enable it locally with `#warnon` . This directive will then apply until a matching `#nowarn` or the end of the file.\n\n**Compatibility:**\n\nThis feature is accompanied by several changes that improve the consistency of `#nowarn` /`#warnon` directives, leading to more predictable behavior. However, these are breaking changes that might affect your codebase when you update to F# 10. A detailed list of potential issues can be found in the [RFC-1146](https://github.com/fsharp/fslang-design/blob/main/RFCs/FS-1146-scoped-nowarn.md), but here are a couple of examples most likely to occur:\n\n- Multiline and empty warn directives are no longer allowed.\n- Whitespace between `#`\nand `nowarn` is no longer allowed.\n- Triple-quoted, interpolated, or verbatim strings cannot be used for warning numbers.\n\nScript behavior is also affected. In previous versions, a `#nowarn` directive anywhere in a script applied to the whole compilation. Now, its behavior in scripts matches that in `.fs` files, applying only until the end of the file or a corresponding `#warnon` .\n\n### 2. Access modifiers on auto property accessors\n\nA frequent pattern in object-oriented programming is to create publicly readable but privately mutable state. Before F# 10, achieving this required explicit property syntax with backing fields, which added significant boilerplate:\n\n```fsharp type Ledger() = [<DefaultValue>] val mutable private _Balance: decimal member this.Balance with public get() = this._Balance and private set v = this._Balance <- v ```\n\nWith F# 10, you can apply distinct access modifiers to individual property accessors. This allows you to specify different access levels for the getter and setter of a property inline, enabling common patterns like publicly readable but privately mutable state without verbose boilerplate.\n\nNow you can rewrite the above as:\n\n```fsharp type Ledger() = member val Balance = 0m with public get, private set ```\n\n**Worth noting:**\n\nYou can place an access modifier either before the property name (applying to both accessors) or before individual accessors, but not both simultaneously.\n\nAlso, this feature does not extend to signature (.fsi) files. The correct signature for the `Ledger` example above would be:\n\n```fsharp type Ledger() = member Balance : decimal member private Balance : decimal with set ```\n\n### 3. `ValueOption`\noptional parameters\n\nOptional parameters can now use a struct-based `ValueOption<'T>` representation. By applying the `[<Struct>]` attribute to an optional parameter, you can instruct the compiler to use `ValueOption<'T>` instead of the reference-based `option` type. This avoids a heap allocation for the option wrapper, which is beneficial in performance-critical code.\n\nPrevious versions of F# always used the heap-allocated `option` type for optional parameters, even when the parameter was absent. For high-throughput scenarios or inner-loop object creation, this imposed unnecessary GC pressure. Developers working on performance-sensitive code had no way to avoid these allocations:\n\n```fsharp // Prior to F# 10: always uses reference option type X() = static member M(?x : string) = match x with | Some v -> printfn \"Some %s\" v | None -> printfn \"None\" ```\n\nNow you can use the `[<Struct>]` attribute on an optional parameter to leverage the struct-backed `ValueOption` and eliminate allocations when the argument is absent:\n\n```fsharp type X() = static member M([<Struct>] ?x : string) = match x with | ValueSome v -> printfn \"ValueSome %s\" v | ValueNone -> printfn \"ValueNone\" ```\n\nChoose this struct-based option for small values or frequently constructed types where allocation pressure matters. Use the default reference-based `option` when you rely on existing pattern matching helpers, need reference semantics, or when the performance difference is negligible. This feature strengthens parity with other F# language constructs that already support `ValueOption` .\n\n### 4. Tail-call support in computation expressions\n\nComputation-expression builders (for example, coroutines or other builders implemented with resumable state machines) can now opt into tail-call optimizations. During desugaring, the compiler recognizes when an expression like `return!` , `yield!` or `do!` appears in a tail position and, when the builder provides special methods, routes those calls to the optimized entry points.\n\nIf a builder implements:\n\n- `ReturnFromFinal`\n, the compiler will call it for a tail `return!` (falling back to `ReturnFrom` if the final variant is absent).\n- `YieldFromFinal`\n, the compiler will call it for a tail `yield!` (falling back to `YieldFrom` if absent).\n- For a terminal `do!`\n, the compiler will prefer `ReturnFromFinal` , then `YieldFromFinal` , before falling back to the normal `Bind` pathway.\n\nThese `*Final` members are optional and exist purely to enable optimization: they allow builders to short-circuit continuations or otherwise relinquish resources early. Builders that do not provide these members keep their existing semantics unchanged.\n\nExamples:\n\n```fsharp coroutine { yield! subRoutine() // tail position -> YieldFromFinal if available } ```\n\n```fsharp coroutine { try yield! subRoutine() // not tail -> normal YieldFrom finally () } ```\n\n**Compatibility:**\n\nThis change can be breaking if a builder already defines members with these names. In most cases, it is backward-compatible: existing builders continue to work without modification when compiled with F# 10. Older compilers will simply ignore the new `*Final` methods, so builders that must remain compatible with earlier compiler versions should not assume those methods will be invoked.\n\n### 5. Typed bindings in computation expressions without parentheses\n\nA long-standing inconsistency in type annotation syntax for computation expression bindings has been resolved. You can now add type annotations on `let!` , `use!` , and `and!` bindings without wrapping the identifier in parentheses.\n\nPrior versions of F# required parentheses for type annotations in computation expression bindings. For example, `let! (x: int) = fetchA()` was valid, but the more natural `let! x: int = fetchA()` would cause an error. This forced developers to use visually noisy parentheses even for simple type annotations:\n\n```fsharp async { let! (a: int) = fetchA() and! (b: int) = fetchB() use! (d: MyDisposable) = acquireAsync() return a + b } ```\n\nNow you can write type annotations without parentheses, matching the style of ordinary `let` bindings:\n\n```fsharp async { let! a: int = fetchA() and! b: int = fetchB() use! d: MyDisposable = acquireAsync() return a + b } ```\n\n### 6. Allow `_`\nin `use!` bindings\n\nPrior versions of F# rejected the discard pattern in `use!` bindings, even when the resource value itself was never referenced. This inconsistency with regular `use` bindings forced developers to create throwaway identifiers like `__` or `_ignored` just to satisfy the compiler.\n\nThe discard pattern (`_` ) now works in `use!` bindings within computation expressions. F# 10 allows you to use `_` directly when binding asynchronous resources whose values are only needed for lifetime management, without being forced to provide a named identifier.\n\nNow you can use the discard pattern directly, clarifying your intent and matching the behavior of `use` :\n\n```fsharp counterDisposable { use! _ = new Disposable() // logic } ```\n\n### 7. Rejecting pseudo-nested modules in types\n\nStructural validation has been tightened in this release to reject misleading module placement within types. F# 10 now raises an error when a `module` declaration appears indented at the same structural level inside a type definition, preventing a common source of confusion about module scoping.\n\nPrevious versions of F# accepted `module` declarations indented within type definitions, but these modules were actually created as siblings to the type rather than being nested within it. This indentation pattern frequently misled developers into believing they had created a nested module, resulting in unexpected scoping behavior:\n\n```fsharp type U = | A | B module M = // Silently created a sibling module, not nested let f () = () ```\n\nNow, this pattern raises error FS0058, forcing you to clarify your intent with proper module placement:\n\n```fsharp type U = | A | B\n\nmodule M = let f () = () ```\n\n### 8. Deprecation warning for omitted `seq`\n\nA deprecation warning now appears for bare sequence expressions that omit the `seq` builder. F# 10 warns when you use bare range braces like `{ 1..10 }` or similar forms, encouraging you to use the explicit `seq { ... }` form for consistency with the broader computation expression model.\n\nHistorically, F# allowed a special-case â€œsequence comprehension liteâ€ syntax where the `seq` keyword could be omitted. This diverged from how other computation expressions work and created an inconsistency in the language:\n\n```fsharp { 1..10 } |> List.ofSeq // implicit sequence ```\n\nNow, the compiler warns about this pattern and encourages the explicit form that clarifies semantics:\n\n```fsharp seq { 1..10 } |> List.ofSeq ```\n\nThis is currently a warning, not an error, giving you time to update your codebase. The explicit `seq` form improves code clarity and consistency with other computation expressions. Future versions of F# may make this an error, so we recommend adopting the explicit syntax when updating code.\n\n### 9. Attribute target enforcement\n\nAttribute target validation will be enforced with this release across all language constructs. F# 10 validates that attributes are only applied to their intended targets by checking `AttributeTargets`\n\nacross let-bound values, functions, union cases, implicit constructors, structs, and classes.\n\nPrevious versions of F# silently allowed attributes to be misapplied to incompatible targets. This caused subtle bugs, such as test attributes being ignored when you forgot `()` to make a function or analyzer directives failing to take effect, leading to confusing CI discrepancies:\n\n```fsharp [<Fact>] let ``this is not a function`` = // Silently ignored, not a test! Assert.True(false) ```\n\nNow, the compiler enforces attribute targets and raises a warning when attributes are misapplied:\n\n```fsharp [<Fact>] //^^^^ - warning FS0842: This attribute cannot be applied to property, field, return value. Valid targets are: method let ``works correctly`` = Assert.True(true) ```\n\n**Compatibility:**\n\nThis is a breaking change that may reveal previously silent issues in your codebase. The early errors prevent test discovery problems and ensure that attributes like analyzers and decorators take effect as intended.\n\n## FSharp.Core enhancement â€“ support for `and!`\nin task expressions\n\nThis release brings a single improvement to the FSharp.Core library: support for `and!` in the `task` computation expression.\n\nUsing `task` is a popular way to work with asynchronous workflows in F#, especially when interop with C# is required. However, until recently there was no concise way to await multiple tasks concurrently in a computation expression.\n\nPerhaps you started with code that awaited computations sequentially:\n\n```fsharp // Awaiting sequentially task { let! a = fetchA() let! b = fetchB() return combineAB a b } ```\n\nIf you then wanted to change it to await them concurrently, you would typically use `Task.WhenAll` :\n\n```fsharp // Use explicit Task combinator to await concurrently task { let ta = fetchA() let tb = fetchB() let! results = Task.WhenAll([| ta; tb |]) return combineAB ta.Result tb.Result } ```\n\nWith F# 10, you can instead write a more idiomatic version using `and!` :\n\n```fsharp task { let! a = fetchA() and! b = fetchB() return combineAB a b } ```\n\nThis combines the semantics of the second snippet with the simplicity of the first.\n\n## Performance & Tooling\n\n### Type subsumption cache\n\nThis release also introduces a new type subsumption cache to accelerate type checking and improve IDE responsiveness, especially in projects with complex type hierarchies. In F# 10, the compiler memoizes the results of type relationship checks, reducing redundant computations and improving overall compiler and tooling performance.\n\nPreviously, the F# compiler would repeatedly perform expensive subsumption checks when dealing with large type hierarchies, such as those involving numerous numeric primitives or many interface implementations. This could lead to noticeable latency during type inference and IDE operations, particularly in large solutions or during long editing sessions, consuming extra CPU and memory.\n\nNow, the new type subsumption cache stores the results of these checks. When the compiler needs to determine if one type can be used in place of another, it first consults the cache. This memoization avoids re-computing the same type relationships, leading to faster compilation and more responsive IntelliSense.\n\nNo code changes are required to benefit from this improvement; the performance gains are automatic.\n\n### Better trimming by default\n\nF# 10 removes a longâ€‘standing bit of friction with trimming F# assemblies: you no longer have to handâ€‘maintain an `ILLink.Substitutions.xml` file just to strip large F# metadata resource blobs (signature/optimization data) that arenâ€™t needed at runtime in the final application.\n\nWhen you publish with trimming enabled (`PublishTrimmed=true` ), the F# build now autoâ€‘generates a substitutions file that targets the toolingâ€‘only F# resources. The result: smaller output by default, less boilerplate, and one fewer maintenance hazard.\n\nIf you need full manual control you can still add your own substitutions file. The auto-generation can be turned off with a property, like so: `<DisableILLinkSubstitutions>false</DisableILLinkSubstitutions>` .\n\n### Parallel compilation in preview\n\nAn exciting update for F# users looking to reduce their projectsâ€™ compilation times is the progressing stabilization of the parallel compilation features. Starting with .NET 10, three features: graph-based type checking, parallel IL code generation, and parallel optimization are grouped together under the `ParallelCompilation` project property.\n\nCurrently, this setting is turned on by default for projects that are using `LangVersion=Preview` , and we plan to turn it on for everyone in .NET 11. Be sure to give it a try and see if it speeds up your compilation. However, if you want to opt out but still enjoy other preview features, then set the `ParallelCompilation` to false.\n\n### Typecheck-only mode for scripts\n\nF# is a great scripting language, and we want to ensure that the tooling also supports that use case. That is why weâ€™re extending the `--typecheck-only` compilation flag to also work for `.fsx` scripts, where itâ€™s arguably the most beneficial. In F# 9 and earlier, there was no easy way to validate syntax and type correctness of a script without running the code, which would often produce side effects.\n\nWith this release, you can simply use the `--typecheck-only` flag while invoking `fsi` to typecheck the script without execution. This feature makes it easy to add CI gates that will be able to catch script rot in your codebase.\n\n**Known issue caveat:** As of publishing this post, there is a [known bug](https://github.com/dotnet/fsharp/issues/19047) that severely limits the benefits of using `--typecheck-only` with scripts that include others via `#load` . In that case type checking will conclude prematurely after processing the first loaded source file. However, the fix has already been implemented and will be included in the upcoming patch release 10.0.200.\n\n## Thanks and acknowledgements\n\nF# is developed as a collaboration between the .NET Foundation, the F# Software Foundation, their members and other contributors including Microsoft. The F# community is involved at all stages of innovation, design, implementation and delivery and weâ€™re proud to be a contributing part of this community.\n\nIn the past year, we merged commits from 25 contributors. We would like to thank all of you, as well as many others who filed [issues](https://github.com/dotnet/fsharp/issues), raised and voted on [language suggestions](https://github.com/fsharp/fslang-suggestions), and contributed to [language design](https://github.com/fsharp/fslang-design). In particular, we explicitly call out some of the most active community contributors:\n\n- [@majocha](https://github.com/majocha) for a multitude of contributions, including infrastructure, testing and tooling improvements.\n- [@Martin521](https://github.com/Martin521) most notably for a herculean effort on the scoped `#nowarn`\nfeature design and implementation.\n- [@edgarfgp](https://github.com/edgarfgp) for his continued efforts in the area of error handling and diagnostics, as well as great improvements to the parser.\n- [@auduchinok](https://github.com/auduchinok) for his work on improving tooling via fixes to parser recovery and other areas, as well as contributions to testing infrastructure.\n\n## Contributor showcase\n\nAs is tradition in our release announcements, the contributor showcase section is where we celebrate some of our most impactful open-source community contributors. While our long-time contributor Jakub Majocha received a well-deserved [shout-out in a .NET 8 announcement](https://devblogs.microsoft.com/dotnet/announcing-dotnet-8-rc1/#community-contributor) two years ago, his outstanding work over the past year on the F# compiler has earned him one here in the F# release blog post. This time, he is going to share a little about his approach to contributing to the repo:\n\n> >\n> Looking back at my PR history I see that most of them are fixes to things that I broke ðŸ™‚\n> Thatâ€™s why as a hobbyist I try to stick to contributions that have low risk of breaking something serious. For example I had a lot of fun making the tests run in parallel.\n> Iâ€™m also always looking for low-hanging fruit, there still are quite a few. For example you can revive some unfinished PRs that were already almost done:\n> Type subsumption cache was one and the other was tail-call support in computation expressions â€“ my first ever RFC implemented.\n> I have an interest in tooling and its performance, so another surprising win that Iâ€™m very happy with is reducing StackGuard related slowdowns.\n> I had a hunch about StackGuard impact on editor performance, and experimented for some time with various approaches.\n> Adding some instrumentation to collect metrics was the most helpful here and the solution turned out to be very straightforward.\n> Iâ€™d like to add huge thanks to the Amplifying F# collective for encouraging my attempts and sponsoring my Copilot subscription.\n> >\n\nIf you read it carefully, you might have noticed a teaser of an upcoming performance improvement that didnâ€™t make it to this release, but we are very excited to bring to F# 11.\n\nAnd just like Jakub, we would like to recognize [Amplifying F#](https://amplifyingfsharp.io/) for their invaluable support of community contributors. Efforts like theirs help make the F# ecosystem thrive.\n\n## Whatâ€™s next?\n\nWork on F# 11 is already under way: more performance wins, language improvements, and tooling upgrades.\n\nGo to our GitHub repo to jump into [discussions](https://github.com/dotnet/fsharp/discussions), [help wanted issues](https://github.com/dotnet/fsharp/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22) or [good first issues for new contributors](https://github.com/dotnet/fsharp/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22).",
  "Title": "Introducing F# 10",
  "Description": "Learn about new F# 10 language features, performance upgrades, and tooling improvements shipping with .NET 10.\n\nThe post [Introducing F# 10](https://devblogs.microsoft.com/dotnet/introducing-fsharp-10/) appeared first on [.NET Blog](https://devblogs.microsoft.com/dotnet).",
  "OutputDir": "_news",
  "ProcessedDate": "2025-11-17 19:02:38",
  "FeedUrl": "https://devblogs.microsoft.com/dotnet/feed/",
  "Link": "https://devblogs.microsoft.com/dotnet/introducing-fsharp-10/",
  "Author": "Adam Boniecki",
  "PubDate": "2025-11-17T18:05:00+00:00"
}
