{
  "PubDate": "2025-08-22T16:52:27+00:00",
  "FeedUrl": "https://github.blog/feed/",
  "Link": "https://github.blog/ai-and-ml/github-copilot/building-your-first-mcp-server-how-to-extend-ai-tools-with-custom-capabilities/",
  "EnhancedContent": "Have you ever worked with AI tools and wished they had access to some additional piece of context? Or wanted them to perform actions on your behalf? Think of those scenarios where you‚Äôre working with [GitHub Copilot](https://github.com/features/copilot?utm_campaign=rdt-blog-devrel&amp;utm_source=blog&amp;utm_medium=copilot-landing-page) and you need it to check a GitHub Issue, run a Playwright test, or interact with an API. By default, these AI tools lack access to those external systems. But that‚Äôs where the [Model Context Protocol (MCP)](https://github.blog/ai-and-ml/generative-ai/a-practical-guide-on-how-to-use-the-github-mcp-server/) comes in. It‚Äôs a standardized way to extend AI tools with custom capabilities.\n\nI wanted to learn more about it by building something visual and interactive. So I created a turn-based game server that lets you play Tic-Tac-Toe and Rock Paper Scissors against Copilot using MCP.\n\nIn my latest **Rubber Duck Thursdays** live stream, I walked through the project, which has a few components, all written in TypeScript:\n\n- A Next.JS Web App and API, intended to run locally for demo/learning purposes\n- An MCP Server that uses the [MCP TypeScript SDK](https://github.com/modelcontextprotocol/typescript-sdk)\n- A shared library for common type definitions and components, which are reused across the web app, API, and MCP server\n\nYou can take a look at the code over at [github-samples/turn-based-game-mcp](https://github.com/github-samples/turn-based-game-mcp?utm_campaign=rdt-blog-devrel&amp;utm_source=blog&amp;utm_medium=turn-based-game-mcp). Here‚Äôs what I learned.\n\n*You can watch the full stream below* üëá\n\nYou can take a look at the code over at [github-samples/turn-based-game-mcp](https://github.com/github-samples/turn-based-game-mcp?utm_campaign=rdt-blog-devrel&amp;utm_source=blog&amp;utm_medium=turn-based-game-mcp). Here‚Äôs what I learned.\n\n## Why MCP matters for developers\n\nEven with powerful AI agents, we continue to run into limitations:\n\n- AI tools can‚Äôt natively access private data for [retrieval augmented generation](https://github.blog/ai-and-ml/generative-ai/what-is-retrieval-augmented-generation-and-what-does-it-do-for-generative-ai?utm_campaign=rdt-blog-devrel&amp;utm_source=blog&amp;utm_medium=github-blog-rag-post), like information from our GitHub repositories.\n- They don‚Äôt have access to the latest documentation or real-time data.\n- Agents can‚Äôt perform actions like creating pull requests, exploring the UI on your locally running application, or interact with your APIs.\n\nTo access external context and take action, we need to extend the capabilities of these AI tools. But before MCP, there was no standard approach to integrating with third-party tools and services. You‚Äôd potentially need different plugins and different integration patterns for whatever AI tool you were using. MCP changes that by providing **one standard way** to plug tools and capabilities into any tool that supports the Model Context Protocol.\n\nMCP follows a client-server pattern that‚Äôs familiar to most developers:\n\n- **Host:** The AI tool you‚Äôre using, like GitHub Copilot in VS Code (you‚Äôll notice that Copilot in VS Code has good support in the [MCP feature support matrix](https://modelcontextprotocol.io/clients#feature-support-matrix)). The host initiates the connection to your MCP server via a client.\n- **Clients:** Clients **** live inside the host application (for example, GitHub Copilot in VS Code), and have a 1:1 relationship with a server. When VS Code connects to a new MCP server (like GitHub, Playwright or the turn-based-game MCP server we‚Äôre talking about in this post), a new client is created to maintain the connection.\n- **Server**: Your custom MCP server that provides tools, resources, and prompts. In our case, we‚Äôre making an MCP server that provides capabilities for playing turn-based games!\n\n## Building the turn-based game MCP server\n\nFor my learning project, I wanted something visual that would show the overall MCP interaction and could be reused when people are trying to explain it as part of a talk. So I built a web app with Tic-Tac-Toe and Rock Paper Scissors. But instead of the game having two people play locally (or online), or even a CPU in the backend, the opponent‚Äôs moves are orchestrated by an MCP server.\n\nThe architecture includes:\n\n- **Next.js frontend**: The game interface where I make moves\n- **API routes (part of the Next.js implementation)**: Backend logic for game state management, called by the frontend and the MCP server.\n- **MCP server**: TypeScript server that handles AI game moves\n- **Shared libraries**: Common game logic used across components\n\nHere‚Äôs how it works in practice:\n\n1. We register an MCP server in VS Code so that Copilot is aware of the new capabilities and tools.\n2. I interact with GitHub Copilot in VS Code. I can call tools explicitly, or Copilot can autodiscover them.\n3. Copilot calls the large language model. Based on the prompt context and the available tools, it may call the MCP server.\n4. The MCP server executes the requested tool (like making a move in the game) and returns results.\n5. Copilot uses those results to continue the conversation.\n\nThe magic step is when you register the MCP server with an MCP application host (in our example, GitHub Copilot in Visual Studio Code). Suddenly, your AI agent gains access to the capabilities that have been built into those servers.\n\n![A screenshot of an MCP server configuration with the turn-based-game MCP server running. It shows a popup listing several tools from the MCP server including analyze_game, create_rock_paper_scissors_game, create_tic_tac_toe_game, play_rock_paper_scissor, play_tic_tac_toe and wait_for_player_move.](https://github.blog/wp-content/uploads/2025/08/rdt1.png?resize=1024%2C576)\n\n### Setting up the MCP server in VS Code\n\nYou can configure your MCP servers by creating a `.vscode/mcp.json` file. You can find more details about that on the [Visual Studio Code docs](https://code.visualstudio.com/docs/copilot/chat/mcp-servers#_add-an-mcp-server-to-your-workspace?utm_campaign=rdt-blog-devrel&amp;utm_source=blog&amp;utm_medium=vscode-docs-mcp-setup).\n\n``` { \"servers\": { \"playwright\": { \"command\": \"npx\", \"args\": [ \"@playwright/mcp@latest\" ] }, \"turn-based-games\": { \"command\": \"node\", \"args\": [\"dist/index.js\"], \"cwd\": \"./mcp-server\" } } } ```\n\nThe above configuration tells GitHub Copilot in VS Code that there are two MCP servers that we‚Äôd like to use:\n\n- A Playwright MCP server that is executed locally as an NPM package.\n- A turn-based-games MCP server that runs a server locally based on the compiled TypeScript code from our working directory.\n\nFor this implementation, I kept my turn-based-game MCP server architecture and logic relatively simple, with all components in a single repository. This monorepo approach bundles the web app, API, and MCP server together, making it straightforward to clone and run the entire system locally without complex dependency management or cross-repository setup. But for a more robust setup, you would likely distribute that MCP server either as a package (such as npm or a docker image), and have clear publishing and versioning processes around that.\n\n## The three core building blocks of MCP\n\nThrough building this project, I familiarized myself with three fundamental MCP server concepts:\n\n### 1. Tools: Actions your AI can take\n\n[Tools](https://modelcontextprotocol.io/docs/learn/server-concepts#tools-ai-actions) define what actions the MCP server can perform. In my game server, I specified tools like:\n\n- `Analyze_game`\n: Get the current state of any game\n- `create_rock_paper_scissors_game`\n: Start a new game of Rock Paper Scissors\n- `create_tic_tac_toe_game`\n: Start a new Tic-Tac-Toe game\n- `play_rock_paper_scissors`\n: Make an AI choice in Rock Paper Scissors\n- `play_tic_tac_toe`\n: Make an AI move in Tic-Tac-Toe\n- `wait_for_player_move`\n: Polls the endpoint until the player has made their move\n\nEach tool has a clear description and input schema that tells the AI what parameters to provide:\n\n``` { name: 'play_tic_tac_toe', description: 'Make an AI move in Tic-Tac-Toe game. IMPORTANT: After calling this tool when the game is still playing, you MUST call wait_for_player_move to continue the game flow.', inputSchema: { type: 'object', properties: { gameId: { type: 'string', description: 'The ID of the Tic-Tac-Toe game to play', }, }, required: ['gameId'], }, }, ```\n\nGitHub Copilot and the Large Language Model (LLM) aren‚Äôt calculating the actual game moves. When Copilot calls the play\\_tic\\_tac\\_toe tool, the MCP server executes a handler for that specific tool that runs the CPU game logic, like random moves for Tic Tac Toe in ‚Äúeasy‚Äù difficulty or a more optimal¬† algorithm for moves when using the ‚Äúhard‚Äù difficulty.\n\nIn other words, tools are reusable pieces of software that can be called by the AI, often to take some form of action (like making a move in a turn-based game!).\n\n### 2. Resources: Context your AI can access\n\n[Resources](https://modelcontextprotocol.io/docs/learn/server-concepts#resources-context-data) provide a way for the AI to gather context, and often have a URI-based identifier. For example, I implemented custom URI schemes like:\n\n- `game://tic-tac-toe`\n: List all Tic-Tac-Toe games\n- `game://tic-tac-toe/{Game-ID}`\n: Get state for a specific game of Tic Tac Toe\n- `game://rock-paper-scissors`\n: List all Rock Paper Scissors games\n- `game://rock-paper-scissors/{Game-ID}`\n: Get state for a specific game of Rock Paper Scissors\n\nAs the [MCP resources docs](https://modelcontextprotocol.io/docs/learn/server-concepts#resources-context-data) explain, you can choose how these resources are passed. In our turn-based-game MCP server, there is a method that translates the resource URIs into an API call to the local API server and passes on the raw response, so that it can be used as context within a tool call (like playing a game).\n\n``` async function readGameResource(uri) { const gameSession = await callBackendAPI(gameType, gameId); if (!gameSession) { throw new Error(\"Game not found\"); } return gameSession; } ```\n\n### 3. Prompts: Reusable guidance for users\n\nThe third concept is [prompts](https://modelcontextprotocol.io/docs/learn/server-concepts#prompts-interaction-templates). You‚Äôll be very familiar with prompts and prompt crafting, as that‚Äôs the way that you interact with AI tools like GitHub Copilot. Your users could write their own prompts to use your tools, like ‚ÄúPlay a game of Tic Tac Toe‚Äù or ‚ÄúCreate a GitHub Issue for the work that we‚Äôve just scoped out.‚Äù\n\nBut you may want to ship your MCP server with predefined prompts that help users get the most out of your tools. For example, the turn-based-game MCP comes with several prompts like:\n\n- Strategy guides for different difficulty levels\n- Game rules and optimal play instructions\n- Troubleshooting help for common scenarios\n\nYour users can access these prompts via slash commands in VS Code. For example, when I typed `/strategy` , I could access the prompt asking for advice on optimal play for a given game or difficulty level.\n\n## Real-world applications and considerations\n\nWhile my game demo is intentionally simple to help you learn some of these initial concepts, the patterns apply to other MCP servers:\n\n- [**GitHub MCP server**](https://github.com/github/github-mcp-server?utm_campaign=rdt-blog-devrel&amp;utm_source=blog&amp;utm_medium=github-mcp-server-repo): Get information from existing GitHub Issues or pull requests, list Dependabot alerts, or create and manage issues and pull requests, all based on the access you provide via OAuth (in the remote MCP server) or a Personal Access Token.\n- [**Playwright MCP server**](https://github.com/microsoft/playwright-mcp): Automatically navigate to specific pages in a browser, click and interact with the pages, capture screenshots, and check rendered content.\n- **Custom API servers**: Connect to your internal services, databases, or business logic.\n\n### Additional capabilities from the MCP specification\n\nTools, resources, and prompts are some of the most commonly used capabilities of the MCP specification. Recently, a number of additional capabilities including sampling and elicitation were added to the spec. I haven‚Äôt had a chance to add those yet, but perhaps they‚Äôll feature as part of another stream!\n\n### Authentication and security\n\nYou may need to handle authentication and authorization for production MCP servers depending on the scenario. As an example, the GitHub MCP server supports OAuth flows for the remote MCP server and Personal Access Tokens in local and remote. This turn-based game MCP server is intended to be simple, and doesn‚Äôt include any auth requirements, but security should be a key consideration if you‚Äôre building your own MCP servers.\n\n### Trusting third-party MCP servers\n\nYou may not always need to create your own MCP server. For example, GitHub ships its own MCP server. Instead of creating your own version, why not make an open source contribution upstream to improve the experience for all?\n\n**Thought üí°:** Make sure to do your due diligence on MCP servers before installing them, just like you would with any other dependency as part of your project‚Äôs supply chain. Do you recognise the publisher? Are you able to review (and contribute to) the code in an open source repository?\n\n### Language and SDK options\n\nMCP provides SDKs [for multiple languages](https://modelcontextprotocol.io/docs/sdk), so you can build servers in whatever technology fits your stack, ranging from TypeScript to Python, Go to Rust and more. I chose TypeScript because I wanted my entire demo (frontend, backend, and MCP server) in one repository with shared code and a common language.\n\nYou can keep up to date with the evolution of the MCP specification [on the Model Context Protocol documentation](https://modelcontextprotocol.io/specification/2025-06-18/changelog).\n\n## Take this with you\n\nHere‚Äôs what you can learn from this exploration:\n\n- **MCP standardizes AI tool extensibility** across different platforms and applications (like Copilot in Visual Studio Code)\n- **Reuse first** by investigating what existing MCP servers are available. Review the MCP servers: Do you recognize the publisher and can you access the code?\n- **Building your own? Start simple** with focused servers that solve specific problems rather than trying to build everything at once\n- **The three building blocks** (tools, resources, prompts) provide a clear framework for designing the capabilities of your MCP server\n\nMCP isn‚Äôt just about playing games with AI (though that was fun). It‚Äôs about breaking down the walls between your AI assistants and the systems they need to help you work effectively.\n\nWhether you‚Äôre building internal developer tools, integrating with external APIs, or creating custom workflows, MCP provides the foundation you need to extend your AI tools in consistent, powerful ways.\n\n## Next steps\n\nWant to explore MCP further? Here are some practical starting points:\n\n- Check out the [GitHub MCP server](https://github.com/github/github-mcp-server?utm_campaign=rdt-blog-devrel&amp;utm_source=blog&amp;utm_medium=github-mcp-server-repo) to use in your own workflows or learn more about a real-world MCP server implementation.\n- Try the [Playwright MCP server](https://github.com/microsoft/playwright-mcp) for UI testing workflows.\n- Build a simple server for your internal APIs or development tools. You can check out the [turn-based-game-mcp](https://github.com/github-samples/turn-based-game-mcp?utm_campaign=rdt-blog-devrel&amp;utm_source=blog&amp;utm_medium=turn-based-game-mcp) as an example.\n- Experiment with custom prompts that encode your team‚Äôs best practices.\n\nThe goal of MCP is to give your AI assistants the tools they need to be truly helpful in your specific development environment. So, which tool will you be using? What will you build?\n\n**Want a closer look?** Check out our [practical guide on how to use the GitHub MCP server &gt;](https://github.blog/ai-and-ml/generative-ai/a-practical-guide-on-how-to-use-the-github-mcp-server/)",
  "OutputDir": "_news",
  "FeedName": "The GitHub Blog",
  "Description": "Learn Model Context Protocol by building a turn-based game server that shows how to extend GitHub Copilot with custom tools, resources, and prompts.\n\nThe post [Building your first MCP server: How to extend AI tools with custom capabilities](https://github.blog/ai-and-ml/github-copilot/building-your-first-mcp-server-how-to-extend-ai-tools-with-custom-capabilities/) appeared first on [The GitHub Blog](https://github.blog).",
  "ProcessedDate": "2025-08-22 17:10:10",
  "FeedLevelAuthor": "The GitHub Blog",
  "Title": "Building your first MCP server: How to extend AI tools with custom capabilities",
  "Tags": [
    "AI & ML",
    "GitHub Copilot",
    "Rubber Duck Thursdays"
  ],
  "Author": "Chris Reddington"
}
