{
  "ProcessedDate": "2025-09-09 22:09:22",
  "PubDate": "2025-09-09T22:00:00+00:00",
  "Description": "Connect commits to artifacts without switching tools.\n\nThe post [How to use the GitHub and JFrog integration for secure, traceable builds from commit to production](https://github.blog/enterprise-software/devsecops/how-to-use-the-github-and-jfrog-integration-for-secure-traceable-builds-from-commit-to-production/) appeared first on [The GitHub Blog](https://github.blog).",
  "EnhancedContent": "Today, we’re introducing a new integration between GitHub and JFrog that connects your source code and your attested binaries in one secure, traceable workflow.\n\nFor developers who often find themselves jumping between multiple tools to figure out which commit produced which artifact — or piecing together results from separate security scans for code and binaries — this integration can save time and effort, centralizing everything you need all in one place.\n\nBelow, we’ll dig into why the GitHub and JFrog integration is important, how it works, and how you can start using it today.\n\n## Why we built the GitHub and JFrog integration\n\nModern software delivery is a supply chain. Your source code, build pipelines, and production artifacts are all links in that chain — and every link needs to be secure, traceable, and automated. Likewise, any weak link is a point of ingress for bad actors to gain access to data that should remain private and secure.\n\nBut keeping this complete supply chain secure is challenging for developers who have numerous (and continually growing) responsibilities. When we talked to teams shipping at scale, we kept hearing the same pain points:\n\n- “We lose traceability once the build leaves GitHub.”\n- “Security scanning is split between multiple systems, and we have to reconcile results manually.”\n- “Our CI/CD pipelines feel stitched together instead of seamless.”\n\nTo address these issues, we worked closely with JFrog’s engineers to design a workflow where the commit that triggers a build is cryptographically linked to the artifact it produces, security scanning happens automatically and in context — providing the vulnerability scan attestations located in JFrog Evidence, and publishing and promoting artifacts, in compliance with an organization’s policies, is just another step in your GitHub Actions workflow, not a separate process.\n\nOur goal: to remove friction, reduce risk, and give developers more time to focus on building features instead of managing handoffs.\n\nThe integration we’re announcing today unlocks a seamless experience that lets you:\n\n- **Run unified security scans,** prioritizing Dependabot alerts based on production context from JFrog.\n- **Publish and promote artifacts** using policy-based gating of artifact promotion.\n- **Automatically** have all attestations created on GitHub (provenance, SBOM, custom attestations) ingested into JFrog evidence and associated with the build artifact.\n\n## Here’s how it works\n\nThe integration connects GitHub’s developer platform with JFrog’s software supply chain platform using secure authentication and build metadata.\n\n**Here’s the flow:**\n\n1. Push code to GitHub.\n2. Build and test with GitHub Actions.\n3. Link commits, builds, and artifacts for full lifecycle visibility.\n4. Publish artifacts to Artifactory automatically.\n5. Scan code with GitHub Advanced Security and artifacts with JFrog Xray.\n\n![Diagram showing the GitHub and JFrog integration.](https://github.blog/wp-content/uploads/2025/09/jfrog1.png?resize=1024%2C658)\n\n## Setting it up\n\n1. Enable the GitHub integration in JFrog Artifactory by navigating to Administration → General Management → Manage Integrations → GitHub. Toggle “Enable GitHub Actions” and authenticate your GitHub organization. Select your token type. Then create a pull request.\n\n![JFrog Artifactory integration screen.](https://github.blog/wp-content/uploads/2025/09/jfrog2.jpg?resize=1024%2C576)\n1. Trigger a build of your GitHub Actions workflow to build the artifact and generate the attestation. Make sure that your GitHub Actions workflow is using the ‘jfrog/jfrog-setup-cli’ and ‘actions/attest-build-provenance’ actions.\n\n```\n- name: Attest docker image\nuses: actions/attest-build-provenance@v2 with: subject-name: oci://${{ env.JF_REGISTRY }}/${{ env.IMAGE_NAME }} subject-digest: ${{ steps.build-and-push.outputs.digest }} ```\n\nHere’s an example of a workflow that you can use to generate the attestation and push it to Artifactory:\n\n``` name: Build, Test & Attest\n\non: push: branches:\n- main\n\nenv: OIDC_PROVIDER_NAME: [...] JF_URL: ${{ vars.JF_URL }} JF_REGISTRY: ${{ vars.JF_REGISTRY }} JF_DOCKER_REPO: [...] IMAGE_NAME: [...] BUILD_NAME: [...]\n\njobs: build-test-deploy: runs-on: ubuntu-latest permissions: contents: read packages: write attestations: write # Required for attestation id-token: write # Added for OIDC token access\n\nsteps:\n- name: Checkout code\nuses: actions/checkout@v5\n\n- name: Install JFrog CLI\nid: setup-jfrog-cli uses: jfrog/setup-jfrog-cli@v4.5.13 env: JF_URL: ${{ env.JF_URL }} with: version: 2.78.8 oidc-provider-name: ${{ env.OIDC_PROVIDER_NAME }}\n\n- name: Docker login\nuses: docker/login-action@v3 with: registry: ${{ env.JF_REGISTRY }} username: ${{ steps.setup-jfrog-cli.outputs.oidc-user }} password: ${{ steps.setup-jfrog-cli.outputs.oidc-token }}\n\n- name: Set up Docker Buildx\nuses: docker/setup-buildx-action@v3\n\n- name: Build and push Docker image\nid: build-and-push uses: docker/build-push-action@v6 with: context: . push: true tags: ${{ env.JF_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.run_number }} build-args: ${{ env.BUILD_ARGS }}\n\n- name: Attest docker image\nuses: actions/attest-build-provenance@v2 with: subject-name: oci://${{ env.JF_REGISTRY }}/${{ env.IMAGE_NAME }} subject-digest: ${{ steps.build-and-push.outputs.digest }} ```\n\n1. Once the build has run and the attestation has been generated, it will push the artifact to the JFrog Artifactory staging repo. The artifact is now ready to be validated.\n\n![Artifactory view of the attestation in the dev environment.](https://github.blog/wp-content/uploads/2025/09/jfrog3.png?resize=1024%2C310)\n1. Once the artifact has been verified, confirming that a valid GitHub-signed provenance matches the trusted conditions (for example the issuer, repo, workflow, branch), on the policy passing, JFrog can automatically promote the attestation from the dev environment to the production environment.\n2. Now that artifacts have been promoted to production, Dependabot continues scanning  its source repository, looking for dependencies and vulnerabilities. When a critical CVE is discovered, administrators will receive an alert of the security threat.\n\n![View of critical Dependabot alerts.](https://github.blog/wp-content/uploads/2025/09/jfrog4.jpg?resize=1024%2C692)\n1. To find the alerts and vulnerabilities for artifacts that made it to production, we can filter with the following tag: `artifact-registry:jfrog-artifactory`\n.\n\nWith this integration enabled, artifact lifecycle data is automatically pushed from JFrog to GitHub using [GitHub’s new artifact metadata API](https://docs.github.com/en/rest/orgs/artifact-metadata?apiVersion=2022-11-28#create-artifact-metadata-storage-records). When an artifact is promoted to production in JFrog Artifactory, JFrog will automatically notify GitHub about the promotion, so that the artifact is picked up with the new Dependabot filter.\n\n![Dependabot filter for JFrog.](https://github.blog/wp-content/uploads/2025/09/jfrog5.jpg?resize=1024%2C387)\n1. Once an alert has been identified, it can be remediated using the suggested dependency update, which then allows you to rebuild and redeploy with fresh provenance.\n\nTo get the most out of using GitHub and Jfrog Artifactory, here are a few best practices:\n\n- **Use OIDC** to avoid long-lived credentials in your workflows.\n- **Automate promotions** in Artifactory to move artifacts from dev → staging → production.\n- **Set security gates early** so unattested or vulnerable builds never make it to production.\n- **Leverage provenance attestations** in JFrog Evidence for instant traceability.\n\n## What’s next\n\nYou can enable the GitHub and JFrog integration today to start building a more secure, automated, and traceable software supply chain.\n\nFor more details, check out the[JFrog integration guide](https://jfrog.com/help/r/jfrog-and-github-integration-guide/jfrog-for-github-dependabot) and the[GitHub documentation](https://docs.github.com/en/code-security/securing-your-organization/understanding-your-organizations-exposure-to-vulnerabilities/prioritizing-dependabot-alerts-using-production-context).",
  "Author": "April Yoho",
  "FeedUrl": "https://github.blog/feed/",
  "FeedLevelAuthor": "The GitHub Blog",
  "Link": "https://github.blog/enterprise-software/devsecops/how-to-use-the-github-and-jfrog-integration-for-secure-traceable-builds-from-commit-to-production/",
  "Title": "How to use the GitHub and JFrog integration for secure, traceable builds from commit to production",
  "OutputDir": "_news",
  "FeedName": "The GitHub Blog",
  "Tags": [
    "compliance",
    "DevSecOps",
    "Enterprise software",
    "supply chain security"
  ]
}
