{
  "Description": "Learn how to configure Copilot coding agent’s environment, optimize project structure, use custom instructions, and extend its capabilities with MCP servers.\n\nThe post [Onboarding your AI peer programmer: Setting up GitHub Copilot coding agent for success](https://github.blog/ai-and-ml/github-copilot/onboarding-your-ai-peer-programmer-setting-up-github-copilot-coding-agent-for-success/) appeared first on [The GitHub Blog](https://github.blog).",
  "ProcessedDate": "2025-08-05 07:42:19",
  "OutputDir": "_news",
  "Title": "Onboarding your AI peer programmer: Setting up GitHub Copilot coding agent for success",
  "Author": "Christopher Harrison",
  "Link": "https://github.blog/ai-and-ml/github-copilot/onboarding-your-ai-peer-programmer-setting-up-github-copilot-coding-agent-for-success/",
  "FeedName": "The GitHub Blog",
  "EnhancedContent": "We often describe GitHub Copilot as an AI peer programmer, or an AI member of the team. With agentic features like coding agent, you can assign issues to Copilot, and it will diligently get to work behind the scenes, creating a proposed solution to the problem, all without even asking for a cup of coffee.\n\nMuch of the initial setup for Copilot coding agent is similar to onboarding a new developer – like providing good documentation and streamlining the setup process. But since it’s AI, there are a few things that make Copilot unique as a team member (aside from it not needing caffeine).\n\nSo let’s explore how this is done. We’ll start by examining the flow Copilot coding agent follows, and key strategies to ensure Copilot has the resources it needs to generate the best possible pull request.\n\n## Inside Copilot coding agent’s workflow: From issue to ready‑to‑review pull request\n\nWhen you assign an issue to Copilot, it follows a set pattern:\n\n1. Creates a branch for the code it will create.\n2. Creates a pull request to track its work and communicate with the team.\n3. Creates a contained environment for its work (running inside GitHub Actions).\n4. Reads the issue or prompt to understand the requested task.\n5. Explores the project to determine the best approach to tackle the problem.\n6. Works iteratively toward a solution.\n7. Finalizes its work, updates the pull request, and notifies the team the pull request is ready to be reviewed.\n\nBy understanding this flow, we can work to ensure Copilot is set up for success.\n\nThe first two steps — creating the pull request and branch — are self-contained, and there’s no additional work for us to do to help Copilot.\n\nSo, let’s skip right to the third step — the environment — where we can configure everything Copilot might need in the environment where it’ll write the code and run tasks as it generates the pull request.\n\n## Configure Copilot’s environment with GitHub Actions\n\nIn keeping with the analogy of onboarding a new developer, let’s consider the environment in which GitHub Copilot — or really any developer — does its work. Before you’re able to be productive, you need specific services, libraries, and frameworks installed.\n\nCopilot is the exact same. In order for Copilot to add a new feature and run the necessary tests to ensure everything works, it needs access to all the tooling the rest of your team has. We’ll do this with a custom workflow file.\n\nCoding agent uses a container running inside [GitHub Actions](https://docs.github.com/en/actions). If you’re not already familiar with Actions, it’s our automation platform, and is configured using YAML files, which describe the necessary tasks that need to be completed.\n\n[Actions is often used for CI/CD](https://github.blog/enterprise-software/ci-cd/build-ci-cd-pipeline-github-actions-four-steps/), so tasks like testing, deployment, etc. In this case, Actions hosts the container coding agent will use for its work. And we can take advantage of the ability to script tasks in YAML to ensure said container is set up correctly!\n\n| 💡**Pro tip**: There’s a good chance you already have a workflow for creating an environment, which could be used for development — say like the one used when running various tests or validation scripts. You can absolutely [reuse those workflows](https://docs.github.com/en/actions/how-tos/sharing-automations/reuse-workflows) for Copilot coding agent’s environment! | | --- |\n\n### Example Copilot setup workflow file\n\nTo do this, create a new [workflow file](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions) located at **.github/workflows/copilot-setup-steps.yml** with a job titled `copilot-setup-steps` . Inside the job, you’ll list all of the steps to install the necessary requirements for the environment. Let’s say, for example, we’re building a Python app that uses SQLite. We could have a workflow file like the following, which will be run to set up the environment for Copilot:\n\n``` name: \"Copilot Setup Steps\"\n\n# Automatically run the setup steps when they are changed\n# Allows for streamlined validation,\n# and allow manual testing through the repository's \"Actions\" tab\n\non: workflow_dispatch: push: paths:\n- .github/workflows/copilot-setup-steps.yml\npull_request: paths:\n- .github/workflows/copilot-setup-steps.yml\n\njobs:\n# The job MUST be called `copilot-setup-steps`\n# otherwise it will not be picked up by Copilot.\ncopilot-setup-steps: runs-on: ubuntu-latest\n\n# Permissions set just for the setup steps\n# Copilot has permissions to its branch\n\npermissions:\n# To allow us to clone the repo for setup\ncontents: read\n\n# The setup steps - install Python and our dependencies\nsteps:\n- name: Checkout code\nuses: actions/checkout@v4\n\n- name: Set up Python\nuses: actions/setup-python@v4 with: python-version: \"3.13\" cache: \"pip\"\n\n- name: Install Python dependencies\nrun: pip install -r requirements.txt\n\n- name: Install SQLite\nrun: sudo apt update && sudo apt install sqlite3 ```\n\nWhenever an issue is assigned to Copilot, it will run this workflow to configure its environment so it’ll have everything it needs!\n\n| 💡 **Pro tip**: If you know something should be done a particular way, tell Copilot! In our above example, Copilot could install the requisite services on its own. However, doing so may lead to unexpected versions or other mistakes. As I always like to joke, don’t be passive aggressive with Copilot. 😀 | | --- |\n\n## Set Copilot up for success with well-written issues and prompts\n\nSpeaking of not being passive aggressive, now’s the perfect time to focus on the next step Copilot follows: reading the issue. This will be Copilot’s entry point into creating the pull request you’ll later review. Remember that the more clearly defined the issue, the better quality the pull request.\n\nThe best approach is to think about how *you’d* like to see the first issue you’re assigned on a new project. Chances are, you’d appreciate the following:\n\n- Clearly defined problem statement or user story\n- If it’s a bug, the full error message, stack trace, or output, and steps to reproduce the problem\n- Any relevant history or approaches that have been tried previously\n- Suggestions on how to approach the issue\n\nThe same holds true with Copilot. Let’s say you needed to migrate a set of tests from **unittest** to **pytest**. Sure,Copilot could likely figure out the best approach on its own, but taking a couple of minutes to write out a good issue goes a long way to ensuring Copilot’s PR will be accepted and merged into your codebase.\n\nHere’s an example of a good issue (for developers and Copilot, alike!):\n\n``` Title: Migrate server tests from unittest to pytest\n\nBody:\n\nWe are looking to migrate from unittest to pytest to take advantage of some pytest specific features.\n\nRequirements:\n\n- A new folder called `migrated_tests` will be created with the new pytest tests.\n- All existing unittests are rewritten using pytest style in the `migrated_tests` folder, keeping the exact same functionality and code coverage.\n- Documentation is updated, highlighting the migration and steps required to run the new tests.\n- All new tests pass.\n\nExisting resources:\n\n- All existing tests exist in `server/tests`\n- There is a script at `scripts/run-server-tests.sh` which is used to run tests and generate code coverage reports\n\nRecommended approach:\n\n- Explore existing tests to determine their functionality\n- Read the coverage reports to determine existing code coverage\n- Recreate the tests one by one, testing along the way, to ensure compatibility\n- Run all tests at the end to ensure everything passes\n- Generate a code coverage report to demonstrate code coverage has been maintained\n- Generate documentation of the migration and how to run the new tests\n```\n\n## Make your repository welcoming (for developers and AI)\n\nLet’s stick with the analogy of onboarding a developer to a new team and project, something I’ve done a handful of times throughout my career.\n\nWhen I am onboarding somewhere new, I get my laptop set up and try to overcome my first-day-of-school butterflies — because I know there’s a lot of work to be done. Setting aside a conversation about my anxiety, let’s explore everything I need to do in order to be productive.\n\nFirst, I need to figure out where, and how, my code should be created. What’s the project structure? What are the rules and guidelines that need to be followed? Are we using tabs or spaces? (The right answer, of course, is spaces.)\n\nGitHub Copilot needs to know these same things! Fortunately, standard best practices around documentation and project structure will help Copilot the same way it helps developers.\n\n| 💡**Pro tip**: Understanding how Copilot tackles problems can help you improve how you use it. Here’s how to do that: On the PR Copilot created you’ll see a **View session** button that shows you everything Copilot did (or is doing if the session is currently active). This is both a great way to validate Copilot’s work and see how it approaches tasks. You can then use this information to further refine your approach to assigning tasks and configuring Copilot’s environment. | | --- |\n\n### Optimize project structure and docs so Copilot finds the right info fast\n\nLet’s say we assign an issue to Copilot, and ask it to add search functionality to an app. When Copilot takes on an issue, the first thing it does is explore the codebase. It’ll look for README files, and, unlike this developer, actually reads the documentation to learn about the project before writing code. It’ll perform searches in the codebase for anything related to interacting with the database, and read through the files it discovers. Then it’ll get to work.\n\nThis is the same approach you’d likely take as a developer if you were assigned the task. So ensuring the project structure has the resources and entities to make it as welcoming to new developers as possible sets up everyone (including your AI teammates) for success.\n\nThis includes having a robust and up-to-date README for the project and services, comments in code to describe what and how operations are performed, and good practices followed in naming classes, functions and variables. Additionally, having a logical project structure that follows accepted best practices in folder names and entity groupings will provide a more predictable environment for Copilot (and the rest of your team).\n\n## Document institutional knowledge with Copilot custom instructions\n\nOne of the best ways to provide guidance to Copilot is through the use of [custom instructions](https://docs.github.com/en/copilot/how-tos/custom-instructions/adding-repository-custom-instructions-for-github-copilot). Custom instructions are just like they sound: a set of instructions specifically for Copilot. They can be about the various rules and guidelines you have around formatting code, or the institutional knowledge that all developers “inherently know,” but isn’t written down anywhere.\n\nCopilot coding agent supports two types of instructions files: **copilot-instructions.md**, which are repository-wide and applied to all requests, and **&lt;file-name&gt;.instructions.md**, which can be targeted at specific types of files.\n\n### Repository level instructions files\n\nRepository level instructions filed, stored in **.github/copilot-instructions.md** in the codebase, house notes which are generally relevant to all requests made to Copilot. Some key pieces of information to include would be:\n\n- An overview of what you’re building, and how you’re building it\n- Any overarching user stories\n- Frameworks and libraries in use\n- The project structure, highlighting key files and folders\n- Global coding guidelines and rules\n\nIn the example below, note how we’ve started with a quick overview of the app, the expected flow for the user, frameworks and rules, and the resources available.\n\n```\n# Classic arcade\n\nThis project hosts a classic arcade, themed after the 1980s 8-bit games.\n\n## Standard player flow\n\n1. Player opens app and sees list of games.\n2. Player selects game to play.\n3. Player sees a splash screen with the message \"Insert quarter\".\n4. Player presses space to start game and plays game\n6. After game ends, the \"Game over\" message is displayed.\n7. The player score is checked against high scores. If the score is in top 10, user is prompted for their initials (3 initials).\n8. High scores are displayed, and an option to return to the main menu to start over again.\n\n## Frameworks\n\n- Python `arcade` library is used for the arcade itself\n- SQLite is used to store all scores\n\n## Coding guidelines\n\n- All games must inherit from `BaseGame`\n- Python code should follow PEP8 practices, including docstrings and type hints\n\n## Project structure\n\n- `data`: Stores data abstraction layer and SQLite database\n- `games`: Stores collection of games and `BaseGame`\n- `app`: Stores core app components including menuing system\n```\n\nEverything documented in the Copilot instructions document above could likely be figured out by Copilot as it does its investigation. But listing your requirements and resources helps ensure it has the right information, especially since there’s likely code that deviates from the accepted best practices of your organization.\n\n**&gt; Note**: This author’s code is always perfect, so that isn’t applicable to me, of course. 😉\n\n### Targeted instructions files\n\nObviously the code that resides in a unit test is very different from code in a data abstraction layer, which is very different from … While having repository-wide instructions is powerful, we typically have rules around specific types of files as well. Copilot coding agent supports this through the use of [**&lt;file-name&gt;.instructions.md**](https://docs.github.com/en/enterprise-cloud@latest/copilot/how-tos/configure-custom-instructions/add-repository-instructions#using-one-or-more-instructionsmd-files-1) files, which reside in the codebase in the **.github/instructions/** folder (or subfolders inside of there).\n\nThese targeted instructions files can contain an `applyTo` section, which allows you to set a glob pattern to identify the files to which the rules should apply. Sticking with the scenario from above — building out a classic arcade — we might have all games in a **games** folder as Python files. The pattern we’d use would be `**/games/*.py` . Within that section, you can add instructions specific to these files, such as which base class to inherit from and any testing requirements.. An example **.github/instructions/game.instructions.py** might look like the following:\n\n``` --- applyTo: **/games/*.py ---\n\n## Resources and requirements\n\n- All games inherit from `BaseGame`\n- Unit tests are required for all games, focused on core functionality\n- When adding a new game to the arcade ensure sample high scores are added to the database\n\n## Arcade framework notes\n\n- `rectangle` is always abbreviated as `rect` in the framework\n- The `BaseGame` class contains numerous abstractions to streamline game creation\n```\n\nNotice how we’re listing requirements and resources. We also added a note about `rectangle` being abbreviated as `rect` , which is there to help Copilot with common mistakes it might make.\n\n| 💡**Pro tip**: Instructions files are a great way to guide Copilot in the right direction when you see it making particular types of mistakes. | | --- |\n\n### A closing thought on instructions files\n\nInvesting time in creating a robust set of instructions files will both aid Copilot when you use it in the IDE and when you assign tasks to Copilot coding agent. In fact, there’s a good chance you’re already familiar with the concepts in this section if you’re experienced with Copilot. Because these become artifacts in the project, they’ll continue to pay dividends in both productivity and suggestion quality.\n\n## Extend Copilot with MCP to give it more context and tools\n\nAll developers need a helping hand at some point. It might be retrieving a specific discussion from your GitHub repository to learn more about the history of a feature, or looking up the syntax for implementing a particular algorithm or block of code.\n\nAI agents can perform these tasks by using MCP, or Model Context Protocol. [MCP is an open standard from Anthopic designed to help AI connect to key services and tools](https://github.blog/ai-and-ml/llms/what-the-heck-is-mcp-and-why-is-everyone-talking-about-it/). This helps AI agents execute tasks on your behalf — but it also allows you to give the model more context by connecting it to more sources of data and information (like GitHub!).\n\nHere’s why this matters: GitHub Copilot can [use MCP servers](https://docs.github.com/en/copilot/how-tos/agents/copilot-coding-agent/extending-copilot-coding-agent-with-mcp)! By default, two MCP servers are available when you use its coding agent: [GitHub](https://github.com/github/github-mcp-server?tab=readme-ov-file#remote-github-mcp-server) and [Playwright](https://github.com/microsoft/playwright-mcp?tab=readme-ov-file#playwright-mcp). The former allows Copilot to interact with your repository, searching for issues and other information while the latter allows Copilot to generate [Playwright tests](https://github.blog/changelog/2025-07-02-copilot-coding-agent-now-has-its-own-web-browser/) for end-to-end or acceptance testing.\n\n### Example: Azure MCP server for Bicep generation\n\nLet’s take [Azure Bicep](https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/overview?tabs=bicep) as an example, which is a domain-specific language (DSL) for defining Azure resources. To do its best work with a DSL, like Azure Bicep, Copilot benefits from a virtual helping hand in generating the code. Fortunately, there’s an [Azure MCP server](https://github.com/Azure/azure-mcp?tab=readme-ov-file) available that Copilot can use to get a bit of support.\n\nIf your team is already using MCP servers for the project in VS Code, the existing **.vscode/mcp.json** file in your project can be used by Copilot to identify MCP servers! Otherwise, you can configure [MCP servers specifically for Copilot coding agent](https://docs.github.com/en/copilot/how-tos/agents/copilot-coding-agent/extending-copilot-coding-agent-with-mcp#adding-your-configuration-to-your-repository) in the **Settings** tab of your project, under **Copilot** then **Coding agent**, where you’ll have a textbox to paste in the JSON.\n\nKeeping with our example of wanting to better support Bicep creation, the JSON below enables the Azure MCP server while specifying we only want Bicep schema support.\n\n``` { \"mcpServers\": { \"AzureBicep\": { \"type\": \"local\", \"command\": \"npx\", \"args\": [ \"-y\", \"@azure/mcp@latest\", \"server\", \"start\", \"--namespace\", \"bicepschema\", \"--read-only\" ] } } } ```\n\n## Manage internet access and data exfiltration risks with Copilot’s firewall\n\nYou may have noticed the **type** option in the previous MCP example is set to **local**. This means that the server will be accessed inside the container without Copilot needing to contact an external service. But this also implies the possibility of a **remote** server, which begs the question: Is Copilot allowed to access the internet? And if so, how can we control it?\n\n[Copilot coding agent has a default firewall](https://docs.github.com/en/copilot/how-tos/agents/copilot-coding-agent/customizing-or-disabling-the-firewall-for-copilot-coding-agent), which effectively limits Copilot’s access to core services, such as package hosting services like **npm** and **pip**. This helps you manage data exfiltration risks. For instance, if malicious instructions are somehow given to GitHub Copilot, it could lead to code or other sensitive information being leaked to remote locations.\n\nIf you are adding a remote MCP server, or need to allow Copilot to access internet resources, [you will need to update the firewall, which you can do by updating the allow list](https://docs.github.com/en/copilot/how-tos/agents/copilot-coding-agent/customizing-or-disabling-the-firewall-for-copilot-coding-agent#allowlisting-additional-hosts-in-the-agents-firewall). This is available under your repository’s settings, inside **Copilot,** then **Coding agent** (conveniently, that’s the same screen as configuring your MCP servers!).\n\n## Welcome to the team, Copilot!\n\nJust like any good teammate, GitHub Copilot coding agent thrives when it’s set up for success! By investing a little time upfront to configure its environment, craft clear issues, optimize your project, and leverage custom instructions and MCP servers, you’ll empower Copilot to deliver its best work.\n\nWith these tips in your arsenal, you’ll be well on your way to getting higher quality pull requests from Copilot coding agent, and a more productive development experience.\n\nReady to see the magic happen? [**Learn more about GitHub Copilot**](https://github.com/features/copilot)!\n\nAs for me, I need to refill my coffee cup.\n\n**Learn how** to assign and complete issues with [coding agent in GitHub Copilot &gt;](https://github.blog/ai-and-ml/github-copilot/assigning-and-completing-issues-with-coding-agent-in-github-copilot/)",
  "FeedLevelAuthor": "The GitHub Blog",
  "PubDate": "2025-07-31T17:12:43+00:00",
  "Tags": [
    "agentic workflows",
    "AI & ML",
    "generative AI",
    "GitHub Copilot"
  ],
  "FeedUrl": "https://github.blog/feed/"
}
