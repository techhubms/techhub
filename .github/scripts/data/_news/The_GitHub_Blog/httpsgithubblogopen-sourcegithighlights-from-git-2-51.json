{
  "Tags": [
    "Git",
    "Open Source"
  ],
  "FeedUrl": "https://github.blog/feed/",
  "Description": "The open source Git project just released Git 2.51. Here is GitHub’s look at some of the most interesting features and changes introduced since last time.\n\nThe post [Highlights from Git 2.51](https://github.blog/open-source/git/highlights-from-git-2-51/) appeared first on [The GitHub Blog](https://github.blog).",
  "Title": "Highlights from Git 2.51",
  "ProcessedDate": "2025-08-18 17:12:39",
  "PubDate": "2025-08-18T17:04:36+00:00",
  "Link": "https://github.blog/open-source/git/highlights-from-git-2-51/",
  "EnhancedContent": "The open source Git project [just released Git 2.51](http://tbd) with features and bug fixes from over 91 contributors, 21 of them new. We last caught up with you on the latest in Git back [when 2.50 was released](https://github.blog/open-source/git/highlights-from-git-2-50/).\n\nTo celebrate this most recent release, here is GitHub’s look at some of the most interesting features and changes introduced since last time.\n\n## Cruft-free multi-pack indexes\n\nReturning readers will have likely seen our coverage of [cruft packs](https://git-scm.com/docs/cruft-packs/2.37.0), [multi-pack indexes](https://git-scm.com/docs/multi-pack-index/2.50.0) (MIDXs), and [reachability bitmaps](https://github.blog/2015-09-22-counting-objects/). In case you’re new around here or otherwise need a refresher, here’s a brief overview:\n\nGit stores repository contents as “[objects](https://git-scm.com/book/en/v2/Git-Internals-Git-Objects)” (blobs, trees, commits), either individually (“loose” objects, e.g. `$GIT_DIR/objects/08/10d6a05...` ) or grouped into “[packfiles](https://git-scm.com/book/en/v2/Git-Internals-Packfiles)” (`$GIT_DIR/objects/pack` ). Each pack has an [index](https://git-scm.com/docs/gitformat-pack/2.44.0#_version_2_pack_idx_files_support_packs_larger_than_4_gib_and) (`*.idx` ) that maps object hashes to offsets. With many packs, lookups slow down to `O(M*log(N))` , (where `M` is the number of packs in your repository, and `N` is the number of objects within a given pack).\n\nA MIDX works like a pack index but covers the objects across multiple individual packfiles, reducing the lookup cost to `O(log(N))` , where `N` is the total number of objects in your repository. We [use MIDXs at GitHub](https://github.blog/engineering/scaling-monorepo-maintenance/) to store the contents of your repository after splitting it into multiple packs. We also use MIDXs to store a collection of reachability bitmaps for some selection of commits to quickly determine which object(s) are reachable from a given commit1.\n\nHowever, we store unreachable objects separately in what is known as a “cruft pack”. Cruft packs were meant to exclude unreachable objects from the MIDX, but we realized pretty quickly that doing so was impossible. The exact reasons are spelled out in [this commit](https://github.com/git/git/commit/ddee3703b36e96056f11ddc4621707b6054bab48), but the gist is as follows: if a once-unreachable object (stored in a cruft pack) later becomes reachable from some bitmapped commit, but the only copy of that object is stored in a cruft pack outside of the MIDX, then that object has no bit position, making it impossible to write a reachability bitmap.\n\nGit 2.51 introduces a change to how the non-cruft portion of your repository is packed. When generating a new pack, Git [used to exclude any object](https://git-scm.com/docs/git-pack-objects/2.49.0#Documentation/git-pack-objects.txt---stdin-packs) which appeared in at least one pack that would not be deleted during a repack operation, including cruft packs. In 2.51, Git now [will store additional copies](https://git-scm.com/docs/git-pack-objects/2.51.0#Documentation/git-pack-objects.txt---stdin-packs) of objects (and their ancestors) whose only other copy is within a cruft pack. Carrying this process out repeatedly guarantees that the set of non-cruft packs does not have any object which reaches some other object not stored within that set of packs. (In other words, the set of non-cruft packs is closed under reachability.)\n\nAs a result, Git 2.51 has [a new `repack.MIDXMustContainCruft` configuration](https://git-scm.com/docs/git-config/2.51.0#Documentation/git-config.txt-repackmidxMustContainCruft) which uses the new repacking behavior described above to store cruft packs outside of the MIDX. Using this at GitHub has allowed us to write significantly smaller MIDXs, in a fraction of the time, and resulting in faster repository read performance overall. (In our primary monorepo, MIDXs shrunk by about 38%, we wrote them 35% faster, and improved read performance by around 5%.)\n\nGive cruft-less MIDXs a try today using the new `repack.MIDXMustContainCruft` configuration option.\n\n[[source](https://github.com/git/git/compare/a636d395ff0b0ccecb4569c0fc80f7c55f2e5f2e...5ee86c273bfc83fa432910a13c6ce28b74361896)]\n\n## Smaller packs with path walk\n\nIn Git 2.49, we talked about [Git’s new “name-hash v2” feature](https://github.blog/open-source/git/highlights-from-git-2-49/#faster-packing-with-name-hash-v2), which changed the way that Git selects pairs of objects to delta-compress against one another. The full details are covered in that post, but here’s a quick gist. When preparing a packfile, Git computes a [hash](https://en.wikipedia.org/wiki/Hash_function) of all objects based on their filepath. Those hashes are then used to sort the list of objects to be packed, and Git uses a sliding window to search between pairs of objects to identify good delta/base candidates.\n\nPrior to 2.49, Git used [a single hash function](https://github.com/git/git/blob/v2.48.0/pack-objects.h#L191-L209) based on the object’s filepath, with a heavy bias towards the last 16 characters of the path. That hash function, dating back [all the way to 2006](https://github.com/git/git/commit/ce0bd64299ae148ef61a63edcac635de41254cb5), works well in many circumstances, but can fall short when, say, unrelated blobs appear in paths whose final 16 characters are similar. Git 2.49 introduced a [new hash function](https://github.com/git/git/blob/v2.49.0/pack-objects.h#L211-L237) which takes more of the directory structure into account2, resulting in [significantly smaller packs](https://github.com/git/git/commit/30696be71f64ca3764b1d334927da927d6d8df78) in some circumstances.\n\nGit 2.51 takes the spirit of that change and goes a step further by introducing a new way to collect objects when repacking, called “path walk”. Instead of walking objects in [revision order](https://git-scm.com/docs/MyFirstObjectWalk#_changing_the_order) with Git emitting objects with their corresponding path names along the way, the path walk approach emits all objects from a given path at the same time. This approach avoids the name-hash heuristic altogether and can look for deltas within groups of objects that are known to be at the same path.\n\nAs a result, Git can generate packs using the path walk approach that are often significantly smaller than even those generated with the new name hash function described above. Its timings are competitive even with generating packs using the existing revision order traversal.\n\nTry it out today by repacking with the new `--path-walk` command-line option.\n\n[[source](https://github.com/git/git/compare/60f9bc3e30ad38678434b46389f9acb644f94189...c178b02e29f7e3d4033893af9fad8477c9b99be9)]\n\n## Stash interchange format\n\nIf you’ve ever needed to switch to another branch, but wanted to save any uncommitted changes, you have likely used `git stash` . The [stash](https://git-scm.com/docs/git-stash) command stores the state of your working copy and index, and then restores your local copy to match whatever was in `HEAD` at the time you stashed.\n\nIf you’ve ever wondered how Git actually stores a stash entry, then this section is for you. Whenever you push something onto your stash, Git creates three3 commits behind the scenes. There are two commits generated which capture the staged and unstaged changes. The staged changes represent whatever was in your index at the time of stashing, and the working directory changes represent everything you changed in your local copy but didn’t add to the index. Finally, Git creates a third commit listing the other two as its parents, capturing the entire snapshot.\n\nThose internally generated commits are stored in the special `refs/stash` ref, and multiple stash entries are managed with the [reflog](https://git-scm.com/docs/git-reflog/2.51.0). They can be accessed with `git stash list` , and so on. Since there is only one stash entry in `refs/stash` at a time, it’s extremely cumbersome to migrate stash entries from one machine to another.\n\nGit 2.51 introduces a variant of the internal stash representation that allows multiple stash entries to be represented as a sequence of commits. Instead of using the first two parents to store changes from the index and working copy, this new representation adds one more parent to refer to the previous stash entry. That results in stash entries that contain four4 parents, and can be treated like an ordinary log of commits.\n\nAs a consequence of that, you can now export your stashes to a single reference, and then push or pull it like you would a normal branch or tag. Git 2.51 makes this easy by introducing two new sub-commands to git stash to import and export, respectively. You can now do something like:\n\n``` $ git stash export --to-ref refs/stashes/my-stash $ git push origin refs/stashes/my-stash ```\n\non one machine to push the contents of your stash to origin, and then:\n\n``` $ git fetch origin '+refs/stashes/*:refs/stashes/*' $ git stash import refs/stashes/my-stash ```\n\non another, preserving the contents of your stash between the two.\n\n[[source](https://github.com/git/git/compare/a013680162522425ab74d12f1d0cd4df1a389383...bc303718cc288b54233b204ce88223a16fb38487)]\n\n## All that…\n\nNow that we’ve covered some of the larger changes in more detail, let’s take a quicker look at a selection of some other new features and updates in this release.\n\n- If you’ve ever scripted around the object contents of your repository, you have no doubt encountered `git cat-file`\n, Git’s dedicated tool to print the raw contents of a given object.\n\n`git cat-file` also has specialized `--batch` and `--batch-check` modes, which take a sequence of objects over stdin and print each object’s information (and contents, in the case of `--batch` ). For example, here’s some basic information about the `README.md` file in Git’s own repository.\n\n``` $ echo HEAD:README.md | git.compile cat-file --batch-check d87bca1b8c3ebf3f32deb557ae9796ddc5b792ca blob 3662 ```\n\nHere, Git is telling us the object ID, type, and size for the object we specified, just as we expect. `cat-file` produces the same information for tree and commit objects. But what happens if we give it the path to a submodule? Prior to Git 2.51, `cat-file` would just print `missing` . But Git 2.51 improves this output, making `cat-file` more useful in a new variety of scripting scenarios:\n\n``` [ pre-2.51 git ] $ echo HEAD:sha1collisiondetection | git cat-file --batch-check HEAD:sha1collisiondetection missing\n\n[ git 2.51 ] $ echo HEAD:sha1collisiondetection | git cat-file --batch-check 855827c583bc30645ba427885caa40c5b81764d2 submodule ```\n\n[[source](https://github.com/git/git/compare/5b124e7c16076ad4d34d93854f194a9bc3223bdd...b0b910e052b2c5a8036343c0475dbbb01add6be8)]\n- Back in our coverage of 2.28, we talked about Git’s new [changed-path Bloom feature](https://github.blog/open-source/git/highlights-from-git-2-28/#changed-path-bloom-filters). If you aren’t familiar with Bloom filters, or could use a refresher about how they’re used in Git, then read on.\n\nA [Bloom filter](https://en.wikipedia.org/wiki/Bloom_filter) is a probabilistic data structure that behaves like a [set](https://en.wikipedia.org/wiki/Set_%28abstract_data_type%29), with one difference. It can only tell you with 100% certainty whether an element is *not* in the set, but may have some false positives when indicating that an item is in the set.\n\nGit uses Bloom filters in its [commit-graph](https://git-scm.com/docs/commit-graph/2.51.0) data structure to store a probabilistic set of which paths were modified by that commit relative to its first parent. That allows history traversals like `git log origin -- path/to/my/file` to quickly skip over commits which are known not to modify that path (or any of its parents). However, because Git’s full [pathspec syntax](https://git-scm.com/docs/gitglossary/2.51.0#Documentation/gitglossary.txt-pathspec) is far more expressive than that, Bloom filters can’t always optimize pathspec-scoped history traversals.\n\nGit 2.51 addresses part of that limitation by adding support for using multiple pathspec items, like `git log -- path/to/a path/to/b` , which previously could not make use of changed-path Bloom filters. At the time of writing, there is [ongoing discussion](https://lore.kernel.org/git/20250807051243.96884-1-yldhome2d2@gmail.com/) about adding support for even more special cases.\n\n[[source](https://github.com/git/git/compare/0e8243a355a69035dac269528b49dc8c9bc81f8a...2a6ce090f27016d68ee6952809d98fe88ce53522)]\n- The modern equivalents of `git checkout`\n, known as `git switch` and `git restore` have been considered experimental since [their introduction back in Git 2.23](https://github.blog/open-source/git/highlights-from-git-2-23/). These commands delineate the many jobs that `git checkout` can perform into separate, more purpose-built commands. Six years later5, these commands are no longer considered experimental, making their command-line interface stable and backwards compatible across future releases.\n\n[[source](https://github.com/git/git/compare/fab596878c5bdac7ea0a95c4d2acd758442c9eaf...f609dc4f7a7cc8b57435696cac1cd0b056f9e8b9)]\n- Even if you’re a veteran Git user, it’s not unlikely to encounter a new Git command (among the 144!6)  every once in a while. One such command you might not have heard of is `git whatchanged`\n, which behaves like its modern alternative `git log --raw` .\n\nThat command is now marked as deprecated with eventual plans to remove it in Git 3.0. As with other similar deprecations, you can still use this command behind the aptly-named `--i-still-use-this` flag7.\n\n[[source](https://github.com/git/git/compare/f0135a9047ca37d4d117dcf21f7e3e89fad85d00...e836757e14bf4fd617828d834d29e679e1f527c0)]\n- Speaking of Git 3.0, this release saw a few more entries added to [the `BreakingChanges`\nlist](https://github.com/git/git/blob/v2.51.0/Documentation/BreakingChanges.adoc). First, Git’s reftable backend (which we talked about extensively in [our coverage of Git 2.45](https://github.blog/open-source/git/highlights-from-git-2-45/#preliminary-reftable-support)) will become the new default format in repositories created with Git 3.0, when it is eventually released. Git 3.0 will also use the SHA-256 hash function as its default hash when initializing new repositories.\n\nThough there is no official release date yet planned for Git 3.0, you can get a feel for some of the new defaults by building Git yourself with the `WITH_BREAKING_CHANGES` flag.\n\n[[source](https://github.com/git/git/compare/50d9c342b401d8040cfc484774b38d12474bbe8e...793b14e1c833dd4ea0d85cdef53cc5ab38f7915e), [source](https://github.com/git/git/compare/90c0775e972847832ac8dfa6a14bc4c3abacd914...c79bb70a2e7d9158ec165ea16ad45371cd6e350d)]\n- Last but not least, a couple of updates on Git’s internal development process. Git has historically prioritized wide platform compatibility, and, as a result, has taken a conservative approach to adopting features from newer C standards. Though Git has required a C99-compatible compiler since [near the end of 2021](https://github.com/git/git/commit/7bc341e21b566c6685b7d993ca80459f9994be38), it has adopted features from that standard gradually, since some of the compilers Git targets only have partial support for the standard.\n\nOne example is [the `bool` keyword](https://port70.net/~nsz/c/c99/n1256.html#7.16), which became part of the C standard in C99. Here, the project began experimenting with the `bool` keyword back [in late 2023](https://github.com/git/git/commit/8277dbe9872205be1588ddfbf01d5439847db1d9). This release declares that experiment a success and now permits the use of `bool` throughout its codebase. This release also began documenting C99 features that the project is [using experimentally](https://github.com/git/git/blob/v2.51.0/Documentation/CodingGuidelines#L304-L310) along with C99 features that the project [doesn’t use](https://github.com/git/git/blob/v2.51.0/Documentation/CodingGuidelines#L312-L322).\n\nFinally, this release saw an update to Git’s guidelines on submitting patches, which have historically required contributions to be non-anonymous, and submitted under a contributor’s legal name. Git now aligns more closely with [the Linux kernel’s approach](https://github.com/torvalds/linux/commit/d4563201f33a022fc0353033d9dfeb1606a88330), to permit submitting patches with an identity other than the contributor’s legal name.\n\n[[source](https://github.com/git/git/compare/97e14d99f6def189b0f786ac6207b792ca3197b1...f006e0323ee4b407bee3e0ff241d9d3f7a03b66a), [source](https://github.com/git/git/compare/8ad370f6683516954bc2f131c3474b0bd3fccc9c...9b2527caa4886dd9c7a1e4fb943f7c6484542c45), [source](https://github.com/git/git/compare/8c7817c36129dea04e761d5284768edca06518c6...1f0fed312a40620b9f33f712d180a3c649e91e27)]\n\n## …and a bag of chips\n\nThat’s just a sample of changes from the latest release. For more, check out the release notes for [2.51](https://github.com/git/git/blob/v2.51.0/Documentation/RelNotes/2.51.0.adoc), or [any previous version](https://github.com/git/git/tree/v2.51.0/Documentation/RelNotes) in [the Git repository](https://github.com/git/git).\n\n1 For some bit position (corresponding to a single object in your repository,) a `1` means that object can be reached from that bitmap’s associated commit, and a `0` means it is not reachable from that commit. There are also four type-level bitmaps (for blobs, trees, commits, and annotated tags); the `XOR` of those bitmaps is the all `1` s bitmap. For more details on multi-pack reachability bitmaps, check out our previous post on [*Scaling monorepo maintenance*](https://github.blog/2021-04-29-scaling-monorepo-maintenance/). ⤴️\n\n2 For the curious, each layer of the directory is hashed individually, then downshifted and `XOR` ed into the overall result. This results in a hash function which is more sensitive to the whole path structure, rather than just the final 16 characters. ⤴️\n\n3 Usually. Git will sometimes generate a fourth commit if you stashed untracked (new files that haven’t yet been committed) or ignored files (that match one or more patterns in a `.gitignore` ). ⤴️\n\n4 Or five. ⤴️\n\n5 Almost to the day; Git 2.23 was released on August 16, 2019, and Git 2.51 was released on August 18, 2025. ⤴️\n\n6 It’s true; `git --list-cmds=builtins | wc -l` outputs “144” with Git 2.51. ⤴️\n\n7 If you are somehow a diehard `git whatchanged` user, please let us know by sending a message to [the Git mailing list](https://lore.kernel.org/git). ⤴️",
  "FeedLevelAuthor": "The GitHub Blog",
  "Author": "Taylor Blau",
  "FeedName": "The GitHub Blog",
  "OutputDir": "_news"
}
