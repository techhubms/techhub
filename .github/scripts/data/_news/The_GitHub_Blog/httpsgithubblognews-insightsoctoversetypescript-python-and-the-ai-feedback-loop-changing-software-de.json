{
  "ProcessedDate": "2025-11-13 16:03:03",
  "Tags": [
    "agents",
    "AI",
    "GitHub Next",
    "LLMs",
    "News & insights",
    "Octoverse",
    "python",
    "Typescript",
    "WASM"
  ],
  "Link": "https://github.blog/news-insights/octoverse/typescript-python-and-the-ai-feedback-loop-changing-software-development/",
  "Author": "Alexandra Lietzke",
  "Description": "An interview with the leader of GitHub Next, Idan Gazit, on TypeScript, Python, and what comes next.\n\nThe post [TypeScript, Python, and the AI feedback loop changing software development](https://github.blog/news-insights/octoverse/typescript-python-and-the-ai-feedback-loop-changing-software-development/) appeared first on [The GitHub Blog](https://github.blog).",
  "EnhancedContent": "When people talk about AI and software development, the focus usually lands on productivity: faster pull requests, fewer boilerplate chores, auto-generated tests, autocomplete that feels psychic. But according to Idan Gazit, who leads [GitHub Next](https://githubnext.com/)—the team behind Copilot and GitHub’s long-range R&D—that’s the shallow end of the change curve.\n\nThe deeper shift is happening *before* a single line of code is written.\n\n“AI isn’t just changing how we write code,” Gazit says. “It’s starting to change what we choose to build with in the first place.”\n\nThat shift is [already visible in this year’s Octoverse report](https://github.blog/news-insights/octoverse/octoverse-a-new-developer-joins-github-every-second-as-ai-leads-typescript-to-1/?utm_source=octoverse-homepage&amp;utm_medium=blog&amp;utm_campaign=universe25). In 2025, TypeScript overtook both JavaScript and Python as the most-used language on GitHub—a 66% year-over-year surge and the biggest language movement in more than a decade.\n\nBut the story isn’t “TypeScript beats Python.” It’s that AI is beginning to shape language trends from the inside out.\n\nThe last generation of change was about *where* code runs: cloud, containers, CI/CD, open source ecosystems.The next one is about *what code is made of*, and why those choices suddenly have different stakes.\n\nTypeScript passed Python. But the real story is *why.*\n\nDevelopers don’t usually switch languages just for philosophical reasons—they switch when something makes their work meaningfully faster, simpler, or less risky. And increasingly, what feels “easier” is tied to how well AI tools will support their work with that language.\n\n“Statically typed languages give you guardrails,” Gazit says. “If an AI tool is going to generate code for me, I want a fast way to know whether that code is correct. Explicit types give me that safety net.”\n\nTyped languages reduce hallucination surface area. They also give models more structure to reason about during generation. That’s not a theoretical benefit. It’s now a behavioral signal in the data:\n\n- AI models tend to perform better on languages which expose information about correctness, like a type system\n- Developers using AI tools are more likely to adopt typed languages for new projects\n- The more teams rely on AI assistance, the more language choice becomes an *AI-compatibility decision*, not merely a personal preference\n\nThat shift sets up a feedback loop.\n\nAI assistance is a new consideration when developers are selecting languages and frameworks\n\nAI models are strongest at authoring code in popular languages: TypeScript, Python, Java, and Go, just to name a few.\n\n“If the model has seen a trillion examples of TypeScript and only thousands of Haskell, it’s just going to be better at TypeScript,” Gazit says. “That changes the incentive before you even start coding.”\n\n> >\n> If an AI tool is going to generate code for me, I want a fast way to know whether that code is correct. Explicit types give me that safety net.\n> >\n> Idan Gazit, head of GitHub Next\n\nBefore AI, picking a language was a tradeoff between runtime, library ecosystem, and personal fluency. After AI, a new constraint appears: How much lift will the model give me if I choose this language?\n\n“Python is the dominant language for machine learning, data science, and model training,” Gazit says. “Why would I not choose the one that already has the most robust frameworks and libraries? Those are wheels I don’t need to reinvent.” So TypeScript isn’t winning *against* Python; each is winning in the situations where it is the right tool for the job, *and* where AI makes it more valuable.\n\nThe surprise winners of the AI era: the “duct tape” languages\n\nOne of the most unexpected signals in the Octoverse data wasn’t about TypeScript or Python—it was about Bash.\n\nShell scripting saw **+206% year-over-year growth in AI-generated projects.** So what gives?\n\nBecause AI makes painful languages *tolerable*.\n\n“Very few developers love writing Bash,” Gazit says. “But everybody needs it. It’s the duct tape of software. And now that I can ask an agent to write the unpleasant parts for me, I can use the right tool for the job without weighing that tradeoff.” If AI automates the drudgery layer of programming, the question stops being *“Is this language enjoyable?”* and becomes *“should I consider using it when I don’t have to write the code myself?”*\n\n> >\n> Very few developers love writing Bash. But everybody needs it. It’s the duct tape of software. And now that I can ask an agent to write the unpleasant parts for me, I can use the right tool for the job without weighing that tradeoff.\n> >\n\nEnterprises aren’t asking “Should we adopt AI?” anymore. They’re asking “What happens after we do?”\n\n“A lot of enterprises have been sitting on the sidelines, waiting to see when the water is warm enough to jump in,” Gazit says. “Now they’re seeing the value: junior developers ramp faster, and senior developers spend less time on toil and more on architecture.”\n\nThat creates second-order effects:\n\n| **Before AI** | **After AI** | | --- | --- | | Skill measured by lines of code | Skill measured by validation, architecture, debugging | | Juniors slow to ship | Juniors ship faster than seniors can review | | Senior devs write the hardest code | Senior devs now *judge* the hardest code | | Tooling was mostly a matter of taste—IDEs, linters, build setups, etc. | Tooling now defines the *surface area* AI can operate on: the wrong stack can block or limit agentic assistance |\n\nTyped languages accelerate this shift—the stronger the safety rails, the more work can be handed to automation.\n\nThe next horizon: when language stops being a constraint\n\nToday, language choice matters because runtimes are still fragmented. Browsers require JavaScript. Models need Python. Firmware expects C.\n\nBut that’s already eroding.\n\n“WebAssembly is starting to change the rules,” Gazit says. “If any language can target Wasm and run everywhere, that removes one key consideration when picking your stack.”\n\nCombine that with AI-generated code, and you get a plausible future:\n\n- Developer writes in Rust (or Go, or Python)\n- AI generates code in that language\n- Compiler targets Wasm\n- The same code runs on web, edge, cloud, local sandbox\n\nThat’s not a TypeScript-wins future. It’s a *portability-wins* future, and a natural extension to the rise of containerization over the last decade as a means of packaging and running software.\n\nLanguages may end up competing less on syntax, and more on ecosystem leverage: package depth, tooling maturity, model familiarity, debugging ergonomics. We’re not fully in that world yet, but the early signals from AI-driven tooling to Wasm-powered portability suggest it’s coming faster than most teams expect.\n\nWhat developers should actually take from this\n\nThis isn’t a “learn TypeScript now” blog (there are enough of those out there, to be sure).\n\nHere are the signals that matter:\n\n| **Shift** | **What it really means** | | --- | --- | | Typed languages rising | AI benefits from structure | | Python stays dominant in AI | Ecosystems outlast language/framework fashions | | Shell scripts up +206% | AI removes pain barriers, not just productivity barriers | | Enterprises adopting AI fast | The definition of “senior engineer” is changing next | | WebAssembly maturing | Language loyalty gets replaced by language interoperability |\n\nThe takeaway isn’t about switching stacks. It’s about **optimizing for leverage, not loyalty.**\n\nThe languages and tools that survive the next decade won’t be the ones developers love most—they’ll be the ones that give developers *and* machines the most shared advantage.\n\n**Looking to stay one step ahead?**\n\n[Read the latest Octoverse report](https://github.blog/news-insights/octoverse/octoverse-a-new-developer-joins-github-every-second-as-ai-leads-typescript-to-1/?utm_source=octoverse-cli-announcement&amp;utm_medium=octoverse&amp;utm_campaign=universe25post) and [consider trying Copilot CLI.](https://github.com/features/copilot/cli?utm_source=octoverse-cli-cta&amp;utm_medium=octoverse&amp;utm_campaign=universe25post)\n\n**More resources:**\n\n- Watch [Idan’s interview](https://youtu.be/MQOaBXwRfYo)\n- Learn more about [GitHub Next](https://githubnext.com/) and the future of developer tools",
  "FeedUrl": "https://github.blog/feed/",
  "Title": "TypeScript, Python, and the AI feedback loop changing software development",
  "FeedLevelAuthor": "The GitHub Blog",
  "OutputDir": "_news",
  "FeedName": "The GitHub Blog",
  "PubDate": "2025-11-13T16:00:00+00:00"
}
