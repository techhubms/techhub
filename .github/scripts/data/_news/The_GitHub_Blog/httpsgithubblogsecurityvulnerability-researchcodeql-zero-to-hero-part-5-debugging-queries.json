{
  "Link": "https://github.blog/security/vulnerability-research/codeql-zero-to-hero-part-5-debugging-queries/",
  "Author": "Sylwia Budzynska",
  "FeedName": "The GitHub Blog",
  "FeedUrl": "https://github.blog/feed/",
  "OutputDir": "_news",
  "PubDate": "2025-09-29T15:00:00+00:00",
  "Title": "CodeQL zero to hero part 5: Debugging queries",
  "Tags": [
    "code scanning",
    "CodeQL",
    "GitHub Security Lab",
    "Security",
    "Vulnerability research"
  ],
  "ProcessedDate": "2025-09-29 15:03:00",
  "Description": "Learn to debug and fix your CodeQL queries.\n\nThe post [CodeQL zero to hero part 5: Debugging queries](https://github.blog/security/vulnerability-research/codeql-zero-to-hero-part-5-debugging-queries/) appeared first on [The GitHub Blog](https://github.blog).",
  "FeedLevelAuthor": "The GitHub Blog",
  "EnhancedContent": "When you‚Äôre first getting started with CodeQL, you may find yourself in a situation where a query doesn‚Äôt return the results you expect. Debugging these queries can be tricky, because CodeQL is a Prolog-like language with an evaluation model that‚Äôs quite different from mainstream languages like Python. This means you can‚Äôt ‚Äústep through‚Äù the code, and techniques such as attaching gdb or adding print statements don‚Äôt apply. Fortunately, CodeQL offers a variety of built-in features to help you diagnose and resolve issues in your queries.\n\nBelow, we‚Äôll dig into these features ‚Äî from an abstract syntax tree (AST) to partial path graphs ‚Äî using questions from CodeQL users as examples. And if you ever have questions of your own, you can visit and ask in GitHub Security Lab‚Äôs [public Slack instance](https://gh.io/securitylabslack), which is monitored by CodeQL engineers.\n\n## Minimal code example\n\nThe issue we are going to use was raised by user¬† `NgocKhanhC311` , and later a similar issue was raised from `zhou noel` . Both encountered difficulties writing a CodeQL query to detect a vulnerability in projects using the Gradio framework. Since I have personally added Gradio support to CodeQL ‚Äî and even wrote a blog about the process ([CodeQL zero to hero part 4: Gradio framework case study](https://github.blog/security/vulnerability-research/codeql-zero-to-hero-part-4-gradio-framework-case-study/)), which includes an introduction to Gradio and its attack surface ‚Äî I jumped in to answer.\n\n`zhou noel` wanted to detect variants of an unsafe deserialization vulnerability that was found in [browser-use/web-ui v1.6](https://github.com/browser-use/web-ui/tree/v1.6).¬† See the simplified code below.\n\n``` import pickle import gradio as gr\n\ndef load_config_from_file(config_file): \"\"\"Load settings from a UUID.pkl file.\"\"\" try: with open(config_file.name, 'rb') as f: settings = pickle.load(f) return settings except Exception as e: return f\"Error loading configuration: {str(e)}\"\n\nwith gr.Blocks(title=\"Configuration Loader\") as demo: config_file_input = gr.File(label=\"Load Config File\")\n\nload_config_button = gr.Button(\"Load Existing Config From File\", variant=\"primary\")\n\nconfig_status = gr.Textbox(label=\"Status\")\n\nload_config_button.click( fn=load_config_from_file, inputs=[config_file_input], outputs=[config_status] )\n\ndemo.launch() ```\n\nUsing the `load_config_button.click` event handler (from `gr.Button` ), a user-supplied file `config_file_input` (of type `gr.File` ) is passed to the `load_config_from_file` function, which reads the file with `open(config_file.name, 'rb')` , and loads the file‚Äôs contents using `pickle.load` .\n\nThe vulnerability here is more of a ‚Äúsecond order‚Äù vulnerability. First, an attacker uploads a malicious file, then the application loads it using `pickle` . In this example, our source is `gr.File` . When using `gr.File` , the uploaded file is stored locally, and the path is available in the name attribute¬† `config_file.name` .¬† Then the app opens the file with `open(config_file.name, 'rb') as f:` and loads it using¬† pickle `pickle.load(f)` , leading to unsafe deserialization.\n\nWhat a pickle! üôÇ\n\nIf you‚Äôd like to test the vulnerability, create a new folder with the code, call it `example.py` , and then run:\n\n``` python -m venv venv source venv/bin/activate pip install gradio python example.py ```\n\nThen, follow [these steps to create a malicious pickle file to exploit the vulnerability](https://snyk.io/articles/python-pickle-poisoning-and-backdooring-pth-files/).\n\nThe user wrote a CodeQL taint tracking query, which at first glance should find the vulnerability.\n\n``` /**\n* @name Gradio unsafe deserialization\n* @description This query tracks data flow from inputs passed to a Gradio's Button component to any sink.\n* @kind path-problem\n* @problem.severity warning\n* @id 5/1\n*/ import python import semmle.python.ApiGraphs import semmle.python.Concepts import semmle.python.dataflow.new.RemoteFlowSources import semmle.python.dataflow.new.TaintTracking\n\nimport MyFlow::PathGraph\n\nclass GradioButton extends RemoteFlowSource::Range { GradioButton() { exists(API::CallNode n | n = API::moduleImport(\"gradio\").getMember(\"Button\").getReturn() .getMember(\"click\").getACall() | this = n.getParameter(0, \"fn\").getParameter(_).asSource()) }\n\noverride string getSourceType() { result = \"Gradio untrusted input\" } }\n\nprivate module MyConfig implements DataFlow::ConfigSig { predicate isSource(DataFlow::Node source) { source instanceof GradioButton }\n\npredicate isSink(DataFlow::Node sink) { exists(Decoding d | sink = d) } } module MyFlow = TaintTracking::Global<MyConfig>;\n\nfrom MyFlow::PathNode source, MyFlow::PathNode sink where MyFlow::flowPath(source, sink) select sink.getNode(), source, sink, \"Data Flow from a Gradio source to decoding\" ```\n\nThe source is set to any parameter passed to function in a `gr.Button.click` event handler. The sink is set to any sink of type `Decoding` . In CodeQL for Python, the `Decoding` type includes unsafe deserialization sinks, such as the first argument to `pickle.load` .\n\nIf you run the query on the database, you won‚Äôt get any results.\n\nTo figure out most CodeQL query issues, I suggest trying out the following options, which we‚Äôll go through in the next sections of the blog:\n\n- Make a minimal code example and create a CodeQL database of it to reduce the number of results.\n- Simplify the query into [predicates](https://github.blog/developer-skills/github/codeql-zero-to-hero-part-2-getting-started-with-codeql/#predicates) and [classes](https://github.blog/developer-skills/github/codeql-zero-to-hero-part-2-getting-started-with-codeql/#classes), making it easier to run the specific parts of the query, and check if they provide the expected results.\n- Use [quick evaluation](https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/running-codeql-queries#running-a-specific-part-of-a-query-or-library) on the simplified predicates.\n- View the [abstract syntax tree](https://docs.github.com/en/code-security/codeql-for-vs-code/using-the-advanced-functionality-of-the-codeql-for-vs-code-extension/exploring-the-structure-of-your-source-code) of your codebase to see the expected CodeQL type for a given code element, and how to query for it.\n- Call the `getAQlClass`\npredicate to identify what types a given code element is.\n- Use a partial path graph to see where taint stops propagating.\n- Write a taint step to help the taint propagate further.\n\n## Creating a CodeQL database\n\nUsing our minimal code example, we‚Äôll create a CodeQL database, similarly to how we did it [in CodeQL ZtH part 4](https://github.blog/security/vulnerability-research/codeql-zero-to-hero-part-4-gradio-framework-case-study/#preparing-example-codeql-database-for-testing), and run the following command in the directory that contains only the minimal code example.\n\n``` codeql database create codeql-zth5 --language=python ```\n\nThis command will create a new directory, `codeql-zth5` , with the CodeQL database. Add it to your CodeQL workspace and then we can get started.\n\n## Simplifying the query and quick evaluation\n\nThe query is already simplified into predicates and classes, so we can quickly evaluate it using the `Quick evaluation` button over the predicate name, or by right-clicking on the predicate name and choosing `CodeQL: Quick evaluation` .\n\n![CodeQL taint tracking query, with `Quick Evaluation: isSource` button over the `isSource` predicate.](https://github.blog/wp-content/uploads/2025/09/image1_7a2639.png?resize=982%2C210)\n\nClicking `Quick Evaluation` over the `isSource` and `isSink` predicate shows a result for each, which means that both source and sink were found correctly. Note, however, that the `isSink` result highlights the whole `pickle.load(f)` call, rather than just the first argument to the call. Typically, we prefer to set a sink as an argument to a call, not the call itself.\n\nIn this case, the `Decoding` abstract sinks have a `getAnInput` predicate, which specifies the argument to a sink call. To differentiate between normal `Decoding` sinks (for example, `json.loads` ), and the ones that could execute code (such as `pickle.load` ), we can use the `mayExecuteInput` predicate.\n\n``` predicate isSink(DataFlow::Node sink) { exists(Decoding d | d.mayExecuteInput() | sink = d.getAnInput()) } ```\n\nQuick evaluation of the `isSink` predicate gives us one result.\n\n![VS Code screenshot with one result from running the query](https://github.blog/wp-content/uploads/2025/09/image2_b12c0e.png?resize=1024%2C316)\n\nWith this, we verified that the sources and sinks are correctly reported. That means there‚Äôs an issue between the source and sink, which CodeQL can‚Äôt propagate through.\n\n## Abstract Syntax Tree (AST) viewer\n\nWe haven‚Äôt had issues identifying the source or sink nodes, but if there were an issue with identifying the source or sink nodes, it would be helpful to examine the abstract syntax tree (AST) of the code to determine the type of a particular code element.\n\nAfter you run `Quick Evaluation` on `isSink` , you‚Äôll see the file where CodeQL identified the sink. To see the abstract syntax tree for the file, right-click the code element you‚Äôre interested in and select `CodeQL: View AST` .\n\n![Highlighted `CodeQL: View AST` option in a dropdown menu after right-clicking](https://github.blog/wp-content/uploads/2025/09/image3.png?resize=1024%2C747)\n\nThe option will display the AST of the file in the CodeQL tab in VS Code, under the AST Viewer section.\n\n![abstract syntax tree of the code with highlighted `\\[Call\\] pickle.load(f) line 8` node](https://github.blog/wp-content/uploads/2025/09/image4.png?resize=844%2C798)\n\nOnce you know the type of a given code element from the AST, it can be easier to write a query for the code element you‚Äôre interested in.\n\n## `getAQlClass`\npredicate\n\nAnother good strategy to figure out the type of a code element you‚Äôre interested in is to use `getAQlClass` predicate. Usually, it‚Äôs best to create a separate query, so you don‚Äôt clutter your original query.\n\nFor example, we could write a query to check the types of a parameter to the function fn passed to `gradio.Button.click` :\n\n``` /**\n* @name getAQlClass on Gradio Button input source\n* @description This query reports on a code element's types.\n* @id 5/2\n* @severity error\n* @kind problem\n*/\n\nimport python import semmle.python.ApiGraphs import semmle.python.Concepts import semmle.python.dataflow.new.RemoteFlowSources from DataFlow::Node node where node = API::moduleImport(\"gradio\").getMember(\"Button\").getReturn() .getMember(\"click\").getACall().getParameter(0, \"fn\").getParameter(_).asSource() select node, node.getAQlClass() ```\n\nRunning the query provides five results showing the types of the parameter: `FutureTypeTrackingNode` , `ExprNode` , `LocalSourceNodeNotModuleVariableNode` , `ParameterNode` , and `LocalSourceParameterNode` . From the results, the most interesting and useful types for writing queries are the `ExprNode` and `ParameterNode` .\n\n![VS Code screenshot with five results from running the query](https://github.blog/wp-content/uploads/2025/09/image5.png?resize=1024%2C275)\n\n## Partial path graph: forwards\n\nNow that we‚Äôve identified that there‚Äôs an issue with connecting the source to the sink, we should verify where the taint flow stops. We can do that using [partial path graphs](https://codeql.github.com/docs/writing-codeql-queries/debugging-data-flow-queries-using-partial-flow/), which show all the sinks the source flows toward and where those flows stop. This is also why having a minimal code example is so vital ‚Äî otherwise we‚Äôd get *a lot* of results.\n\nIf you do end up working on a large codebase, you should try to limit the source you‚Äôre starting with to, for example, a specific file with a condition akin to:\n\n``` predicate isSource(DataFlow::Node source) { source instanceof GradioButton and source.getLocation().getFile().getBaseName() = \"example.py\" } ```\n\nSee [other ways of providing location information](https://codeql.github.com/docs/writing-codeql-queries/providing-locations-in-codeql-queries/#using-extracted-location-information).\n\nPartial graphs come in two forms: forward `FlowExplorationFwd` , which traces flow from a given source to any sink, and backward/reverse `FlowExplorationRev` , which traces flow from a given sink back to any source.\n\nWe have public templates for partial path graphs in most languages for your queries in CodeQL Community Packs ‚Äî see [the template for Python](https://github.com/GitHubSecurityLab/CodeQL-Community-Packs/blob/main/python/src/debugging/PartialPathsFromSource.ql).\n\nHere‚Äôs how we would write a forward partial path graph query for our current issue:\n\n``` /**\n* @name Gradio Button partial path graph\n* @description This query tracks data flow from inputs passed to a Gradio's Button component to any sink.\n* @kind path-problem\n* @problem.severity warning\n* @id 5/3\n*/\n\nimport python import semmle.python.ApiGraphs import semmle.python.Concepts import semmle.python.dataflow.new.RemoteFlowSources import semmle.python.dataflow.new.TaintTracking\n\n// import MyFlow::PathGraph import PartialFlow::PartialPathGraph\n\nclass GradioButton extends RemoteFlowSource::Range { GradioButton() { exists(API::CallNode n | n = API::moduleImport(\"gradio\").getMember(\"Button\").getReturn() .getMember(\"click\").getACall() | this = n.getParameter(0, \"fn\").getParameter(_).asSource()) }\n\noverride string getSourceType() { result = \"Gradio untrusted input\" } }\n\nprivate module MyConfig implements DataFlow::ConfigSig { predicate isSource(DataFlow::Node source) { source instanceof GradioButton }\n\npredicate isSink(DataFlow::Node sink) { exists(Decoding d | d.mayExecuteInput() | sink = d.getAnInput()) }\n\n} module MyFlow = TaintTracking::Global<MyConfig>; int explorationLimit() { result = 10 } module PartialFlow = MyFlow::FlowExplorationFwd<explorationLimit/0>;\n\nfrom PartialFlow::PartialPathNode source, PartialFlow::PartialPathNode sink where PartialFlow::partialFlow(source, sink, _) select sink.getNode(), source, sink, \"Partial Graph $@.\", source.getNode(), \"user-provided value.\" ```\n\nWhat changed:\n\n- We commented out `import MyFlow::PathGraph`\nand instead `import PartialFlow::PartialPathGraph` .\n- We set `explorationLimit()`\nto `10` , which controls how deep the analysis goes. This is especially useful in larger codebases with complex flows.\n- We create a `PartialFlow`\nmodule with `FlowExplorationFwd` , meaning we are tracing flows from a specified source to any sink. If we want to start from a sink and trace back to any source, we‚Äôd use `FlowExplorationRev` with small changes in the query itself. [See template for `FlowExplorationRev`](https://github.com/GitHubSecurityLab/CodeQL-Community-Packs/blob/main/python/src/debugging/PartialPathsFromSink.ql).\n- Finally, we made changes to the from-where-select query to use `PartialFlow::PartialPathNodes`\n, and the `PartialFlow::partialFlow` predicate.\n\nRunning the query gives us one result, which ends at `config_file` in the `with open(config_file.name, 'rb') as f:` line. This means CodeQL didn‚Äôt propagate to the `name` attribute in `config_file.name` .\n\n![VS Code screenshot of a code path from def load_config_from_file(config_file) to config_file in open(config_file.name, 'rb') call](https://github.blog/wp-content/uploads/2025/09/image6.png?resize=1024%2C148)\n\nThe `config_name` here is an instance of `gr.File` , which has the `name` attribute, which stores the path to the uploaded file.\n\nQuite often, if an object is tainted, we can‚Äôt tell if all of its attributes are tainted as well. By default, CodeQL would not propagate to an object‚Äôs attributes. As such, we need to help taint propagate from an object to its `name` attribute by writing a taint step.\n\n## Taint step\n\nThe quickest way, though not the prettiest, would be to write a taint step to propagate from any object to that object‚Äôs `name` attribute. This is naturally not something we‚Äôd like to include in production CodeQL queries, since it might lead to false positives. For our use case it‚Äôs fine, since we are writing the query for security research.\n\nWe add a taint step into a taint tracking configuration by using an `isAdditionalFlowStep` predicate. This taint step will allow CodeQL to propagate to any read of a `name` attribute. We specify the two nodes that we want to connect ‚Äî `nodeFrom` and `nodeTo` ‚Äî and how they should be connected. `nodeFrom` is a node that accesses `name` attribute, and `nodeTo` is the node that represents the attribute read.\n\n``` predicate isAdditionalFlowStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) { exists(DataFlow::AttrRead attr | attr.accesses(nodeFrom, \"name\") and nodeTo = attr ) } ```\n\nLet‚Äôs make it a separate predicate for easier testing, and plug it into our partial path graph query.\n\n``` /**\n* @name Gradio Button partial path graph\n* @description This query tracks data flow from Gradio's Button component to any sink.\n* @kind path-problem\n* @problem.severity warning\n* @id 5/4\n*/\n\nimport python import semmle.python.ApiGraphs import semmle.python.Concepts import semmle.python.dataflow.new.RemoteFlowSources import semmle.python.dataflow.new.TaintTracking\n\n// import MyFlow::PathGraph import PartialFlow::PartialPathGraph\n\nclass GradioButton extends RemoteFlowSource::Range { GradioButton() { exists(API::CallNode n | n = API::moduleImport(\"gradio\").getMember(\"Button\").getReturn() .getMember(\"click\").getACall() | this = n.getParameter(0, \"fn\").getParameter(_).asSource()) }\n\noverride string getSourceType() { result = \"Gradio untrusted input\" } }\n\npredicate nameAttrRead(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) { // Connects an attribute read of an object's `name` attribute to the object itself exists(DataFlow::AttrRead attr | attr.accesses(nodeFrom, \"name\") and nodeTo = attr ) }\n\nprivate module MyConfig implements DataFlow::ConfigSig { predicate isSource(DataFlow::Node source) { source instanceof GradioButton }\n\npredicate isSink(DataFlow::Node sink) { exists(Decoding d | d.mayExecuteInput() | sink = d.getAnInput()) }\n\npredicate isAdditionalFlowStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) { nameAttrRead(nodeFrom, nodeTo) } } module MyFlow = TaintTracking::Global<MyConfig>; int explorationLimit() { result = 10 } module PartialFlow = MyFlow::FlowExplorationFwd<explorationLimit/0>;\n\nfrom PartialFlow::PartialPathNode source, PartialFlow::PartialPathNode sink where PartialFlow::partialFlow(source, sink, _) select sink.getNode(), source, sink, \"Partial Graph $@.\", source.getNode(), \"user-provided value.\" ```\n\nRunning the query gives us two results. In the second path, we see that the taint propagated to `config_file.name` , but not further. What happened?\n\n![VS Code screenshot of a code path from `def load_config_from_file(config_file)` to `config_file.name` in `open(config_file.name, 'rb')` call](https://github.blog/wp-content/uploads/2025/09/image7.png?resize=1024%2C241)\n\n## Taint step‚Ä¶ again?\n\nThe specific piece of code turned out to be a bit of a special case. I mentioned earlier that this vulnerability is essentially a ‚Äúsecond order‚Äù vulnerability ‚Äî we first upload a malicious file, then load that locally stored file. Generally in these cases it‚Äôs the path to the file that we consider as tainted, and not the contents of the file itself, so CodeQL wouldn‚Äôt normally propagate here. In our case, in Gradio, we do control the file that is being loaded.\n\nThat‚Äôs why we need another taint step to propagate from `config_file.name` to `open(config_file.name, 'rb')` .\n\nWe can write a predicate that would propagate from the argument to `open()` to the result of `open()` (and also from the argument to `os.open` to `os.open` call since we are at it).\n\n``` predicate osOpenStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) { // Connects the argument to `open()` to the result of `open()` // And argument to `os.open()` to the result of `os.open()` exists(API::CallNode call | call = API::moduleImport(\"os\").getMember(\"open\").getACall() and nodeFrom = call.getArg(0) and nodeTo = call) or exists(API::CallNode call | call = API::builtin(\"open\").getACall() and nodeFrom = call.getArg(0) and nodeTo = call) } ```\n\nThen we can add this second taint step to `isAdditionalFlowStep` .\n\n``` predicate isAdditionalFlowStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) { nameAttrRead(nodeFrom, nodeTo) or osOpenStep(nodeFrom, nodeTo) } ```\n\nLet‚Äôs add the taint step to a final taint tracking query, and make it a normal taint tracking query again.\n\n``` /**\n* @name Gradio File Input Flow\n* @description This query tracks data flow from Gradio's Button component to a Decoding sink.\n* @kind path-problem\n* @problem.severity warning\n* @id 5/5\n*/\n\nimport python import semmle.python.ApiGraphs import semmle.python.Concepts import semmle.python.dataflow.new.RemoteFlowSources import semmle.python.dataflow.new.TaintTracking\n\nimport MyFlow::PathGraph\n\nclass GradioButton extends RemoteFlowSource::Range { GradioButton() { exists(API::CallNode n | n = API::moduleImport(\"gradio\").getMember(\"Button\").getReturn() .getMember(\"click\").getACall() | this = n.getParameter(0, \"fn\").getParameter(_).asSource()) }\n\noverride string getSourceType() { result = \"Gradio untrusted input\" } } predicate nameAttrRead(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) { // Connects an attribute read of an object's `name` attribute to the object itself exists(DataFlow::AttrRead attr | attr.accesses(nodeFrom, \"name\") and nodeTo = attr ) }\n\npredicate osOpenStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) { // Connects the argument to `open()` to the result of `open()` // And argument to `os.open()` to the result of `os.open()` exists(API::CallNode call | call = API::moduleImport(\"os\").getMember(\"open\").getACall() and nodeFrom = call.getArg(0) and nodeTo = call) or exists(API::CallNode call | call = API::builtin(\"open\").getACall() and nodeFrom = call.getArg(0) and nodeTo = call) }\n\nprivate module MyConfig implements DataFlow::ConfigSig { predicate isSource(DataFlow::Node source) { source instanceof GradioButton }\n\npredicate isSink(DataFlow::Node sink) { exists(Decoding d | d.mayExecuteInput() | sink = d.getAnInput()) }\n\npredicate isAdditionalFlowStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) { nameAttrRead(nodeFrom, nodeTo) or osOpenStep(nodeFrom, nodeTo) } } module MyFlow = TaintTracking::Global<MyConfig>;\n\nfrom MyFlow::PathNode source, MyFlow::PathNode sink where MyFlow::flowPath(source, sink) select sink.getNode(), source, sink, \"Data Flow from a Gradio source to decoding\" ```\n\nRunning the query provides one result ‚Äî the vulnerability we‚Äôve been looking for! üéâ\n\n![VS Code screenshot of a code path from `def load_config_from_file(config_file)` to `f` in `pickle.load(f)` sink](https://github.blog/wp-content/uploads/2025/09/image8.png?resize=1024%2C368)\n\n## A prettier taint step\n\nNote that the CodeQL written in this section is very specific to Gradio, and you‚Äôre unlikely to encounter similar modeling in other frameworks. What follows is a more advanced version of the previous taint step, which I added for those of you who want to dig deeper into writing a more maintainable solution to this taint step problem. You are unlikely to need to write this kind of granular CodeQL as a security researcher, but if you use CodeQL at work, this section might come in handy.\n\nAs we‚Äôve mentioned, the taint step that propagates taint through a `name` attribute read on any object is a hacky solution. Not every object that propagates taint through `name` read would cause a vulnerability. We‚Äôd like to limit the taint step to only propagate similarly to this case ‚Äî only for `gr.File` type.\n\nBut we encounter a problem ‚Äî Gradio sources are modeled as any parameters passed to function in `gr.Button.click` event handlers, so CodeQL is not aware of what type a given argument passed to a function in `gr.Button.click` is. For that reason, we can‚Äôt easily write a straightforward taint step that would check if the source is of `gr.File` type before propagating to a `name` attribute.\n\nWe have to ‚Äúlook back‚Äù to where the source was instantiated, check its type, and later connect that object to a `name` attribute read.\n\nRecall our minimal code example.\n\n``` import pickle import gradio as gr\n\ndef load_config_from_file(config_file): \"\"\"Load settings from a UUID.pkl file.\"\"\" try: with open(config_file.name, 'rb') as f: settings = pickle.load(f) return settings except Exception as e: return f\"Error loading configuration: {str(e)}\"\n\nwith gr.Blocks(title=\"Configuration Loader\") as demo: config_file_input = gr.File(label=\"Load Config File\")\n\nload_config_button = gr.Button(\"Load Existing Config From File\", variant=\"primary\")\n\nconfig_status = gr.Textbox(label=\"Status\")\n\nload_config_button.click( fn=load_config_from_file, inputs=[config_file_input], outputs=[config_status] )\n\ndemo.launch() ```\n\nTaint steps work by creating an edge (a connection) between two specified nodes. In our case, we are looking to connect two sets of nodes, which are on the same path.\n\nFirst, we want CodeQL to connect the variables passed to `inputs` (here `config_file_input` ) in e.g. `gr.Button.click` and connect it to the parameter `config_file` in the `load_config_from_file` function. This way it will be able to propagate back to the instantiation, to `config_file_input = gr.File(label=\"Load Config File\")` .\n\nSecond, we want CodeQL to propagate from the nodes that we checked are of `gr.File` type, to the cases where they read the `name` attribute.\n\nFunnily enough, I‚Äôve already written a taint step, called [`ListTaintStep`](https://github.com/github/codeql/blob/4be995dc194f9d6df882b4fd99528398ae87436d/python/ql/lib/semmle/python/frameworks/Gradio.qll#L102) that can track back to the instantiations, and even [written a section in the previous CodeQL zero to hero about it](https://github.blog/security/vulnerability-research/codeql-zero-to-hero-part-4-gradio-framework-case-study/#taint-step). We can reuse the implemented logic, and add it to our query. We‚Äôll do it by modifying the `nameAttrRead` predicate.\n\n``` predicate nameAttrRead(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) { // Connects an attribute read of an object's `name` attribute to the object itself exists(DataFlow::AttrRead attr | attr.accesses(nodeFrom, \"name\") and nodeTo = attr ) and exists(API::CallNode node, int i, DataFlow::Node n1, DataFlow::Node n2 | node = API::moduleImport(\"gradio\").getAMember().getReturn().getAMember().getACall() and n2 = node.getParameter(0, \"fn\").getParameter(i).asSource() and n1.asCfgNode() = node.getParameter(1, \"inputs\").asSink().asCfgNode().(ListNode).getElement(i) and n1.getALocalSource() = API::moduleImport(\"gradio\").getMember(\"File\").getReturn().asSource() and (DataFlow::localFlow(n2, nodeFrom) or DataFlow::localFlow(nodeTo, n1)) ) } ```\n\nThe taint step connects any object to that object‚Äôs `name` read (like before). Then, it looks for the function passed to `fn` ,¬† variables passed to `inputs` in e.g. `gr.Button.click` and connects the variables in `inputs` to the parameters given to the function `fn` by using an integer `i` to keep track of position of the variables.\n\nThen, by using:\n\n``` nodeFrom.getALocalSource() = API::moduleImport(\"gradio\").getMember(\"File\").getReturn().asSource() ```\n\nWe check that the node we are tracking is of `gr.File` type.\n\n``` and (DataFlow::localFlow(n2, nodeFrom) or DataFlow::localFlow(nodeTo, n1) ```\n\nAt last, we check that there is a local flow (with any number of path steps) between the `fn` function parameter `n2` and an attribute read `nodeFrom` or that there is a local flow between specifically the `name` attribute read `nodeTo` , and a variable passed to `gr.Button.click` ‚Äôs `inputs` .\n\nWhat we did is essentially two taint steps (we connect, that is create edges between two sets of nodes) connected by local flow, which combines them into one taint step. The reason we are making it into one taint step is because one condition can‚Äôt exist without the other. We use `localFlow` because there can be several steps between the connection we made from variables passed to `inputs` to the function defined in `fn` in `gr.Button.click` and later reading the `name` attribute on an object. `localFlow` allows us to connect the two.\n\nIt looks complex, but it stems from how directed graphs work.\n\nFull CodeQL query:\n\n``` /**\n* @name Gradio File Input Flow\n* @description This query tracks data flow from Gradio's Button component to a Decoding sink.\n* @kind path-problem\n* @problem.severity warning\n* @id 5/6\n*/\n\nimport python import semmle.python.dataflow.new.DataFlow import semmle.python.dataflow.new.TaintTracking import semmle.python.Concepts import semmle.python.dataflow.new.RemoteFlowSources import semmle.python.ApiGraphs\n\nclass GradioButton extends RemoteFlowSource::Range { GradioButton() { exists(API::CallNode n | n = API::moduleImport(\"gradio\").getMember(\"Button\").getReturn() .getMember(\"click\").getACall() | this = n.getParameter(0, \"fn\").getParameter(_).asSource()) }\n\noverride string getSourceType() { result = \"Gradio untrusted input\" } }\n\npredicate nameAttrRead(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) { // Connects an attribute read of an object's `name` attribute to the object itself exists(DataFlow::AttrRead attr | attr.accesses(nodeFrom, \"name\") and nodeTo = attr ) and exists(API::CallNode node, int i, DataFlow::Node n1, DataFlow::Node n2 | node = API::moduleImport(\"gradio\").getAMember().getReturn().getAMember().getACall() and n2 = node.getParameter(0, \"fn\").getParameter(i).asSource() and n1.asCfgNode() = node.getParameter(1, \"inputs\").asSink().asCfgNode().(ListNode).getElement(i) and n1.getALocalSource() = API::moduleImport(\"gradio\").getMember(\"File\").getReturn().asSource() and (DataFlow::localFlow(n2, nodeFrom) or DataFlow::localFlow(nodeTo, n1)) ) } predicate osOpenStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) { exists(API::CallNode call | call = API::moduleImport(\"os\").getMember(\"open\").getACall() and nodeFrom = call.getArg(0) and nodeTo = call) or exists(API::CallNode call | call = API::builtin(\"open\").getACall() and nodeFrom = call.getArg(0) and nodeTo = call) }\n\nmodule MyConfig implements DataFlow::ConfigSig { predicate isSource(DataFlow::Node source) { source instanceof GradioButton }\n\npredicate isSink(DataFlow::Node sink) { exists(Decoding d | d.mayExecuteInput() | sink = d.getAnInput()) }\n\npredicate isAdditionalFlowStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo) { nameAttrRead(nodeFrom, nodeTo) or osOpenStep(nodeFrom, nodeTo) } }\n\nimport MyFlow::PathGraph\n\nmodule MyFlow = TaintTracking::Global<MyConfig>;\n\nfrom MyFlow::PathNode source, MyFlow::PathNode sink where MyFlow::flowPath(source, sink) select sink.getNode(), source, sink, \"Data Flow from a Gradio source to decoding\" ```\n\nRunning the taint step will return a full path from `gr.File` to `pickle.load(f)` .\n\nA taint step in this form could be contributed to CodeQL upstream. However, this is a very specific taint step, which makes sense for some vulnerabilities, and not others. For example, it works for an unsafe deserialization vulnerability like described in the article, but not for path injection. That‚Äôs because this is a ‚Äúsecond order‚Äù vulnerability ‚Äî we control the uploaded file, but not its path (stored in ‚Äúname‚Äù). For path injection vulnerabilities with sinks like `open(file.name, ‚Äòr‚Äô)` , this would be a false positive.\n\n## Conclusion\n\nSome of the issues we encounter on the [GHSL Slack](https://gh.io/securitylabslack) around tracking taint can be a challenge. Cases like these don‚Äôt happen often, but when they do, it makes them a good candidate for sharing lessons learned and writing a blog post, like this one.\n\nI hope my story of chasing taint helps you with debugging your queries. If, after trying out the tips in this blog, there are still issues with your query, feel free to ask for help on our public [GitHub Security Lab Slack instance](https://gh.io/securitylabslack) or in [github/codeql discussions](https://github.com/github/codeql/discussions)."
}
