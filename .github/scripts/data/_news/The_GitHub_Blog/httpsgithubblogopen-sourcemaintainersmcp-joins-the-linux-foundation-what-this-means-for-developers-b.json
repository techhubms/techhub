{
  "PubDate": "2025-12-09T21:00:13+00:00",
  "FeedName": "The GitHub Blog",
  "Tags": [
    "agentic AI",
    "agentic workflows",
    "Linux Foundation",
    "Maintainers",
    "MCP",
    "Open Source"
  ],
  "ProcessedDate": "2025-12-09 21:02:36",
  "FeedUrl": "https://github.blog/feed/",
  "Title": "MCP joins the Linux Foundation: What this means for developers building the next era of AI tools and agents",
  "OutputDir": "_news",
  "Author": "Martin Woodward",
  "Link": "https://github.blog/open-source/maintainers/mcp-joins-the-linux-foundation-what-this-means-for-developers-building-the-next-era-of-ai-tools-and-agents/",
  "FeedLevelAuthor": "The GitHub Blog",
  "EnhancedContent": "Over the past year, AI development has exploded. More than 1.1 million public GitHub repositories now import an LLM SDK (+178% YoY), and developers created nearly 700,000 new AI repositories, [according to this year’s Octoverse report](https://github.blog/news-insights/octoverse/octoverse-a-new-developer-joins-github-every-second-as-ai-leads-typescript-to-1/?utm_source=octoverse-homepage&amp;utm_medium=blog&amp;utm_campaign=universe25). Agentic tools like [vllm](http://github.com/vllm-project/vllm), [ollama](https://github.com/ollama/ollama?utm_campaign=universe25&amp;utm_medium=blog&amp;utm_source=octoverse-homepage), [continue](https://github.com/continuedev/continue), [aider](https://github.com/Aider-AI/aider), [ragflow](https://github.com/infiniflow/ragflow), and [cline](https://github.com/cline/cline) are quickly becoming part of the modern developer stack.\n\nAs this ecosystem expands, we’ve seen a growing need to connect models to external tools and systems—securely, consistently, and across platforms. That’s the gap the [Model Context Protocol](https://github.com/modelcontextprotocol) (MCP) has rapidly filled.\n\nBorn as an open source idea inside Anthropic, MCP grew quickly because it was open from the very beginning and designed for the community to extend, adopt, and shape together. That openness is a core reason it became one of the fastest-growing standards in the industry. That also allowed companies like GitHub and Microsoft to join in and help build out the standard.\n\nNow, [Anthropic is donating MCP to the Agentic AI Foundation, which will be managed by the Linux Foundation](https://www.anthropic.com/news/donating-the-model-context-protocol-and-establishing-of-the-agentic-ai-foundation), and the protocol is entering a new phase of shared stewardship. This will provide developers with a foundation for long-term tooling, production agents, and enterprise systems.  This is exciting for those of us who have been involved in the MCP community. And given our long-term support of the Linux Foundation, we are hugely supportive of this move.\n\nThe past year has seen incredible growth and change for MCP.  I thought it would be great to review how MCP got here, and what its transition to the Linux Foundation means for the next wave of AI development.\n\n## Before MCP: Fragmented APIs and brittle integrations\n\nLLMs started as isolated systems. You sent them prompts and got responses back. We would use patterns like retrieval-augmented generation (RAG) to help us bring in data to give more context to the LLM, but that was limited. OpenAI’s [introduction of function calling](https://openai.com/index/function-calling-and-other-api-updates/) brought about a huge change as, for the first time, you could call any external function. This is what we initially built on top of as part of GitHub Copilot.\n\nBy early 2023, developers were connecting LLMs to external systems through a patchwork of incompatible APIs: bespoke extensions, IDE plugins, and platform-specific agent frameworks, among other things. Every provider had its own integration story, and none of them worked in exactly the same way.\n\nNick Cooper, an OpenAI engineer and MCP steering committee member, summarized it plainly: “All the platforms had their own attempts like function calling, plugin APIs, extensions, but they just didn’t get much traction.”\n\nThis wasn’t a tooling problem. It was an architecture problem.\n\nConnecting a model to the realtime web, a database, ticketing system, search index, or CI pipeline required bespoke code that often broke with the next model update. Developers had to write deep integration glue one platform at a time.\n\nAs David Soria Parra, a senior engineer at Anthropic and one of the original architects of MCP, put it, the industry was running headfirst into an n×m integration problem with too many clients, too many systems, and no shared protocol to connect them.\n\nIn practical terms, the n×m integration problem describes a world where every model client (n) must integrate separately with every tool, service, or system developers rely on (m). This would mean five different AI clients talking to ten internal systems, resulting in fifty bespoke integrations—each with different semantics, authentication flows, and failure modes. MCP collapses this by defining a single, vendor-neutral protocol that both clients and tools can speak. With something like GitHub Copilot, where we are connecting to *all* of the frontier labs models and developers using Copilot, we also need to connect to hundreds of systems as part of their developer platform. This was not just an integration challenge, but an innovation challenge.\n\nAnd the absence of a standard wasn’t just inefficient; it slowed real-world adoption. In regulated industries like finance, healthcare, security, developers needed secure, auditable, cross-platform ways to let models communicate with systems. What they got instead were proprietary plugin ecosystems with unclear trust boundaries.\n\n## MCP: A protocol built for how developers work\n\nAcross the industry including at Anthropic, GitHub, Microsoft, and others, engineers kept running into the same wall: reliably connecting models to context and tools. Inside Anthropic, teams noticed that their internal prototypes kept converging on similar patterns for requesting data, invoking tools, and handling long-running tasks.\n\nSoria Parra described MCP’s origin simply: it was a way to standardize patterns Anthropic engineers were reinventing. MCP distilled those patterns into a protocol designed around communication, or how models and systems talk to each other, request context, and execute tools.\n\nAnthropic’s Jerome Swanwick recalled an early internal hackathon where “every entry was built on MCP … went viral internally.”\n\nThat early developer traction became the seed. Once [Anthropic released MCP publicly](https://www.anthropic.com/news/model-context-protocol) alongside high-quality reference servers, we saw the value immediately, and it was clear that the broader community understood the value immediately. MCP offered a shared way for models to communicate with external systems, regardless of client, runtime, or vendor.\n\n## Why MCP clicked: Built for real developer workflows\n\nWhen MCP launched, adoption was immediate and unlike any standard I have seen before.\n\nDevelopers building AI-powered tools and agents had already experienced the pain MCP solved. As Microsoft’s Den Delimarsky, a principal engineer and core MCP steering committee member focused on security and OAuth, said: “It just clicked. I got the problem they were trying to solve; I got why this needs to exist.”\n\nWithin weeks, contributors from Anthropic, Microsoft, GitHub, OpenAI, and independent developers began expanding and hardening the protocol. Over the next nine months, the community added:\n\n- OAuth flows for secure, remote servers\n- Sampling semantics (These help ensure consistent model behavior when tools are invoked or context is requested, giving developers more predictable execution across different MCP clients.)\n- Refined tool schemas\n- Consistent server discovery patterns\n- Expanded reference implementations\n- Improving long-running task support\n\nLong-running task APIs are a critical feature. They allow builds, indexing operations, deployments, and other multi-minute jobs to be tracked predictably, without polling hacks or custom callback channels. This was essential for the long-running AI agent workflows that we now see today.\n\nDelimarsky’s OAuth work also became an inflection point. Prior to it, most MCP servers ran locally, which limited usage in enterprise environments and caused installation friction. OAuth enabled remote MCP servers, unlocking secure, compliant integrations at scale. This shift is what made MCP viable for multi-machine orchestration, shared enterprise services, and non-local infrastructure.\n\nJust as importantly, OAuth gives MCP a familiar and proven security model with no proprietary token formats or ad-hoc trust flows. That makes it significantly easier to adopt inside existing enterprise authentication stacks.\n\nSimilarly, the MCP Registry—developed in the open by the MCP community with contributions and tooling support from Anthropic, GitHub, and others—gave developers a discoverability layer and gave enterprises governance control. Toby Padilla, who leads MCP Server and Registry efforts at GitHub, described this as a way to ensure “developers can find high-quality servers, and enterprises can control what their users adopt.”\n\nBut no single company drove MCP’s trajectory. What stands out across all my conversations with the community is the sense of shared stewardship.\n\nCooper articulated it clearly: “I don’t meet with Anthropic, I meet with David. And I don’t meet with Google, I meet with Che.” The work was never about corporate boundaries. It was about the protocol.\n\nThis collaborative culture, reminiscent of the early days of the web, is the absolute best of open source. It’s also why, in my opinion, MCP spread so quickly.\n\n## Developer momentum: MCP enters the Octoverse\n\nThe [2025 Octoverse report](https://github.blog/news-insights/octoverse/octoverse-a-new-developer-joins-github-every-second-as-ai-leads-typescript-to-1/?utm_source=octoverse-homepage&amp;utm_medium=blog&amp;utm_campaign=universe25), our annual deep dive into open source and public activity on GitHub, highlights an unprecedented surge in AI development:\n\n- 1.13M public repositories now import an LLM SDK (+178% YoY)\n- 693k new AI repositories were created this year\n- 6M+ monthly commits to AI repositories\n- Tools like [vllm](http://github.com/vllm-project/vllm), [ollama](https://github.com/ollama/ollama), [continue](https://github.com/continuedev/continue), [aider](https://github.com/Aider-AI/aider), [cline](https://github.com/cline/cline), and [ragflow](https://github.com/infiniflow/ragflow) dominated fastest-growing repos\n- Standards are emerging in real time with MCP alone, hitting 37k stars in under eight months\n\nThese signals tell a clear story: developers aren’t just experimenting with LLMs, they’re operationalizing them.\n\nWith hundreds of thousands of developers building AI agents, local runners, pipelines, and inference stacks, the ecosystem needs consistent ways to connect models to tools, services, and context.\n\nMCP isn’t riding the wave. The protocol aligns with where developers already are and where the ecosystem is heading.\n\n## The Linux Foundation move: The protocol becomes infrastructure\n\nAs MCP adoption accelerated, the need for neutral governance became unavoidable. Openness is what drove its initial adoption, but that also demands shared stewardship—especially once multiple LLM providers, tool builders, and enterprise teams began depending on the protocol.\n\nBy transitioning governance to the Linux Foundation, Anthropic and the MCP steering committee are signaling that MCP has reached the maturity threshold of a true industry standard.\n\nOpen, vendor-neutral governance offers everyone:\n\n### 1. Long-term stability\n\nA protocol is only as strong as its longevity. Linux Foundation’s backing reduces risk for teams adopting MCP for deep integrations.\n\n### 2. Equal participation\n\nWhether you’re a cloud provider, startup, or individual maintainer, Linux Foundation governance processes support equal contribution rights and transparent evolution.\n\n### 3. Compatibility guarantees\n\nAs more clients, servers, and agent frameworks rely on MCP, compatibility becomes as important as the protocol itself.\n\n### 4. The safety of an open standard\n\nIn an era where AI is increasingly part of regulated workloads, neutral governance makes MCP a safer bet for enterprises.\n\nMCP is now on the same path as technologies like Kubernetes, SPDX, GraphQL, and the CNCF stack—critical infrastructure maintained in the open.\n\nTaken together, this move aligns with [the Agentic AI Foundation](https://aaif.io/)’s intention to bring together multiple model providers, platform teams, enterprise tool builders, and independent developers under a shared, neutral process.\n\n## What MCP unlocks for developers today\n\nDevelopers often ask: “What do I actually get from adopting MCP?”\n\nHere’s the concrete value as I see it:\n\n### 1. One server, many clients\n\nExpose a tool once. Use it across multiple AI clients, agents, shells, and IDEs.\n\nNo more bespoke function-calling adapters per model provider.\n\n### 2. Predictable, testable tool invocation\n\nMCP’s schemas make tool interaction debuggable and reliable, which is closer to API contracts than prompt engineering.\n\n### 3. A protocol for agent-native workloads\n\nAs Octoverse shows, agent workflows are moving into mainstream engineering:\n\n- 1M+ agent-authored pull requests via GitHub Copilot coding agent alone in the five months since it was released\n- Rapid growth of key AI projects like [vllm](http://github.com/vllm-project/vllm) and [ragflow](https://github.com/infiniflow/ragflow)\n- Local inference tools exploding in popularity\n\nAgents need structured ways to call tools and fetch context. MCP provides exactly that.\n\n### 4. Secure, remote execution\n\nOAuth and remote-server support mean MCP works for:\n\n- Enterprises\n- Regulated workloads\n- Multi-machine orchestration\n- Shared internal tools\n\n### 5. A growing ecosystem of servers\n\nWith a growing set of community and vendor-maintained MCP servers (and more added weekly), developers can connect to:\n\n- Issue trackers\n- Code search and repositories\n- Observability systems\n- Internal APIs\n- Cloud services\n- Personal productivity tools\n\nSoria Parra emphasized that MCP isn’t just for LLMs calling tools. It can also invert the workflow by letting developers use a model to understand their own complex systems.\n\n### 6. It matches how developers already build software\n\nMCP aligns with developer habits:\n\n- Schema-driven interfaces (JSON Schema–based)\n- Reproducible workflows\n- Containerized infrastructure\n- CI/CD environments\n- Distributed systems\n- Local-first testing\n\nMost developers don’t want magical behavior—they want predictable systems. MCP meets that expectation.\n\nMCP also intentionally mirrors patterns developers already know from API design, distributed systems, and standards evolution—favoring predictable, contract-based interactions over “magical” model behaviors.\n\n## What happens next\n\nThe [Linux Foundation announcement](https://aaif.io/) is the beginning of MCP’s next phase, and the move signals:\n\n- Broader contribution\n- More formal governance\n- Deeper integration into agent frameworks\n- Cross-platform interoperability\n- An expanding ecosystem of servers and clients\n\nGiven the global developer growth highlighted in Octoverse—36M new developers on GitHub alone this year—the industry needs shared standards for AI tooling more urgently than ever.\n\nMCP is poised to be part of that future. It’s a stable, open protocol that lets developers build agents, tools, and workflows without vendor lock-in or proprietary extensions.\n\nThe next era of software will be shaped not just by models, but by how models interact with systems. MCP is becoming the connective tissue for that interaction.\n\nAnd with its new home in the Linux Foundation, that future now belongs to the community.\n\n[**Explore the MCP specification**](https://github.com/modelcontextprotocol/modelcontextprotocol) **and** [**the GitHub MCP Registry**](https://github.com/mcp) to join the community working on the next phase of the protocol.",
  "Description": "MCP is moving to the Linux Foundation. Here's how that will affect developers.\n\nThe post [MCP joins the Linux Foundation: What this means for developers building the next era of AI tools and agents](https://github.blog/open-source/maintainers/mcp-joins-the-linux-foundation-what-this-means-for-developers-building-the-next-era-of-ai-tools-and-agents/) appeared first on [The GitHub Blog](https://github.blog)."
}
