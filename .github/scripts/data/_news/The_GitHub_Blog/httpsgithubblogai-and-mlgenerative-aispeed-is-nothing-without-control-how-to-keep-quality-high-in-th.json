{
  "Description": "AI can help you build faster than ever, but it can also produce bugs, issues, and problems. Use these strategies to keep your speed without losing control of your code.\n\nThe post [Speed is nothing without control: How to keep quality high in the AI era](https://github.blog/ai-and-ml/generative-ai/speed-is-nothing-without-control-how-to-keep-quality-high-in-the-ai-era/) appeared first on [The GitHub Blog](https://github.blog).",
  "Author": "Gwen Davis",
  "FeedUrl": "https://github.blog/feed/",
  "EnhancedContent": "What‚Äôs the point of moving faster if you can‚Äôt trust the code you‚Äôre shipping?\n\nWe‚Äôve all been using AI in our workflows for a while now, and there‚Äôs no denying how much faster everyday development has become. Tasks that once took hours now finish in minutes. Entire features come together before you‚Äôve even finished your morning coffee.\n\nBut we‚Äôve also experienced the other side of that speed: when AI is used without clear direction or guardrails, it can generate what‚Äôs often called *AI slop*‚Äîsemi-functional code stitched together without context, quietly piling up bugs, broken imports, and technical debt.\n\nIn this new era, being fast isn‚Äôt enough. Precision and quality are what set teams apart.\n\n‚ÄúThe best drivers aren‚Äôt the ones who simply go the fastest, but the ones who stay smooth and in control at high speed,‚Äù said [Marcelo Oliveira](https://www.linkedin.com/in/marcelogoliveira22/), GitHub VP of product at [GitHub Universe 2025](https://githubuniverse.com/). ‚ÄúSpeed and control aren‚Äôt trade-offs. They reinforce each other.‚Äù\n\nSo how do you get the best of both? How do you move fast *and* keep your code clean, reliable, and firmly under your direction? Here are three essential strategies:\n\n## Tip #1: Treat speed and quality as a package deal\n\nIt‚Äôs very easy to accept AI-generated code that appears polished but hides underlying issues. However, speed without quality doesn‚Äôt help you ship faster, it just increases the risk of issues compounding down the road. That‚Äôs why the teams and organizations that succeed are the ones that pair AI-driven velocity with real guardrails.\n\nAnd that‚Äôs exactly what [GitHub Code Quality](https://docs.github.com/code-security/code-quality/concepts/about-code-quality) (currently in public preview) helps you do. GitHub Code Quality is an AI- and CodeQL-powered analysis tool that surfaces maintainability issues, reliability risks, and technical debt across your codebase, right as you work. Here‚Äôs how to start using it:\n\n1. **Enable with one click**\nTurn it on at the repository level and GitHub will analyze your code using a combination of CodeQL and LLM-based detection. This will give you a clear view of the maintainability and reliability issues in your codebase.\n2. **Get automatic fixes inside every pull request** As soon as you open a pull request, GitHub Code Quality flags unused variables, duplicated logic, runtime errors, and more. Here‚Äôs an example of pull request code that ‚Äúworks,‚Äù but isn‚Äôt production-ready:\n\n``` // fuelCalculator.js\n\nexport function calculateFuelUsage(laps, fuelPerLap) { const lastLap = laps[laps.length - 1]; // unused variable\n\nfunction totalFuel(laps, fuelPerLap) { return laps.length * fuelPerLap; }\n\n// duplicated function function totalFuel(laps, fuelPerLap) { return laps.length * fuelPerLap; }\n\nreturn totalFuel(laps, fuelPerLap); ```\n\nGitHub Code Quality responds with AI + CodeQL-powered suggestions, including a one-click fix:\n\n``` -export function calculateFuelUsage(laps, fuelPerLap) {\n- const lastLap = laps[laps.length - 1]; // unused variable\n-\n- function totalFuel(laps, fuelPerLap) {\n- return laps.length * fuelPerLap;\n- }\n-\n- // duplicated function\n- function totalFuel(laps, fuelPerLap) {\n- return laps.length * fuelPerLap;\n- }\n-\n- return totalFuel(laps, fuelPerLap);\n-} +export function calculateFuelUsage(laps, fuelPerLap) {\n+ if (!Array.isArray(laps) || typeof fuelPerLap !== \"number\") {\n+ throw new Error(\"Invalid input\");\n+ }\n+ return laps.length * fuelPerLap;\n+} ```\n\nNo triage or slowdown, just clean, reliable code.\n\n1. **Enforce your quality bar** Rulesets let you block merges that don‚Äôt meet your team‚Äôs standards. This keeps quality consistent without relying on reviewer willpower and without killing your velocity.\n2. **Reveal (and fix) legacy technical debt**\nThe **AI Findings** page highlights issues in files your team is already working in, helping you fix problems while they‚Äôre top of mind and reduce context switching.\n\n**Bottom line:** AI gives you speed. GitHub Code Quality gives you control. Together, they let you move faster and build better without ever trading one for the other.\n\n[Learn more about GitHub Code Quality](https://github.blog/changelog/2025-10-28-github-code-quality-in-public-preview/) üëâ\n\n## Tip #2: Be the driver, not the passenger\n\nAI can generate code quickly, but quality has never come from automation alone. GitHub has always believed in giving you the tools to write your best code‚Äîfrom [Copilot in the IDE](https://docs.github.com/en/copilot/how-tos/get-code-suggestions/get-ide-code-suggestions), to [GitHub Copilot code review in pull requests](https://docs.github.com/en/copilot/how-tos/use-copilot-agents/request-a-code-review/use-code-review), to [GitHub Code Quality](https://github.blog/changelog/2025-10-28-github-code-quality-in-public-preview/)‚Äîproviding visibility into long-standing issues and tech debt, along with actionable fixes to help you address them.\n\nThese features give you the power to set direction, standards, and constraints. The clearer your intent, the better AI can support you.\n\nHere‚Äôs a simple prompting framework that helps you do just that:\n\n1. **Set the goal, not just the action**\nThink of your prompts like giving direction to another engineer: the more clarity you provide, the better the final output.\n\nBad prompt:\n\n``` refactor this file ```\n\nBetter prompt:\n\n``` refactor this file to improve readability and maintainability while preserving functionality, no breaking changes allowed ```\n\n1. **Establish constraints**Examples:\n- ‚ÄúNo third-party dependencies‚Äù\n- ‚ÄúMust be backwards compatible with v1.7‚Äù\n- ‚ÄúFollow existing naming patterns‚Äù\n2. **Provide reference context** Link to related files, docs, existing tests, or architectural decisions.\n3. **Decide the format of the output** Pull request, diff, patch, commentary, or code block.\n\nWith [GitHub Copilot coding agent](https://docs.github.com/copilot/concepts/agents/coding-agent/about-coding-agent), you can even assign multi-step tasks like:\n\n``` Create a new helper function for formatting currency across the app.\n- Must handle USD and EUR\n- Round up to two decimals\n- Add three unit tests\n- Do not modify existing price parser\n- Return as a pull request\n```\n\nNotice how you remain accountable for the *thinking* and the agent becomes accountable for the *doing*.\n\n**Bottom line:** AI accelerates execution, but your clarity‚Äîand GitHub‚Äôs guardrails‚Äîare what turn that acceleration into high-quality software.\n\n[Learn more about coding agent](https://github.com/features/copilot?utm_source=blog-universe-ai-control&amp;utm_medium=blog&amp;utm_campaign=dec25postuniverse) üëâ\n\n## Tip #3: Build visible proof of your thinking, not just your output\n\nAs AI takes on more execution work, what sets effective developers apart is how clearly they communicate decisions, trade-offs, and reasoning. It‚Äôs no longer enough to write code, you need to show how you think, evaluate, and approach problems across the lifecycle of a feature.\n\nHere‚Äôs a best practice to level up your documentation signal:\n\n1. **Create an issue that captures the why** Write a brief summary of the problem, what success looks like, constraints, and any risks.\n2. **Name your branch clearly and commit thoughtfully** Use meaningful names and commit messages that narrate your reasoning, not just your keystrokes.\n3. **Use Copilot and coding agent to build, then document decisions** Include short notes on why you chose one approach over another and what alternatives you considered.\n4. **Open a pull request with signal-rich context** Add a short ‚ÄúWhy,‚Äù ‚ÄúWhat changed,‚Äù and ‚ÄúTrade-offs‚Äù section, plus screenshots or test notes.\n\nFor example, instead of:\n\n``` Added dark mode toggle ```\n\nTry this:\n\n```\n- Added dark mode toggle to improve accessibility and user preference support.\n- Chose localStorage for persistence to avoid server dependency.\n- Kept styling changes scoped to avoid side effects on existing themes.\n```\n\n**Bottom line:** Your code shows what you did, but your documentation shows why it matters. In this new AI era, the latter is just as critical as the former.\n\n[Learn more about effective documentation](https://github.blog/developer-skills/documentation-done-right-a-developers-guide/) üëâ\n\n## Moving forward together\n\nAt the end of the day, quality is everything. While AI may accelerate the pace of work, it can also turn that speed on its head if the output isn‚Äôt guided with intent. But when you combine AI with clear direction, strong guardrails, and visible thinking, you help your team deliver cleaner, more reliable code at scale‚Äîand position your organization to move quickly without compromising on what matters most.\n\nGet started with [GitHub Copilot](https://github.com/features/copilot?utm_source=blog-universe-ai-control&amp;utm_medium=blog&amp;utm_campaign=dec25postuniverse) &gt;",
  "FeedName": "The GitHub Blog",
  "OutputDir": "_news",
  "ProcessedDate": "2025-12-09 17:03:56",
  "Link": "https://github.blog/ai-and-ml/generative-ai/speed-is-nothing-without-control-how-to-keep-quality-high-in-the-ai-era/",
  "PubDate": "2025-12-09T17:00:00+00:00",
  "Title": "Speed is nothing without control: How to keep quality high in the AI era",
  "FeedLevelAuthor": "The GitHub Blog",
  "Tags": [
    "AI & ML",
    "Generative AI"
  ]
}
