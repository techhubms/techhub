{
  "ProcessedDate": "2025-10-14 16:03:15",
  "OutputDir": "_news",
  "Tags": [
    "AI & ML",
    "AI agents",
    "COBOL",
    "enterprise development",
    "GitHub Copilot",
    "mainframe modernization"
  ],
  "Link": "https://github.blog/ai-and-ml/github-copilot/how-github-copilot-and-ai-agents-are-saving-legacy-systems/",
  "EnhancedContent": "Picture this: you‚Äôre a developer in 2025, and your company just told you they need to modernize a mainframe system that processes millions of ATM transactions daily. We‚Äôre talking about [COBOL](https://en.wikipedia.org/wiki/COBOL#), a programming language that‚Äôs been around for 65 years. That‚Äôs older than the internet.\n\nNow, your first instinct might be to laugh or maybe cry a little. But here‚Äôs the thing‚ÄîCOBOL isn‚Äôt going anywhere. In fact, it‚Äôs powering some of the largest and most critical systems on the planet right now.\n\nThe problem? **Finding developers who understand COBOL is like finding unicorns.** The original developers are retiring, and yet 200 billion lines of COBOL code are still running our banks, insurance companies, and government systems.\n\nBut here‚Äôs the plot twist: we now have the opportunity to support the unicorns. We have GitHub Copilot and autonomous AI agents.\n\n## Meet the developer who‚Äôs modernizing COBOL (without learning COBOL)\n\nI recently spoke with [Julia Kordick](https://www.linkedin.com/in/julia-kordick/), Microsoft Global Black Belt, who‚Äôs modernizing COBOL systems using AI. What‚Äôs remarkable? She never learned COBOL.\n\nJulia brought her AI expertise and worked directly with the people who had decades of domain knowledge. That partnership is the key insight here. She didn‚Äôt need to become a COBOL expert. Instead, she focused on what she does best: designing intelligent solutions. The COBOL experts provided the legacy system knowledge.\n\n> >\n> When this whole idea of Gen AI appeared, we were thinking about how we can actually use AI to solve this problem that has not been really solved yet.\n> >\n> Julia Kordick, Microsoft Global Black Belt\n\n## The three-step framework for AI-powered legacy modernization\n\nJulia and her team at Microsoft have cracked the code (pun intended) with a systematic approach that works for any legacy modernization project, not just COBOL. Here‚Äôs their GitHub Copilot powered, battle-tested framework.\n\n### Step 1: Code preparation (reverse engineering)\n\nThe biggest problem with legacy systems? **Organizations have no idea what their code actually does anymore.** They use it, they depend on it, but understanding it? That‚Äôs another story.\n\nThis is where GitHub Copilot becomes your archaeological tool. Instead of hiring consultants to spend months analyzing code, you can use AI to:\n\n- Extract business logic from legacy files.\n- Document everything in markdown for human review.\n- Automatically identify call chains and dependencies.\n- Clean up irrelevant comments and historical logs.\n- Add additional information as comments where needed.\n\n| üí°**Pro tip:** Always have human experts review AI-generated analysis. AI is incredible at pattern recognition, but domain knowledge still matters for business context. | | --- |\n\nHere‚Äôs what GitHub Copilot generates for you:\n\n```\n# Business Logic Analysis Generated by GitHub Copilot\n## File Inventory\n- listings.cobol: List management functionality (~100 lines)\n- mainframe-example.cobol: Full mainframe program (~10K lines, high complexity)\n\n## Business Purpose\nCustomer account validation with balance checking\n- Validates account numbers against master file\n- Performs balance calculations with overdraft protection\n- Generates transaction logs for audit compliance\n\n## Dependencies Discovered\n- DB2 database connections via SQLCA\n- External validation service calls\n- Legacy print queue system\n```\n\n### Step 2: Enrichment (making code AI-digestible)\n\nYou usually need to add context to help AI understand your code better. Here‚Äôs what that looks like:\n\n**Translation:** If your code has Danish, German, or other non-English comments, translate them. Models work better with English context.\n\n**Structural analysis:** COBOL has deterministic patterns. Even if you‚Äôve never written COBOL, you can leverage these patterns because they‚Äôre predictable. Here‚Äôs how:\n\nCOBOL programs always follow the same four-division structure:\n\n- IDENTIFICATION DIVISION (metadata about the program)\n- ENVIRONMENT DIVISION (file and system configurations)\n- DATA DIVISION (variable declarations and data structures)\n- PROCEDURE DIVISION (the actual business logic)\n\nAsk GitHub Copilot to map these divisions for you. Use prompts like:\n\n``` \"Identify all the divisions in this COBOL file and summarize what each one does\"\n\n\"List all data structures defined in the DATA DIVISION and their purpose\"\n\n\"Extract the main business logic flow from the PROCEDURE DIVISION\" ```\n\nThe AI can parse these structured sections and explain them in plain English. You don‚Äôt need to understand COBOL syntax. You just need to know that COBOL‚Äôs rigid structure makes it easier for AI to analyze than more flexible languages.\n\n**Documentation as source of truth:** Save everything AI generates as markdown files that become the primary reference. Julia explained it this way: ‚ÄúEverything that you let Copilot generate as a preparation, write it down as a markdown file so that it can actually reference these markdown files as source of truth.‚Äù\n\n| **üí°Pro tip:** COBOL‚Äôs verbosity is actually an advantage here. Statements like `ADD TOTAL-SALES TO ANNUAL-REVENUE`<br> are almost self-documenting. Ask Copilot to extract these business rules into natural language descriptions. | | --- |\n\n### Step 3: Automation Aids (Scaling the Process)\n\nOnce you‚Äôve analyzed and enriched individual files, you need to understand how they all fit together. This is where you move from using Copilot interactively to building automated workflows with AI agents.\n\nJulia‚Äôs team built a framework using Microsoft Semantic Kernel, which orchestrates multiple specialized agents. Each agent has a specific job, and they work together to handle the complexity that would overwhelm a single AI call.\n\nHere‚Äôs what this orchestration looks like in practice:\n\n- **Call chain mapping:** Generate Mermaid diagrams showing how files interact. One agent reads your COBOL files, another traces the CALL statements between programs, and a third generates a visual diagram. You end up with a map of your entire system without manually tracing dependencies.\n- **Test-driven modernization:** Extract business logic (agent 1), generate test cases that validate that logic (agent 2), then generate modern code that passes those tests (agent 3). The tests become your safety net during migration.\n- **Dependency optimization:** Identify utility classes and libraries that you can replace with modern equivalents. An agent analyzes what third-party COBOL libraries you‚Äôre using, checks if modern alternatives exist, and flags opportunities to simplify your migration.\n\nThink of it like this: Copilot in your IDE is a conversation. This framework is a production line. Each agent does one thing well, and the orchestration layer manages the workflow between them.\n\n| **üí°Pro tip:** Use Mermaid diagrams to visualize complex dependencies before making any changes. It helps you catch edge cases early. You can generate these diagrams by asking Copilot to trace all CALL statements in your codebase and output them in Mermaid syntax. Mermaid chart example: | | --- |\n\n![Flowchart showing the COBOL to Java modernization agent workflow. Seven boxes connected by arrows flow top to bottom: COBOLAnalyzerAgent, DependencyMapperAgent, Business Logic Extractor, Test Generator, JavaConverterAgent, Human Validation, and Production-Ready Java Quarkus Output.](https://github.blog/wp-content/uploads/2025/10/mermaid.png?resize=475%2C908)\n\n## The reality check: It‚Äôs not a silver bullet\n\nJulia‚Äôs brutally honest about limitations:\n\n> >\n> Everyone who‚Äôs currently promising you, ‚Äòhey, I can solve all your mainframe problems with just one click‚Äô is lying to you.\n> >\n\nThe reality is:\n\n- Humans must stay in the loop for validation.\n- Each COBOL codebase is unique and complex.\n- We‚Äôre early in the agentic AI journey.\n- Full automation is probably at least five years away.\n\nBut that doesn‚Äôt mean we can‚Äôt make massive progress today.\n\n## See it in action: the Azure samples framework\n\nJulia and her team have open-sourced their entire framework. It‚Äôs built with Microsoft Semantic Kernel for agentic orchestration and includes:\n\n- **Multiple specialized agents:** DependencyMapperAgent, COBOLAnalyzerAgent, JavaConverterAgent\n- **Cost tracking:** See exactly how much each AI operation costs (usually $2-5 per 1000 lines analyzed)\n- **Human validation points:** Built-in checkpoints for expert review\n- **`doctor.sh`:** A configuration and testing script that gets you started quickly\n\nTry running the COBOL modernization framework:\n\n1. **Fork the repository:**[aka.ms/cobol](https://aka.ms/cobol)\n2. **Set up your environment:** Configure Azure OpenAI endpoint (or use local models for sensitive data)\n3. **Run the doctor script:** `./doctor.sh doctor`\nvalidates your setup and dependencies\n4. **Start modernization:** `./doctor.sh run`\nbegins the automated process\n\n```\n# Quick setup for the impatient developer\n\ngit clone https://github.com/Azure-Samples/Legacy-Modernization-Agents\n\ncd Legacy-Modernization-Agents\n\n./doctor.sh setup\n\n./doctor.sh run ```\n\n## The business case that changes everything\n\nThis isn‚Äôt just about technical debt. It‚Äôs about business survival. Organizations are facing a critical shortage of COBOL expertise right when they need it most.\n\nThe traditional approach has been to hire expensive consultants, spend 5+ years on manual conversion, and end up with auto-generated code that‚Äôs unmaintainable. I‚Äôve seen this play out at multiple organizations. The consultants come in, run automated conversion tools, hand over thousands of lines of generated code, and leave. Then the internal team is stuck maintaining code they don‚Äôt understand in a language they‚Äôre still learning.\n\nThe AI-powered approach changes this. You use AI to understand business logic, generate human-readable modern code, and maintain control of your intellectual property. Your team stays involved throughout the process. They learn the business logic as they go. The code that comes out the other end is something your developers can actually work with.\n\nJulia explained the shift:\n\n> >\n> What a lot of customers do not want to actually give all their intellectual property like a hundred percent to a partner anymore, right? They want to keep it in check.\n> >\n\n## Start here: your path to becoming the modernization hero\n\nWhether you‚Äôre dealing with COBOL, ancient Java, or any legacy system, here‚Äôs how you can start today:\n\n### Start small\n\n- Identify one problematic legacy system (start with fewer than 5,000 lines)\n- Use GitHub Copilot to analyze a single file\n- Document what you discover in markdown\n- Share findings with your team\n\n### Build your AI toolkit\n\n- Experiment with the Azure Samples framework\n- Learn prompt engineering for code analysis (try: ‚ÄúAnalyze this COBOL program and explain its business purpose in simple terms‚Äù)\n- Practice iterative modernization techniques\n\n### Think beyond code\n\n- Consider nonfunctional requirements for cloud-native design\n- Plan for distributed systems architecture\n- Remember: most COBOL programs are doing simple CRUD operations. They don‚Äôt need the complexity of a mainframe. They need the simplicity of modern architecture.\n\n**Here‚Äôs a challenge:** Find a legacy system in your organization. Six-month-old code counts as legacy in our industry. Try using GitHub Copilot to:\n\n1. Generate business logic documentation\n2. Identify potential modernization opportunities\n3. Create a migration plan with human validation checkpoints\n\nShare your results on LinkedIn and tag me. I‚Äôd love to see what you discover.\n\n## The best time to start is now\n\nThe most powerful insight from my conversation with Julia is this: **AI doesn‚Äôt replace developer expertise. It amplifies it.**\n\nCOBOL experts bring irreplaceable domain knowledge. Modern developers bring fresh perspectives on architecture and best practices. AI brings pattern recognition and translation capabilities at scale.\n\nWhen these three forces work together, legacy modernization transforms from an impossible challenge into an achievable project.\n\n> >\n> The best time to modernize legacy code was 10 years ago. The second-best time is now.\n> >\n\nSpecial thanks to Julia Kordick, Microsoft Global Black Belt, who shared her insights and experiences that made this blog post possible.\n\n**Ready to dive deeper?** Check out the full blog post about this project at[aka.ms/cobol-blog](https://devblogs.microsoft.com/all-things-azure/how-we-use-ai-agents-for-cobol-migration-and-mainframe-modernization/) and connect with [Julia on LinkedIn](https://www.linkedin.com/in/julia-kordick/) for the latest updates.\n\nThe age of legacy code doesn‚Äôt have to be a barrier anymore. With the right AI tools and framework, even 65-year-old COBOL can become approachable, maintainable, and modern.\n\n**What legacy system will you modernize next?** Start building now with [GitHub Copilot](https://github.com/copilot) now &gt;",
  "FeedUrl": "https://github.blog/feed/",
  "Author": "Andrea Griffiths",
  "Title": "How GitHub Copilot and AI agents are saving legacy systems",
  "Description": "GitHub Copilot and AI agents are making legacy COBOL systems accessible to modern developers.\n\nThe post [How GitHub Copilot and AI agents are saving legacy systems](https://github.blog/ai-and-ml/github-copilot/how-github-copilot-and-ai-agents-are-saving-legacy-systems/) appeared first on [The GitHub Blog](https://github.blog).",
  "FeedName": "The GitHub Blog",
  "FeedLevelAuthor": "The GitHub Blog",
  "PubDate": "2025-10-14T16:00:00+00:00"
}
