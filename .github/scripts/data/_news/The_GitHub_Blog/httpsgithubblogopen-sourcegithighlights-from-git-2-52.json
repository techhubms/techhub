{
  "OutputDir": "_news",
  "Author": "Taylor Blau",
  "EnhancedContent": "The open source Git project [just released Git 2.52](https://lore.kernel.org/git/xmqqh5usmvsd.fsf@gitster.g/) with features and bug fixes from over 94 contributors, 33 of them new. We last caught up with you on the latest in Git back [when 2.51 was released](https://github.blog/open-source/git/highlights-from-git-2-51/).\n\nTo celebrate this most recent release, here is GitHub’s look at some of the most interesting features and changes introduced since last time.\n\n# Tree-level blame information\n\nIf you’re a seasoned Git user, then you are no doubt familiar with git blame, Git’s tool for figuring out which commit most recently modified each line at a given filepath. Git’s blame functionality is great for figuring out when a bug was introduced, or why some code was written the way it was.\n\nIf you want to know which commit last modified any portion of a given filepath, that’s easy enough to do with git log -1 — path/to/my/file, since -1 will give us only the first commit which modifies that path. But what if instead you want to know which commit most recently modified every file in some directory? Answering that question may seem contrived, but it’s not. If you’ve ever looked at a repository’s file listing on GitHub, the middle column of information has a link to the commit which most recently modified that path, along with (part of) its commit message.\n\n![Screenshot of GitHub's repository file.](https://github.blog/wp-content/uploads/2025/11/unnamed-1.png?resize=1024%2C454)*GitHub’s repository file listing, showing tree-level blame information.*\n\nThe question remains: how do we efficiently determine which commit most recently modified each file in a given directory? You could imagine that you might enumerate each tree entry, feeding it to `git log -1` and collecting the output there, like so:\n\n``` $ git ls-tree -z --name-only HEAD^{tree} | xargs -0 -I{} sh -c ' git log -1 --format=\"$1 %h %s\" -- $1 ' -- {} | column -t -l3 .cirrus.yml 1e77de1864e ci: update FreeBSD image to 14.3 .clang-format 3721541d35a clang-format: exclude control macros from SpaceBeforeParens .editorconfig c84209a8fda editorconfig: add .bash extension .gitattributes d3b5832381c merge-file doc: set conflict-marker-size attribute .github 5db9d35a28f Merge branch 'js/ci-github-actions-update' [...] ```\n\nThat works, but not efficiently. To see why, consider a case with files `A` , `B` , and `C` introduced by commits `C1` , `C2` , and `C3` , respectively. To blame `A` , we walk from `C3` back to `C1` in order to determine that `C1` was the most recent commit to modify `A` . That traversal passed through `C2` and `C3` , but since we were only looking for modifications to `A` , we’ll end up revisiting those commits when trying to blame `B` and `C` . In this example, we visit those three commits six times in total, which is twice the necessary number of history traversals.\n\nGit 2.52 introduces a new command which comes up with the same information in a fraction of the time: `git last-modified` . To get a sense for how much faster `last-modified` is than the example above, here are some [hyperfine](https://github.com/sharkdp/hyperfine) results:\n\n``` Benchmark 1: git ls-tree + log Time (mean ± σ): 3.962 s ± 0.011 s [User: 2.676 s, System: 1.330 s] Range (min … max): 3.940 s … 3.984 s 10 runs\n\nBenchmark 2: git last-modified Time (mean ± σ): 722.7 ms ± 4.6 ms [User: 682.4 ms, System: 40.1 ms] Range (min … max): 717.3 ms … 731.3 ms 10 runs\n\nSummary git last-modified ran 5.48 ± 0.04 times faster than git ls-tree + log ```\n\nThe core functionality behind `git last-modified` was written by GitHub over many years (originally called `blame-tree` in GitHub’s fork of Git), and is what has powered our tree-level blame since 2012. Earlier this year, we [shared those patches](https://lore.kernel.org/git/Z+XJ+1L3PnC9Dyba@nand.local/) with engineers at GitLab, who tidied up [years of development](https://github.com/git/git/compare/d61ab360b996c6370f65bb9eaa316c68a58f7fd1%5E...ttaylorr:git:tb/blame-tree) into a [reviewable series](https://lore.kernel.org/git/20250422-toon-new-blame-tree-v1-0-fdb51b8a394a@iotcl.com/#t) of patches which landed in this release.\n\nThere are still some features in GitHub’s version of this command that have yet to make their way into a Git release, including an on-disk format to cache the results of previous runs. In the meantime, [check out `git last-modified`](https://git-scm.com/docs/git-last-modified/2.52.0), available in Git 2.52.\n\n[[source](https://github.com/git/git/compare/a3c6459ab6610d93da8c95000d0ffc803ce39892...a1dfa5448d583bbfd1ec45642a4495ad499970c9), [source](https://github.com/git/git/compare/576e0b6eb34f8989f07ae77db10baf1c75125c47...8d9a7cdfda4c883e83d6ea7b57d0a1d989a7d439), [source](https://github.com/git/git/compare/96ed0a89066c2ea57c18b6586b2cab2edc333515...e6c06e87a255995d2e7ead2b8e49e46e29a724fb)]\n\n# Advanced repository maintenance strategies\n\nReturning readers of this series [may recall](https://github.blog/open-source/git/highlights-from-git-2-31/#introducing-git-maintenance) our coverage of the `git maintenance` command. If this is your first time reading along, or you could use a refresher, we’ve got you covered.\n\n`git maintenance` is a Git command which can perform repository housekeeping tasks either on a scheduled or ad-hoc basis. The `maintenance` command can perform a [variety of tasks](https://git-scm.com/docs/git-maintenance/2.52.0#_tasks), like repacking the contents of your repository, updating commit-graphs, expiring stale reflog entries, and much more. Put together, `maintenance` ensures that your repository continues to operate smoothly and efficiently.\n\nBy default (or when running the `gc` task), `git maintenance` relies on `git gc` internally to repack your repository, and remove any unreachable objects. This has a couple of drawbacks, namely that `git gc` performs “all-into-one” repacks to consolidate the contents of your repository, which can be sluggish for very large repositories. As an alternative, `git maintenance` has an `incremental-repack` strategy, but this never prunes out any unreachable objects.\n\nGit 2.52 bridges this gap by introducing a new `geometric` task within `git maintenance` that avoids all-into-one repacks when possible, and prunes unreachable objects on a less frequent basis. This new task uses tools (like geometric repacking) that were designed at GitHub and have [powered GitHub’s own repository maintenance](https://github.blog/2021-04-29-scaling-monorepo-maintenance/) for many years. Those tools have been in Git [since 2.33](https://github.blog/open-source/git/highlights-from-git-2-33/#geometric-repacking), but were awkward to use or discover since their implementation was buried within `git repack` , not `git gc` .\n\nThe `geometric` task here works by inspecting the contents of your repository to determine if we can combine some number of [packfiles](https://git-scm.com/book/en/v2/Git-Internals-Packfiles) to form a [geometric progression](https://en.wikipedia.org/wiki/Geometric_progression) by object count. If it can, it performs a geometric repack, condensing the contents of your repository without pruning any objects. Alternatively, if a geometric repack would pack the entirety of your repository into a single pack, then a full `git gc` is performed instead, which consolidates the contents of your repository and prunes out unreachable objects.\n\nGit 2.52 makes it a breeze to keep even your largest repositories running smoothly. Check out the new `geometric` strategy, or any of the many other capabilities of `git maintenance` can do in 2.52.\n\n[[source](https://github.com/git/git/compare/52364670907b84f91bcd42035ddd30ceac0f2771...a4265572bb8488205b53a4a1af0c8d877f11dbe6)]\n\n# The tip of the iceberg…\n\nNow that we’ve covered some of the larger changes in more detail, let’s take a closer look at a selection of some other new features and updates in this release.\n\n- This release saw a couple of new sub-commands be added to [`git refs`](https://git-scm.com/docs/git-refs), Git’s relatively new tool for providing low-level access to your repository’s [references](https://git-scm.com/book/en/v2/Git-Internals-Git-References). Prior to this release, `git refs`\nwas capable of migrating between reference backends (e.g., to have your repository store reference data in the [reftable](https://git-scm.com/docs/reftable) format), along with verifying the internal representation of those references.\n\n`git refs` now includes two new sub-commands: `git refs list` and `git refs exists` . The former is an alias for `git for-each-ref` and supports the same set of options. The latter works like `git show-ref --exists` , and can be used to quickly determine whether or not a given reference exists.\n\nNeither of these new sub-commands introduce new functionality, but they do consolidate a couple of common reference-related operations into a single Git command rather than many individual ones.\n\n[[source](https://github.com/git/git/compare/fd13909eb63ef121824f243183db6b1f49ef1aed...c44afd67d2bcfc2958e7cc79d7064ab5fcfa468a)]\n- If you’ve ever scripted around Git, you are likely familiar with Git’s `rev-parse`\ncommand. If not, you’d be forgiven for thinking that `rev-parse` is designed to just resolve the various ways to describe a commit into a full object ID. In reality, `rev-parse` can perform functionality totally unrelated to resolving object IDs, including shell quoting, option parsing (as a replacement for [getopt](https://man7.org/linux/man-pages/man1/getopt.1.html)), printing local `GIT_` environment variables, resolving paths inside of `$GIT_DIR` and [so much more](https://git-scm.com/docs/git-rev-parse/2.52.0).\n\nGit 2.52 introduces the first step to giving some of this functionality a new home via its new `git repo` command. The `git repo` command—currently designated as experimental—is designed to be a general-purpose tool for retrieving pieces of information about your repository. For example, you can check whether or not a repository is shallow or bare, along with what type of object and reference format it uses, like so:\n\n``` $ keys='layout.bare layout.shallow object.format references.format' $ git repo info $keys layout.bare=false layout.shallow=false object.format=sha1 references.format=files ```\n\nThe new `git repo` command can also print out some general statistics about your repository’s structure and contents via its `git repo structure` sub-command:\n\n``` $ git.compile repo structure Counting objects: 497533, done. | Repository structure | Value | | -------------------- | ------ | | * References | | | * Count | 2871 | | * Branches | 58 | | * Tags | 1273 | | * Remotes | 1534 | | * Others | 6 | | | | | * Reachable objects | | | * Count | 497533 | | * Commits | 91386 | | * Trees | 208050 | | * Blobs | 197103 | | * Tags | 994 | ```\n\n[[source](https://github.com/git/git/compare/eed447dd959bd99a24c43688b7f6f14f727b550b...a81224d12818e94a2e3c257ee2e5b0f3169da12b), [source](https://github.com/git/git/compare/7d00521d7be21ca4a3713b2fa367eb7296212e09...c2e3713334aa822683f046bbad7905ec8510d38b), [source](https://github.com/git/git/compare/175048344f5b04c720e34426137418b64c7b260f...16a93c03c7824a40b034a6ee1cb1c68c8ef48682)]\n\n- Back in 2.28, the Git project [introduced](https://github.blog/open-source/git/highlights-from-git-2-28/#introducing-init-defaultbranch) the `init.defaultBranch`\n[configuration option](https://git-scm.com/docs/git-config/2.52.0#Documentation/git-config.txt-initdefaultBranch) to provide a default branch name for any repositories created with `git init` . Since its introduction, the default value of that configuration option was “master”, though many set `init.defaultBranch` to “main” instead.\n\nBeginning in Git 3.0, the default value for `init.defaultBranch` will change to “main”. That means that any repositories created in Git 3.0 or newer using `git init` will have their default branch named “main” without the need for any additional configuration.\n\nIf you want to get a sneak peak of that, or any other planned change for Git 3.0, you can build Git locally with the `WITH_BREAKING_CHANGES` build-flag to try out the new changes today.\n\n[[source](https://github.com/git/git/compare/d235f69ae880aba0a29841c61eec214f59b19650...5590b4e7f52017794169a93d571204141bab3d28), [source](https://github.com/git/git/compare/e50c3ca095b33a941833ffab150b8822099d1b75...373ad8917beb99dc643b6e7f5c117a294384a57e)]\n- By default, Git uses SHA-1 to provide a [content-addressable hash](https://en.wikipedia.org/wiki/Content-addressable_storage) of any object in your repository. In Git 3.0, Git will instead use SHA-256 which offers more appealing security properties. Back in [our coverage of Git 2.45](https://github.blog/open-source/git/highlights-from-git-2-45), we talked about [some new changes](https://github.blog/open-source/git/highlights-from-git-2-45/#preliminary-support-for-sha-1-and-sha-256-interoperability) which enable writing out separate copies of new objects using both SHA-1 and SHA-256 as a transitory step towards interoperability between the two.\n\nIn Git 2.52, the rest of that work towards interoperability begins. Though the changes that landed in this release are focused on laying the groundwork for future interoperability features, the hope is that eventually you can use a Git repository with one hash algorithm, while pushing and pulling from another repository using a different hash algorithm.\n\n[[source](https://github.com/git/git/compare/c9ccf81948973e9b9632cbb483a3908307092620...db00605c13a9f5709da712671df5c7594c06cf31)]\n- Speaking of other bleeding-edge changes in Git, this release is the first to (optionally) use Rust code for some internal functionality within Git. This mode is optional and guarded behind a new `WITH_RUST`\nbuild flag. When built with this mode enabled, Git will use a [Rust implementation](https://github.com/git/git/blob/v2.52.0/src/varint.rs) for encoding and decoding [variable-width integers](https://en.wikipedia.org/wiki/Variable-length_quantity).\n\nThough this release only introduces a Rust variant of some minor utility functionality, it sets up the infrastructure for much more interesting parts of Git to be rewritten in Rust.\n\nRust support is not yet mandatory, so Git 2.52 will continue to run just fine on platforms that don’t have a Rust compiler. However, Rust support [will be required for Git 3.0](https://github.com/git/git/commit/8f5daaff927e868b0460dda40cdb0923b8a6ef35), at which point many more components of Git will likely depend on Rust code.\n\n[[source](https://github.com/git/git/compare/3aa0ced36a53b817a27844c898c0474b9c120db9...e425c40aa00d2ae6b1bbc33cfa9fecd30a0a8ec6), [source](https://github.com/git/git/compare/3deb97fe24eccb1245e9323475f10cfba705e08f...e509b5b8be0f17467dcc75130f941d84a09d96a3), [source](https://github.com/git/git/compare/4253630c6f07a4bdcc9aa62a50e26a4d466219d1...f3b4c89d59f15f3b67f29bff6f1f53dbc11a5b58)]\n- Long-time readers may recall our coverage of changed-path Bloom filters within Git from [back in 2.28](https://github.blog/open-source/git/highlights-from-git-2-28/). If not, a changed-path [Bloom filter](https://en.wikipedia.org/wiki/Bloom_filter) is a probabilistic data structure that can approximate which file path(s) were modified by a commit (relative to its first parent). Since Bloom filters never have false negatives (i.e. indicating a commit did not modify some path when it in fact did), they can be used to accelerate many path-scoped traversals throughout Git (including `last-modified`\nabove!).\n\n[More recently](https://github.blog/open-source/git/highlights-from-git-2-51/), we covered new ways of using Bloom filters within Git, like providing multiple paths of interest at the same time (e.g., `git log /my/subdir /my/other/subdir` ) which previously were not supported with Bloom filters. At that time, we wrote that there were [ongoing discussions](https://lore.kernel.org/git/20250807051243.96884-1-yldhome2d2@gmail.com/) about supporting Bloom filters in even more of Git’s expressive pathspec syntax.\n\nThis release delivers the result of those discussions, and now supports the performance benefits of using Bloom filters in even more scenarios. One example here is when a pathspec contains wildcards in some, but not all of its components, like `foo/bar/*/baz` , where Git will now use its Bloom filter for the non-wildcard components of the path. To read about even more scenarios that can now leverage Bloom filters, check out the link below.\n\n[[source](https://github.com/git/git/compare/d1123cd8103b238da624e0d09655df853799bb38...6d192462eb3ca605600731a9717fd0d9aa72eff0)]\n- This release also saw a number of performance improvements across many areas of the project. `git describe`\nlearned how to use a [priority queue](https://en.wikipedia.org/wiki/Priority_queue) to speed up performance by 30%. `git remote` picked up a couple of new tricks to optimize renaming references with its `rename` sub-command. `git ls-files` can keep the index sparse in cases where it couldn’t before. `git log -L` became [significantly faster](https://github.com/git/git/commit/a3540ed20efad4e1aebb71edac2fc74604f2122e) by avoiding some unnecessary tree-level diffs when processing merge commits. Finally, `xdiff` (the library that powers Git’s file-level diff and merge engine) benefitted from a pair of optimizations ([here](https://github.com/git/git/commit/41d97837ab1e5a35fdcfd7f6af9b5d56af62e92a), and [here](https://github.com/git/git/commit/a4bbe8af0b48f9c80ccc2c4619309c4a81c1460a)) in this release, and [even more optimizations](https://lore.kernel.org/git/pull.1980.git.git.1752784344.gitgitgadget@gmail.com/) that will likely land in a future release.\n\n[[source](https://github.com/git/git/compare/9a85fa8406d6281dfcc3caa1e3d3828a5f73a363...08bb69d70f55cb6b44cdc6aefa7bc1d9cf4eb3f3), [source](https://github.com/git/git/compare/c3c8b6910a7cd3d5a25522d3fd6925083048be24...16c4fa26b99e6f6c24dc93575ffa884c13b1fe5f), [source](https://github.com/git/git/compare/4a7ebb9138b47bdc469fd8c8a97a753714fd5d92...681f26bccc017371ae6ee20db55e3edb52420a25), [source](https://github.com/git/git/compare/8d5e4290a73069466f34743993f23cad1fe90fc2...a4bbe8af0b48f9c80ccc2c4619309c4a81c1460a)]\n- Last but not least, some updates to Git’s `sparse-checkout`\nfeature, which learned a new “clean” sub-command. `git sparse-checkout clean` can help you recover from tricky cases where some files are left outside of your sparse-checkout definition when changing which part(s) of the repository you have checked out.\n\nThe details of how one might get into this situation, and why recovering from it with pre-2.52 tools alone was so difficult, are surprisingly technical. If you’re interested in all of the gory details, [this commit](https://github.com/git/git/commit/2520efd3bc8c81cb4bd8f832b241c3b2b8c0630f) has all of the information about this change.\n\nIn the meantime, if you use `sparse-checkout` and have ever had difficulty cleaning up when switching your `sparse-checkout` definition, give `git sparse-checkout clean` a whirl with Git 2.52.\n\n[[source](https://github.com/git/git/compare/419c72cb8ada252b260efc38ff91fe201de7c8c3...c32aa72466ec9da5762ef56f70ec10b42cab65da)]\n\n# …the rest of the iceberg\n\nThat’s just a sample of changes from the latest release. For more, check out the release notes for [2.52](https://github.com/git/git/blob/v2.52.0/Documentation/RelNotes/2.52.0.adoc), or [any previous version](https://github.com/git/git/tree/v2.52.0/Documentation/RelNotes) in [the Git repository](https://github.com/git/git).",
  "PubDate": "2025-11-17T17:54:31+00:00",
  "Tags": [
    "Git",
    "Open Source"
  ],
  "Title": "Highlights from Git 2.52",
  "Link": "https://github.blog/open-source/git/highlights-from-git-2-52/",
  "FeedName": "The GitHub Blog",
  "FeedUrl": "https://github.blog/feed/",
  "FeedLevelAuthor": "The GitHub Blog",
  "ProcessedDate": "2025-11-17 18:02:48",
  "Description": "The open source Git project just released Git 2.52. Here is GitHub’s look at some of the most interesting features and changes introduced since last time.\n\nThe post [Highlights from Git 2.52](https://github.blog/open-source/git/highlights-from-git-2-52/) appeared first on [The GitHub Blog](https://github.blog)."
}
