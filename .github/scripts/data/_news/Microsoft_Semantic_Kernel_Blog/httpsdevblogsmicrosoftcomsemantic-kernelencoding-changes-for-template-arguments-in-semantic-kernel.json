{
  "OutputDir": "_news",
  "FeedName": "Microsoft Semantic Kernel Blog",
  "EnhancedContent": "In previous versions of the Semantic Kernel, the encoding of template arguments was performed automatically if the argument type was a `string` . The encoding was not applied for custom types, anonymous types, or collections.\n\nWith the latest changes, we’ve introduced stricter rules: if automatic encoding is enabled (the default behavior), an exception will now be thrown when complex types are used as arguments. This enforces more secure template rendering by requiring developers to handle encoding manually for complex types and explicitly disable automatic encoding for those variables. This change promotes best practices for security, especially when using templating engines like Handlebars or Liquid.\n\nThis post explains the problem with the previous approach, the new behavior, and how to update your code to comply with these changes. For more details on template rendering in Semantic Kernel, refer to the [official documentation](https://learn.microsoft.com/en-us/semantic-kernel/concepts/prompts/).\n\n## **Encoding for Complex Types**\n\nAutomatic encoding is a safeguard against common vulnerabilities, such as template injection, by escaping special characters in strings. However, when dealing with complex types (e.g., custom objects, anonymous types, or collections), the SDK cannot reliably determine how to encode nested properties or elements without risking data corruption or incomplete protection.\n\nTo address this, the SDK now throws an exception in such cases, forcing explicit manual encoding and configuration.\n\n## **Changes in the Latest Version and Potential Errors**\n\nStarting with latest .NET and Python Semantic Kernel packages, when rendering templates with encoding enabled, using complex types without proper configuration will raise an exception. This prevents accidental insecure rendering and requires code updates for affected scenarios. If your code uses Handlebars or Liquid templates with complex arguments (e.g., objects with user-input properties), you’ll encounter this change. The exception message will guide you to manually encode the data and set `AllowDangerouslySetContent` to `true` for the relevant input variables. This shift ensures stricter, more secure rules, reducing the risk of vulnerabilities while maintaining flexibility for advanced use cases.\n\n## **How to Update Your Code**\n\nTo resolve this, you must manually encode any potentially unsafe data within complex types and explicitly disable automatic encoding for those arguments by setting `AllowDangerouslySetContent` to `true` in the prompt template configuration.\n\n### **.NET Example**\n\nHere’s an example of the code before the change:\n\n```cs var arguments = new KernelArguments() { { \"customer\", new { firstName = userInput.FirstName, lastName = userInput.LastName, } } };\n\nvar templateFactory = new LiquidPromptTemplateFactory(); var promptTemplateConfig = new PromptTemplateConfig() { TemplateFormat = \"liquid\" };\n\nvar promptTemplate = templateFactory.Create(promptTemplateConfig); // The following line will throw an exception now, because of the complex type passed as argument and enabled encoding var renderedPrompt = await promptTemplate.RenderAsync(kernel, arguments); ```\n\nAnd after the change:\n\n```cs var arguments = new KernelArguments() { { \"customer\", new { // Perform encoding for each property of complex type firstName = HttpUtility.HtmlEncode(userInput.FirstName), lastName = HttpUtility.HtmlEncode(userInput.LastName), } } };\n\nvar templateFactory = new LiquidPromptTemplateFactory(); var promptTemplateConfig = new PromptTemplateConfig() { TemplateFormat = \"liquid\", InputVariables = new() { // We set AllowDangerouslySetContent to 'true' because each property of this argument is encoded manually new() { Name = \"customer\", AllowDangerouslySetContent = true }, } };\n\nvar promptTemplate = templateFactory.Create(promptTemplateConfig); // No exception, because we disabled encoding for arguments due to manual encoding var renderedPrompt = await promptTemplate.RenderAsync(kernel, arguments); ```\n\n### **Python Example**\n\nHere’s an example of the code before the change:\n\n```python arguments = { \"customer\": { \"first_name\": user_input.first_name, \"last_name\": user_input.last_name, } }\n\nprompt_template_config = PromptTemplateConfig( template_format=\"handlebars\" )\n\nprompt_template = HandlebarsPromptTemplate(prompt_template_config=prompt_template_config)\n# The following line will throw an exception now, because of the complex type passed as argument and enabled encoding\nrendered_prompt = await prompt_template.render(kernel, arguments) ```\n\nAnd after the change:\n\n```python arguments = { \"customer\": {\n# Perform encoding for each property of the complex type\n\"first_name\": escape(user_input.first_name), \"last_name\": escape(user_input.last_name), } }\n\nprompt_template_config = PromptTemplateConfig( template=template, template_format=\"handlebars\", input_variables=[\n# We set allow_dangerously_set_content to True because each property of this argument is encoded manually\nInputVariable(name=\"customer\", allow_dangerously_set_content=True), ] )\n\nprompt_template = HandlebarsPromptTemplate(prompt_template_config=prompt_template_config)\n# No exception, because we disabled encoding for arguments due to manual encoding\nrendered_prompt = await prompt_template.render(kernel, arguments) ```\n\nIn this update:\n\n1. Manually encode properties using methods like `HttpUtility.HtmlEncode`\n(or equivalent for your templating engine) to sanitize user input.\n2. Add `InputVariables`\nto the `PromptTemplateConfig` and set `AllowDangerouslySetContent = true` for complex arguments where you’ve handled encoding yourself. This tells the SDK to skip automatic encoding for that variable.\n\nApply similar changes for Handlebars or other supported templates. Always test rendered output to ensure encoding is applied correctly without breaking functionality.\n\n## **Summary**\n\nThis update to Semantic Kernel introduces stricter encoding rules for template arguments, throwing exceptions for complex types under automatic encoding to enforce manual sanitization and explicit configuration. It significantly enhances security by preventing potential vulnerabilities in template rendering.\n\nWe’re always interested in hearing from you. If you have feedback, questions, or want to discuss further, feel free to reach out to us and the community on the [discussion boards](https://github.com/microsoft/semantic-kernel/discussions) on GitHub! We would also love your support—if you’ve enjoyed using Semantic Kernel, give us a star on [GitHub](https://github.com/microsoft/semantic-kernel).",
  "PubDate": "2025-08-27T05:17:18+00:00",
  "FeedLevelAuthor": "Semantic Kernel",
  "Description": "In previous versions of the Semantic Kernel, the encoding of template arguments was performed automatically if the argument type was a string. The encoding was not applied for custom types, anonymous types, or collections. With the latest changes, we’ve introduced stricter rules: if automatic encoding is enabled (the default behavior), an exception will now be […]\n\nThe post [Encoding Changes for Template Arguments in Semantic Kernel](https://devblogs.microsoft.com/semantic-kernel/encoding-changes-for-template-arguments-in-semantic-kernel/) appeared first on [Semantic Kernel](https://devblogs.microsoft.com/semantic-kernel).",
  "Author": "Dmytro Struk",
  "Title": "Encoding Changes for Template Arguments in Semantic Kernel",
  "ProcessedDate": "2025-08-27 06:17:16",
  "FeedUrl": "https://devblogs.microsoft.com/semantic-kernel/feed/",
  "Link": "https://devblogs.microsoft.com/semantic-kernel/encoding-changes-for-template-arguments-in-semantic-kernel/",
  "Tags": [
    ".NET",
    "Announcements",
    "Python",
    "Semantic Kernel"
  ]
}
