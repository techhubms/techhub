{
  "PubDate": "2024-11-08T21:01:44+00:00",
  "EnhancedContent": "Today we are announcing the availability of the release candidate of TypeScript 5.7.\n\nTo get started using the RC, you can get it through npm with the following command:\n\n``` npm install -D typescript@rc\n\n```\n\nLet’s take a look at what’s new in TypeScript 5.7!\n\n## Checks for Never-Initialized Variables\n\nFor a long time, TypeScript has been able to catch issues when a variable has not yet been initialized in all prior branches.\n\n``` let result: number if (someCondition()) { result = doSomeWork(); } else { let temporaryWork = doSomeWork(); temporaryWork *= 2; // forgot to assign to 'result' }\n\nconsole.log(result); // error: Variable 'result' is used before being assigned.\n\n```\n\nUnfortunately, there are some places where this analysis doesn’t work. For example, if the variable is accessed in a separate function, the type system doesn’t know when the function will be called, and instead takes an \"optimistic\" view that the variable will be initialized.\n\n``` function foo() { let result: number if (someCondition()) { result = doSomeWork(); } else { let temporaryWork = doSomeWork(); temporaryWork *= 2; // forgot to assign to 'result' }\n\nprintResult();\n\nfunction printResult() { console.log(result); // no error here. } }\n\n```\n\nWhile TypeScript 5.7 is still lenient on variables that have *possibly* been initialized, the type system is able to report errors when variables have *never* been initialized at all.\n\n``` function foo() { let result: number\n\n// do work, but forget to assign to 'result'\n\nfunction printResult() { console.log(result); // error: Variable 'result' is used before being assigned. } }\n\n```\n\n[This change](https://github.com/microsoft/TypeScript/pull/55887) was contributed thanks to the work of GitHub user [Zzzen](https://github.com/Zzzen)!\n\n## Path Rewriting for Relative Paths\n\nThere are several tools and runtimes that allow you to run TypeScript code \"in-place\", meaning they do not require a build step which generates output JavaScript files. For example, ts-node, tsx, Deno, and Bun all support running `.ts` files directly. More recently, Node.js has been investigating such support with `--experimental-transform-types` and `--experimental-strip-types` . This is extremely convenient because it allows us to iterate faster without worrying about re-running a build task.\n\nThere is some complexity to be aware of when using these modes though. To be maximally compatible with all these tools, a TypeScript file that’s imported \"in-place\" **must** be imported with the appropriate TypeScript extension at runtime. For example, to import a file called `foo.ts` , we have to write the following in Node’s new experimental support:\n\n``` // main.ts\n\nimport * as foo from \"./foo.ts\"; // <- we need foo.ts here, not foo.js\n\n```\n\nTypically, TypeScript would issue an error if we did this, because it expects us to import *the output file*. Because some tools do allow `.ts` imports, TypeScript has supported this import style with an option called `--allowImportingTsExtensions` for a while now. This works fine, but what happens if we need to actually generate `.js` files out of these `.ts` files? This is a requirement for library authors who will need to be able to distribute just `.js` files, but up until now TypeScript has avoided rewriting any paths.\n\nTo support this scenario, we’ve added a new compiler option called `--rewriteRelativeImportExtensions` . When an import path is *relative* (starts with `./` or `../` ), ends in a TypeScript extension (`.ts` , `.tsx` , `.mts` , `.cts` ), and is a non-declaration file, the compiler will rewrite the path to the corresponding JavaScript extension (`.js` , `.jsx` , `.mjs` , `.cjs` ).\n\n``` // Under --rewriteRelativeImportExtensions...\n\n// these will be rewritten. import * as foo from \"./foo.ts\"; import * as bar from \"../someFolder/bar.mts\";\n\n// these will NOT be rewritten in any way. import * as a from \"./foo\"; import * as b from \"some-package/file.ts\"; import * as c from \"@some-scope/some-package/file.ts\"; import * as d from \"#/file.ts\"; import * as e from \"./file.js\";\n\n```\n\nThis allows us to write TypeScript code that can be run in-place and then compiled into JavaScript when we’re ready.\n\nNow, we noted that TypeScript generally avoided rewriting paths. There are several reasons for this, but the most obvious one is dynamic imports. If a developer writes the following, it’s not trivial to handle the path that `import` receives. In fact, it’s impossible to override the behavior of `import` within any dependencies.\n\n``` function getPath() { if (Math.random() < 0.5) { return \"./foo.ts\"; } else { return \"./foo.js\"; } }\n\nlet myImport = await import(getPath());\n\n```\n\nAnother issue is that (as we saw above) only *relative* paths are rewritten, and they are written \"naively\". This means that any path that relies on TypeScript’s `baseUrl` and `paths` will not get rewritten:\n\n``` // tsconfig.json\n\n{ \"compilerOptions\": { \"module\": \"nodenext\", // ... \"paths\": { \"@/*\": [\"./src/*\"] } } }\n\n```\n\n``` // Won't be transformed, won't work. import * as utilities from \"@/utilities.ts\";\n\n```\n\nNor will any path that might resolve through the [`exports`](https://nodejs.org/api/packages.html#exports) and [`imports`](https://nodejs.org/api/packages.html#imports) fields of a `package.json` .\n\n``` // package.json { \"name\": \"my-package\", \"imports\": { \"#root/*\": \"./dist/*\" } }\n\n```\n\n``` // Won't be transformed, won't work. import * as utilities from \"#root/utilities.ts\";\n\n```\n\nAs a result, if you’ve been using a workspace-style layout with multiple packages referencing each other, you might need to use [conditional exports](https://nodejs.org/api/packages.html#conditional-exports) with [scoped custom conditions](https://nodejs.org/api/packages.html#resolving-user-conditions) to make this work:\n\n``` // my-package/package.json\n\n{ \"name\": \"my-package\", \"exports\": { \".\": { \"@my-package/development\": \"./src/index.ts\", \"import\": \"./lib/index.js\" }, \"./*\": { \"@my-package/development\": \"./src/*.ts\", \"import\": \"./lib/*.js\" } } }\n\n```\n\nAny time you want to import the `.ts` files, you can run it with `node --conditions=@my-package/development` .\n\nNote the \"namespace\" or \"scope\" we used for the condition `@my-package/development` . This is a bit of a makeshift solution to avoid conflicts from dependencies that might also use the `development` condition. If everyone ships a `development` in their package, then resolution may try to resolve to a `.ts` file which will not necessarily work. This idea is similar to what’s described in Colin McDonnell’s essay *[Live types in a TypeScript monorepo](https://colinhacks.com/essays/live-types-typescript-monorepo#:~:text=custom%20conditions)*, along with [tshy’s guidance for loading from source](https://github.com/isaacs/tshy#loading-from-source).\n\nFor more specifics on how this feature works, [read up on the change here](https://github.com/microsoft/TypeScript/pull/59767).\n\n## Support for `--target es2024`\nand `--lib es2024`\n\nTypeScript 5.7 now supports `--target es2024` , which allows users to target ECMAScript 2024 runtimes. This target primarily enables specifying the new `--lib es2024` which contains many features for `SharedArrayBuffer` and `ArrayBuffer` , `Object.groupBy` , `Map.groupBy` , `Promise.withResolvers` , and more. It also moves `Atomics.waitAsync` from `--lib es2022` to `--lib es2024` .\n\nNote that as part of the changes to `SharedArrayBuffer` and `ArrayBuffer` , the two now diverge a bit. To bridge the gap and preserve the underlying buffer type, all `TypedArrays` (like `Uint8Array` and others) [are now also generic](https://github.com/microsoft/TypeScript/pull/59417).\n\n``` interface Uint8Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike> { // ... }\n\n```\n\nEach `TypedArray` now contains a type parameter named `TArrayBuffer` , though that type parameter has a default type argument so that we can continue to refer to `Int32Array` without explicitly writing out `Int32Array<ArrayBufferLike>` .\n\nIf you encounter any issues as part of this update, you may need to update `@types/node` .\n\n[This work](https://github.com/microsoft/TypeScript/pull/58573) was primarily provided thanks to [Kenta Moriuchi](https://github.com/petamoriken)!\n\n## Searching Ancestor Configuration Files for Project Ownership\n\nWhen a TypeScript file is loaded in an editor using TSServer (like Visual Studio or VS Code), the editor will try to find the relevant `tsconfig.json` file that \"owns\" the file. To do this, it walks up the directory tree from the file being edited, looking for any file named `tsconfig.json` .\n\nPreviously, this search would stop at the first `tsconfig.json` file found; however, imagine a project structure like the following:\n\n``` project/ ├── src/ │ ├── foo.ts │ ├── foo-test.ts │ ├── tsconfig.json │ └── tsconfig.test.json └── tsconfig.json\n\n```\n\nHere, the idea is that `src/tsconfig.json` is the \"main\" configuration file for the project, and `src/tsconfig.test.json` is a configuration file for running tests.\n\n``` // src/tsconfig.json { \"compilerOptions\": { \"outDir\": \"../dist\" }, \"exclude\": [\"**/*.test.ts\"] }\n\n```\n\n``` // src/tsconfig.test.json { \"compilerOptions\": { \"outDir\": \"../dist/test\" }, \"include\": [\"**/*.test.ts\"], \"references\": [ { \"path\": \"./tsconfig.json\" } ] }\n\n```\n\n``` // tsconfig.json { // This is a \"workspace-style\" or \"solution-style\" tsconfig. // Instead of specifying any files, it just references all the actual projects. \"files\": [], \"references\": [ { \"path\": \"./src/tsconfig.json\" }, { \"path\": \"./src/tsconfig.test.json\" }, ] }\n\n```\n\nThe problem here is that when editing `foo-test.ts` , the editor would find `project/src/tsconfig.json` as the \"owning\" configuration file – but that’s not the one we want! If the walk stops at this point, that might not be desirable. The only way to avoid this previously was to rename `src/tsconfig.json` to something like `src/tsconfig.src.json` , and then all files would hit the top-level `tsconfig.json` which references every possible project.\n\n``` project/ ├── src/ │ ├── foo.ts │ ├── foo-test.ts │ ├── tsconfig.src.json │ └── tsconfig.test.json └── tsconfig.json\n\n```\n\nInstead of forcing developers to do this, TypeScript 5.7 now continues walking up the directory tree to find other appropriate `tsconfig.json` files for editor scenarios. This can provide more flexibility in how projects are organized and how configuration files are structured.\n\nYou can get more specifics on the implementation on GitHub [here](https://github.com/microsoft/TypeScript/pull/57196) and [here](https://github.com/microsoft/TypeScript/pull/59688).\n\n## Faster Project Ownership Checks in Editors for Composite Projects\n\nImagine a large codebase with the following structure:\n\n``` packages ├── graphics/ │ ├── tsconfig.json │ └── src/ │ └── ... ├── sound/ │ ├── tsconfig.json │ └── src/ │ └── ... ├── networking/ │ ├── tsconfig.json │ └── src/ │ └── ... ├── input/ │ ├── tsconfig.json │ └── src/ │ └── ... └── app/ ├── tsconfig.json ├── some-script.js └── src/ └── ...\n\n```\n\nEach directory in `packages` is a separate TypeScript project, and the `app` directory is the main project that depends on all the other projects.\n\n``` // app/tsconfig.json { \"compilerOptions\": { // ... }, \"include\": [\"src\"], \"references\": [ { \"path\": \"../graphics/tsconfig.json\" }, { \"path\": \"../sound/tsconfig.json\" }, { \"path\": \"../networking/tsconfig.json\" }, { \"path\": \"../input/tsconfig.json\" } ] }\n\n```\n\nNow notice we have the file `some-script.js` in the `app` directory. When we open `some-script.js` in the editor, the TypeScript language service (which also handles the editor experience for JavaScript files!) has to figure out which project the file belongs to so it can apply the right settings.\n\nIn this case, the nearest `tsconfig.json` does *not* include `some-script.js` , but TypeScript will proceed to ask \"could one of the projects *referenced* by `app/tsconfig.json` include `some-script.js` ?\". To do so, TypeScript would previously load up each project, one-by-one, and stop as soon as it found a project which contained `some-script.js` . Even if `some-script.js` isn’t included in the root set of files, TypeScript would still parse all the files within a project because some of the root set of files can still *transitively* reference `some-script.js` .\n\nWhat we found over time was that this behavior caused extreme and unpredictable behavior in larger codebases. Developers would open up stray script files and find themselves waiting for their entire codebase to be opened up.\n\nThankfully, every project that can be referenced by another (non-workspace) project must enable a flag called `composite` , which enforces a rule that all input source files must be known up-front. So when probing a `composite` project, TypeScript 5.7 will only check if a file belongs to the *root set of files* of that project. This should avoid this common worst-case behavior.\n\nFor more information, [see the change here](https://github.com/microsoft/TypeScript/pull/59688).\n\n### Validated JSON Imports in `--module nodenext`\n\nWhen importing from a `.json` file under `--module nodenext` , TypeScript will now enforce certain rules to prevent runtime errors.\n\nFor one, an import attribute containing `type: \"json\"` needs to be present for any JSON file import.\n\n``` import myConfig from \"./myConfig.json\"; // ~~~~~~~~~~~~~~~~~ // ❌ error: Importing a JSON file into an ECMAScript module requires a 'type: \"json\"' import attribute when 'module' is set to 'NodeNext'.\n\nimport myConfig from \"./myConfig.json\" with { type: \"json\" }; // ^^^^^^^^^^^^^^^^ // ✅ This is fine because we provided `type: \"json\"`\n\n```\n\nOn top of this validation, TypeScript will not generate \"named\" exports, and the contents of a JSON import will only be accessible via a default.\n\n``` // ✅ This is okay: import myConfigA from \"./myConfig.json\" with { type: \"json\" }; let version = myConfigA.version;\n\n///////////\n\nimport * as myConfigB from \"./myConfig.json\" with { type: \"json\" };\n\n// ❌ This is not: let version = myConfig.version;\n\n// ✅ This is okay: let version = myConfig.default.version;\n\n```\n\n[See here](https://github.com/microsoft/TypeScript/pull/60019) for more information on this change.\n\n## Support for V8 Compile Caching in Node.js\n\nNode.js 22 supports [a new API called `module.enableCompileCache()`](https://github.com/nodejs/node/pull/54501). This API allows the runtime to reuse some of the parsing and compilation work done after the first run of a tool.\n\nTypeScript 5.7 now leverages the API so that it can start doing useful work sooner. In some of our own testing, we’ve witnessed about a 2.5x speed-up in running `tsc --version` .\n\n``` Benchmark 1: node ./built/local/_tsc.js --version (*without* caching) Time (mean ± σ): 122.2 ms ± 1.5 ms [User: 101.7 ms, System: 13.0 ms] Range (min … max): 119.3 ms … 132.3 ms 200 runs\n\nBenchmark 2: node ./built/local/tsc.js --version (*with* caching) Time (mean ± σ): 48.4 ms ± 1.0 ms [User: 34.0 ms, System: 11.1 ms] Range (min … max): 45.7 ms … 52.8 ms 200 runs\n\nSummary node ./built/local/tsc.js --version ran 2.52 ± 0.06 times faster than node ./built/local/_tsc.js --version\n\n```\n\nFor more information, [see the pull request here](https://github.com/microsoft/TypeScript/pull/59720).\n\n## Notable Behavioral Changes\n\nThis section highlights a set of noteworthy changes that should be acknowledged and understood as part of any upgrade. Sometimes it will highlight deprecations, removals, and new restrictions. It can also contain bug fixes that are functionally improvements, but which can also affect an existing build by introducing new errors.\n\n### `lib.d.ts`\n\nTypes generated for the DOM may have an impact on type-checking your codebase. For more information, [see linked issues related to DOM and `lib.d.ts` updates for this version of TypeScript](https://github.com/microsoft/TypeScript/pull/60061).\n\n### `TypedArray`\ns Are Now Generic Over `ArrayBufferLike`\n\nIn ECMAScript 2024, `SharedArrayBuffer` and `ArrayBuffer` have types that slightly diverge. To bridge the gap and preserve the underlying buffer type, all `TypedArrays` (like `Uint8Array` and others) [are now also generic](https://github.com/microsoft/TypeScript/pull/59417).\n\n``` interface Uint8Array<TArrayBuffer extends ArrayBufferLike = ArrayBufferLike> { // ... }\n\n```\n\nEach `TypedArray` now contains a type parameter named `TArrayBuffer` , though that type parameter has a default type argument so that users can continue to refer to `Int32Array` without explicitly writing out `Int32Array<ArrayBufferLike>` .\n\nIf you encounter any issues as part of this update, such as\n\n``` error TS2322: Type 'Buffer' is not assignable to type 'Uint8Array<ArrayBufferLike>'. error TS2345: Argument of type 'Buffer' is not assignable to parameter of type 'Uint8Array<ArrayBufferLike>'. error TS2345: Argument of type 'ArrayBufferLike' is not assignable to parameter of type 'ArrayBuffer'. error TS2345: Argument of type 'Buffer' is not assignable to parameter of type 'string | ArrayBufferView | Stream | Iterable<string | ArrayBufferView> | AsyncIterable<string | ArrayBufferView>'.\n\n```\n\nthen you may need to update `@types/node` .\n\nYou can read the [specifics about this change on GitHub](https://github.com/microsoft/TypeScript/pull/59417).\n\n### Creating Index Signatures from Non-Literal Method Names in Classes\n\nTypeScript now has a more consistent behavior for methods in classes when they are declared with non-literal computed property names. For example, in the following:\n\n``` declare const symbolMethodName: symbol;\n\nexport class A { [symbolMethodName]() { return 1 }; }\n\n```\n\nPreviously TypeScript just viewed the class in a way like the following:\n\n``` export class A { }\n\n```\n\nIn other words, from the type system’s perspective, `[symbolMethodName]` contributed nothing to the type of `A`\n\nTypeScript 5.7 now views the method `[symbolMethodName]() {}` more meaningfully, and generates an index signature. As a result, the code above is interpreted as something like the following code:\n\n``` export class A { [x: symbol]: () => number; }\n\n```\n\nThis provides behavior that is consistent with properties and methods in object literals.\n\n[Read up more on this change here](https://github.com/microsoft/TypeScript/pull/59860).\n\n### More Implicit `any`\nErrors on Functions Returning `null` and `undefined`\n\nWhen a function expression is contextually typed by a signature returning a generic type, TypeScript now appropriately provides an implicit `any` error under `noImplicitAny` , but outside of `strictNullChecks` .\n\n``` declare var p: Promise<number>; const p2 = p.catch(() => null); // ~~~~~~~~~~ // error TS7011: Function expression, which lacks return-type annotation, implicitly has an 'any' return type.\n\n```\n\n[See this change for more details](https://github.com/microsoft/TypeScript/pull/59661).\n\n## What’s Next?\n\nAt this point, we anticipate very few changes to TypeScript 5.7 apart from critical bug fixes to the compiler and minor bug fixes to the language service. In the next few weeks, we’ll be releasing the first stable version of TypeScript 5.7. [Keep an eye on our iteration plan](https://github.com/microsoft/TypeScript/issues/59905) for target release dates and more if you need to coordinate around that.\n\nOtherwise, our main focus is on developing TypeScript 5.7, and we’ll have the iteration plan available in the coming days (including scheduled release dates). On top of that, we make it easy to use [nightly builds of TypeScript on npm](https://www.typescriptlang.org/docs/handbook/nightly-builds.html), and there is [an extension to use those nightly releases in Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next).\n\nSo give the RC or our nightlies a try, and let us know how it goes!\n\nHappy Hacking!\n\n– Daniel Rosenwasser and the TypeScript Team",
  "FeedUrl": "https://devblogs.microsoft.com/typescript/feed/",
  "Title": "Announcing TypeScript 5.7 RC",
  "FeedLevelAuthor": "TypeScript",
  "Link": "https://devblogs.microsoft.com/typescript/announcing-typescript-5-7-rc/",
  "Tags": [
    "TypeScript"
  ],
  "OutputDir": "_news",
  "Author": "Daniel Rosenwasser",
  "ProcessedDate": "2025-08-05 11:18:32",
  "Description": "Today we are announcing the availability of the release candidate of TypeScript 5.7. To get started using the RC, you can get it through npm with the following command: npm install -D typescript@rc Let’s take a look at what’s new in TypeScript 5.7! Checks for Never-Initialized Variables For a long time, TypeScript has been able […]\n\nThe post [Announcing TypeScript 5.7 RC](https://devblogs.microsoft.com/typescript/announcing-typescript-5-7-rc/) appeared first on [TypeScript](https://devblogs.microsoft.com/typescript).",
  "FeedName": "Microsoft TypeScript Blog"
}
