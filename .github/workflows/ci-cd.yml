name: CI/CD Pipeline

on:
  push:
    branches: [dotnet-migration]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      force-infra-deploy:
        description: 'Force infrastructure deployment even if no infra files changed'
        type: boolean
        default: false

# Allow cancellation of in-progress runs when new commits are pushed
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  id-token: write
  pull-requests: read
  security-events: write

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CI JOBS â€” Run on every trigger (push, PR, manual)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

jobs:
  build:
    name: Build .NET Solution
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Restore dependencies
        run: dotnet restore TechHub.slnx

      - name: Build solution
        run: dotnet build TechHub.slnx --configuration Release --no-restore

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: |
            **/bin/Release/
            **/obj/Release/
          retention-days: 1

  test-unit:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Restore dependencies
        run: dotnet restore TechHub.slnx

      - name: Run unit tests
        run: |
          dotnet test --project tests/TechHub.Core.Tests/TechHub.Core.Tests.csproj \
            --configuration Release --no-restore \
            --results-directory TestResults \
            --report-xunit-trx --report-xunit-trx-filename core-test-results.trx \
            -- --coverage --coverage-output-format cobertura \
            --coverage-output ${{ github.workspace }}/TestResults/core-coverage.cobertura.xml
          dotnet test --project tests/TechHub.Web.Tests/TechHub.Web.Tests.csproj \
            --configuration Release --no-restore \
            --results-directory TestResults \
            --report-xunit-trx --report-xunit-trx-filename web-test-results.trx \
            -- --coverage --coverage-output-format cobertura \
            --coverage-output ${{ github.workspace }}/TestResults/web-coverage.cobertura.xml

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: unit-test-results
          path: '**/TestResults/**'
          retention-days: 7

      - name: Upload coverage data
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-unit
          path: '**/TestResults/*-coverage.cobertura.xml'
          retention-days: 7

  test-integration:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Restore dependencies
        run: dotnet restore TechHub.slnx

      - name: Run integration tests
        run: |
          dotnet test --project tests/TechHub.Api.Tests/TechHub.Api.Tests.csproj \
            --configuration Release \
            --no-restore \
            --results-directory TestResults \
            --report-xunit-trx \
            --report-xunit-trx-filename integration-test-results.trx \
            -- --coverage --coverage-output-format cobertura \
            --coverage-output ${{ github.workspace }}/TestResults/api-coverage.cobertura.xml
          dotnet test --project tests/TechHub.Infrastructure.Tests/TechHub.Infrastructure.Tests.csproj \
            --configuration Release \
            --no-restore \
            --results-directory TestResults \
            --report-xunit-trx \
            --report-xunit-trx-filename infrastructure-test-results.trx \
            -- --coverage --coverage-output-format cobertura \
            --coverage-output ${{ github.workspace }}/TestResults/infrastructure-coverage.cobertura.xml

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: integration-test-results
          path: '**/TestResults/**'
          retention-days: 7

      - name: Upload coverage data
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-integration
          path: '**/TestResults/*-coverage.cobertura.xml'
          retention-days: 7

  test-e2e:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: build

    services:
      postgres:
        image: postgres:17-alpine
        env:
          POSTGRES_DB: techhub
          POSTGRES_USER: techhub
          POSTGRES_PASSWORD: localdev
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U techhub -d techhub"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Restore dependencies
        run: dotnet restore TechHub.slnx

      - name: Build solution
        run: dotnet build TechHub.slnx --configuration Release --no-restore

      - name: Install Playwright dependencies
        run: |
          cd tests/TechHub.E2E.Tests
          pwsh bin/Release/net10.0/playwright.ps1 install --with-deps

      - name: Generate dev certificate
        run: dotnet dev-certs https

      - name: Start API server
        run: |
          nohup dotnet run --project src/TechHub.Api/TechHub.Api.csproj \
            --launch-profile Development --no-build --configuration Release \
            > /tmp/api-server.log 2>&1 &
          echo $! > /tmp/api-server.pid
          echo "API server started (PID: $(cat /tmp/api-server.pid))"
        env:
          AppSettings__Content__CollectionsPath: ${{ github.workspace }}/collections
          Database__ConnectionString: "Host=localhost;Port=5432;Database=techhub;Username=techhub;Password=localdev"

      - name: Start Web server
        run: |
          nohup dotnet run --project src/TechHub.Web/TechHub.Web.csproj \
            --launch-profile Development --no-build --configuration Release \
            > /tmp/web-server.log 2>&1 &
          echo $! > /tmp/web-server.pid
          echo "Web server started (PID: $(cat /tmp/web-server.pid))"

      - name: Wait for servers to be ready
        run: |
          API_READY=false
          echo "Waiting for API to be ready (health check must return 200)..."
          for i in $(seq 1 120); do
            HTTP_CODE=$(curl -sk -o /dev/null -w '%{http_code}' https://localhost:5001/health 2>/dev/null || true)
            if [ "$HTTP_CODE" = "200" ]; then
              echo ""
              echo "API is ready! (health returned 200)"
              API_READY=true
              break
            fi
            echo "Attempt $i - API not ready yet (HTTP $HTTP_CODE)..."
            sleep 5
          done

          if [ "$API_READY" = "false" ]; then
            echo "::error::API server failed to start within timeout"
            echo "--- Listening ports ---"
            ss -tlnp 2>/dev/null | grep -E '5001|5003' || echo "No relevant ports listening"
            echo "--- API Server Log (first 30 lines, for Kestrel binding) ---"
            head -30 /tmp/api-server.log || true
            echo "--- API Server Log (last 80 lines) ---"
            tail -80 /tmp/api-server.log || true
            echo "--- API PID check ---"
            ps -p $(cat /tmp/api-server.pid 2>/dev/null) 2>/dev/null || echo "Process not running"
            exit 1
          fi

          WEB_READY=false
          echo "Waiting for Web to be ready..."
          for i in $(seq 1 60); do
            if curl -sk -o /dev/null -w '%{http_code}' https://localhost:5003 2>/dev/null | grep -q '200'; then
              echo ""
              echo "Web is ready!"
              WEB_READY=true
              break
            fi
            echo "Attempt $i - Web not ready yet..."
            sleep 5
          done

          if [ "$WEB_READY" = "false" ]; then
            echo "::error::Web server failed to start within timeout"
            echo "--- Listening ports ---"
            ss -tlnp 2>/dev/null | grep -E '5001|5003' || echo "No relevant ports listening"
            echo "--- Web Server Log (first 30 lines, for Kestrel binding) ---"
            head -30 /tmp/web-server.log || true
            echo "--- Web Server Log (last 80 lines) ---"
            tail -80 /tmp/web-server.log || true
            echo "--- Web PID check ---"
            ps -p $(cat /tmp/web-server.pid 2>/dev/null) 2>/dev/null || echo "Process not running"
            exit 1
          fi

      - name: Run E2E tests
        run: |
          dotnet test --project tests/TechHub.E2E.Tests/TechHub.E2E.Tests.csproj \
            --configuration Release \
            --no-build \
            --results-directory TestResults \
            --report-xunit-trx \
            --report-xunit-trx-filename e2e-test-results.trx
        env:
          AppSettings__Content__CollectionsPath: ${{ github.workspace }}/collections
          Database__ConnectionString: "Host=localhost;Port=5432;Database=techhub;Username=techhub;Password=localdev"

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: e2e-test-results
          path: '**/TestResults/**'
          retention-days: 7

      - name: Upload Playwright traces
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: playwright-traces
          path: tests/TechHub.E2E.Tests/bin/Release/net10.0/playwright-traces/
          retention-days: 7

      - name: Upload server logs
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: e2e-server-logs
          path: /tmp/*-server.log
          retention-days: 7

  test-powershell:
    name: PowerShell Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Pester and dependencies
        shell: pwsh
        run: |
          Install-Module -Name Pester -MinimumVersion 5.0.0 -Force -Scope CurrentUser
          Install-Module -Name HtmlToMarkdown -Force -Scope CurrentUser

      - name: Run Pester tests
        shell: pwsh
        run: |
          # Pre-load all content-processing functions (required by tests)
          . "$PWD/tests/powershell/Initialize-BeforeAll.ps1"

          $config = New-PesterConfiguration
          $config.Run.Path = "tests/powershell"
          $config.Output.Verbosity = "Detailed"
          $config.TestResult.Enabled = $true
          $config.TestResult.OutputPath = "TestResults/pester-results.xml"
          $config.TestResult.OutputFormat = "JUnitXml"
          Invoke-Pester -Configuration $config

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: powershell-test-results
          path: TestResults/pester-results.xml
          retention-days: 7

  lint:
    name: Lint & Format Check
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Restore .NET dependencies
        run: dotnet restore TechHub.slnx

      - name: Check dotnet format
        run: |
          dotnet format TechHub.slnx --verify-no-changes --verbosity diagnostic --severity error

      - name: Install npm dependencies
        run: npm ci

      - name: Run markdownlint
        run: |
          npx markdownlint-cli2 "**/*.md" "#node_modules" "#.tmp"

  security:
    name: Security Scan
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '10.0.x'

      - name: Restore dependencies
        run: dotnet restore TechHub.slnx

      - name: Run dependency vulnerability scan
        run: |
          dotnet list TechHub.slnx package --vulnerable --include-transitive

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.32.0
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'
          skip-dirs: 'node_modules,.tmp'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  code-coverage:
    name: Code Coverage Report
    runs-on: ubuntu-latest
    needs: [test-unit, test-integration]
    if: always()

    steps:
      - name: Download unit coverage
        uses: actions/download-artifact@v4
        with:
          name: coverage-unit
          path: coverage-data/unit
        continue-on-error: true

      - name: Download integration coverage
        uses: actions/download-artifact@v4
        with:
          name: coverage-integration
          path: coverage-data/integration
        continue-on-error: true

      - name: Install ReportGenerator
        run: dotnet tool install -g dotnet-reportgenerator-globaltool

      - name: Merge and generate coverage report
        run: |
          # Find all Cobertura XML files
          COVERAGE_FILES=$(find coverage-data -name '*.cobertura.xml' -type f 2>/dev/null | tr '\n' ';')

          if [ -z "$COVERAGE_FILES" ]; then
            echo "## ðŸ“Š Code Coverage Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âš ï¸ No coverage data available. Test jobs may have failed." >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          echo "Found coverage files: $COVERAGE_FILES"

          reportgenerator \
            -reports:"$COVERAGE_FILES" \
            -targetdir:coverage-report \
            -reporttypes:"Cobertura;MarkdownSummaryGithub" \
            -verbosity:Warning

          # Append Markdown summary to GitHub Step Summary
          if [ -f coverage-report/SummaryGithub.md ]; then
            echo "## ðŸ“Š Code Coverage Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            cat coverage-report/SummaryGithub.md >> $GITHUB_STEP_SUMMARY
          fi

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-report
          path: coverage-report/
          retention-days: 7

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # Quality Gate â€” All CI checks must pass before deployment
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  quality-gate:
    name: Quality Gate
    runs-on: ubuntu-latest
    needs: [build, test-unit, test-integration, test-e2e, test-powershell, lint, security]
    if: always()

    steps:
      - name: Check quality gate
        run: |
          echo "## ðŸŽ¯ Quality Gate Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Check each job result
          BUILD_STATUS="${{ needs.build.result }}"
          UNIT_STATUS="${{ needs.test-unit.result }}"
          INTEGRATION_STATUS="${{ needs.test-integration.result }}"
          E2E_STATUS="${{ needs.test-e2e.result }}"
          POWERSHELL_STATUS="${{ needs.test-powershell.result }}"
          LINT_STATUS="${{ needs.lint.result }}"
          SECURITY_STATUS="${{ needs.security.result }}"

          echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY

          # Build
          if [ "$BUILD_STATUS" = "success" ]; then
            echo "| ðŸ—ï¸ Build | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸ—ï¸ Build | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          # Unit Tests
          if [ "$UNIT_STATUS" = "success" ]; then
            echo "| ðŸ§ª Unit Tests | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸ§ª Unit Tests | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          # Integration Tests
          if [ "$INTEGRATION_STATUS" = "success" ]; then
            echo "| ðŸ”— Integration Tests | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸ”— Integration Tests | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          # E2E Tests
          if [ "$E2E_STATUS" = "success" ]; then
            echo "| ðŸŒ E2E Tests | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸŒ E2E Tests | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          # PowerShell Tests
          if [ "$POWERSHELL_STATUS" = "success" ]; then
            echo "| ðŸ”µ PowerShell Tests | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸ”µ PowerShell Tests | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          # Lint
          if [ "$LINT_STATUS" = "success" ]; then
            echo "| ðŸ“ Linting & Formatting | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸ“ Linting & Formatting | âŒ Failed |" >> $GITHUB_STEP_SUMMARY
          fi

          # Security
          if [ "$SECURITY_STATUS" = "success" ]; then
            echo "| ðŸ”’ Security Scan | âœ… Passed |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| ðŸ”’ Security Scan | âš ï¸ Issues Found |" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY

          # Overall result
          if [ "$BUILD_STATUS" = "success" ] && \
             [ "$UNIT_STATUS" = "success" ] && \
             [ "$INTEGRATION_STATUS" = "success" ] && \
             [ "$E2E_STATUS" = "success" ] && \
             [ "$POWERSHELL_STATUS" = "success" ] && \
             [ "$LINT_STATUS" = "success" ]; then
            echo "### âœ… All quality gates passed! ðŸŽ‰" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # PR-specific guidance
            if [ "${{ github.event_name }}" = "pull_request" ]; then
              echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
              echo "- ðŸŽ‰ This PR is ready for review and merge!" >> $GITHUB_STEP_SUMMARY
              echo "- ðŸ“Š Code coverage reports available in artifacts" >> $GITHUB_STEP_SUMMARY
              if [ "$SECURITY_STATUS" != "success" ]; then
                echo "- âš ï¸ Note: Security scan found issues - review Security tab" >> $GITHUB_STEP_SUMMARY
              fi
            fi

            exit 0
          else
            echo "### âŒ Quality gate failed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Please fix the failing checks before merging:**" >> $GITHUB_STEP_SUMMARY

            if [ "$BUILD_STATUS" != "success" ]; then
              echo "- ðŸ—ï¸ Build failed - check compilation errors" >> $GITHUB_STEP_SUMMARY
            fi
            if [ "$UNIT_STATUS" != "success" ] || [ "$INTEGRATION_STATUS" != "success" ] || [ "$E2E_STATUS" != "success" ] || [ "$POWERSHELL_STATUS" != "success" ]; then
              echo "- ðŸ§ª Tests failed - see test results in job logs" >> $GITHUB_STEP_SUMMARY
            fi
            if [ "$LINT_STATUS" != "success" ]; then
              echo "- ðŸ“ Code formatting issues - run \`dotnet format\` and \`markdownlint-cli2 --fix\`" >> $GITHUB_STEP_SUMMARY
            fi

            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ“– See [testing documentation](docs/testing-strategy.md) for help" >> $GITHUB_STEP_SUMMARY

            exit 1
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # DEPLOYMENT JOBS â€” Only run on push/manual (NOT on PRs)
  # All deployment jobs require quality-gate to pass first
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'
    needs: quality-gate
    outputs:
      infra-changed: ${{ steps.result.outputs.infra-changed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check for infrastructure changes
        uses: dorny/paths-filter@v3
        id: changes
        with:
          filters: |
            infra:
              - 'infra/**'

      - name: Determine infra deployment
        id: result
        run: |
          if [[ "${{ steps.changes.outputs.infra }}" == "true" || "${{ inputs.force-infra-deploy }}" == "true" ]]; then
            echo "infra-changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "infra-changed=false" >> "$GITHUB_OUTPUT"
          fi

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Shared infrastructure (ACR) â€” runs first, only when infra changed
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy-shared-infra:
    name: Deploy Shared Infrastructure
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.infra-changed == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy shared infrastructure
        shell: pwsh
        run: |
          ./scripts/Deploy-Infrastructure.ps1 `
            -Environment shared `
            -Mode deploy

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Build & push Docker images
  # Runs after shared infra (ACR must exist), BEFORE env infra
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  build-and-push:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy-shared-infra]
    if: |
      always() &&
      needs.detect-changes.result == 'success' &&
      (needs.deploy-shared-infra.result == 'success' || needs.deploy-shared-infra.result == 'skipped')
    outputs:
      image-tag: ${{ github.sha }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Build and push images
        shell: pwsh
        run: |
          ./scripts/Deploy-Application.ps1 `
            -Environment staging `
            -Tag "${{ github.sha }}" `
            -SkipDeploy

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Staging infrastructure â€” only when infra changed
  # Runs after build so image tag can be passed to Bicep
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy-staging-infra:
    name: Deploy Staging Infrastructure
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy-shared-infra, build-and-push]
    if: |
      always() &&
      needs.detect-changes.outputs.infra-changed == 'true' &&
      needs.build-and-push.result == 'success' &&
      (needs.deploy-shared-infra.result == 'success' || needs.deploy-shared-infra.result == 'skipped')
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy staging infrastructure
        shell: pwsh
        env:
          POSTGRES_ADMIN_PASSWORD: ${{ secrets.POSTGRES_ACC_PW }}
        run: |
          ./scripts/Deploy-Infrastructure.ps1 `
            -Environment staging `
            -Mode deploy `
            -ImageTag "${{ needs.build-and-push.outputs.image-tag }}"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Deploy application to staging
  # Waits for both images and staging infra
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-staging-infra]
    if: |
      always() &&
      needs.build-and-push.result == 'success' &&
      needs.deploy-staging-infra.result == 'skipped'
    environment:
      name: staging
      url: https://${{ steps.deploy.outputs.web-url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy to Staging
        id: deploy
        shell: pwsh
        run: |
          ./scripts/Deploy-Application.ps1 `
            -Environment staging `
            -Tag "${{ needs.build-and-push.outputs.image-tag }}" `
            -SkipBuild -SkipPush

          $webUrl = az containerapp show `
            --name ca-techhub-web-staging `
            --resource-group rg-techhub-staging `
            --query properties.configuration.ingress.fqdn `
            -o tsv
          "web-url=$webUrl" | Out-File -Append -FilePath $env:GITHUB_OUTPUT

      - name: Deployment summary
        run: |
          echo "## Staging Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag**: ${{ needs.build-and-push.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Infrastructure**: ${{ needs.deploy-staging-infra.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**Web**: https://${{ steps.deploy.outputs.web-url }}" >> $GITHUB_STEP_SUMMARY

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Production infrastructure â€” only when infra changed
  # Uses GitHub environment protection for approval
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy-production-infra:
    name: Deploy Production Infrastructure
    runs-on: ubuntu-latest
    needs: [detect-changes, deploy-staging, build-and-push]
    if: needs.detect-changes.outputs.infra-changed == 'true'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy production infrastructure
        shell: pwsh
        env:
          POSTGRES_ADMIN_PASSWORD: ${{ secrets.POSTGRES_PROD_PW }}
        run: |
          ./scripts/Deploy-Infrastructure.ps1 `
            -Environment production `
            -Mode deploy `
            -ImageTag "${{ needs.build-and-push.outputs.image-tag }}"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Deploy application to production
  # Uses GitHub environment protection for approval
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-staging, deploy-staging-infra, deploy-production-infra]
    if: |
      always() &&
      needs.build-and-push.result == 'success' &&
      (needs.deploy-staging.result == 'success' || needs.deploy-staging-infra.result == 'success') &&
      needs.deploy-production-infra.result == 'skipped'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Deploy to Production
        id: deploy
        shell: pwsh
        run: |
          ./scripts/Deploy-Application.ps1 `
            -Environment production `
            -Tag "${{ needs.build-and-push.outputs.image-tag }}" `
            -SkipBuild -SkipPush

          $webUrl = az containerapp show `
            --name ca-techhub-web-prod `
            --resource-group rg-techhub-prod `
            --query properties.configuration.ingress.fqdn `
            -o tsv
          "web-url=$webUrl" | Out-File -Append -FilePath $env:GITHUB_OUTPUT

      - name: Deployment summary
        run: |
          echo "## Production Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag**: ${{ needs.build-and-push.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Infrastructure**: ${{ needs.deploy-production-infra.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed By**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Web**: https://${{ steps.deploy.outputs.web-url }}" >> $GITHUB_STEP_SUMMARY
