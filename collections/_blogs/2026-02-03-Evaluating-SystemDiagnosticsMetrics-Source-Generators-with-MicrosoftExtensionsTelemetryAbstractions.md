---
external_url: https://andrewlock.net/creating-strongly-typed-metics-with-a-source-generator/
title: Evaluating System.Diagnostics.Metrics Source Generators with Microsoft.Extensions.Telemetry.Abstractions
author: Andrew Lock
primary_section: dotnet
feed_name: Andrew Lock's Blog
date: 2026-02-03 10:00:00 +00:00
tags:
- .NET 6
- .NET Core
- Blogs
- Boilerplate Reduction
- C#
- Counter
- Instrumentation
- Meter
- Metrics
- Microsoft.Extensions.Telemetry.Abstractions
- Observability
- OpenTelemetry
- Performance
- Source Generators
- Strongly Typed Tags
- System.Diagnostics.Metrics
- .NET
section_names:
- dotnet
---
Andrew Lock dives into the System.Diagnostics.Metrics source generators in Microsoft.Extensions.Telemetry.Abstractions, examining their implementation, generated code, and practical value for .NET developers.<!--excerpt_end-->

# Evaluating System.Diagnostics.Metrics Source Generators with Microsoft.Extensions.Telemetry.Abstractions

Author: Andrew Lock

## Introduction

This post investigates the use of source generators shipped in the [Microsoft.Extensions.Telemetry.Abstractions](https://www.nuget.org/packages/Microsoft.Extensions.Telemetry.Abstractions) package for generating boilerplate code around the System.Diagnostics.Metrics APIs, introduced in .NET 6. The discussion centers around how these source generators modify the process of defining and recording metrics, and their real-world usefulness.

## Background: System.Diagnostics.Metrics APIs

System.Diagnostics.Metrics provides APIs for defining and recording metrics in .NET applications. Key abstractions include:

- **Instrument:** Represents a single metric (e.g., products sold).
- **Meter:** Groups related instruments together for logical organization.

There are several types of instruments, including Counter<T>, UpDownCounter<T>, Gauge<T>, and Histogram<T>. Metrics can be created manually by instantiating these types and wiring up the appropriate methods in application code.

## The Manual Approach

Andrew demonstrates the traditional approach of defining a metrics helper class that manually creates the relevant Meter and Counter, wiring everything up for dependency injection. The process, while requiring some boilerplate, is clear and flexible.

```csharp
public class ProductMetrics
{
  private readonly Counter<long> _pricingDetailsViewed;

  public ProductMetrics(IMeterFactory meterFactory) {
    var meter = meterFactory.Create("MyApp.Products");
    _pricingDetailsViewed = meter.CreateCounter<int>(
      "myapp.products.pricing_page_requests",
      unit: "requests",
      description: "The number of requests to the pricing details page for the product with the given product_id"
    );
  }

  public void PricingPageViewed(int id) {
    _pricingDetailsViewed.Add(1, new KeyValuePair<string, object?>("product_id", id));
  }
}
```

## Using the Source Generator

With the source generator from Microsoft.Extensions.Telemetry.Abstractions, a portion of this boilerplate can be eliminated by applying specific attributes to partial methods in a factory class. For example:

```csharp
private static partial class Factory {
  [Counter<int>("product_id", Name = "myapp.products.pricing_page_requests")]
  internal static partial PricingPageViewed CreatePricingPageViewed(Meter meter);
}
```

The metrics helper is then updated to utilize the factory method generated by the source generator. The resulting `ProductMetrics` becomes a partial class using the generated strongly-typed metric wrappers.

## Observations: Generated Code and Practical Impact

Andrew inspects the generated code and concludes that, while it formalizes some patterns and supports less common scenarios (such as sharing instruments across meters), in practical terms it does not reduce significant boilerplate or provide performance gains over hand-written code for most situations. Some limitations include the inability to specify full metric metadata directly and the necessity to accommodate the generator's generic method signatures when calling Add().

### Strongly-Typed Tag Objects

The generator supports a strongly-typed tags option, which uses a custom struct to encapsulate tag values for type safety and reduced parameter ambiguity. However, this adds only modest benefit, as similar type safety can easily be implemented manually.

## Overall Assessment

While source generators can be valuable in some places, Andrew's assessment for System.Diagnostics.Metrics is that the generator does not deliver notable benefits for most day-to-day usage, as the underlying APIs are already quite ergonomic. Its main value lies in specialized use-cases or for those who prefer attribute-driven code generation.

## Summary

This article provided:

- An overview of System.Diagnostics.Metrics manual and source-generator-based approaches
- Implementation walkthroughs and sample code
- Comparison of usability, flexibility, and efficiency
- Critical assessment highlighting current limitations and scenarios where generators might or might not be worthwhile

The post concludes that, at present, manually controlling metric definitions often results in clearer, more performant application code. Future improvements to the generator or evolving scenarios may change this calculus.

This post appeared first on "Andrew Lock's Blog". [Read the entire article here](https://andrewlock.net/creating-strongly-typed-metics-with-a-source-generator/)
