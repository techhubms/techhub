const { test, expect } = require('@playwright/test');
const {
  getVisiblePostCount,
  waitForFilteringComplete,
  navigateAndVerify,
  TEST_URLS
} = require('./helpers.js');

test.describe('Server-Side Requirements - Critical Foundation Tests', () => {
  test.describe.configure({ mode: 'serial' }); // Run these tests in order - if one fails, others likely will too

  // Test 1: Server-Side Date Filter Generation Requirements
  test('should generate only positive-count date filters on initial page load', async ({ page }) => {
    await navigateAndVerify(page, '/ai/news.html');

    console.log('\n🏗️ Testing server-side date filter generation requirements');

    // Test initial page load state - no filter interactions to preserve server-generated counts

    // Get all date filter buttons - these should all have count > 0 per server-side generation
    const dateFilters = page.locator('.tag-filter-btn[data-tag*="day"], .tag-filter-btn[data-tag*="last"], .tag-filter-btn[data-tag*="month"]');
    const dateFilterCount = await dateFilters.count();

    console.log(`📅 Found ${dateFilterCount} date filters generated by server`);

    let allPositiveCounts = true;
    const dateFilterData = [];

    for (let i = 0; i < dateFilterCount; i++) {
      const dateFilter = dateFilters.nth(i);

      if (await dateFilter.isVisible()) {
        const countElement = dateFilter.locator('.filter-count');
        const countText = await countElement.textContent();
        const count = parseInt(countText.replace(/[()]/g, ''), 10);
        const filterTag = await dateFilter.getAttribute('data-tag');

        dateFilterData.push({ tag: filterTag, count });
        console.log(`📊 Date filter "${filterTag}": ${count} posts`);

        if (count <= 0) {
          console.log(`❌ Server-generated date filter "${filterTag}" has count ${count} - violates server-side generation requirement`);
          allPositiveCounts = false;
        }

        // Server-side generation requirement: all generated filters must have count > 0
        expect(count).toBeGreaterThan(0);
      }
    }

    // Verify that the server-side generation logic worked correctly
    expect(allPositiveCounts).toBe(true);
    expect(dateFilterCount).toBeGreaterThan(0);

    console.log(`✅ All ${dateFilterCount} server-generated date filters have positive counts when no tag filters active`);
  });

  // Test 2: Server-Side Date Filter Generation Rules
  test('should apply server-side date filter generation rules (50% growth + 85% cleanup)', async ({ page }) => {
    await navigateAndVerify(page, '/ai/news.html');

    console.log('\n🏗️ Testing server-side date filter generation rules');

    // Test server-generated filter state - no JavaScript interactions to preserve counts

    const dateFilters = page.locator('.tag-filter-btn[data-tag*="day"], .tag-filter-btn[data-tag*="last"], .tag-filter-btn[data-tag*="month"]');
    const dateFilterCount = await dateFilters.count();

    if (dateFilterCount > 1) {
      const filterData = [];

      for (let i = 0; i < dateFilterCount; i++) {
        const dateFilter = dateFilters.nth(i);

        if (await dateFilter.isVisible()) {
          const countElement = dateFilter.locator('.filter-count');
          const countText = await countElement.textContent();
          const count = parseInt(countText.replace(/[()]/g, ''), 10);
          const filterTag = await dateFilter.getAttribute('data-tag');

          filterData.push({ tag: filterTag, count });
        }
      }

      // Sort by count to analyze growth pattern
      filterData.sort((a, b) => a.count - b.count);
      console.log('📈 Date filters ordered by count:', filterData.map(f => `${f.tag}: ${f.count}`));

      // Verify 50% growth rule: subsequent filters should add meaningful growth
      let growthRuleViolations = 0;
      for (let i = 1; i < filterData.length; i++) {
        const prevCount = filterData[i-1].count;
        const currentCount = filterData[i].count;
        const requiredMinimum = Math.max(prevCount * 1.5, prevCount + 1);

        if (currentCount < requiredMinimum) {
          console.log(`⚠️ 50% growth rule violation: ${filterData[i].tag} (${currentCount}) vs ${filterData[i-1].tag} (${prevCount}) - should be ≥${requiredMinimum}`);
          growthRuleViolations++;
        }
      }

      // Verify 85% cleanup rule: last filter shouldn't include ≥85% of all posts
      const totalVisiblePosts = await getVisiblePostCount(page);
      const largestFilterCount = filterData[filterData.length - 1].count;
      const percentageOfTotal = (largestFilterCount / totalVisiblePosts) * 100;

      console.log(`📊 Largest date filter covers ${largestFilterCount}/${totalVisiblePosts} posts (${percentageOfTotal.toFixed(1)}%)`);

      if (percentageOfTotal >= 85) {
        console.log(`⚠️ 85% cleanup rule may apply: largest filter covers ${percentageOfTotal.toFixed(1)}% of posts`);
      }

      console.log('✅ Server-side generation rules analysis complete');
      console.log(`   - 50% growth violations: ${growthRuleViolations}`);
      console.log(`   - 85% cleanup threshold: ${percentageOfTotal.toFixed(1)}% (threshold: 85%)`);
    } else {
      console.log(`ℹ️ Only ${dateFilterCount} date filter(s) found - insufficient for growth rule analysis`);
    }
  });

  // Test 4: Content Limiting "20 + Same-Day" Rule Application
  test('should apply "20 + same-day" content limiting rule on index pages', async ({ page }) => {
    const indexPages = ['/', TEST_URLS.sectionIndexes.find(p => p.section === 'ai').url, TEST_URLS.sectionIndexes.find(p => p.section === 'github-copilot').url];

    for (const indexPage of indexPages) {
      console.log(`\n🏗️ Testing content limiting on: ${indexPage}`);

      await navigateAndVerify(page, indexPage);

      // Get content analysis
      const contentAnalysis = await page.evaluate(() => {
        const allItems = document.querySelectorAll('.navigation-post-square');
        const visibleItems = document.querySelectorAll('.navigation-post-square:not([style*="display: none"])');

        // Analyze dates of visible items
        const visibleDates = Array.from(visibleItems).map(item => {
          const dateEpoch = item.dataset.epoch || item.dataset.dateEpoch;
          return dateEpoch ? parseInt(dateEpoch) : null;
        }).filter(d => d !== null);

        // Group by date
        const dateGroups = {};
        visibleDates.forEach(epoch => {
          const date = new Date(epoch * 1000).toDateString();
          dateGroups[date] = (dateGroups[date] || 0) + 1;
        });

        return {
          totalItems: allItems.length,
          visibleItems: visibleItems.length,
          dateGroups: dateGroups,
          uniqueDates: Object.keys(dateGroups).length
        };
      });

      console.log(`📊 Content on ${indexPage}:`);
      console.log(`   Total items: ${contentAnalysis.totalItems}`);
      console.log(`   Visible items: ${contentAnalysis.visibleItems}`);
      console.log(`   Unique dates: ${contentAnalysis.uniqueDates}`);
      console.log('   Date distribution:', contentAnalysis.dateGroups);

      // Check if content limiting was applied
      if (contentAnalysis.visibleItems < contentAnalysis.totalItems) {
        console.log(`✅ Content limiting applied (${contentAnalysis.totalItems - contentAnalysis.visibleItems} items limited)`);

        // Verify limiting makes sense (should have meaningful content)
        expect(contentAnalysis.visibleItems).toBeGreaterThan(0);
        expect(contentAnalysis.visibleItems).toBeLessThanOrEqual(contentAnalysis.totalItems);

        // Check if same-day rule is evident (items from latest date should all be included)
        const dateEntries = Object.entries(contentAnalysis.dateGroups);
        if (dateEntries.length > 0) {
          console.log(`📅 Same-day rule analysis: ${dateEntries.length} dates represented in visible content`);
        }
      } else {
        console.log(`ℹ️ No content limiting detected (all ${contentAnalysis.totalItems} items visible)`);
      }
    }
  });

  // Test 5: Page Structure Requirements for Filter Types
  test('should have correct filter types available per page type', async ({ page }) => {
    const pageTypes = [
      { url: '/', name: 'Root Index', expectedFilters: [] }, // Homepage doesn't have filters in current design
      { url: TEST_URLS.sectionIndexes.find(p => p.section === 'ai').url, name: 'AI Section Index', expectedFilters: ['date', 'collection'] },
      { url: TEST_URLS.sectionIndexes.find(p => p.section === 'github-copilot').url, name: 'GitHub Copilot Section Index', expectedFilters: ['date', 'collection'] },
      { url: '/ai/news.html', name: 'AI News Collection', expectedFilters: ['date', 'tag'] }
    ];

    console.log('\n🏗️ Testing server-side filter type generation per page type');

    for (const pageType of pageTypes) {
      console.log(`\n📄 Testing: ${pageType.name} (${pageType.url})`);

      await navigateAndVerify(page, pageType.url);

      const filterAnalysis = await page.evaluate(() => {
        return {
          dateFilters: document.querySelectorAll('.tag-filter-btn[data-tag*="day"], .tag-filter-btn[data-tag*="last"], .tag-filter-btn[data-tag*="month"]').length,
          sectionFilters: document.querySelectorAll('.tag-filter-btn[data-tag="ai"], .tag-filter-btn[data-tag="github copilot"]').length,
          collectionFilters: document.querySelectorAll('.tag-filter-btn[data-tag="news"], .tag-filter-btn[data-tag="posts"], .tag-filter-btn[data-tag="videos"], .tag-filter-btn[data-tag="community"]').length,
          tagFilters: document.querySelectorAll('.tag-filter-btn[data-tag]:not([data-tag*="last"]):not([data-tag*="day"]):not([data-tag*="month"]):not([data-tag="ai"]):not([data-tag="github copilot"]):not([data-tag="news"]):not([data-tag="posts"]):not([data-tag="videos"]):not([data-tag="community"])').length,
          totalFilters: document.querySelectorAll('.tag-filter-btn[data-tag]').length
        };
      });

      console.log(`📊 ${pageType.name} filter analysis:`, filterAnalysis);

      // Special handling for homepage which doesn't have filters
      if (pageType.url === '/') {
        console.log(`ℹ️ Homepage (${pageType.name}) does not have filtering - this is expected behavior`);
        expect(filterAnalysis.totalFilters).toBe(0);
        console.log(`✅ No filters on homepage as expected`);
        continue;
      }

      // Verify expected filter types are present
      if (pageType.expectedFilters.includes('date')) {
        expect(filterAnalysis.dateFilters).toBeGreaterThan(0);
        console.log(`✅ Date filters present: ${filterAnalysis.dateFilters}`);
      }

      if (pageType.expectedFilters.includes('section')) {
        expect(filterAnalysis.sectionFilters).toBeGreaterThan(0);
        console.log(`✅ Section filters present: ${filterAnalysis.sectionFilters}`);
      }

      if (pageType.expectedFilters.includes('collection')) {
        expect(filterAnalysis.collectionFilters).toBeGreaterThan(0);
        console.log(`✅ Collection filters present: ${filterAnalysis.collectionFilters}`);
      }

      if (pageType.expectedFilters.includes('tag')) {
        expect(filterAnalysis.tagFilters).toBeGreaterThan(0);
        console.log(`✅ Tag filters present: ${filterAnalysis.tagFilters}`);
      }

      // Verify total filter count makes sense
      expect(filterAnalysis.totalFilters).toBeGreaterThan(0);
    }

    console.log('✅ All page types have correct server-side filter generation');
  });
});
