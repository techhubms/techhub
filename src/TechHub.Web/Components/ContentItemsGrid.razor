@using TechHub.Core.Models
@using TechHub.Core.Configuration
@using TechHub.Web.Services
@using Microsoft.JSInterop
@using Microsoft.AspNetCore.Components.Web
@rendermode @(new InteractiveServerRenderMode(prerender: true))
@inject TechHubApiClient ApiClient
@inject SectionCache SectionCache
@inject ILogger<ContentItemsGrid> Logger
@inject IJSRuntime JSRuntime
@inject PersistentComponentState ApplicationState
@implements IAsyncDisposable

<section class="collection-content @(isLoading ? "loading" : "")" aria-label="@GetCollectionTitle() content">
    <h1 id="skiptohere" class="page-h1">@GetPageTitle()</h1>

    @if (isLoading && !contentItems.Any())
    {
        <div class="content-grid" role="feed" aria-busy="true" aria-label="Loading content">
            @for (int i = 0; i < 6; i++)
            {
                <div class="skeleton-card" aria-hidden="true">
                    <div class="content-header">
                        <div class="skeleton skeleton-card-title"></div>
                        <div class="skeleton skeleton-card-meta"></div>
                    </div>
                    <div class="skeleton skeleton-card-description"></div>
                    <div class="skeleton skeleton-card-description" style="width: 80%;"></div>
                    <div class="content-tags">
                        <div class="skeleton skeleton-card-tag"></div>
                        <div class="skeleton skeleton-card-tag"></div>
                        <div class="skeleton skeleton-card-tag"></div>
                    </div>
                </div>
            }
        </div>
    }
    else if (errorMessage != null)
    {
        <div class="error" role="alert">
            <h2>Error Loading Content</h2>
            <p>@errorMessage</p>
            <button @onclick="LoadInitialBatch" aria-label="Retry loading content">Retry</button>
        </div>
    }
    else if (FilteredContentItems.Any())
    {
        <div class="content-grid" role="feed" aria-busy="@isLoadingMore">
            @foreach (var item in FilteredContentItems)
            {
                <ContentItemCard Item="@item" ShowCollectionBadge="@ShowCollectionBadge" SectionName="@SectionName" />
            }
        </div>

        @if (hasMoreContent)
        {
            <div id="scroll-trigger" class="scroll-trigger" style="height: 1px; margin-bottom: 50px;"></div>
        }

        @if (isLoadingMore)
        {
            <div class="loading-more-indicator" role="status" aria-live="polite">
                <div class="loading-spinner"></div>
                <p>Loading more content...</p>
            </div>
        }

        @if (!hasMoreContent && contentItems.Any())
        {
            <div class="end-of-content" role="status">
                <p>End of content</p>
            </div>
        }
    }
    else if (FilterTags != null && FilterTags.Count > 0 && contentItems.Any())
    {
        <div class="no-content" role="status">
            <p>No content matches the selected tags. Try selecting different tags or clearing filters.</p>
        </div>
    }
    else
    {
        <div class="no-content" role="status">
            <p>No content available for this collection.</p>
        </div>
    }
</section>

@code {
    private const int BatchSize = 20;

    [Parameter, EditorRequired]
    public required string SectionName { get; set; }

    [Parameter, EditorRequired]
    public required string CollectionName { get; set; }

    [Parameter]
    public List<string>? FilterTags { get; set; }

    // Content state
    private List<ContentItem> contentItems = [];
    private bool isLoading = true;
    private bool isLoadingMore;
    private bool hasMoreContent = true;
    private string? errorMessage;
    private int currentBatch = 1;

    // Change detection
    private string previousCollectionName = string.Empty;
    private List<string>? previousFilterTags;

    // JS interop
    private IJSObjectReference? scrollModule;
    private DotNetObjectReference<ContentItemsGrid>? dotNetRef;
    private bool needsObserverSetup;

    // State persistence (prevents double-fetch during prerender -> interactive transition)
    private PersistingComponentStateSubscription _persistSubscription;

    private bool ShowCollectionBadge =>
        SectionName.Equals("all", StringComparison.OrdinalIgnoreCase) ||
        CollectionName.Equals("all", StringComparison.OrdinalIgnoreCase);

    // No longer needed - API now handles tag filtering
    // Content items are already filtered by the backend
    private IEnumerable<ContentItem> FilteredContentItems => contentItems;

    protected override async Task OnInitializedAsync()
    {
        previousCollectionName = CollectionName;
        previousFilterTags = FilterTags?.ToList();

        // Register for state persistence (called during prerender to save state)
        _persistSubscription = ApplicationState.RegisterOnPersisting(PersistState);

        // Try to restore state from prerender
        var stateKey = GetStateKey();
        if (ApplicationState.TryTakeFromJson<PersistedGridState>(stateKey, out var restored) && restored != null)
        {
            // Restored from prerender - skip API call
            contentItems = restored.Items;
            currentBatch = restored.CurrentBatch;
            hasMoreContent = restored.HasMoreContent;
            isLoading = false;
            needsObserverSetup = hasMoreContent;
            Logger.LogDebug("Restored {Count} items from prerender state for {Key}", contentItems.Count, stateKey);
        }
        else
        {
            // Not restored - fetch from API
            await LoadInitialBatch();
        }
    }

    private string GetStateKey() => $"ContentItemsGrid_{SectionName}_{CollectionName}";

    private Task PersistState()
    {
        var stateKey = GetStateKey();
        ApplicationState.PersistAsJson(stateKey, new PersistedGridState
        {
            Items = contentItems,
            CurrentBatch = currentBatch,
            HasMoreContent = hasMoreContent
        });
        return Task.CompletedTask;
    }

    private sealed class PersistedGridState
    {
        public List<ContentItem> Items { get; set; } = [];
        public int CurrentBatch { get; set; }
        public bool HasMoreContent { get; set; }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (CollectionName != previousCollectionName)
        {
            previousCollectionName = CollectionName;
            await LoadInitialBatch();
            return; // Don't check tags if collection changed - LoadInitialBatch handles everything
        }

        var tagsChanged = !TagsAreEqual(FilterTags, previousFilterTags);
        if (tagsChanged)
        {
            previousFilterTags = FilterTags?.ToList();
            // Tags changed - reload data from API with new filters
            await LoadInitialBatch();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // JS interop is allowed after the component becomes interactive
        if (firstRender && hasMoreContent && scrollModule == null)
        {
            await SetupScrollObserver();
        }
        else if (needsObserverSetup && scrollModule == null)
        {
            needsObserverSetup = false;
            await SetupScrollObserver();
        }
    }

    private async Task SetupScrollObserver()
    {
        try
        {
            scrollModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                "import", "/js/infinite-scroll.js");
            dotNetRef = DotNetObjectReference.Create(this);

            await scrollModule.InvokeVoidAsync("observeScrollTrigger", dotNetRef, "scroll-trigger");
            Logger.LogDebug("Infinite scroll observer initialized");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to initialize infinite scroll");
        }
    }

    private async Task LoadInitialBatch()
    {
        contentItems.Clear();
        currentBatch = 1;
        hasMoreContent = true;
        isLoading = true;
        errorMessage = null;
        StateHasChanged();

        try
        {
            await LoadBatch(1);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load content for {Section}/{Collection}", SectionName, CollectionName);
            errorMessage = "Unable to load content";
        }
        finally
        {
            isLoading = false;
            // Request observer setup in next OnAfterRenderAsync (where JS interop is allowed)
            needsObserverSetup = hasMoreContent;
            StateHasChanged();
        }
    }

    private async Task LoadBatch(int batch)
    {
        var skip = (batch - 1) * BatchSize;
        
        // Build tags parameter for API (comma-separated list)
        var tagsParam = FilterTags != null && FilterTags.Count > 0
            ? string.Join(",", FilterTags)
            : null;
        
        var items = await ApiClient.GetCollectionItemsAsync(
            SectionName, 
            CollectionName, 
            take: BatchSize, 
            skip: skip,
            tags: tagsParam);
            
        var newItems = items?.ToList() ?? [];

        if (newItems.Count < BatchSize)
        {
            hasMoreContent = false;
        }

        contentItems.AddRange(newItems);
        currentBatch = batch;
    }

    [JSInvokable]
    public async Task LoadNextBatch()
    {
        if (isLoadingMore || !hasMoreContent)
        {
            return;
        }

        isLoadingMore = true;
        StateHasChanged();

        try
        {
            await LoadBatch(currentBatch + 1);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load more content");
        }
        finally
        {
            isLoadingMore = false;
            StateHasChanged();
        }
    }

    private static bool TagsAreEqual(List<string>? a, List<string>? b)
    {
        if (a == null && b == null) return true;
        if (a == null || b == null) return false;
        if (a.Count != b.Count) return false;
        return a.OrderBy(x => x).SequenceEqual(b.OrderBy(x => x));
    }

    private string GetCollectionTitle()
    {
        if (CollectionName.Equals("all", StringComparison.OrdinalIgnoreCase))
        {
            return "All";
        }

        var section = SectionCache.GetSectionByName(SectionName);
        var collection = section?.Collections.FirstOrDefault(c => c.Name == CollectionName);
        if (collection != null)
        {
            return collection.DisplayName ?? collection.Title ?? CollectionName;
        }

        // Fallback to title case if not found
        return System.Globalization.CultureInfo.InvariantCulture.TextInfo.ToTitleCase(CollectionName.ToLowerInvariant());
    }

    private string GetPageTitle()
    {
        var collectionDisplay = GetCollectionTitle();
        var isAllSection = SectionName.Equals("all", StringComparison.OrdinalIgnoreCase);
        var isAllCollection = CollectionName.Equals("all", StringComparison.OrdinalIgnoreCase);
        
        var section = SectionCache.GetSectionByName(SectionName);
        var sectionDisplayName = section?.Title ?? SectionName;

        return (isAllSection, isAllCollection) switch
        {
            (true, true) => "Browse All Posts",
            (true, false) => $"Browse All {collectionDisplay}",
            (false, true) => $"Browse All {sectionDisplayName} Content",
            _ => $"Browse {sectionDisplayName} {collectionDisplay}"
        };
    }

    public async ValueTask DisposeAsync()
    {
        _persistSubscription.Dispose();

        if (scrollModule != null)
        {
            try
            {
                await scrollModule.InvokeVoidAsync("dispose");
                await scrollModule.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors during navigation or circuit disconnection
            }
        }

        dotNetRef?.Dispose();
        GC.SuppressFinalize(this);
    }
}
