@using TechHub.Core.Models
@using TechHub.Core.Configuration
@using TechHub.Web.Services
@using Microsoft.JSInterop
@inject TechHubApiClient ApiClient
@inject SectionCache SectionCache
@inject ILogger<ContentItemsGrid> Logger
@inject IJSRuntime JSRuntime
@attribute [StreamRendering]
@implements IAsyncDisposable

<section class="collection-content @(isLoading ? "loading" : "")" aria-label="@GetCollectionTitle() content">
    <h1 id="main-content" class="page-h1" tabindex="-1">@GetPageTitle()</h1>

    @if (isLoading && !contentItems.Any())
    {
        <div class="content-grid" role="feed" aria-busy="true" aria-label="Loading content">
            @* Skeleton cards while loading - mimics actual content card structure *@
            @for (int i = 0; i < 6; i++)
            {
                <div class="skeleton-card" aria-hidden="true">
                    <div class="content-header">
                        <div class="skeleton skeleton-card-title"></div>
                        <div class="skeleton skeleton-card-meta"></div>
                    </div>
                    <div class="skeleton skeleton-card-description"></div>
                    <div class="skeleton skeleton-card-description" style="width: 80%;"></div>
                    <div class="content-tags">
                        <div class="skeleton skeleton-card-tag"></div>
                        <div class="skeleton skeleton-card-tag"></div>
                        <div class="skeleton skeleton-card-tag"></div>
                    </div>
                </div>
            }
        </div>
    }
    else if (errorMessage != null)
    {
        <div class="error" role="alert">
            <h2>Error Loading Content</h2>
            <p>@errorMessage</p>
            <button @onclick="LoadInitialBatch" aria-label="Retry loading content">Retry</button>
        </div>
    }
    else if (FilteredContentItems.Any())
    {
        <div class="content-grid" role="feed" aria-busy="false">
            @foreach (var item in FilteredContentItems)
            {
                <ContentItemCard Item="@item" ShowCollectionBadge="@ShowCollectionBadge" SectionName="@SectionName" />
            }
        </div>

        @if (_hasMoreContent && !_isLoadingMore)
        {
            <div id="scroll-trigger" style="height: 1px;"></div>
        }

        @if (_isLoadingMore)
        {
            <div class="loading-more-indicator" role="status" aria-live="polite">
                <div class="loading-spinner"></div>
                <p>Loading more content...</p>
            </div>
        }

        @if (!_hasMoreContent && contentItems.Any())
        {
            <div class="end-of-content" role="status">
                <p>End of content</p>
            </div>
        }
    }
    else if (FilterTags != null && FilterTags.Count > 0 && contentItems.Any())
    {
        <div class="no-content" role="status">
            <p>No content matches the selected tags. Try selecting different tags or clearing filters.</p>
        </div>
    }
    else
    {
        <div class="no-content" role="status">
            <p>No content available for this collection.</p>
        </div>
    }
</section>

@code {
    [Parameter, EditorRequired]
    public required string SectionName { get; set; }

    [Parameter, EditorRequired]
    public required string CollectionName { get; set; }

    /// <summary>
    /// Tags to filter content by (client-side filtering with OR logic)
    /// </summary>
    [Parameter]
    public List<string>? FilterTags { get; set; }

    private List<ContentItem> contentItems = new();
    private bool isLoading = true;
    private string? errorMessage;
    private string previousCollectionName = string.Empty;
    private List<string>? previousFilterTags;

    // Infinite scroll state
    private int _currentBatch = 1;
    private const int BatchSize = 20;
    private bool _hasMoreContent = true;
    private bool _isLoadingMore = false;
    private IJSObjectReference? _infiniteScrollModule;
    private IJSObjectReference? _observerInstance;
    private DotNetObjectReference<ContentItemsGrid>? _dotNetRef;

    private bool ShowCollectionBadge =>
    SectionName.Equals("all", StringComparison.OrdinalIgnoreCase) ||
    CollectionName.Equals("all", StringComparison.OrdinalIgnoreCase);

    /// <summary>
    /// Returns content items filtered by selected tags (if any)
    /// Uses AND logic - content must have ALL selected tags
    /// </summary>
    private IEnumerable<ContentItem> FilteredContentItems
    {
        get
        {
            if (FilterTags == null || FilterTags.Count == 0)
            {
                return contentItems;
            }

            // Filter items that have ALL of the selected tags (AND logic)
            // Case-insensitive matching
            var normalizedTags = FilterTags.Select(t => t.ToLowerInvariant()).ToHashSet();
            return contentItems.Where(item =>
            {
                if (item.Tags == null || item.Tags.Count == 0)
                {
                    return false;
                }

                var itemTagsLower = item.Tags.Select(t => t.ToLowerInvariant()).ToHashSet();
                // ALL selected tags must be present in the item's tags
                return normalizedTags.All(selectedTag => itemTagsLower.Contains(selectedTag));
            });
        }
    }

    protected override async Task OnInitializedAsync()
    {
        previousCollectionName = CollectionName;
        previousFilterTags = FilterTags?.ToList();
        await LoadInitialBatch();
    }

    protected override async Task OnParametersSetAsync()
    {
        // Only reload if collection actually changed
        if (CollectionName != previousCollectionName)
        {
            previousCollectionName = CollectionName;
            await LoadInitialBatch();
        }

        // Check if filter tags changed (triggers re-render but not reload)
        var tagsChanged = !TagsAreEqual(FilterTags, previousFilterTags);
        if (tagsChanged)
        {
            previousFilterTags = FilterTags?.ToList();
            // No need to reload - filtering is done client-side via FilteredContentItems
            StateHasChanged();
        }
    }

    private static bool TagsAreEqual(List<string>? a, List<string>? b)
    {
        if (a == null && b == null) return true;
        if (a == null || b == null) return false;
        if (a.Count != b.Count) return false;
        return a.OrderBy(x => x).SequenceEqual(b.OrderBy(x => x));
    }

    private async Task LoadInitialBatch()
    {
        // Reset state
        contentItems.Clear();
        _currentBatch = 1;
        _hasMoreContent = true;
        _isLoadingMore = false;

        isLoading = true;
        errorMessage = null;
        StateHasChanged();

        Logger.LogDebug("LoadInitialBatch START: Section={SectionName}, Collection={CollectionName}",
            SectionName, CollectionName);

        try
        {
            await LoadBatch(batch: 1);
            Logger.LogDebug("LoadInitialBatch COMPLETE: Loaded {Count} items", contentItems.Count);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load initial batch for {SectionName}/{CollectionName}", SectionName, CollectionName);
            errorMessage = "Unable to load content";
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
            Logger.LogDebug("LoadInitialBatch FINALLY: isLoading={IsLoading}, contentItems.Count={Count}",
                isLoading, contentItems.Count);
        }
    }

    private async Task LoadBatch(int batch)
    {
        var skip = (batch - 1) * BatchSize;

        Logger.LogDebug("LoadBatch: batch={Batch}, skip={Skip}, take={Take}", batch, skip, BatchSize);

        IEnumerable<ContentItem>? items = await ApiClient.GetCollectionItemsAsync(
            SectionName,
            CollectionName,
            take: BatchSize,
            skip: skip);

        var newItems = items?.ToList() ?? new List<ContentItem>();

        Logger.LogDebug("LoadBatch: Retrieved {Count} items", newItems.Count);

        // Check if we've reached the end
        if (newItems.Count < BatchSize)
        {
            _hasMoreContent = false;
            Logger.LogDebug("LoadBatch: Reached end of content (got {Count} items, expected {BatchSize})", 
                newItems.Count, BatchSize);
        }

        // Append new items
        contentItems.AddRange(newItems);
        _currentBatch = batch;

        Logger.LogDebug("LoadBatch: Total items now: {Total}", contentItems.Count);
    }

    [JSInvokable]
    public async Task LoadNextBatch()
    {
        if (_isLoadingMore || !_hasMoreContent)
        {
            Logger.LogDebug("LoadNextBatch: Skipped (_isLoadingMore={IsLoadingMore}, _hasMoreContent={HasMore})",
                _isLoadingMore, _hasMoreContent);
            return;
        }

        _isLoadingMore = true;
        StateHasChanged();

        Logger.LogDebug("LoadNextBatch: Loading batch {NextBatch}", _currentBatch + 1);

        try
        {
            await LoadBatch(_currentBatch + 1);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load next batch for {SectionName}/{CollectionName}", SectionName, CollectionName);
            errorMessage = "Unable to load more content";
        }
        finally
        {
            _isLoadingMore = false;
            StateHasChanged();
        }
    }

    private string GetCollectionTitle()
    {
        if (CollectionName.Equals("all", StringComparison.OrdinalIgnoreCase))
        {
            return "All";
        }

        // Try to get DisplayName from section cache first
        var section = SectionCache.GetSectionByName(SectionName);
        var collection = section?.Collections.FirstOrDefault(c => c.Name == CollectionName);
        if (collection != null)
        {
            return collection.DisplayName ?? collection.Title ?? CollectionName;
        }

        // Fallback to SectionHelper
        return SectionHelper.GetCollectionTitle(CollectionName);
    }

    private string GetPageTitle()
    {
        var collectionDisplay = GetCollectionTitle();
        var isAllSection = SectionName.Equals("all", StringComparison.OrdinalIgnoreCase);
        var isAllCollection = CollectionName.Equals("all", StringComparison.OrdinalIgnoreCase);

        // Get proper section display name (e.g., "GitHub Copilot" instead of "github-copilot")
        var sectionDisplayName = SectionHelper.GetSectionDisplayName(SectionName);

        if (isAllSection && isAllCollection)
        {
            // /all → "Browse All Posts"
            return "Browse All Posts";
        }
        else if (isAllSection && !isAllCollection)
        {
            // /all/news → "Browse All News"
            return $"Browse All {collectionDisplay}";
        }
        else if (!isAllSection && isAllCollection)
        {
            // /github-copilot → "Browse All GitHub Copilot Content"
            return $"Browse All {sectionDisplayName} Content";
        }
        else
        {
            // /github-copilot/news → "Browse GitHub Copilot News"
            return $"Browse {sectionDisplayName} {collectionDisplay}";
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                _infiniteScrollModule = await JSRuntime.InvokeAsync<IJSObjectReference>(
                    "import", "/js/infinite-scroll.js");
                _dotNetRef = DotNetObjectReference.Create(this);

                Logger.LogDebug("InfiniteScroll: Module imported and DotNetRef created");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Failed to initialize infinite scroll module");
            }
        }

        // Set up observer when scroll trigger is rendered and we don't already have an observer
        if (_observerInstance == null && _hasMoreContent && !_isLoadingMore && _infiniteScrollModule != null && _dotNetRef != null)
        {
            Logger.LogDebug("InfiniteScroll: Attempting to set up observer (firstRender={FirstRender}, hasMore={HasMore}, isLoading={IsLoading})", 
                firstRender, _hasMoreContent, _isLoadingMore);

            try
            {
                // Create new observer
                _observerInstance = await _infiniteScrollModule.InvokeAsync<IJSObjectReference>(
                    "observeScrollTrigger", _dotNetRef, "scroll-trigger");

                Logger.LogDebug("InfiniteScroll: Observer created successfully");
            }
            catch (JSException jsEx) when (jsEx.Message.Contains("not found"))
            {
                // Scroll trigger not yet rendered, will retry on next render
                Logger.LogDebug("InfiniteScroll: Scroll trigger not yet in DOM, will retry");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "InfiniteScroll: Failed to set up scroll observer");
            }
        }
        else if (_observerInstance != null)
        {
            Logger.LogDebug("InfiniteScroll: Observer already exists, skipping setup");
        }
        else
        {
            Logger.LogDebug("InfiniteScroll: Conditions not met for observer setup (hasMore={HasMore}, isLoading={IsLoading}, moduleLoaded={ModuleLoaded}, dotNetRefCreated={DotNetRefCreated})",
                _hasMoreContent, _isLoadingMore, _infiniteScrollModule != null, _dotNetRef != null);
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_observerInstance != null)
        {
            try
            {
                await _observerInstance.InvokeVoidAsync("dispose");
                await _observerInstance.DisposeAsync();
            }
            catch
            {
                // Ignore disposal errors
            }
        }

        if (_infiniteScrollModule != null)
        {
            await _infiniteScrollModule.DisposeAsync();
        }

        _dotNetRef?.Dispose();

        GC.SuppressFinalize(this);
    }
}