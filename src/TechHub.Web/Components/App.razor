@using TechHub.Web.Services
@inject FaviconService FaviconService

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="/" />

    <ImportMap />
    <HeadOutlet />

    @if (Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") == "Development")
    {
        <!-- Development: Individual files for easy debugging -->
        @foreach (var cssFile in TechHub.Web.Configuration.CssFiles.All)
        {
            <link rel="stylesheet" href="@cssFile" />
        }
    }
    else
    {
        <!-- Production: Bundled and minified CSS for optimal performance -->
        <link rel="stylesheet" href="css/bundle.css" />
    }

    <!-- Scoped Component Styles -->
    <link rel="stylesheet" href="@Assets["TechHub.Web.styles.css"]" />

    <!-- Favicon embedded as data URI to eliminate HTTP requests during navigation -->
    <link id="favicon" rel="icon" type="image/x-icon" href="@FaviconService.DataUri" sizes="any" data-permanent />
</head>

<body>
    <Routes />
    <ReconnectModal />
    <script src="@Assets["_framework/blazor.web.js"]"></script>

    <!-- Page Timing - Performance monitoring -->
    <script src="@Assets["js/page-timing.js"]"></script>

    <!-- Navigation Helpers - Back to Top and Back to Previous -->
    <!-- Uses @Assets for fingerprinted URL (cache busting). See Configuration/JsFiles.cs -->
    <script src="@Assets["js/nav-helpers.js"]" defer></script>

    <!-- Dynamic Script Loading - Load libraries only when needed -->
    <!-- CDN versions configured in Configuration/CdnLibraries.cs -->
    <script type="module">
        // CDN Library Configuration - rendered from C# for single source of truth
        // See: Configuration/CdnLibraries.cs
        const CDN = {
            highlightJs: {
                version: '@TechHub.Web.Configuration.CdnLibraries.HighlightJs.Version',
                cdnUrl: '@TechHub.Web.Configuration.CdnLibraries.HighlightJs.CdnUrl',
                coreIntegrity: '@TechHub.Web.Configuration.CdnLibraries.HighlightJs.CoreIntegrity',
                themeIntegrity: '@TechHub.Web.Configuration.CdnLibraries.HighlightJs.ThemeIntegrity',
                themeFile: '@TechHub.Web.Configuration.CdnLibraries.HighlightJs.ThemeFile',
                languages: @(new MarkupString(System.Text.Json.JsonSerializer.Serialize(TechHub.Web.Configuration.CdnLibraries.HighlightJs.Languages))),
                // Third-party language plugins (Terraform for IaC content)
                // Note: Bicep plugin doesn't exist yet, ARM templates use 'json'
                thirdPartyLanguages: {
                    terraform: '@TechHub.Web.Configuration.CdnLibraries.HighlightJs.ThirdPartyLanguages.TerraformCdnUrl'
                }
            },
            mermaid: {
                version: '@TechHub.Web.Configuration.CdnLibraries.Mermaid.Version',
                cdnUrl: '@TechHub.Web.Configuration.CdnLibraries.Mermaid.CdnUrl'
            }
        };

        // Track what's already been loaded to avoid duplicates
        const loaded = {
            highlightJs: false,
            mermaid: false,
            customPages: false,
            infiniteScroll: null  // Will hold the module reference
        };

        // Load Highlight.js for syntax highlighting
        async function loadHighlighting(codeElements) {
            if (loaded.highlightJs || !codeElements) return;

            loaded.highlightJs = true;

            try {
                // Inject CSS theme (no integrity check - often causes failures)
                const link = document.createElement('link');
                link.rel = 'stylesheet';
                link.href = `${CDN.highlightJs.cdnUrl}/${CDN.highlightJs.themeFile}`;
                link.crossOrigin = 'anonymous';
                link.referrerPolicy = 'no-referrer';
                document.head.appendChild(link);

                // Load core library (no integrity check - often causes failures)
                await loadScript(`${CDN.highlightJs.cdnUrl}/highlight.min.js`);

                // Load all core language files in parallel
                await Promise.all(
                    CDN.highlightJs.languages.map(lang =>
                        loadScript(`${CDN.highlightJs.cdnUrl}/languages/${lang}.min.js`).catch(err => {
                            console.warn(`Failed to load language: ${lang}`, err);
                        })
                    )
                );

                // Load third-party language plugins (Terraform for IaC content)
                // These are loaded separately as they come from different CDN sources
                await Promise.all(
                    Object.values(CDN.highlightJs.thirdPartyLanguages).map(url => 
                        loadScript(url).catch(err => {
                            console.warn('Failed to load third-party language plugin:', err);
                        })
                    )
                );

                // Register third-party languages with hljs
                // Terraform plugin exposes window.hljsDefineTerraform
                if (typeof window.hljsDefineTerraform === 'function') {
                    hljs.registerLanguage('terraform', window.hljsDefineTerraform);
                    hljs.registerLanguage('tf', window.hljsDefineTerraform);
                    hljs.registerLanguage('hcl', window.hljsDefineTerraform);
                }

                hljs.highlightAll();
            } catch (error) {
                console.error('Failed to load Highlight.js:', error);
            }
        }

        // Load Mermaid for diagrams
        async function loadMermaid(mermaidElements) {
            if (!mermaidElements) return;

            try {
                // Load library only once
                if (!loaded.mermaid) {
                    loaded.mermaid = true;
                    await loadScript(CDN.mermaid.cdnUrl);

                const config = {
                    startOnLoad: false,
                    theme: 'dark',
                    useMaxWidth: true,  // Scale diagrams to fit container
                    themeVariables: {
                        primaryColor: '#2d2d4a',
                        primaryTextColor: '#e0e0e0',
                        primaryBorderColor: '#e0e0e0',  // Changed from #64b5f6 to off-white
                        lineColor: '#e0e0e0',  // Changed from #64b5f6 to match text
                        secondaryColor: '#1a1a2e',
                        tertiaryColor: '#16162a',
                        background: '#1a1a2e',
                        mainBkg: '#2d2d4a',
                        secondBkg: '#1a1a2e',
                        labelBackground: '#2d2d4a',
                        labelColor: '#e0e0e0',
                        nodeTextColor: '#e0e0e0',
                        textColor: '#e0e0e0',
                        titleColor: '#e0e0e0',
                        edgeLabelBackground: '#2d2d4a',
                        clusterBkg: '#16162a',
                        clusterBorder: '#e0e0e0',  // Changed from #64b5f6 to off-white
                        defaultLinkColor: '#e0e0e0',  // Changed from #64b5f6 to match text
                        activationBorderColor: '#e0e0e0',  // Changed from #64b5f6 to off-white
                        activationBkgColor: '#2d2d4a',
                        sequenceNumberColor: '#1a1a2e'
                    },
                    flowchart: {
                        curve: 'basis',
                        padding: 20,
                        nodeSpacing: 50,
                        rankSpacing: 80
                    },
                    sequence: {
                        actorMargin: 50,
                        boxMargin: 10,
                        boxTextMargin: 5,
                        noteMargin: 10,
                        messageMargin: 35
                    },
                    gantt: {
                        leftPadding: 75,
                        gridLineStartPadding: 35
                    },
                    class: {
                        padding: 20
                    },
                    state: {
                        padding: 20
                    }
                };

                mermaid.initialize(config);
            }

            // Render diagrams every time (for Blazor navigation)
            try {
                await mermaid.run({ nodes: mermaidElements });

                // Add expand buttons to each diagram
                mermaidElements.forEach(element => {
                    if (element.querySelector('.mermaid-expand-btn')) return; // Already added

                    const expandBtn = document.createElement('button');
                    expandBtn.className = 'mermaid-expand-btn';
                    expandBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/></svg> Expand';
                    expandBtn.title = 'Expand diagram to fullscreen';
                    expandBtn.setAttribute('aria-label', 'Expand diagram to fullscreen');
                    expandBtn.onclick = () => showMermaidModal(element);
                    element.appendChild(expandBtn);
                });
            } catch (error) {
                console.error('Mermaid rendering failed:', error);
            }
            } catch (error) {
                console.error('Failed to load Mermaid:', error);
            }
        }

        // Show mermaid diagram in fullscreen modal
        function showMermaidModal(diagramElement) {
            // Create modal if it doesn't exist
            let modal = document.getElementById('mermaid-modal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'mermaid-modal';
                modal.className = 'mermaid-modal';
                modal.innerHTML = `
                    <div class="mermaid-modal-backdrop"></div>
                    <div class="mermaid-modal-content">
                        <div class="mermaid-modal-diagram"></div>
                    </div>
                `;
                document.body.appendChild(modal);

                // Close on backdrop click
                modal.querySelector('.mermaid-modal-backdrop').onclick = () => closeMermaidModal();

                // Close on ESC key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && modal.classList.contains('active')) {
                        closeMermaidModal();
                    }
                });
            }

            // Re-render diagram at full size in modal
            const modalDiagram = modal.querySelector('.mermaid-modal-diagram');
            modalDiagram.innerHTML = '';

            // Clone the entire mermaid element (which contains the rendered SVG)
            const clonedDiagram = diagramElement.cloneNode(true);

            // Remove the expand button from the clone
            const clonedButton = clonedDiagram.querySelector('.mermaid-expand-btn');
            if (clonedButton) {
                clonedButton.remove();
            }

            // Add close button to the diagram
            const closeBtn = document.createElement('button');
            closeBtn.className = 'mermaid-modal-close';
            closeBtn.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor"><path d="M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z"/></svg> Close';
            closeBtn.setAttribute('aria-label', 'Close fullscreen diagram');
            closeBtn.onclick = (e) => {
                e.stopPropagation();
                closeMermaidModal();
            };
            clonedDiagram.appendChild(closeBtn);

            // Scale the diagram to be large but maintain aspect ratio
            const svg = clonedDiagram.querySelector('svg');
            if (svg) {
                // Remove fixed dimensions to allow scaling
                svg.removeAttribute('width');
                svg.removeAttribute('height');
                // Scale up to a good size, but constrain if needed
                svg.style.width = 'min(1200px, 85vw)';
                svg.style.height = 'auto';
                svg.style.maxHeight = '75vh';
            }

            modalDiagram.appendChild(clonedDiagram);

            // Show modal
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeMermaidModal() {
            const modal = document.getElementById('mermaid-modal');
            if (modal) {
                modal.classList.remove('active');
                document.body.style.overflow = '';
            }
        }

        // Load TOC scroll spy
        async function loadTocScrollSpy(tocElement) {
            if (!tocElement) return;

            try {
                const module = await import('./js/toc-scroll-spy.js');
                module.initTocScrollSpy();
            } catch (error) {
                console.error('Failed to load TOC scroll spy:', error);
            }
        }

        // Load custom pages interactivity (ES module with explicit init)
        async function loadCustomPages(collapsibleElements, expandableElements) {
            if (!collapsibleElements && !expandableElements) return;

            try {
                const module = await import('./js/custom-pages.js');
                
                // Init collapsible cards only once (they maintain state)
                if (collapsibleElements && !loaded.customPages) {
                    module.initCollapsibleCards();
                    loaded.customPages = true;
                }
                
                // Always re-init expandable badges on each navigation (they're one-time actions)
                if (expandableElements) {
                    module.initExpandableBadges();
                }
            } catch (error) {
                console.error('Failed to load custom pages:', error);
            }
        }

        // Load infinite scroll observer for content grids
        async function loadInfiniteScroll(scrollTrigger) {
            // Clean up previous observer on navigation
            if (loaded.infiniteScroll) {
                try {
                    loaded.infiniteScroll.dispose();
                } catch (e) {
                    // Ignore cleanup errors
                }
                loaded.infiniteScroll = null;
            }

            // Only set up if trigger element exists (page has infinite scroll)
            if (!scrollTrigger) return;

            try {
                const module = await import('./js/infinite-scroll.js');
                loaded.infiniteScroll = module;
                
                // Initialize the observer - the Blazor component exposes LoadNextBatch via DotNet interop
                // But we need a reference to the component's DotNetObjectReference
                // For now, just load the module - the component will call observeScrollTrigger
                console.debug('[InfiniteScroll] Module loaded, waiting for Blazor component to initialize');
            } catch (error) {
                console.error('Failed to load infinite scroll:', error);
            }
        }

        // Load all scripts for current page (runs all loaders in parallel)
        async function loadScriptsForPage() {
            // Set loading flag for E2E tests
            window.__scriptsLoading = true;
            
            // Query DOM once for all needed elements
            const codeElements = document.querySelector('pre code');
            const mermaidElements = document.querySelectorAll('.mermaid:not([data-processed="true"])');
            const tocElement = document.querySelector('[data-toc-scroll-spy]');
            const collapsibleElements = document.querySelector('[data-collapsible]');
            const expandableElements = document.querySelector('[data-expand-target]');
            const scrollTrigger = document.getElementById('scroll-trigger');

            // Load scripts in parallel with independent error handling
            await Promise.all([
                loadHighlighting(codeElements).catch(err => console.error('Highlighting loader failed:', err)),
                loadMermaid(mermaidElements.length > 0 ? mermaidElements : null).catch(err => console.error('Mermaid loader failed:', err)),
                loadCustomPages(collapsibleElements, expandableElements).catch(err => console.error('Custom pages loader failed:', err)),
                loadInfiniteScroll(scrollTrigger).catch(err => console.error('Infinite scroll loader failed:', err))
            ]);

            // TOC scroll spy loads last (after other scripts are ready)
            await loadTocScrollSpy(tocElement);
            
            // Set ready flag for E2E tests
            window.__scriptsReady = true;
            window.__scriptsLoading = false;
        }

        // Helper: Load external script
        function loadScript(src, integrity = null) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.defer = true;
                script.crossOrigin = 'anonymous';
                script.referrerPolicy = 'no-referrer';
                if (integrity) {
                    script.integrity = integrity;
                }
                script.onload = resolve;
                script.onerror = reject;
                document.body.appendChild(script);
            });
        }

        // Initial load (DOMContentLoaded)
        document.addEventListener('DOMContentLoaded', loadScriptsForPage);

        // After Blazor enhanced navigation (SPA-style page changes)
        if (typeof Blazor !== 'undefined') {
            Blazor.addEventListener('enhancedload', loadScriptsForPage);
        }
    </script>
</body>

</html>